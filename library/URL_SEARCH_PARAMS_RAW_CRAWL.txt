URLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

GuidesThe HTML guides help you build with HTML on the web, covering topics such as forms, CORS, content preloading, and responsive images.

HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

GuidesThe HTML guides help you build with HTML on the web, covering topics such as forms, CORS, content preloading, and responsive images.

HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

GuidesThe HTML guides help you build with HTML on the web, covering topics such as forms, CORS, content preloading, and responsive images.

HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.ReferenceThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

GuidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The HTTP guides are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.ReferenceThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

GuidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The HTTP guides are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.ReferenceThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

GuidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The HTTP guides are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessorMediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension and your second extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox. Continue your learning by discovering a list of resources to follow.ConceptsGet detailed information on the concepts that underpin extensions.

Overview of the JavaScript API
Content scripts
Background scripts
Match patterns
Working with files
Internationalization
Content security policy
Native messaging
Native manifests
User actions
Differences between API implementations
Chrome incompatibilities
User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toA range of tutorials to get you started on specific aspects of extension development.

Intercept HTTP requests
Modify a web page
Safely insert external content into a page
Share objects with page scripts
Add a button to the toolbar
Implement a settings page
Work with the Tabs API
Work with the Bookmarks API
Work with the Cookies API
Work with contextual identities
Interact with the clipboard
Extend the developer tools
Build a cross-browser extension
Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension and your second extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox. Continue your learning by discovering a list of resources to follow.ConceptsGet detailed information on the concepts that underpin extensions.

Overview of the JavaScript API
Content scripts
Background scripts
Match patterns
Working with files
Internationalization
Content security policy
Native messaging
Native manifests
User actions
Differences between API implementations
Chrome incompatibilities
User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toA range of tutorials to get you started on specific aspects of extension development.

Intercept HTTP requests
Modify a web page
Safely insert external content into a page
Share objects with page scripts
Add a button to the toolbar
Implement a settings page
Work with the Tabs API
Work with the Bookmarks API
Work with the Cookies API
Work with contextual identities
Interact with the clipboard
Extend the developer tools
Build a cross-browser extension
Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension and your second extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox. Continue your learning by discovering a list of resources to follow.ConceptsGet detailed information on the concepts that underpin extensions.

Overview of the JavaScript API
Content scripts
Background scripts
Match patterns
Working with files
Internationalization
Content security policy
Native messaging
Native manifests
User actions
Differences between API implementations
Chrome incompatibilities
User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toA range of tutorials to get you started on specific aspects of extension development.

Intercept HTTP requests
Modify a web page
Safely insert external content into a page
Share objects with page scripts
Add a button to the toolbar
Implement a settings page
Work with the Tabs API
Work with the Bookmarks API
Work with the Cookies API
Work with contextual identities
Interact with the clipboard
Extend the developer tools
Build a cross-browser extension
Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guidesThe Accessibility guides cover authoring principles, WCAG compliance, accessible widgets and navigation, mobile accessibility, and other key topics that will help you understand why accessibility is crucial for the web and how to improve it in your projects.

Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guidesThe Accessibility guides cover authoring principles, WCAG compliance, accessible widgets and navigation, mobile accessibility, and other key topics that will help you understand why accessibility is crucial for the web and how to improve it in your projects.

Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guidesThe Accessibility guides cover authoring principles, WCAG compliance, accessible widgets and navigation, mobile accessibility, and other key topics that will help you understand why accessibility is crucial for the web and how to improve it in your projects.

Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\n\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\n\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\n\n\nColor models for humans and devicesPolina GurtovaiaMay 6, 202517 minute readImages help bring more color and life to the web. This post describes how images are represented by humans and on different devices, with details about color spaces and vision theory.Read more →Default styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\nBlog it betterColor models for humans and devicesPolina GurtovaiaMay 6, 202517 minute readImages help bring more color and life to the web. This post describes how images are represented by humans and on different devices, with details about color spaces and vision theory.Read more →Default styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Hinweis: Diese Funktion ist in Web Workers verfügbar.
Das URLSearchParams-Interface definiert Hilfsmethoden zur Arbeit mit der Abfragezeichenfolge einer URL.
URLSearchParams-Objekte sind iterierbar, sodass sie direkt in einer for...of-Struktur verwendet werden können, um über Schlüssel/Wert-Paare in der gleichen Reihenfolge zu iterieren, wie sie in der Abfragezeichenfolge erscheinen. Zum Beispiel sind die folgenden zwei Zeilen gleichwertig:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Obwohl URLSearchParams funktional einem Map ähnelt, kann es beim Iterieren einige Fallstricke geben, denen Map aufgrund seiner Implementierung nicht begegnet.Konstruktor
URLSearchParams()

Gibt eine Instanz eines URLSearchParams-Objekts zurück.

Instanzeigenschaften
size Schreibgeschützt

Gibt die Gesamtzahl der Einträge von Suchparametern an.

Instanzmethoden
URLSearchParams[Symbol.iterator]()

Gibt einen Iterator zurück, der die Iteration durch alle in diesem Objekt enthaltenen Schlüssel/Wert-Paare in der gleichen Reihenfolge wie in der Abfragezeichenfolge erlaubt.

URLSearchParams.append()

Fügt ein angegebenes Schlüssel/Wert-Paar als neuen Suchparameter hinzu.

URLSearchParams.delete()

Löscht Suchparameter, die mit einem Namen und optional einem Wert übereinstimmen, aus der Liste aller Suchparameter.

URLSearchParams.entries()

Gibt einen Iterator zurück, der die Iteration durch alle in diesem Objekt enthaltenen Schlüssel/Wert-Paare in der gleichen Reihenfolge wie in der Abfragezeichenfolge erlaubt.

URLSearchParams.forEach()

Ermöglicht die Iteration durch alle in diesem Objekt enthaltenen Werte über eine Callback-Funktion.

URLSearchParams.get()

Gibt den ersten Wert zurück, der mit dem angegebenen Suchparameter verknüpft ist.

URLSearchParams.getAll()

Gibt alle Werte zurück, die mit einem gegebenen Suchparameter verknüpft sind.

URLSearchParams.has()

Gibt einen booleschen Wert zurück, der angibt, ob ein bestimmter Parameter oder ein Parameter-Wert-Paar existiert.

URLSearchParams.keys()

Gibt einen Iterator zurück, der die Iteration durch alle Schlüssel der in diesem Objekt enthaltenen Schlüssel/Wert-Paare erlaubt.

URLSearchParams.set()

Setzt den Wert, der mit einem gegebenen Suchparameter verknüpft ist, auf den angegebenen Wert. Wenn es mehrere Werte gibt, werden die anderen gelöscht.

URLSearchParams.sort()

Sortiert alle Schlüssel/Wert-Paare (falls vorhanden) nach ihren Schlüsseln.

URLSearchParams.toString()

Gibt eine Zeichenfolge zurück, die eine zum Gebrauch in einer URL geeignete Abfragezeichenfolge enthält.

URLSearchParams.values()

Gibt einen Iterator zurück, der die Iteration durch alle Werte der in diesem Objekt enthaltenen Schlüssel/Wert-Paare erlaubt.

BeispieleVerwendung von URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Suchparameter können auch ein Objekt sein.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsen von window.locationIm Gegensatz zur URL bietet das Location-Interface keine sofort verfügbare searchParams-Eigenschaft. Wir können location.search mit URLSearchParams parsen.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Doppelte Suchparameterjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
Kein URL-ParsingDer URLSearchParams-Konstruktor parst nicht vollständige URLs. Er entfernt jedoch ein initiales führendes ? von einer Zeichenfolge, falls vorhanden.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
ProzentkodierungURLSearchParams-Objekte prozentkodieren alles in dem application/x-www-form-urlencoded Prozent-Encoding-Set (das alle Zeichen außer ASCII-Alphanumerisch, *, -, ., und _ enthält) und kodieren U+0020 SPACE als +. Es behandelt jedoch die Prozentcodierung nur beim Serialisieren und Deserialisieren der vollständigen URL-Suchparameter-Syntax. Beim Arbeiten mit einzelnen Schlüsseln und Werten verwenden Sie immer die nicht kodierte Version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

Wenn Sie ein Schlüssel/Wert-Paar mit einem prozentkodierten Schlüssel anhängen, wird dieser Schlüssel als unkodiert behandelt und erneut kodiert.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Pluszeichen beibehaltenDer URLSearchParams-Konstruktor interpretiert Pluszeichen (+) als Leerzeichen, was Probleme verursachen kann. Im folgenden Beispiel verwenden wir hexadezimale Escape-Sequenzen, um eine Zeichenfolge mit Binärdaten (bei der jedes Byte Informationen trägt) darzustellen, die in den URL-Suchparametern gespeichert werden muss. Beachten Sie, wie die von btoa() erzeugte kodierte Zeichenfolge + enthält und von URLSearchParams nicht beibehalten wird.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Erstellen Sie niemals URLSearchParams-Objekte mit dynamisch interpolierten Zeichenfolgen. Verwenden Sie stattdessen die append()-Methode, die, wie oben erwähnt, alle Zeichen unverändert interpretiert.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaktion mit URL.searchParamsDie URL.searchParams-Eigenschaft stellt die search-Zeichenfolge der URL als URLSearchParams-Objekt dar. Wenn Sie diese URLSearchParams aktualisieren, wird die search der URL mit ihrer Serialisierung aktualisiert. URL.search kodiert jedoch eine Teilmenge von Zeichen, die URLSearchParams tut, und kodiert Leerzeichen als %20 statt +. Dies kann zu überraschenden Interaktionen führen – wenn Sie searchParams aktualisieren, auch mit denselben Werten, kann die URL unterschiedlich serialisiert werden.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Leerwert vs. kein WertURLSearchParams unterscheidet nicht zwischen einem Parameter ohne etwas nach dem = und einem Parameter, der überhaupt kein = hat.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpezifikationenSpecificationURL # urlsearchparamsBrowser-KompatibilitätSiehe auch
Polyfill von URLSearchParams in core-js
Das URL-Interface.
Google Developers: Einfache URL-Manipulation mit URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Hinweis: Diese Funktion ist in Web Workers verfügbar.
Das URLSearchParams-Interface definiert Hilfsmethoden zur Arbeit mit der Abfragezeichenfolge einer URL.
URLSearchParams-Objekte sind iterierbar, sodass sie direkt in einer for...of-Struktur verwendet werden können, um über Schlüssel/Wert-Paare in der gleichen Reihenfolge zu iterieren, wie sie in der Abfragezeichenfolge erscheinen. Zum Beispiel sind die folgenden zwei Zeilen gleichwertig:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Obwohl URLSearchParams funktional einem Map ähnelt, kann es beim Iterieren einige Fallstricke geben, denen Map aufgrund seiner Implementierung nicht begegnet.Konstruktor
URLSearchParams()

Gibt eine Instanz eines URLSearchParams-Objekts zurück.

Instanzeigenschaften
size Schreibgeschützt

Gibt die Gesamtzahl der Einträge von Suchparametern an.

Instanzmethoden
URLSearchParams[Symbol.iterator]()

Gibt einen Iterator zurück, der die Iteration durch alle in diesem Objekt enthaltenen Schlüssel/Wert-Paare in der gleichen Reihenfolge wie in der Abfragezeichenfolge erlaubt.

URLSearchParams.append()

Fügt ein angegebenes Schlüssel/Wert-Paar als neuen Suchparameter hinzu.

URLSearchParams.delete()

Löscht Suchparameter, die mit einem Namen und optional einem Wert übereinstimmen, aus der Liste aller Suchparameter.

URLSearchParams.entries()

Gibt einen Iterator zurück, der die Iteration durch alle in diesem Objekt enthaltenen Schlüssel/Wert-Paare in der gleichen Reihenfolge wie in der Abfragezeichenfolge erlaubt.

URLSearchParams.forEach()

Ermöglicht die Iteration durch alle in diesem Objekt enthaltenen Werte über eine Callback-Funktion.

URLSearchParams.get()

Gibt den ersten Wert zurück, der mit dem angegebenen Suchparameter verknüpft ist.

URLSearchParams.getAll()

Gibt alle Werte zurück, die mit einem gegebenen Suchparameter verknüpft sind.

URLSearchParams.has()

Gibt einen booleschen Wert zurück, der angibt, ob ein bestimmter Parameter oder ein Parameter-Wert-Paar existiert.

URLSearchParams.keys()

Gibt einen Iterator zurück, der die Iteration durch alle Schlüssel der in diesem Objekt enthaltenen Schlüssel/Wert-Paare erlaubt.

URLSearchParams.set()

Setzt den Wert, der mit einem gegebenen Suchparameter verknüpft ist, auf den angegebenen Wert. Wenn es mehrere Werte gibt, werden die anderen gelöscht.

URLSearchParams.sort()

Sortiert alle Schlüssel/Wert-Paare (falls vorhanden) nach ihren Schlüsseln.

URLSearchParams.toString()

Gibt eine Zeichenfolge zurück, die eine zum Gebrauch in einer URL geeignete Abfragezeichenfolge enthält.

URLSearchParams.values()

Gibt einen Iterator zurück, der die Iteration durch alle Werte der in diesem Objekt enthaltenen Schlüssel/Wert-Paare erlaubt.

BeispieleVerwendung von URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Suchparameter können auch ein Objekt sein.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsen von window.locationIm Gegensatz zur URL bietet das Location-Interface keine sofort verfügbare searchParams-Eigenschaft. Wir können location.search mit URLSearchParams parsen.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Doppelte Suchparameterjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
Kein URL-ParsingDer URLSearchParams-Konstruktor parst nicht vollständige URLs. Er entfernt jedoch ein initiales führendes ? von einer Zeichenfolge, falls vorhanden.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
ProzentkodierungURLSearchParams-Objekte prozentkodieren alles in dem application/x-www-form-urlencoded Prozent-Encoding-Set (das alle Zeichen außer ASCII-Alphanumerisch, *, -, ., und _ enthält) und kodieren U+0020 SPACE als +. Es behandelt jedoch die Prozentcodierung nur beim Serialisieren und Deserialisieren der vollständigen URL-Suchparameter-Syntax. Beim Arbeiten mit einzelnen Schlüsseln und Werten verwenden Sie immer die nicht kodierte Version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

Wenn Sie ein Schlüssel/Wert-Paar mit einem prozentkodierten Schlüssel anhängen, wird dieser Schlüssel als unkodiert behandelt und erneut kodiert.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Pluszeichen beibehaltenDer URLSearchParams-Konstruktor interpretiert Pluszeichen (+) als Leerzeichen, was Probleme verursachen kann. Im folgenden Beispiel verwenden wir hexadezimale Escape-Sequenzen, um eine Zeichenfolge mit Binärdaten (bei der jedes Byte Informationen trägt) darzustellen, die in den URL-Suchparametern gespeichert werden muss. Beachten Sie, wie die von btoa() erzeugte kodierte Zeichenfolge + enthält und von URLSearchParams nicht beibehalten wird.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Erstellen Sie niemals URLSearchParams-Objekte mit dynamisch interpolierten Zeichenfolgen. Verwenden Sie stattdessen die append()-Methode, die, wie oben erwähnt, alle Zeichen unverändert interpretiert.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaktion mit URL.searchParamsDie URL.searchParams-Eigenschaft stellt die search-Zeichenfolge der URL als URLSearchParams-Objekt dar. Wenn Sie diese URLSearchParams aktualisieren, wird die search der URL mit ihrer Serialisierung aktualisiert. URL.search kodiert jedoch eine Teilmenge von Zeichen, die URLSearchParams tut, und kodiert Leerzeichen als %20 statt +. Dies kann zu überraschenden Interaktionen führen – wenn Sie searchParams aktualisieren, auch mit denselben Werten, kann die URL unterschiedlich serialisiert werden.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Leerwert vs. kein WertURLSearchParams unterscheidet nicht zwischen einem Parameter ohne etwas nach dem = und einem Parameter, der überhaupt kein = hat.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpezifikationenSpecificationURL # urlsearchparamsBrowser-KompatibilitätSiehe auch
Polyfill von URLSearchParams in core-js
Das URL-Interface.
Google Developers: Einfache URL-Manipulation mit URLSearchParams
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Hinweis: Diese Funktion ist in Web Workers verfügbar.
Das URLSearchParams-Interface definiert Hilfsmethoden zur Arbeit mit der Abfragezeichenfolge einer URL.
URLSearchParams-Objekte sind iterierbar, sodass sie direkt in einer for...of-Struktur verwendet werden können, um über Schlüssel/Wert-Paare in der gleichen Reihenfolge zu iterieren, wie sie in der Abfragezeichenfolge erscheinen. Zum Beispiel sind die folgenden zwei Zeilen gleichwertig:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Obwohl URLSearchParams funktional einem Map ähnelt, kann es beim Iterieren einige Fallstricke geben, denen Map aufgrund seiner Implementierung nicht begegnet.Konstruktor
URLSearchParams()

Gibt eine Instanz eines URLSearchParams-Objekts zurück.

Instanzeigenschaften
size Schreibgeschützt

Gibt die Gesamtzahl der Einträge von Suchparametern an.

Instanzmethoden
URLSearchParams[Symbol.iterator]()

Gibt einen Iterator zurück, der die Iteration durch alle in diesem Objekt enthaltenen Schlüssel/Wert-Paare in der gleichen Reihenfolge wie in der Abfragezeichenfolge erlaubt.

URLSearchParams.append()

Fügt ein angegebenes Schlüssel/Wert-Paar als neuen Suchparameter hinzu.

URLSearchParams.delete()

Löscht Suchparameter, die mit einem Namen und optional einem Wert übereinstimmen, aus der Liste aller Suchparameter.

URLSearchParams.entries()

Gibt einen Iterator zurück, der die Iteration durch alle in diesem Objekt enthaltenen Schlüssel/Wert-Paare in der gleichen Reihenfolge wie in der Abfragezeichenfolge erlaubt.

URLSearchParams.forEach()

Ermöglicht die Iteration durch alle in diesem Objekt enthaltenen Werte über eine Callback-Funktion.

URLSearchParams.get()

Gibt den ersten Wert zurück, der mit dem angegebenen Suchparameter verknüpft ist.

URLSearchParams.getAll()

Gibt alle Werte zurück, die mit einem gegebenen Suchparameter verknüpft sind.

URLSearchParams.has()

Gibt einen booleschen Wert zurück, der angibt, ob ein bestimmter Parameter oder ein Parameter-Wert-Paar existiert.

URLSearchParams.keys()

Gibt einen Iterator zurück, der die Iteration durch alle Schlüssel der in diesem Objekt enthaltenen Schlüssel/Wert-Paare erlaubt.

URLSearchParams.set()

Setzt den Wert, der mit einem gegebenen Suchparameter verknüpft ist, auf den angegebenen Wert. Wenn es mehrere Werte gibt, werden die anderen gelöscht.

URLSearchParams.sort()

Sortiert alle Schlüssel/Wert-Paare (falls vorhanden) nach ihren Schlüsseln.

URLSearchParams.toString()

Gibt eine Zeichenfolge zurück, die eine zum Gebrauch in einer URL geeignete Abfragezeichenfolge enthält.

URLSearchParams.values()

Gibt einen Iterator zurück, der die Iteration durch alle Werte der in diesem Objekt enthaltenen Schlüssel/Wert-Paare erlaubt.

BeispieleVerwendung von URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Suchparameter können auch ein Objekt sein.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsen von window.locationIm Gegensatz zur URL bietet das Location-Interface keine sofort verfügbare searchParams-Eigenschaft. Wir können location.search mit URLSearchParams parsen.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Doppelte Suchparameterjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
Kein URL-ParsingDer URLSearchParams-Konstruktor parst nicht vollständige URLs. Er entfernt jedoch ein initiales führendes ? von einer Zeichenfolge, falls vorhanden.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
ProzentkodierungURLSearchParams-Objekte prozentkodieren alles in dem application/x-www-form-urlencoded Prozent-Encoding-Set (das alle Zeichen außer ASCII-Alphanumerisch, *, -, ., und _ enthält) und kodieren U+0020 SPACE als +. Es behandelt jedoch die Prozentcodierung nur beim Serialisieren und Deserialisieren der vollständigen URL-Suchparameter-Syntax. Beim Arbeiten mit einzelnen Schlüsseln und Werten verwenden Sie immer die nicht kodierte Version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

Wenn Sie ein Schlüssel/Wert-Paar mit einem prozentkodierten Schlüssel anhängen, wird dieser Schlüssel als unkodiert behandelt und erneut kodiert.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Pluszeichen beibehaltenDer URLSearchParams-Konstruktor interpretiert Pluszeichen (+) als Leerzeichen, was Probleme verursachen kann. Im folgenden Beispiel verwenden wir hexadezimale Escape-Sequenzen, um eine Zeichenfolge mit Binärdaten (bei der jedes Byte Informationen trägt) darzustellen, die in den URL-Suchparametern gespeichert werden muss. Beachten Sie, wie die von btoa() erzeugte kodierte Zeichenfolge + enthält und von URLSearchParams nicht beibehalten wird.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Erstellen Sie niemals URLSearchParams-Objekte mit dynamisch interpolierten Zeichenfolgen. Verwenden Sie stattdessen die append()-Methode, die, wie oben erwähnt, alle Zeichen unverändert interpretiert.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaktion mit URL.searchParamsDie URL.searchParams-Eigenschaft stellt die search-Zeichenfolge der URL als URLSearchParams-Objekt dar. Wenn Sie diese URLSearchParams aktualisieren, wird die search der URL mit ihrer Serialisierung aktualisiert. URL.search kodiert jedoch eine Teilmenge von Zeichen, die URLSearchParams tut, und kodiert Leerzeichen als %20 statt +. Dies kann zu überraschenden Interaktionen führen – wenn Sie searchParams aktualisieren, auch mit denselben Werten, kann die URL unterschiedlich serialisiert werden.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Leerwert vs. kein WertURLSearchParams unterscheidet nicht zwischen einem Parameter ohne etwas nach dem = und einem Parameter, der überhaupt kein = hat.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpezifikationenSpecificationURL # urlsearchparamsBrowser-KompatibilitätSiehe auch
Polyfill von URLSearchParams in core-js
Das URL-Interface.
Google Developers: Einfache URL-Manipulation mit URLSearchParams
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackLa interfaz URLSearchParams define métodos útiles para trabajar con los parámetros de búsqueda de una URL.
Un objeto implementando URLSearchParams puede directamente ser usado en una for...of estructura, en lugar de entries(): for (var p of mySearchParams) la cual es equivalente a for (var p of mySearchParams.entries()).Constructor
URLSearchParams()

El Constructor returna un objeto de tipo URLSearchParams.

PropiedadesEsta interfaz no hereda ninguna propiedad.MétodosEsta interfaz no hereda ningún método.

URLSearchParams.append()

Agrega el par de llave/valor especificado como un nuevo parámetro de búsqueda.

URLSearchParams.delete()

Elimina el parámetro de búsqueda especificado, y su valor asociado, de la lista de todos los parámetros de búsqueda.

URLSearchParams.entries()

Returna un iterator que permite iterar a traves de todos los pares de llave/valor que contiene el objeto.

URLSearchParams.get()

Returna el primer valor asociado al parámetro de búsqueda especificado.

URLSearchParams.getAll()

Returna todas los valores asociados con el parámetro de búsqueda especificado.

URLSearchParams.has()

Returna un Boolean que indica si el parametro de búsqueda especificado existe.

URLSearchParams.keys()

Returna un iterator que permite iterar a través de todas las llaves de los pares de llave/valor que contiene un objeto.

URLSearchParams.set()

Establece el valor al parámetro de búsqueda asociado con el valor dado. Si hay varios valores, elimina los demás.

URLSearchParams.sort()

Organiza todos los pares de llave/valor, si existen, por sus llaves.

URLSearchParams.toString()

Returna una cadena de texto que contiene un parámetro de consulta adecuado para utilizar en una URL.

URLSearchParams.values()

Returna un iterator que permite iterar a través de todos los valores de los pares de llave/valor que contiene un objeto.

Ejemplojsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

//Itera los parámetros de búsqueda.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
EspecificacionesSpecificationURL # urlsearchparamsCompatibilidad con navegadoresVea también
Otras interfaces relacionadas con URL: URL, URLUtils.
Google Developers: Fácil manipulación de una URL con URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackLa interfaz URLSearchParams define métodos útiles para trabajar con los parámetros de búsqueda de una URL.
Un objeto implementando URLSearchParams puede directamente ser usado en una for...of estructura, en lugar de entries(): for (var p of mySearchParams) la cual es equivalente a for (var p of mySearchParams.entries()).Constructor
URLSearchParams()

El Constructor returna un objeto de tipo URLSearchParams.

PropiedadesEsta interfaz no hereda ninguna propiedad.MétodosEsta interfaz no hereda ningún método.

URLSearchParams.append()

Agrega el par de llave/valor especificado como un nuevo parámetro de búsqueda.

URLSearchParams.delete()

Elimina el parámetro de búsqueda especificado, y su valor asociado, de la lista de todos los parámetros de búsqueda.

URLSearchParams.entries()

Returna un iterator que permite iterar a traves de todos los pares de llave/valor que contiene el objeto.

URLSearchParams.get()

Returna el primer valor asociado al parámetro de búsqueda especificado.

URLSearchParams.getAll()

Returna todas los valores asociados con el parámetro de búsqueda especificado.

URLSearchParams.has()

Returna un Boolean que indica si el parametro de búsqueda especificado existe.

URLSearchParams.keys()

Returna un iterator que permite iterar a través de todas las llaves de los pares de llave/valor que contiene un objeto.

URLSearchParams.set()

Establece el valor al parámetro de búsqueda asociado con el valor dado. Si hay varios valores, elimina los demás.

URLSearchParams.sort()

Organiza todos los pares de llave/valor, si existen, por sus llaves.

URLSearchParams.toString()

Returna una cadena de texto que contiene un parámetro de consulta adecuado para utilizar en una URL.

URLSearchParams.values()

Returna un iterator que permite iterar a través de todos los valores de los pares de llave/valor que contiene un objeto.

Ejemplojsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

//Itera los parámetros de búsqueda.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
EspecificacionesSpecificationURL # urlsearchparamsCompatibilidad con navegadoresVea también
Otras interfaces relacionadas con URL: URL, URLUtils.
Google Developers: Fácil manipulación de una URL con URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 jul 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackLa interfaz URLSearchParams define métodos útiles para trabajar con los parámetros de búsqueda de una URL.
Un objeto implementando URLSearchParams puede directamente ser usado en una for...of estructura, en lugar de entries(): for (var p of mySearchParams) la cual es equivalente a for (var p of mySearchParams.entries()).Constructor
URLSearchParams()

El Constructor returna un objeto de tipo URLSearchParams.

PropiedadesEsta interfaz no hereda ninguna propiedad.MétodosEsta interfaz no hereda ningún método.

URLSearchParams.append()

Agrega el par de llave/valor especificado como un nuevo parámetro de búsqueda.

URLSearchParams.delete()

Elimina el parámetro de búsqueda especificado, y su valor asociado, de la lista de todos los parámetros de búsqueda.

URLSearchParams.entries()

Returna un iterator que permite iterar a traves de todos los pares de llave/valor que contiene el objeto.

URLSearchParams.get()

Returna el primer valor asociado al parámetro de búsqueda especificado.

URLSearchParams.getAll()

Returna todas los valores asociados con el parámetro de búsqueda especificado.

URLSearchParams.has()

Returna un Boolean que indica si el parametro de búsqueda especificado existe.

URLSearchParams.keys()

Returna un iterator que permite iterar a través de todas las llaves de los pares de llave/valor que contiene un objeto.

URLSearchParams.set()

Establece el valor al parámetro de búsqueda asociado con el valor dado. Si hay varios valores, elimina los demás.

URLSearchParams.sort()

Organiza todos los pares de llave/valor, si existen, por sus llaves.

URLSearchParams.toString()

Returna una cadena de texto que contiene un parámetro de consulta adecuado para utilizar en una URL.

URLSearchParams.values()

Returna un iterator que permite iterar a través de todos los valores de los pares de llave/valor que contiene un objeto.

Ejemplojsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

//Itera los parámetros de búsqueda.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
EspecificacionesSpecificationURL # urlsearchparamsCompatibilidad con navegadoresVea también
Otras interfaces relacionadas con URL: URL, URLUtils.
Google Developers: Fácil manipulación de una URL con URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 jul 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'interface URLSearchParams définit des méthodes utilitaires pour travailler avec la chaîne de requête (les paramètres GET) d'une URL.
Un objet implémentant URLSearchParams peut être directement utilisé dans une structure for...of, au lieu de entries() : for (var p of mySearchParams) ou son équivalent for (var p of mySearchParams.entries()).Constructeur
URLSearchParams()

Constructeur renvoyant un objet URLSearchParams.

PropriétésCette interface n'hérite d'aucune propriété.MéthodesCette interface n'hérite d'aucune méthode.

URLSearchParams.append()

Ajoute une paire clé / valeur spécifiée en tant que nouveau paramètre de recherche.

URLSearchParams.delete()

Supprime le paramètre de recherche donné et sa valeur associée de la liste de tous les paramètres de recherche.

URLSearchParams.entries()

Retourne un iterator permettant de parcourir toutes les paires clé / valeur contenues dans cet objet.

URLSearchParams.get()

Retourne la première valeur associée au paramètre de recherche donné.

URLSearchParams.getAll()

Retourne toutes les valeurs associées au paramètre de recherche donné.

URLSearchParams.has()

Retourne un Boolean indiquant si un tel paramètre de recherche existe.

URLSearchParams.keys()

Retourne un iterator permettant de parcourir toutes les clés des paires clé / valeur contenues dans cet objet.

URLSearchParams.set()

Définit la valeur associée à un paramètre de recherche donné à la valeur donnée. S'il y avait plusieurs valeurs, les autres sont supprimées.

URLSearchParams.sort()

Trie toutes les paires clé / valeur, s'il y en a, par leurs clés.

URLSearchParams.toString()

Retourne une chaîne contenant une chaîne de requête pouvant être utilisée dans une URL.

URLSearchParams.values()

Retourne un iterator permettant de parcourir toutes les valeurs des paires clé / valeur contenues dans cet objet.

Exemplejsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

// Itère sur les paramètres de recherche.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
SpécificationsSpecificationURL # urlsearchparamsCompatibilité des navigateursVoir aussi
Autres interfaces liées aux URL : URL, URLUtils.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'interface URLSearchParams définit des méthodes utilitaires pour travailler avec la chaîne de requête (les paramètres GET) d'une URL.
Un objet implémentant URLSearchParams peut être directement utilisé dans une structure for...of, au lieu de entries() : for (var p of mySearchParams) ou son équivalent for (var p of mySearchParams.entries()).Constructeur
URLSearchParams()

Constructeur renvoyant un objet URLSearchParams.

PropriétésCette interface n'hérite d'aucune propriété.MéthodesCette interface n'hérite d'aucune méthode.

URLSearchParams.append()

Ajoute une paire clé / valeur spécifiée en tant que nouveau paramètre de recherche.

URLSearchParams.delete()

Supprime le paramètre de recherche donné et sa valeur associée de la liste de tous les paramètres de recherche.

URLSearchParams.entries()

Retourne un iterator permettant de parcourir toutes les paires clé / valeur contenues dans cet objet.

URLSearchParams.get()

Retourne la première valeur associée au paramètre de recherche donné.

URLSearchParams.getAll()

Retourne toutes les valeurs associées au paramètre de recherche donné.

URLSearchParams.has()

Retourne un Boolean indiquant si un tel paramètre de recherche existe.

URLSearchParams.keys()

Retourne un iterator permettant de parcourir toutes les clés des paires clé / valeur contenues dans cet objet.

URLSearchParams.set()

Définit la valeur associée à un paramètre de recherche donné à la valeur donnée. S'il y avait plusieurs valeurs, les autres sont supprimées.

URLSearchParams.sort()

Trie toutes les paires clé / valeur, s'il y en a, par leurs clés.

URLSearchParams.toString()

Retourne une chaîne contenant une chaîne de requête pouvant être utilisée dans une URL.

URLSearchParams.values()

Retourne un iterator permettant de parcourir toutes les valeurs des paires clé / valeur contenues dans cet objet.

Exemplejsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

// Itère sur les paramètres de recherche.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
SpécificationsSpecificationURL # urlsearchparamsCompatibilité des navigateursVoir aussi
Autres interfaces liées aux URL : URL, URLUtils.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 3 août 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'interface URLSearchParams définit des méthodes utilitaires pour travailler avec la chaîne de requête (les paramètres GET) d'une URL.
Un objet implémentant URLSearchParams peut être directement utilisé dans une structure for...of, au lieu de entries() : for (var p of mySearchParams) ou son équivalent for (var p of mySearchParams.entries()).Constructeur
URLSearchParams()

Constructeur renvoyant un objet URLSearchParams.

PropriétésCette interface n'hérite d'aucune propriété.MéthodesCette interface n'hérite d'aucune méthode.

URLSearchParams.append()

Ajoute une paire clé / valeur spécifiée en tant que nouveau paramètre de recherche.

URLSearchParams.delete()

Supprime le paramètre de recherche donné et sa valeur associée de la liste de tous les paramètres de recherche.

URLSearchParams.entries()

Retourne un iterator permettant de parcourir toutes les paires clé / valeur contenues dans cet objet.

URLSearchParams.get()

Retourne la première valeur associée au paramètre de recherche donné.

URLSearchParams.getAll()

Retourne toutes les valeurs associées au paramètre de recherche donné.

URLSearchParams.has()

Retourne un Boolean indiquant si un tel paramètre de recherche existe.

URLSearchParams.keys()

Retourne un iterator permettant de parcourir toutes les clés des paires clé / valeur contenues dans cet objet.

URLSearchParams.set()

Définit la valeur associée à un paramètre de recherche donné à la valeur donnée. S'il y avait plusieurs valeurs, les autres sont supprimées.

URLSearchParams.sort()

Trie toutes les paires clé / valeur, s'il y en a, par leurs clés.

URLSearchParams.toString()

Retourne une chaîne contenant une chaîne de requête pouvant être utilisée dans une URL.

URLSearchParams.values()

Retourne un iterator permettant de parcourir toutes les valeurs des paires clé / valeur contenues dans cet objet.

Exemplejsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

// Itère sur les paramètres de recherche.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
SpécificationsSpecificationURL # urlsearchparamsCompatibilité des navigateursVoir aussi
Autres interfaces liées aux URL : URL, URLUtils.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 3 août 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
メモ: この機能はウェブワーカー内で利用可能です。
URLSearchParams インターフェイスは、URL のクエリー文字列の操作に役立つメソッドを定義します。
URLSearchParams オブジェクトは反復可能ですので、for...of 構造の中で直接使用して、キーと値のペアをクエリー文字列に現れるのと同じ順序で反復処理することができます。例えば次の 2 行は等価です。
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

URLSearchParams は機能的には Map に似ていますが、反復処理を行う際には、Map では実装方法の関係で発生しないような落とし穴に陥る可能性があります。コンストラクター
URLSearchParams()

URLSearchParams オブジェクトを返すコンストラクターです。

インスタンスプロパティ
size 読取専用

検索パラメーター項目の総数を示します。

インスタンスメソッド
URLSearchParams[Symbol.iterator]()

このオブジェクトに含まれるすべてのキーと値のペアを、クエリー文字列に現れるのと同じ順序で反復処理することができるイテレーターを返します。

URLSearchParams.append()

指定されたキーと値のペアを新しい検索パラメーターとして追加します。

URLSearchParams.delete()

指定された名前と値に一致する検索パラメーターを、検索パラメーターのリストからすべて削除します。

URLSearchParams.entries()

このオブジェクトに含まれるすべてのキーと値のペアを、クエリー文字列に現れるのと同じ順序で反復処理することができるイテレーターを返します。

URLSearchParams.forEach()

コールバック関数を介して、このオブジェクトに含まれるすべての値を反復処理します。

URLSearchParams.get()

指定された検索パラメーターに対応する最初の値を返します。

URLSearchParams.getAll()

指定された検索パラメーターに対応するすべての値を返します。

URLSearchParams.has()

指定されたパラメーター、またはパラメーターと値のペアが存在するかどうかを示す論理値を返します。

URLSearchParams.keys()

このオブジェクトに含まれるすべてのキーと値のペアのキーを反復処理する イテレーターを返します。

URLSearchParams.set()

指定された検索パラメーターに結び付けられた値を指定された値に設定します。複数の値が存在していた場合、他のものは削除されます。

URLSearchParams.sort()

すべてのキーと値のペアを、キーを基準にソートします。

URLSearchParams.toString()

URL で使用するのに適したクエリー文字列を返します。

URLSearchParams.values()

このオブジェクトに含まれるすべてのキーと値のペアの値を反復処理する イテレーターを返します。

例jsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// 検索パラメーターの列挙
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// 検索パラメーターはオブジェクトにすることもできる
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
重複する検索パラメーターjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar （最初の値のみを返す）
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
URL の解釈なしURLSearchParams コンストラクターは URL 全体を解釈しません。しかし、もし存在すれば、文字列から最初の ? 以降を削除します。
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" （decodeURIComponent('%40') と同じ）

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
プラス記号の温存URLSearchParams コンストラクターはプラス記号 (+) を空白として解釈します。以下の例では、16 進エスケープシーケンス を使って、URL 検索パラメーターに格納する必要のあるバイナリーデータ（各バイトが情報を持つ）を含む文字列を模倣しています。btoa() でエンコードされた文字列は + を含んでおり、 URLSearchParams では温存されないことに注意してください。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' はスペースに置き換えられる

console.log(atob(binQuery) === rawData); // false

データを encodeURIComponent() でエンコードすることで、これを回避できます。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
空の値と値なしURLSearchParams は = の後に何もないパラメーターと、= もないパラメーターの区別をしません。
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // '' を返す
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // これも '' を返す
console.log(noEquals.toString()); // 'foo=&bar=baz'
仕様書SpecificationURL # urlsearchparamsブラウザーの互換性関連情報
URLSearchParams のポリフィル (core-js)
URL インターフェイス。
Google Developers: URLSearchParams を使用した簡単な URL 操作 (英語)\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
メモ: この機能はウェブワーカー内で利用可能です。
URLSearchParams インターフェイスは、URL のクエリー文字列の操作に役立つメソッドを定義します。
URLSearchParams オブジェクトは反復可能ですので、for...of 構造の中で直接使用して、キーと値のペアをクエリー文字列に現れるのと同じ順序で反復処理することができます。例えば次の 2 行は等価です。
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

URLSearchParams は機能的には Map に似ていますが、反復処理を行う際には、Map では実装方法の関係で発生しないような落とし穴に陥る可能性があります。コンストラクター
URLSearchParams()

URLSearchParams オブジェクトを返すコンストラクターです。

インスタンスプロパティ
size 読取専用

検索パラメーター項目の総数を示します。

インスタンスメソッド
URLSearchParams[Symbol.iterator]()

このオブジェクトに含まれるすべてのキーと値のペアを、クエリー文字列に現れるのと同じ順序で反復処理することができるイテレーターを返します。

URLSearchParams.append()

指定されたキーと値のペアを新しい検索パラメーターとして追加します。

URLSearchParams.delete()

指定された名前と値に一致する検索パラメーターを、検索パラメーターのリストからすべて削除します。

URLSearchParams.entries()

このオブジェクトに含まれるすべてのキーと値のペアを、クエリー文字列に現れるのと同じ順序で反復処理することができるイテレーターを返します。

URLSearchParams.forEach()

コールバック関数を介して、このオブジェクトに含まれるすべての値を反復処理します。

URLSearchParams.get()

指定された検索パラメーターに対応する最初の値を返します。

URLSearchParams.getAll()

指定された検索パラメーターに対応するすべての値を返します。

URLSearchParams.has()

指定されたパラメーター、またはパラメーターと値のペアが存在するかどうかを示す論理値を返します。

URLSearchParams.keys()

このオブジェクトに含まれるすべてのキーと値のペアのキーを反復処理する イテレーターを返します。

URLSearchParams.set()

指定された検索パラメーターに結び付けられた値を指定された値に設定します。複数の値が存在していた場合、他のものは削除されます。

URLSearchParams.sort()

すべてのキーと値のペアを、キーを基準にソートします。

URLSearchParams.toString()

URL で使用するのに適したクエリー文字列を返します。

URLSearchParams.values()

このオブジェクトに含まれるすべてのキーと値のペアの値を反復処理する イテレーターを返します。

例jsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// 検索パラメーターの列挙
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// 検索パラメーターはオブジェクトにすることもできる
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
重複する検索パラメーターjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar （最初の値のみを返す）
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
URL の解釈なしURLSearchParams コンストラクターは URL 全体を解釈しません。しかし、もし存在すれば、文字列から最初の ? 以降を削除します。
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" （decodeURIComponent('%40') と同じ）

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
プラス記号の温存URLSearchParams コンストラクターはプラス記号 (+) を空白として解釈します。以下の例では、16 進エスケープシーケンス を使って、URL 検索パラメーターに格納する必要のあるバイナリーデータ（各バイトが情報を持つ）を含む文字列を模倣しています。btoa() でエンコードされた文字列は + を含んでおり、 URLSearchParams では温存されないことに注意してください。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' はスペースに置き換えられる

console.log(atob(binQuery) === rawData); // false

データを encodeURIComponent() でエンコードすることで、これを回避できます。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
空の値と値なしURLSearchParams は = の後に何もないパラメーターと、= もないパラメーターの区別をしません。
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // '' を返す
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // これも '' を返す
console.log(noEquals.toString()); // 'foo=&bar=baz'
仕様書SpecificationURL # urlsearchparamsブラウザーの互換性関連情報
URLSearchParams のポリフィル (core-js)
URL インターフェイス。
Google Developers: URLSearchParams を使用した簡単な URL 操作 (英語)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月29日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
メモ: この機能はウェブワーカー内で利用可能です。
URLSearchParams インターフェイスは、URL のクエリー文字列の操作に役立つメソッドを定義します。
URLSearchParams オブジェクトは反復可能ですので、for...of 構造の中で直接使用して、キーと値のペアをクエリー文字列に現れるのと同じ順序で反復処理することができます。例えば次の 2 行は等価です。
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

URLSearchParams は機能的には Map に似ていますが、反復処理を行う際には、Map では実装方法の関係で発生しないような落とし穴に陥る可能性があります。コンストラクター
URLSearchParams()

URLSearchParams オブジェクトを返すコンストラクターです。

インスタンスプロパティ
size 読取専用

検索パラメーター項目の総数を示します。

インスタンスメソッド
URLSearchParams[Symbol.iterator]()

このオブジェクトに含まれるすべてのキーと値のペアを、クエリー文字列に現れるのと同じ順序で反復処理することができるイテレーターを返します。

URLSearchParams.append()

指定されたキーと値のペアを新しい検索パラメーターとして追加します。

URLSearchParams.delete()

指定された名前と値に一致する検索パラメーターを、検索パラメーターのリストからすべて削除します。

URLSearchParams.entries()

このオブジェクトに含まれるすべてのキーと値のペアを、クエリー文字列に現れるのと同じ順序で反復処理することができるイテレーターを返します。

URLSearchParams.forEach()

コールバック関数を介して、このオブジェクトに含まれるすべての値を反復処理します。

URLSearchParams.get()

指定された検索パラメーターに対応する最初の値を返します。

URLSearchParams.getAll()

指定された検索パラメーターに対応するすべての値を返します。

URLSearchParams.has()

指定されたパラメーター、またはパラメーターと値のペアが存在するかどうかを示す論理値を返します。

URLSearchParams.keys()

このオブジェクトに含まれるすべてのキーと値のペアのキーを反復処理する イテレーターを返します。

URLSearchParams.set()

指定された検索パラメーターに結び付けられた値を指定された値に設定します。複数の値が存在していた場合、他のものは削除されます。

URLSearchParams.sort()

すべてのキーと値のペアを、キーを基準にソートします。

URLSearchParams.toString()

URL で使用するのに適したクエリー文字列を返します。

URLSearchParams.values()

このオブジェクトに含まれるすべてのキーと値のペアの値を反復処理する イテレーターを返します。

例jsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// 検索パラメーターの列挙
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// 検索パラメーターはオブジェクトにすることもできる
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
重複する検索パラメーターjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar （最初の値のみを返す）
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
URL の解釈なしURLSearchParams コンストラクターは URL 全体を解釈しません。しかし、もし存在すれば、文字列から最初の ? 以降を削除します。
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" （decodeURIComponent('%40') と同じ）

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
プラス記号の温存URLSearchParams コンストラクターはプラス記号 (+) を空白として解釈します。以下の例では、16 進エスケープシーケンス を使って、URL 検索パラメーターに格納する必要のあるバイナリーデータ（各バイトが情報を持つ）を含む文字列を模倣しています。btoa() でエンコードされた文字列は + を含んでおり、 URLSearchParams では温存されないことに注意してください。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' はスペースに置き換えられる

console.log(atob(binQuery) === rawData); // false

データを encodeURIComponent() でエンコードすることで、これを回避できます。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
空の値と値なしURLSearchParams は = の後に何もないパラメーターと、= もないパラメーターの区別をしません。
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // '' を返す
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // これも '' を返す
console.log(noEquals.toString()); // 'foo=&bar=baz'
仕様書SpecificationURL # urlsearchparamsブラウザーの互換性関連情報
URLSearchParams のポリフィル (core-js)
URL インターフェイス。
Google Developers: URLSearchParams を使用した簡単な URL 操作 (英語)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月29日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackURLSearchParams 인터페이스는 URL의 쿼리 문자열을 대상으로 작업할 수 있는 유틸리티 메서드를 정의합니다.
URLSearchParams를 구현하는 객체는 for...of 반복문으로 직접 키/값 쌍을 순회할 수 있습니다. 키/값 쌍의 순회 순서는 쿼리 문자열에 나타나는 순서와 같습니다. 예를 들어, 다음 두 줄의 코드는 동일합니다.
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

참고 : 이 기능은 Web Worker에서 사용할 수 있습니다.생성자
URLSearchParams()

URLSearchParams 객체 인스턴스를 반환합니다.

메서드
URLSearchParams.append()

주어진 키/값 쌍을 새로운 검색 매개변수로 추가합니다.

URLSearchParams.delete()

주어진 검색 매개변수와 그 값을 모두 삭제합니다.

URLSearchParams.entries()

객체의 모든 키/값 쌍을 쿼리 문자열과 같은 순서로 순회할 수 있는 순회기를 반환합니다.

URLSearchParams.forEach()

객체의 모든 값을 순회하면서 지정한 콜백을 호출합니다.

URLSearchParams.get()

주어진 검색 매개변수에 연결된 첫 번째 값을 반환합니다.

URLSearchParams.getAll()

주어진 검색 매개변수에 연결된 모든 값을 반환합니다.

URLSearchParams.has()

주어진 검색 매개변수의 존재 여부를 나타내는 불리언 값을을 반환합니다.

URLSearchParams.keys()

객체의 모든 키/값 쌍에서 키만 순회할 수 있는 순회기를 반환합니다.

URLSearchParams.set()

주어진 검색 매개변수에 값을 설정합니다. 이미 해당 매개변수에 연결된 값이 있으면 우선 모두 제거합니다.

URLSearchParams.sort()

모든 키/값 쌍을 키의 순서로 정렬합니다.

URLSearchParams.toString()

URL에 쓰기 적합한 형태의 쿼리 문자열을 반환합니다.

URLSearchParams.values()

객체의 모든 키/값 쌍에서 값만 순회할 수 있는 순회기를 반환합니다.

예제jsconst paramsString = "q=URLUtils.searchParams&topic=api";
let searchParams = new URLSearchParams(paramsString);

// 검색 매개변수 순회
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"

js// 검색 매개변수는 객체도 가능
let paramsObj = { foo: "bar", baz: "bar" };
let searchParams = new URLSearchParams(paramsObj);

searchParams.toString(); // "foo=bar&baz=bar"
searchParams.has("foo"); // true
searchParams.get("foo"); // bar
중복된 검색 매개변수jslet paramStr = "foo=bar&foo=baz";
let searchParams = new URLSearchParams(paramStr);

searchParams.toString(); // "foo=bar&foo=baz"
searchParams.has("foo"); // true
searchParams.get("foo"); // bar, 첫 번째 값만 반환
searchParams.getAll("foo"); // ["bar", "baz"]
URL 파싱 없음URLSearchParams 생성자에 URL 파싱 기능은 없습니다. 다만 쿼리 문자열이 ?로 시작하면 무시합니다.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

searchParams1.has("query"); // false
searchParams1.has("http://example.com/search?query"); // true

searchParams1.get("query"); // null
searchParams1.get("http://example.com/search?query"); // "@" (decodeURIComponent('%40')과 동일)

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
searchParams2.has("query"); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
searchParams3.has("query"); // true
더하기 기호 보존하기URLSearchParams 생성자는 더하기 기호(+)를 공백으로 취급하므로 원하지 않는 결과를 낳을 수 있습니다.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+'가 공백으로 대체됨

console.log(atob(binQuery) === rawData); // false

encodeURIComponent()로 값을 먼저 인코딩하면 이 문제를 피할 수 있습니다.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
빈 값과 없는 값URLSearchParams는 = 뒤에 값이 없는 것과, 아예 =조차 없는 매개변수를 구분하지 않습니다.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
emptyVal.get("foo"); // '' 반환
const noEquals = new URLSearchParams("foo&bar=baz");
noEquals.get("foo"); // '' 반환, 동일함
noEquals.toString(); // 'foo=&bar=baz'
명세SpecificationURL # urlsearchparams브라우저 호환성같이 보기
core-js의 URLSearchParams 폴리필
URL 인터페이스
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackURLSearchParams 인터페이스는 URL의 쿼리 문자열을 대상으로 작업할 수 있는 유틸리티 메서드를 정의합니다.
URLSearchParams를 구현하는 객체는 for...of 반복문으로 직접 키/값 쌍을 순회할 수 있습니다. 키/값 쌍의 순회 순서는 쿼리 문자열에 나타나는 순서와 같습니다. 예를 들어, 다음 두 줄의 코드는 동일합니다.
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

참고 : 이 기능은 Web Worker에서 사용할 수 있습니다.생성자
URLSearchParams()

URLSearchParams 객체 인스턴스를 반환합니다.

메서드
URLSearchParams.append()

주어진 키/값 쌍을 새로운 검색 매개변수로 추가합니다.

URLSearchParams.delete()

주어진 검색 매개변수와 그 값을 모두 삭제합니다.

URLSearchParams.entries()

객체의 모든 키/값 쌍을 쿼리 문자열과 같은 순서로 순회할 수 있는 순회기를 반환합니다.

URLSearchParams.forEach()

객체의 모든 값을 순회하면서 지정한 콜백을 호출합니다.

URLSearchParams.get()

주어진 검색 매개변수에 연결된 첫 번째 값을 반환합니다.

URLSearchParams.getAll()

주어진 검색 매개변수에 연결된 모든 값을 반환합니다.

URLSearchParams.has()

주어진 검색 매개변수의 존재 여부를 나타내는 불리언 값을을 반환합니다.

URLSearchParams.keys()

객체의 모든 키/값 쌍에서 키만 순회할 수 있는 순회기를 반환합니다.

URLSearchParams.set()

주어진 검색 매개변수에 값을 설정합니다. 이미 해당 매개변수에 연결된 값이 있으면 우선 모두 제거합니다.

URLSearchParams.sort()

모든 키/값 쌍을 키의 순서로 정렬합니다.

URLSearchParams.toString()

URL에 쓰기 적합한 형태의 쿼리 문자열을 반환합니다.

URLSearchParams.values()

객체의 모든 키/값 쌍에서 값만 순회할 수 있는 순회기를 반환합니다.

예제jsconst paramsString = "q=URLUtils.searchParams&topic=api";
let searchParams = new URLSearchParams(paramsString);

// 검색 매개변수 순회
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"

js// 검색 매개변수는 객체도 가능
let paramsObj = { foo: "bar", baz: "bar" };
let searchParams = new URLSearchParams(paramsObj);

searchParams.toString(); // "foo=bar&baz=bar"
searchParams.has("foo"); // true
searchParams.get("foo"); // bar
중복된 검색 매개변수jslet paramStr = "foo=bar&foo=baz";
let searchParams = new URLSearchParams(paramStr);

searchParams.toString(); // "foo=bar&foo=baz"
searchParams.has("foo"); // true
searchParams.get("foo"); // bar, 첫 번째 값만 반환
searchParams.getAll("foo"); // ["bar", "baz"]
URL 파싱 없음URLSearchParams 생성자에 URL 파싱 기능은 없습니다. 다만 쿼리 문자열이 ?로 시작하면 무시합니다.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

searchParams1.has("query"); // false
searchParams1.has("http://example.com/search?query"); // true

searchParams1.get("query"); // null
searchParams1.get("http://example.com/search?query"); // "@" (decodeURIComponent('%40')과 동일)

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
searchParams2.has("query"); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
searchParams3.has("query"); // true
더하기 기호 보존하기URLSearchParams 생성자는 더하기 기호(+)를 공백으로 취급하므로 원하지 않는 결과를 낳을 수 있습니다.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+'가 공백으로 대체됨

console.log(atob(binQuery) === rawData); // false

encodeURIComponent()로 값을 먼저 인코딩하면 이 문제를 피할 수 있습니다.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
빈 값과 없는 값URLSearchParams는 = 뒤에 값이 없는 것과, 아예 =조차 없는 매개변수를 구분하지 않습니다.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
emptyVal.get("foo"); // '' 반환
const noEquals = new URLSearchParams("foo&bar=baz");
noEquals.get("foo"); // '' 반환, 동일함
noEquals.toString(); // 'foo=&bar=baz'
명세SpecificationURL # urlsearchparams브라우저 호환성같이 보기
core-js의 URLSearchParams 폴리필
URL 인터페이스
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2023년 7월 30일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackURLSearchParams 인터페이스는 URL의 쿼리 문자열을 대상으로 작업할 수 있는 유틸리티 메서드를 정의합니다.
URLSearchParams를 구현하는 객체는 for...of 반복문으로 직접 키/값 쌍을 순회할 수 있습니다. 키/값 쌍의 순회 순서는 쿼리 문자열에 나타나는 순서와 같습니다. 예를 들어, 다음 두 줄의 코드는 동일합니다.
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

참고 : 이 기능은 Web Worker에서 사용할 수 있습니다.생성자
URLSearchParams()

URLSearchParams 객체 인스턴스를 반환합니다.

메서드
URLSearchParams.append()

주어진 키/값 쌍을 새로운 검색 매개변수로 추가합니다.

URLSearchParams.delete()

주어진 검색 매개변수와 그 값을 모두 삭제합니다.

URLSearchParams.entries()

객체의 모든 키/값 쌍을 쿼리 문자열과 같은 순서로 순회할 수 있는 순회기를 반환합니다.

URLSearchParams.forEach()

객체의 모든 값을 순회하면서 지정한 콜백을 호출합니다.

URLSearchParams.get()

주어진 검색 매개변수에 연결된 첫 번째 값을 반환합니다.

URLSearchParams.getAll()

주어진 검색 매개변수에 연결된 모든 값을 반환합니다.

URLSearchParams.has()

주어진 검색 매개변수의 존재 여부를 나타내는 불리언 값을을 반환합니다.

URLSearchParams.keys()

객체의 모든 키/값 쌍에서 키만 순회할 수 있는 순회기를 반환합니다.

URLSearchParams.set()

주어진 검색 매개변수에 값을 설정합니다. 이미 해당 매개변수에 연결된 값이 있으면 우선 모두 제거합니다.

URLSearchParams.sort()

모든 키/값 쌍을 키의 순서로 정렬합니다.

URLSearchParams.toString()

URL에 쓰기 적합한 형태의 쿼리 문자열을 반환합니다.

URLSearchParams.values()

객체의 모든 키/값 쌍에서 값만 순회할 수 있는 순회기를 반환합니다.

예제jsconst paramsString = "q=URLUtils.searchParams&topic=api";
let searchParams = new URLSearchParams(paramsString);

// 검색 매개변수 순회
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"

js// 검색 매개변수는 객체도 가능
let paramsObj = { foo: "bar", baz: "bar" };
let searchParams = new URLSearchParams(paramsObj);

searchParams.toString(); // "foo=bar&baz=bar"
searchParams.has("foo"); // true
searchParams.get("foo"); // bar
중복된 검색 매개변수jslet paramStr = "foo=bar&foo=baz";
let searchParams = new URLSearchParams(paramStr);

searchParams.toString(); // "foo=bar&foo=baz"
searchParams.has("foo"); // true
searchParams.get("foo"); // bar, 첫 번째 값만 반환
searchParams.getAll("foo"); // ["bar", "baz"]
URL 파싱 없음URLSearchParams 생성자에 URL 파싱 기능은 없습니다. 다만 쿼리 문자열이 ?로 시작하면 무시합니다.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

searchParams1.has("query"); // false
searchParams1.has("http://example.com/search?query"); // true

searchParams1.get("query"); // null
searchParams1.get("http://example.com/search?query"); // "@" (decodeURIComponent('%40')과 동일)

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
searchParams2.has("query"); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
searchParams3.has("query"); // true
더하기 기호 보존하기URLSearchParams 생성자는 더하기 기호(+)를 공백으로 취급하므로 원하지 않는 결과를 낳을 수 있습니다.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+'가 공백으로 대체됨

console.log(atob(binQuery) === rawData); // false

encodeURIComponent()로 값을 먼저 인코딩하면 이 문제를 피할 수 있습니다.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
빈 값과 없는 값URLSearchParams는 = 뒤에 값이 없는 것과, 아예 =조차 없는 매개변수를 구분하지 않습니다.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
emptyVal.get("foo"); // '' 반환
const noEquals = new URLSearchParams("foo&bar=baz");
noEquals.get("foo"); // '' 반환, 동일함
noEquals.toString(); // 'foo=&bar=baz'
명세SpecificationURL # urlsearchparams브라우저 호환성같이 보기
core-js의 URLSearchParams 폴리필
URL 인터페이스
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2023년 7월 30일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackA interface URLSearchParams define métodos utilitários para trabalhar com os parâmetros de uma URL.
Um objeto que implementa URLSearchParams pode ser usado diretamente em uma estrutura for...of para iterar sobre pares chave/valor na mesma ordem em que elas aparecem nos parâmetros, por exemplo as linhas a seguir são equivalentes:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Nota: This feature is available in Web Workers.Construtor
URLSearchParams()

Retorna uma instância do objeto URLSearchParams.

Métodos
URLSearchParams.append()

Adiciona o par chave/valor especificado como um novo parâmetro de busca.

URLSearchParams.delete()

Exclui o parâmetro de pesquisa fornecido e seu valor associado da lista de todos os parâmetros de pesquisa.

URLSearchParams.entries()

Retorna um iterator permitindo a iteração através de todos os pares de chave/valor contidos neste objeto na mesma ordem em que aparecem na string de consulta.

URLSearchParams.forEach()

Permite a iteração através de todos os valores contidos neste objeto por meio de uma função de retorno de chamada.

URLSearchParams.get()

Retorna o primeiro valor associado ao parâmetro de pesquisa fornecido.

URLSearchParams.getAll()

Retorna todos os valores associados a um determinado parâmetro de pesquisa.

URLSearchParams.has()

Retorna um valor booleano indicando se tal parâmetro existe.

URLSearchParams.keys()

Retorna um iterator permitindo a iteração através de todas as chaves dos pares chave/valor contidos neste objeto.

URLSearchParams.set()

Define o valor associado a um determinado parâmetro de pesquisa para o valor fornecido. Se houver vários valores, os demais serão excluídos.

URLSearchParams.sort()

Ordena todos os pares de chave/valor, se houver, por suas chaves.

URLSearchParams.toString()

Retorna uma string contendo uma string de consulta adequada para uso em uma URL.

URLSearchParams.values()

Retorna um iterator permitindo a iteração através de todos os valores dos pares chave/valor contidos neste objeto.

Exemplosjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterando os parâmetros de pesquisa
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// Os parâmetros de pesquisa também podem ser objetos
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parâmetros de pesquisa duplicadosjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, somente o primeiro valor
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
Sem análise de URLO construtor URLSearchParams não analisa URLs completas. No entanto, ele retirará um ? inicial inicial de uma string, se presente.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalente a decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Preservando os sinais de adiçãoO construtor URLSearchParams interpreta sinais de adição (+) como espaços, o que pode causar problemas.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' são substituídos por espaços

console.log(atob(binQuery) === rawData); // false

Você pode evitar isso codificando os dados com o encodeURIComponent().
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Valor vazio vs. nenhum valorURLSearchParams não distingue entre parâmetros com nada após o = e um parâmetro que não possui um =.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // retorna ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // também retorna ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
EspecificaçõesSpecificationURL # urlsearchparamsCompatibilidade com navegadoresVeja também
Polyfill de URLSearchParams no core-js
A interface URL.
Google Developers: Manipulação de URL fácil com URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackA interface URLSearchParams define métodos utilitários para trabalhar com os parâmetros de uma URL.
Um objeto que implementa URLSearchParams pode ser usado diretamente em uma estrutura for...of para iterar sobre pares chave/valor na mesma ordem em que elas aparecem nos parâmetros, por exemplo as linhas a seguir são equivalentes:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Nota: This feature is available in Web Workers.Construtor
URLSearchParams()

Retorna uma instância do objeto URLSearchParams.

Métodos
URLSearchParams.append()

Adiciona o par chave/valor especificado como um novo parâmetro de busca.

URLSearchParams.delete()

Exclui o parâmetro de pesquisa fornecido e seu valor associado da lista de todos os parâmetros de pesquisa.

URLSearchParams.entries()

Retorna um iterator permitindo a iteração através de todos os pares de chave/valor contidos neste objeto na mesma ordem em que aparecem na string de consulta.

URLSearchParams.forEach()

Permite a iteração através de todos os valores contidos neste objeto por meio de uma função de retorno de chamada.

URLSearchParams.get()

Retorna o primeiro valor associado ao parâmetro de pesquisa fornecido.

URLSearchParams.getAll()

Retorna todos os valores associados a um determinado parâmetro de pesquisa.

URLSearchParams.has()

Retorna um valor booleano indicando se tal parâmetro existe.

URLSearchParams.keys()

Retorna um iterator permitindo a iteração através de todas as chaves dos pares chave/valor contidos neste objeto.

URLSearchParams.set()

Define o valor associado a um determinado parâmetro de pesquisa para o valor fornecido. Se houver vários valores, os demais serão excluídos.

URLSearchParams.sort()

Ordena todos os pares de chave/valor, se houver, por suas chaves.

URLSearchParams.toString()

Retorna uma string contendo uma string de consulta adequada para uso em uma URL.

URLSearchParams.values()

Retorna um iterator permitindo a iteração através de todos os valores dos pares chave/valor contidos neste objeto.

Exemplosjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterando os parâmetros de pesquisa
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// Os parâmetros de pesquisa também podem ser objetos
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parâmetros de pesquisa duplicadosjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, somente o primeiro valor
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
Sem análise de URLO construtor URLSearchParams não analisa URLs completas. No entanto, ele retirará um ? inicial inicial de uma string, se presente.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalente a decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Preservando os sinais de adiçãoO construtor URLSearchParams interpreta sinais de adição (+) como espaços, o que pode causar problemas.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' são substituídos por espaços

console.log(atob(binQuery) === rawData); // false

Você pode evitar isso codificando os dados com o encodeURIComponent().
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Valor vazio vs. nenhum valorURLSearchParams não distingue entre parâmetros com nada após o = e um parâmetro que não possui um =.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // retorna ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // também retorna ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
EspecificaçõesSpecificationURL # urlsearchparamsCompatibilidade com navegadoresVeja também
Polyfill de URLSearchParams no core-js
A interface URL.
Google Developers: Manipulação de URL fácil com URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2 de ago. de 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackA interface URLSearchParams define métodos utilitários para trabalhar com os parâmetros de uma URL.
Um objeto que implementa URLSearchParams pode ser usado diretamente em uma estrutura for...of para iterar sobre pares chave/valor na mesma ordem em que elas aparecem nos parâmetros, por exemplo as linhas a seguir são equivalentes:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Nota: This feature is available in Web Workers.Construtor
URLSearchParams()

Retorna uma instância do objeto URLSearchParams.

Métodos
URLSearchParams.append()

Adiciona o par chave/valor especificado como um novo parâmetro de busca.

URLSearchParams.delete()

Exclui o parâmetro de pesquisa fornecido e seu valor associado da lista de todos os parâmetros de pesquisa.

URLSearchParams.entries()

Retorna um iterator permitindo a iteração através de todos os pares de chave/valor contidos neste objeto na mesma ordem em que aparecem na string de consulta.

URLSearchParams.forEach()

Permite a iteração através de todos os valores contidos neste objeto por meio de uma função de retorno de chamada.

URLSearchParams.get()

Retorna o primeiro valor associado ao parâmetro de pesquisa fornecido.

URLSearchParams.getAll()

Retorna todos os valores associados a um determinado parâmetro de pesquisa.

URLSearchParams.has()

Retorna um valor booleano indicando se tal parâmetro existe.

URLSearchParams.keys()

Retorna um iterator permitindo a iteração através de todas as chaves dos pares chave/valor contidos neste objeto.

URLSearchParams.set()

Define o valor associado a um determinado parâmetro de pesquisa para o valor fornecido. Se houver vários valores, os demais serão excluídos.

URLSearchParams.sort()

Ordena todos os pares de chave/valor, se houver, por suas chaves.

URLSearchParams.toString()

Retorna uma string contendo uma string de consulta adequada para uso em uma URL.

URLSearchParams.values()

Retorna um iterator permitindo a iteração através de todos os valores dos pares chave/valor contidos neste objeto.

Exemplosjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterando os parâmetros de pesquisa
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// Os parâmetros de pesquisa também podem ser objetos
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parâmetros de pesquisa duplicadosjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, somente o primeiro valor
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
Sem análise de URLO construtor URLSearchParams não analisa URLs completas. No entanto, ele retirará um ? inicial inicial de uma string, se presente.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalente a decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Preservando os sinais de adiçãoO construtor URLSearchParams interpreta sinais de adição (+) como espaços, o que pode causar problemas.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' são substituídos por espaços

console.log(atob(binQuery) === rawData); // false

Você pode evitar isso codificando os dados com o encodeURIComponent().
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Valor vazio vs. nenhum valorURLSearchParams não distingue entre parâmetros com nada após o = e um parâmetro que não possui um =.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // retorna ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // também retorna ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
EspecificaçõesSpecificationURL # urlsearchparamsCompatibilidade com navegadoresVeja também
Polyfill de URLSearchParams no core-js
A interface URL.
Google Developers: Manipulação de URL fácil com URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2 de ago. de 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Примечание: Эта возможность доступна в Web Workers.
URLSearchParams интерфейс определяет служебные методы для работы со строкой запроса URL.
Объект, реализующий URLSearchParams, может непосредственно использоваться в структуре for...of, например, следующие две строки идентичны:
for (var p of mySearchParams);
for (var p of mySearchParams.entries());

Примечание: Эта возможность доступна в Web Workers.Конструктор
URLSearchParams()

Конструктор возвращает объект URLSearchParams.

СвойстваНаследование свойств отсутствует.МетодыОтсутствует наследование методов.

URLSearchParams.append()

Добавляет указанную пару key/value в качестве нового параметра поиска.

URLSearchParams.delete()

Удаляет заданный параметр поиска и связанное с ним значение из списка всех параметров поиска.

URLSearchParams.entries()

Возвращает iterator, позволяющий пройти через все пары key/value, содержащиеся в этом объекте.

URLSearchParams.get()

Возвращает первое значение, связанное с заданным параметром поиска.

URLSearchParams.getAll()

Возвращает все значения ассоциации с заданным параметром поиска.

URLSearchParams.has()

Возвращает Boolean, указывающий, существует ли такой параметр поиска.

URLSearchParams.keys()

Возвращает iterator, позволяющий пройти все ключи пары key/value, содержащиеся в этом объекте.

URLSearchParams.set()

Устанавливает значение, связанное с заданным параметром поиска, с заданным значением. Если было несколько значений, удалите остальные.

URLSearchParams.toString()

Возвращает строку, содержащую строку запроса, подходящую для использования в URL-адресе.

URLSearchParams.values()

Возвращает iterator, позволяющий пройти через все значения пар key/value, содержащихся в этом объекте.

Примерjsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

// Итерируем параметры поиска.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
СпецификацииSpecificationURL # urlsearchparamsСовместимость с браузерамиСмотрите также
Other URL-related interfaces: URL, URLUtils.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Примечание: Эта возможность доступна в Web Workers.
URLSearchParams интерфейс определяет служебные методы для работы со строкой запроса URL.
Объект, реализующий URLSearchParams, может непосредственно использоваться в структуре for...of, например, следующие две строки идентичны:
for (var p of mySearchParams);
for (var p of mySearchParams.entries());

Примечание: Эта возможность доступна в Web Workers.Конструктор
URLSearchParams()

Конструктор возвращает объект URLSearchParams.

СвойстваНаследование свойств отсутствует.МетодыОтсутствует наследование методов.

URLSearchParams.append()

Добавляет указанную пару key/value в качестве нового параметра поиска.

URLSearchParams.delete()

Удаляет заданный параметр поиска и связанное с ним значение из списка всех параметров поиска.

URLSearchParams.entries()

Возвращает iterator, позволяющий пройти через все пары key/value, содержащиеся в этом объекте.

URLSearchParams.get()

Возвращает первое значение, связанное с заданным параметром поиска.

URLSearchParams.getAll()

Возвращает все значения ассоциации с заданным параметром поиска.

URLSearchParams.has()

Возвращает Boolean, указывающий, существует ли такой параметр поиска.

URLSearchParams.keys()

Возвращает iterator, позволяющий пройти все ключи пары key/value, содержащиеся в этом объекте.

URLSearchParams.set()

Устанавливает значение, связанное с заданным параметром поиска, с заданным значением. Если было несколько значений, удалите остальные.

URLSearchParams.toString()

Возвращает строку, содержащую строку запроса, подходящую для использования в URL-адресе.

URLSearchParams.values()

Возвращает iterator, позволяющий пройти через все значения пар key/value, содержащихся в этом объекте.

Примерjsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

// Итерируем параметры поиска.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
СпецификацииSpecificationURL # urlsearchparamsСовместимость с браузерамиСмотрите также
Other URL-related interfaces: URL, URLUtils.
Google Developers: Easy URL manipulation with URLSearchParams

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 19 мая 2024 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Примечание: Эта возможность доступна в Web Workers.
URLSearchParams интерфейс определяет служебные методы для работы со строкой запроса URL.
Объект, реализующий URLSearchParams, может непосредственно использоваться в структуре for...of, например, следующие две строки идентичны:
for (var p of mySearchParams);
for (var p of mySearchParams.entries());

Примечание: Эта возможность доступна в Web Workers.Конструктор
URLSearchParams()

Конструктор возвращает объект URLSearchParams.

СвойстваНаследование свойств отсутствует.МетодыОтсутствует наследование методов.

URLSearchParams.append()

Добавляет указанную пару key/value в качестве нового параметра поиска.

URLSearchParams.delete()

Удаляет заданный параметр поиска и связанное с ним значение из списка всех параметров поиска.

URLSearchParams.entries()

Возвращает iterator, позволяющий пройти через все пары key/value, содержащиеся в этом объекте.

URLSearchParams.get()

Возвращает первое значение, связанное с заданным параметром поиска.

URLSearchParams.getAll()

Возвращает все значения ассоциации с заданным параметром поиска.

URLSearchParams.has()

Возвращает Boolean, указывающий, существует ли такой параметр поиска.

URLSearchParams.keys()

Возвращает iterator, позволяющий пройти все ключи пары key/value, содержащиеся в этом объекте.

URLSearchParams.set()

Устанавливает значение, связанное с заданным параметром поиска, с заданным значением. Если было несколько значений, удалите остальные.

URLSearchParams.toString()

Возвращает строку, содержащую строку запроса, подходящую для использования в URL-адресе.

URLSearchParams.values()

Возвращает iterator, позволяющий пройти через все значения пар key/value, содержащихся в этом объекте.

Примерjsvar paramsString = "q=URLUtils.searchParams&topic=api";
var searchParams = new URLSearchParams(paramsString);

// Итерируем параметры поиска.
for (let p of searchParams) {
  console.log(p);
}

searchParams.has("topic") === true; // true
searchParams.get("topic") === "api"; // true
searchParams.getAll("topic"); // ["api"]
searchParams.get("foo") === null; // true
searchParams.append("topic", "webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=api&topic=webdev"
searchParams.set("topic", "More webdev");
searchParams.toString(); // "q=URLUtils.searchParams&topic=More+webdev"
searchParams.delete("topic");
searchParams.toString(); // "q=URLUtils.searchParams"
СпецификацииSpecificationURL # urlsearchparamsСовместимость с браузерамиСмотрите также
Other URL-related interfaces: URL, URLUtils.
Google Developers: Easy URL manipulation with URLSearchParams

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 19 мая 2024 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
备注： 此特性在 Web Worker 中可用。
URLSearchParams 接口定义了一些实用的方法来处理 URL 的查询字符串。
一个实现了 URLSearchParams 的对象可以直接用在 for...of 结构中，以键/值对在查询字符串中出现的顺序对它们进行迭代，例如下面两行是等价的：
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}
构造函数
URLSearchParams()

返回一个 URLSearchParams 对象。

实例属性
size 只读 

返回 URLSearchParams 对象中查询参数的总个数。

实例方法
URLSearchParams[Symbol.iterator]()

返回一个 iterator，允许以键/值对在查询字符串中出现的顺序迭代包含在该对象的键/值对。

URLSearchParams.append()

插入一个指定的键/值对作为新的查询参数。

URLSearchParams.delete()

从查询参数列表里删除指定的查询参数及其对应的值。

URLSearchParams.entries()

返回一个iterator可以遍历所有键/值对的对象。

URLSearchParams.forEach()

通过回调函数迭代此对象中包含的所有值。

URLSearchParams.get()

获取指定查询参数的第一个值。

URLSearchParams.getAll()

获取指定查询参数的所有值，返回是一个数组。

URLSearchParams.has()

返回 Boolean 判断是否存在此查询参数。

URLSearchParams.keys()

返回iterator 此对象包含了键/值对的所有键名。

URLSearchParams.set()

设置一个查询参数的新值，假如原来有多个值将删除其他所有的值。

URLSearchParams.sort()

按键名排序。

URLSearchParams.toString()

返回查询参数组成的字符串，可直接使用在 URL 上。

URLSearchParams.values()

返回iterator 此对象包含了键/值对的所有值。

示例jsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// 迭代查询参数
for (let p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// 对象也可作为查询参数
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
重复的查询参数jsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, 仅返回第一个值
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
不完整的 URL 解析URLSearchParams 构造函数不会解析完整 URL，但是如果字符串起始位置有 ? 的话会被去除。
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@"（等价于 decodeURIComponent('%40')）

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
保留加号URLSearchParams 的构造函数将加号（+）解释为空格，这可能会有问题。在下面的示例中，我们使用十六进制转义序列模拟一个包含二进制数据（其中每个字节都携带信息）的字符串，该数据需要存储在 URL 查询参数中。请注意 btoa() 生成的编码字符串包含 +，而其并不会被 URLSearchParams 保留。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A'，“+”被替换为空格

console.log(atob(binQuery) === rawData); // false

可以通过使用 encodeURIComponent() 对数据进行编解码来避免这种情况。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
空值 vs 无值URLSearchParams 不区分 = 后面没有任何内容的参数和完全没有 = 的参数。
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // 返回 ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // 也返回 ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
规范SpecificationURL # urlsearchparams浏览器兼容性参见
core-js 中 URLSearchParams 的 Polyfill
URL 接口
谷歌开发者：使用 URLSearchParams 轻松操作 URL\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
备注： 此特性在 Web Worker 中可用。
URLSearchParams 接口定义了一些实用的方法来处理 URL 的查询字符串。
一个实现了 URLSearchParams 的对象可以直接用在 for...of 结构中，以键/值对在查询字符串中出现的顺序对它们进行迭代，例如下面两行是等价的：
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}
构造函数
URLSearchParams()

返回一个 URLSearchParams 对象。

实例属性
size 只读 

返回 URLSearchParams 对象中查询参数的总个数。

实例方法
URLSearchParams[Symbol.iterator]()

返回一个 iterator，允许以键/值对在查询字符串中出现的顺序迭代包含在该对象的键/值对。

URLSearchParams.append()

插入一个指定的键/值对作为新的查询参数。

URLSearchParams.delete()

从查询参数列表里删除指定的查询参数及其对应的值。

URLSearchParams.entries()

返回一个iterator可以遍历所有键/值对的对象。

URLSearchParams.forEach()

通过回调函数迭代此对象中包含的所有值。

URLSearchParams.get()

获取指定查询参数的第一个值。

URLSearchParams.getAll()

获取指定查询参数的所有值，返回是一个数组。

URLSearchParams.has()

返回 Boolean 判断是否存在此查询参数。

URLSearchParams.keys()

返回iterator 此对象包含了键/值对的所有键名。

URLSearchParams.set()

设置一个查询参数的新值，假如原来有多个值将删除其他所有的值。

URLSearchParams.sort()

按键名排序。

URLSearchParams.toString()

返回查询参数组成的字符串，可直接使用在 URL 上。

URLSearchParams.values()

返回iterator 此对象包含了键/值对的所有值。

示例jsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// 迭代查询参数
for (let p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// 对象也可作为查询参数
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
重复的查询参数jsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, 仅返回第一个值
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
不完整的 URL 解析URLSearchParams 构造函数不会解析完整 URL，但是如果字符串起始位置有 ? 的话会被去除。
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@"（等价于 decodeURIComponent('%40')）

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
保留加号URLSearchParams 的构造函数将加号（+）解释为空格，这可能会有问题。在下面的示例中，我们使用十六进制转义序列模拟一个包含二进制数据（其中每个字节都携带信息）的字符串，该数据需要存储在 URL 查询参数中。请注意 btoa() 生成的编码字符串包含 +，而其并不会被 URLSearchParams 保留。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A'，“+”被替换为空格

console.log(atob(binQuery) === rawData); // false

可以通过使用 encodeURIComponent() 对数据进行编解码来避免这种情况。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
空值 vs 无值URLSearchParams 不区分 = 后面没有任何内容的参数和完全没有 = 的参数。
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // 返回 ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // 也返回 ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
规范SpecificationURL # urlsearchparams浏览器兼容性参见
core-js 中 URLSearchParams 的 Polyfill
URL 接口
谷歌开发者：使用 URLSearchParams 轻松操作 URL
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024年9月23日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
备注： 此特性在 Web Worker 中可用。
URLSearchParams 接口定义了一些实用的方法来处理 URL 的查询字符串。
一个实现了 URLSearchParams 的对象可以直接用在 for...of 结构中，以键/值对在查询字符串中出现的顺序对它们进行迭代，例如下面两行是等价的：
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}
构造函数
URLSearchParams()

返回一个 URLSearchParams 对象。

实例属性
size 只读 

返回 URLSearchParams 对象中查询参数的总个数。

实例方法
URLSearchParams[Symbol.iterator]()

返回一个 iterator，允许以键/值对在查询字符串中出现的顺序迭代包含在该对象的键/值对。

URLSearchParams.append()

插入一个指定的键/值对作为新的查询参数。

URLSearchParams.delete()

从查询参数列表里删除指定的查询参数及其对应的值。

URLSearchParams.entries()

返回一个iterator可以遍历所有键/值对的对象。

URLSearchParams.forEach()

通过回调函数迭代此对象中包含的所有值。

URLSearchParams.get()

获取指定查询参数的第一个值。

URLSearchParams.getAll()

获取指定查询参数的所有值，返回是一个数组。

URLSearchParams.has()

返回 Boolean 判断是否存在此查询参数。

URLSearchParams.keys()

返回iterator 此对象包含了键/值对的所有键名。

URLSearchParams.set()

设置一个查询参数的新值，假如原来有多个值将删除其他所有的值。

URLSearchParams.sort()

按键名排序。

URLSearchParams.toString()

返回查询参数组成的字符串，可直接使用在 URL 上。

URLSearchParams.values()

返回iterator 此对象包含了键/值对的所有值。

示例jsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// 迭代查询参数
for (let p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

js// 对象也可作为查询参数
const paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
重复的查询参数jsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, 仅返回第一个值
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
不完整的 URL 解析URLSearchParams 构造函数不会解析完整 URL，但是如果字符串起始位置有 ? 的话会被去除。
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@"（等价于 decodeURIComponent('%40')）

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
保留加号URLSearchParams 的构造函数将加号（+）解释为空格，这可能会有问题。在下面的示例中，我们使用十六进制转义序列模拟一个包含二进制数据（其中每个字节都携带信息）的字符串，该数据需要存储在 URL 查询参数中。请注意 btoa() 生成的编码字符串包含 +，而其并不会被 URLSearchParams 保留。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A'，“+”被替换为空格

console.log(atob(binQuery) === rawData); // false

可以通过使用 encodeURIComponent() 对数据进行编解码来避免这种情况。
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'
const encodedBase64Data = encodeURIComponent(base64Data); // 'E%2BAXQB%2BA'

const searchParams = new URLSearchParams(`bin=${encodedBase64Data}`); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
空值 vs 无值URLSearchParams 不区分 = 后面没有任何内容的参数和完全没有 = 的参数。
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // 返回 ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // 也返回 ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
规范SpecificationURL # urlsearchparams浏览器兼容性参见
core-js 中 URLSearchParams 的 Polyfill
URL 接口
谷歌开发者：使用 URLSearchParams 轻松操作 URL
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024年9月23日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURL API 
Note: This feature is available in Web Workers.
The URL API is a component of the URL standard, which defines what constitutes a valid Uniform Resource Locator and the API that accesses and manipulates URLs. The URL standard also defines concepts such as domains, hosts, and IP addresses, and also attempts to describe in a standard way the legacy application/x-www-form-urlencoded MIME type used to submit web forms' contents as a set of key/value pairs.Concepts and usageThe majority of the URL standard is taken up by the definition of a URL and how it is structured and parsed. Also covered are definitions of various terms related to addressing of computers on a network, and the algorithms for parsing IP addresses and DOM addresses are specified. More interesting to most developers is the API itself.Accessing URL componentsCreating an URL object for a given URL parses the URL and provides quick access to its constituent parts through its properties.
jslet addr = new URL("https://developer.mozilla.org/en-US/docs/Web/API/URL_API");
let host = addr.host;
let path = addr.pathname;

The snippet above creates a URL object for the article you're reading right now, then fetches the host and pathname properties. In this case, those strings are developer.mozilla.org and /en-US/docs/Web/API/URL_API, respectively.Changing the URLMost of the properties of URL are settable; you can write new values to them to alter the URL represented by the object. For example, to create a URL and set its username:
jslet myUsername = "some-guy";
let addr = new URL("https://example.com/login");
addr.username = myUsername;

Setting the value of username not only sets that property's value, but it updates the overall URL. After executing the code snippet above, the value returned by href is https://some-guy@example.com/login. This is true for any of the writable properties.QueriesThe search property on a URL contains the query string portion of the URL. For example, if the URL is https://example.com/login?user=some-guy&page=news, then the value of the search property is ?user=some-guy&page=news. You can also look up the values of individual parameters with the URLSearchParams object's get() method:
jslet addr = new URL("https://example.com/login?user=some-guy&page=news");
try {
  loginUser(addr.searchParams.get("user"));
  gotoPage(addr.searchParams.get("page"));
} catch (err) {
  showErrorMessage(err);
}

For example, in the above snippet, the username and target page are taken from the query and passed to appropriate functions that are used by the site's code to log in and route the user to their desired destination within the site.
Other functions within URLSearchParams let you change the value of keys, add and delete keys and their values, and even sort the list of parameters.InterfacesThe URL API is a simple one, with only a couple of interfaces to its name:

URL

Can be used to parse, construct, normalize, and encode URLs.

URLSearchParams

Defines utility methods to work with the query string of a URL.

ExamplesIf you want to process the parameters included in a URL, you could do it manually, but it's much easier to create a URL object to do it for you. The fillTableWithParameters() function below takes as input a HTMLTableElement object representing a <table>. Rows are added to the table, one for each key found in the parameters, with the first column containing the key's name, and the second column having the value.
Note the call to URLSearchParams.sort() to sort the parameter list before generating the table.
jsfunction fillTableWithParameters(tbl) {
  const url = new URL(document.location.href);
  url.searchParams.sort();
  const keys = url.searchParams.keys();

  for (const key of keys) {
    const val = url.searchParams.get(key);
    const row = document.createElement("tr");
    const cell1 = document.createElement("td");
    cell1.innerText = key;
    row.appendChild(cell1);
    const cell2 = document.createElement("td");
    cell2.innerText = val;
    row.appendChild(cell2);
    tbl.appendChild(row);
  }
}

A working version of this example can be found on Glitch. Just add parameters to the URL when loading the page to see them in the table. For instance, try https://url-api.glitch.me/?from=mdn&excitement=high&likelihood=inconceivable.SpecificationsSpecificationURL # apiBrowser compatibilityapi.URLapi.URLSearchParamsSee also
Fetch API
CSS <url> type
encodeURI()
encodeURIComponent()\n\nURL API 
Note: This feature is available in Web Workers.
The URL API is a component of the URL standard, which defines what constitutes a valid Uniform Resource Locator and the API that accesses and manipulates URLs. The URL standard also defines concepts such as domains, hosts, and IP addresses, and also attempts to describe in a standard way the legacy application/x-www-form-urlencoded MIME type used to submit web forms' contents as a set of key/value pairs.Concepts and usageThe majority of the URL standard is taken up by the definition of a URL and how it is structured and parsed. Also covered are definitions of various terms related to addressing of computers on a network, and the algorithms for parsing IP addresses and DOM addresses are specified. More interesting to most developers is the API itself.Accessing URL componentsCreating an URL object for a given URL parses the URL and provides quick access to its constituent parts through its properties.
jslet addr = new URL("https://developer.mozilla.org/en-US/docs/Web/API/URL_API");
let host = addr.host;
let path = addr.pathname;

The snippet above creates a URL object for the article you're reading right now, then fetches the host and pathname properties. In this case, those strings are developer.mozilla.org and /en-US/docs/Web/API/URL_API, respectively.Changing the URLMost of the properties of URL are settable; you can write new values to them to alter the URL represented by the object. For example, to create a URL and set its username:
jslet myUsername = "some-guy";
let addr = new URL("https://example.com/login");
addr.username = myUsername;

Setting the value of username not only sets that property's value, but it updates the overall URL. After executing the code snippet above, the value returned by href is https://some-guy@example.com/login. This is true for any of the writable properties.QueriesThe search property on a URL contains the query string portion of the URL. For example, if the URL is https://example.com/login?user=some-guy&page=news, then the value of the search property is ?user=some-guy&page=news. You can also look up the values of individual parameters with the URLSearchParams object's get() method:
jslet addr = new URL("https://example.com/login?user=some-guy&page=news");
try {
  loginUser(addr.searchParams.get("user"));
  gotoPage(addr.searchParams.get("page"));
} catch (err) {
  showErrorMessage(err);
}

For example, in the above snippet, the username and target page are taken from the query and passed to appropriate functions that are used by the site's code to log in and route the user to their desired destination within the site.
Other functions within URLSearchParams let you change the value of keys, add and delete keys and their values, and even sort the list of parameters.InterfacesThe URL API is a simple one, with only a couple of interfaces to its name:

URL

Can be used to parse, construct, normalize, and encode URLs.

URLSearchParams

Defines utility methods to work with the query string of a URL.

ExamplesIf you want to process the parameters included in a URL, you could do it manually, but it's much easier to create a URL object to do it for you. The fillTableWithParameters() function below takes as input a HTMLTableElement object representing a <table>. Rows are added to the table, one for each key found in the parameters, with the first column containing the key's name, and the second column having the value.
Note the call to URLSearchParams.sort() to sort the parameter list before generating the table.
jsfunction fillTableWithParameters(tbl) {
  const url = new URL(document.location.href);
  url.searchParams.sort();
  const keys = url.searchParams.keys();

  for (const key of keys) {
    const val = url.searchParams.get(key);
    const row = document.createElement("tr");
    const cell1 = document.createElement("td");
    cell1.innerText = key;
    row.appendChild(cell1);
    const cell2 = document.createElement("td");
    cell2.innerText = val;
    row.appendChild(cell2);
    tbl.appendChild(row);
  }
}

A working version of this example can be found on Glitch. Just add parameters to the URL when loading the page to see them in the table. For instance, try https://url-api.glitch.me/?from=mdn&excitement=high&likelihood=inconceivable.SpecificationsSpecificationURL # apiBrowser compatibilityapi.URLapi.URLSearchParamsSee also
Fetch API
CSS <url> type
encodeURI()
encodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 30, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURL API 
Note: This feature is available in Web Workers.
The URL API is a component of the URL standard, which defines what constitutes a valid Uniform Resource Locator and the API that accesses and manipulates URLs. The URL standard also defines concepts such as domains, hosts, and IP addresses, and also attempts to describe in a standard way the legacy application/x-www-form-urlencoded MIME type used to submit web forms' contents as a set of key/value pairs.Concepts and usageThe majority of the URL standard is taken up by the definition of a URL and how it is structured and parsed. Also covered are definitions of various terms related to addressing of computers on a network, and the algorithms for parsing IP addresses and DOM addresses are specified. More interesting to most developers is the API itself.Accessing URL componentsCreating an URL object for a given URL parses the URL and provides quick access to its constituent parts through its properties.
jslet addr = new URL("https://developer.mozilla.org/en-US/docs/Web/API/URL_API");
let host = addr.host;
let path = addr.pathname;

The snippet above creates a URL object for the article you're reading right now, then fetches the host and pathname properties. In this case, those strings are developer.mozilla.org and /en-US/docs/Web/API/URL_API, respectively.Changing the URLMost of the properties of URL are settable; you can write new values to them to alter the URL represented by the object. For example, to create a URL and set its username:
jslet myUsername = "some-guy";
let addr = new URL("https://example.com/login");
addr.username = myUsername;

Setting the value of username not only sets that property's value, but it updates the overall URL. After executing the code snippet above, the value returned by href is https://some-guy@example.com/login. This is true for any of the writable properties.QueriesThe search property on a URL contains the query string portion of the URL. For example, if the URL is https://example.com/login?user=some-guy&page=news, then the value of the search property is ?user=some-guy&page=news. You can also look up the values of individual parameters with the URLSearchParams object's get() method:
jslet addr = new URL("https://example.com/login?user=some-guy&page=news");
try {
  loginUser(addr.searchParams.get("user"));
  gotoPage(addr.searchParams.get("page"));
} catch (err) {
  showErrorMessage(err);
}

For example, in the above snippet, the username and target page are taken from the query and passed to appropriate functions that are used by the site's code to log in and route the user to their desired destination within the site.
Other functions within URLSearchParams let you change the value of keys, add and delete keys and their values, and even sort the list of parameters.InterfacesThe URL API is a simple one, with only a couple of interfaces to its name:

URL

Can be used to parse, construct, normalize, and encode URLs.

URLSearchParams

Defines utility methods to work with the query string of a URL.

ExamplesIf you want to process the parameters included in a URL, you could do it manually, but it's much easier to create a URL object to do it for you. The fillTableWithParameters() function below takes as input a HTMLTableElement object representing a <table>. Rows are added to the table, one for each key found in the parameters, with the first column containing the key's name, and the second column having the value.
Note the call to URLSearchParams.sort() to sort the parameter list before generating the table.
jsfunction fillTableWithParameters(tbl) {
  const url = new URL(document.location.href);
  url.searchParams.sort();
  const keys = url.searchParams.keys();

  for (const key of keys) {
    const val = url.searchParams.get(key);
    const row = document.createElement("tr");
    const cell1 = document.createElement("td");
    cell1.innerText = key;
    row.appendChild(cell1);
    const cell2 = document.createElement("td");
    cell2.innerText = val;
    row.appendChild(cell2);
    tbl.appendChild(row);
  }
}

A working version of this example can be found on Glitch. Just add parameters to the URL when loading the page to see them in the table. For instance, try https://url-api.glitch.me/?from=mdn&excitement=high&likelihood=inconceivable.SpecificationsSpecificationURL # apiBrowser compatibilityapi.URLapi.URLSearchParamsSee also
Fetch API
CSS <url> type
encodeURI()
encodeURIComponent()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 30, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: URLSearchParams() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams() constructor creates and returns a
new URLSearchParams object.Syntaxjsnew URLSearchParams()
new URLSearchParams(options)
Parameters
options Optional

One of:

A string, which will be parsed from application/x-www-form-urlencoded format. A leading '?' character is ignored. This is the only form that decodes percent-encoding, and decodes + to U+0020 SPACE.
A literal sequence of name-value string pairs, or any object — such as a FormData object — with an iterator that produces a sequence of string pairs. Note that File entries will be serialized as [object File] rather than as their filename (as they would in an application/x-www-form-urlencoded form).
A record of string keys and string values. Note that nesting is not supported.


Return valueA URLSearchParams object instance.ExamplesThe following example shows how to create a URLSearchParams object from
various inputs.
js// Retrieve params via url.search, passed into constructor
const url = new URL("https://example.com?foo=1&bar=2");
const params1 = new URLSearchParams(url.search);

// Get the URLSearchParams object directly from a URL object
const params1a = url.searchParams;

// Pass in a string literal
const params2 = new URLSearchParams("foo=1&bar=2");
const params2a = new URLSearchParams("?foo=1&bar=2");

// Pass in a sequence of pairs
const params3 = new URLSearchParams([
  ["foo", "1"],
  ["bar", "2"],
]);

// Pass in a record
const params4 = new URLSearchParams({ foo: "1", bar: "2" });

This example shows how to build a new URL with an object of search parameters from an existing URL that has search parameters.
jsconst url = new URL("https://example.com/?a=hello&b=world");

console.log(url.href);
// https://example.com/?a=hello&b=world

console.log(url.origin);
// https://example.com

const add_params = {
  c: "a",
  d: new String(2),
  e: false.toString(),
};

const new_params = new URLSearchParams([
  ...Array.from(url.searchParams.entries()), // [["a","hello"],["b","world"]]
  ...Object.entries(add_params), // [["c","a"],["d","2"],["e","false"]]
]).toString();
console.log(new_params);
// a=hello&b=world&c=a&d=2&e=false

const new_url = new URL(`${url.origin}${url.pathname}?${new_params}`);

console.log(new_url.href);
// https://example.com/?a=hello&b=world&c=a&d=2&e=false

// Here it is as a function that accepts (URL, Record<string, string>)
const addSearchParams = (url, params = {}) =>
  new URL(
    `${url.origin}${url.pathname}?${new URLSearchParams([
      ...Array.from(url.searchParams.entries()),
      ...Object.entries(params),
    ])}`,
  );
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibility\n\nURLSearchParams: URLSearchParams() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams() constructor creates and returns a
new URLSearchParams object.Syntaxjsnew URLSearchParams()
new URLSearchParams(options)
Parameters
options Optional

One of:

A string, which will be parsed from application/x-www-form-urlencoded format. A leading '?' character is ignored. This is the only form that decodes percent-encoding, and decodes + to U+0020 SPACE.
A literal sequence of name-value string pairs, or any object — such as a FormData object — with an iterator that produces a sequence of string pairs. Note that File entries will be serialized as [object File] rather than as their filename (as they would in an application/x-www-form-urlencoded form).
A record of string keys and string values. Note that nesting is not supported.


Return valueA URLSearchParams object instance.ExamplesThe following example shows how to create a URLSearchParams object from
various inputs.
js// Retrieve params via url.search, passed into constructor
const url = new URL("https://example.com?foo=1&bar=2");
const params1 = new URLSearchParams(url.search);

// Get the URLSearchParams object directly from a URL object
const params1a = url.searchParams;

// Pass in a string literal
const params2 = new URLSearchParams("foo=1&bar=2");
const params2a = new URLSearchParams("?foo=1&bar=2");

// Pass in a sequence of pairs
const params3 = new URLSearchParams([
  ["foo", "1"],
  ["bar", "2"],
]);

// Pass in a record
const params4 = new URLSearchParams({ foo: "1", bar: "2" });

This example shows how to build a new URL with an object of search parameters from an existing URL that has search parameters.
jsconst url = new URL("https://example.com/?a=hello&b=world");

console.log(url.href);
// https://example.com/?a=hello&b=world

console.log(url.origin);
// https://example.com

const add_params = {
  c: "a",
  d: new String(2),
  e: false.toString(),
};

const new_params = new URLSearchParams([
  ...Array.from(url.searchParams.entries()), // [["a","hello"],["b","world"]]
  ...Object.entries(add_params), // [["c","a"],["d","2"],["e","false"]]
]).toString();
console.log(new_params);
// a=hello&b=world&c=a&d=2&e=false

const new_url = new URL(`${url.origin}${url.pathname}?${new_params}`);

console.log(new_url.href);
// https://example.com/?a=hello&b=world&c=a&d=2&e=false

// Here it is as a function that accepts (URL, Record<string, string>)
const addSearchParams = (url, params = {}) =>
  new URL(
    `${url.origin}${url.pathname}?${new URLSearchParams([
      ...Array.from(url.searchParams.entries()),
      ...Object.entries(params),
    ])}`,
  );
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: URLSearchParams() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams() constructor creates and returns a
new URLSearchParams object.Syntaxjsnew URLSearchParams()
new URLSearchParams(options)
Parameters
options Optional

One of:

A string, which will be parsed from application/x-www-form-urlencoded format. A leading '?' character is ignored. This is the only form that decodes percent-encoding, and decodes + to U+0020 SPACE.
A literal sequence of name-value string pairs, or any object — such as a FormData object — with an iterator that produces a sequence of string pairs. Note that File entries will be serialized as [object File] rather than as their filename (as they would in an application/x-www-form-urlencoded form).
A record of string keys and string values. Note that nesting is not supported.


Return valueA URLSearchParams object instance.ExamplesThe following example shows how to create a URLSearchParams object from
various inputs.
js// Retrieve params via url.search, passed into constructor
const url = new URL("https://example.com?foo=1&bar=2");
const params1 = new URLSearchParams(url.search);

// Get the URLSearchParams object directly from a URL object
const params1a = url.searchParams;

// Pass in a string literal
const params2 = new URLSearchParams("foo=1&bar=2");
const params2a = new URLSearchParams("?foo=1&bar=2");

// Pass in a sequence of pairs
const params3 = new URLSearchParams([
  ["foo", "1"],
  ["bar", "2"],
]);

// Pass in a record
const params4 = new URLSearchParams({ foo: "1", bar: "2" });

This example shows how to build a new URL with an object of search parameters from an existing URL that has search parameters.
jsconst url = new URL("https://example.com/?a=hello&b=world");

console.log(url.href);
// https://example.com/?a=hello&b=world

console.log(url.origin);
// https://example.com

const add_params = {
  c: "a",
  d: new String(2),
  e: false.toString(),
};

const new_params = new URLSearchParams([
  ...Array.from(url.searchParams.entries()), // [["a","hello"],["b","world"]]
  ...Object.entries(add_params), // [["c","a"],["d","2"],["e","false"]]
]).toString();
console.log(new_params);
// a=hello&b=world&c=a&d=2&e=false

const new_url = new URL(`${url.origin}${url.pathname}?${new_params}`);

console.log(new_url.href);
// https://example.com/?a=hello&b=world&c=a&d=2&e=false

// Here it is as a function that accepts (URL, Record<string, string>)
const addSearchParams = (url, params = {}) =>
  new URL(
    `${url.origin}${url.pathname}?${new URLSearchParams([
      ...Array.from(url.searchParams.entries()),
      ...Object.entries(params),
    ])}`,
  );
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: size propertyBaseline 2023Newly availableSince September 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The size read-only property of the URLSearchParams interface indicates the total number of search parameter entries.ValueA number indicating the total number of search parameter entries in the URLSearchParams object.ExamplesGetting the amount of search parameter entriesYou can get the total number of search parameter entries like so:
jsconst searchParams = new URLSearchParams("c=4&a=2&b=3&a=1");
searchParams.size; // 4

Note how the a parameter is given twice, but size returns the number of all given entries (4) and not 3. To get the amount of unique keys, you can use a Set, for example:
js[...new Set(searchParams.keys())].length; // 3
Checking if search parameters existThe size property is useful for checking whether there are any search parameters at all:
jsconst url = new URL("https://example.com?foo=1&bar=2");

if (url.searchParams.size) {
  console.log("URL has search parameters!");
}
SpecificationsSpecificationURL # dom-urlsearchparams-sizeBrowser compatibilitySee also
URL.searchParams
Polyfill of URLSearchParams in core-js\n\nURLSearchParams: size propertyBaseline 2023Newly availableSince September 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The size read-only property of the URLSearchParams interface indicates the total number of search parameter entries.ValueA number indicating the total number of search parameter entries in the URLSearchParams object.ExamplesGetting the amount of search parameter entriesYou can get the total number of search parameter entries like so:
jsconst searchParams = new URLSearchParams("c=4&a=2&b=3&a=1");
searchParams.size; // 4

Note how the a parameter is given twice, but size returns the number of all given entries (4) and not 3. To get the amount of unique keys, you can use a Set, for example:
js[...new Set(searchParams.keys())].length; // 3
Checking if search parameters existThe size property is useful for checking whether there are any search parameters at all:
jsconst url = new URL("https://example.com?foo=1&bar=2");

if (url.searchParams.size) {
  console.log("URL has search parameters!");
}
SpecificationsSpecificationURL # dom-urlsearchparams-sizeBrowser compatibilitySee also
URL.searchParams
Polyfill of URLSearchParams in core-js
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: size propertyBaseline 2023Newly availableSince September 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The size read-only property of the URLSearchParams interface indicates the total number of search parameter entries.ValueA number indicating the total number of search parameter entries in the URLSearchParams object.ExamplesGetting the amount of search parameter entriesYou can get the total number of search parameter entries like so:
jsconst searchParams = new URLSearchParams("c=4&a=2&b=3&a=1");
searchParams.size; // 4

Note how the a parameter is given twice, but size returns the number of all given entries (4) and not 3. To get the amount of unique keys, you can use a Set, for example:
js[...new Set(searchParams.keys())].length; // 3
Checking if search parameters existThe size property is useful for checking whether there are any search parameters at all:
jsconst url = new URL("https://example.com?foo=1&bar=2");

if (url.searchParams.size) {
  console.log("URL has search parameters!");
}
SpecificationsSpecificationURL # dom-urlsearchparams-sizeBrowser compatibilitySee also
URL.searchParams
Polyfill of URLSearchParams in core-js
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: append() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The append() method of the URLSearchParams
interface appends a specified key/value pair as a new search parameter.
As shown in the example below, if the same key is appended multiple times it will
appear in the parameter string multiple times for each value.Syntaxjsappend(name, value)
Parameters
name

The name of the parameter to append.

value

The value of the parameter to append.

Return valueNone (undefined).ExamplesAdding the same parameter multiple timesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);
// Query string is now: 'foo=1&bar=2&foo=4'
SpecificationsSpecificationURL # dom-urlsearchparams-appendBrowser compatibilitySee also
URL
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParams: append() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The append() method of the URLSearchParams
interface appends a specified key/value pair as a new search parameter.
As shown in the example below, if the same key is appended multiple times it will
appear in the parameter string multiple times for each value.Syntaxjsappend(name, value)
Parameters
name

The name of the parameter to append.

value

The value of the parameter to append.

Return valueNone (undefined).ExamplesAdding the same parameter multiple timesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);
// Query string is now: 'foo=1&bar=2&foo=4'
SpecificationsSpecificationURL # dom-urlsearchparams-appendBrowser compatibilitySee also
URL
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: append() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The append() method of the URLSearchParams
interface appends a specified key/value pair as a new search parameter.
As shown in the example below, if the same key is appended multiple times it will
appear in the parameter string multiple times for each value.Syntaxjsappend(name, value)
Parameters
name

The name of the parameter to append.

value

The value of the parameter to append.

Return valueNone (undefined).ExamplesAdding the same parameter multiple timesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);
// Query string is now: 'foo=1&bar=2&foo=4'
SpecificationsSpecificationURL # dom-urlsearchparams-appendBrowser compatibilitySee also
URL
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: delete() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The delete() method of the URLSearchParams interface deletes specified parameters and their associated value(s) from the list of all search parameters.
A parameter name and optional value are used to match parameters.
If only a parameter name is specified, then all search parameters that match the name are deleted, along with their associated values.
If both a parameter name and value are specified, then all search parameters that match both the parameter name and value are deleted.Syntaxjsdelete(name)
delete(name, value)
Parameters
name

The name of the parameters to be deleted.

value Optional

The value that parameters must match, along with the given name, to be deleted.

Return valueNone (undefined).ExamplesDelete all parameters with specified nameThis example shows how to delete all query parameters (and values) that have a particular name.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);
console.log(`Query string (before):\t ${params}`);
params.delete("foo");
console.log(`Query string (after):\t ${params}`);

The log below shows that all parameters that have the name of foo are deleted.
Query string (before):  foo=1&bar=2&foo=3
Query string (after):   bar=2
Delete parameters with specified name and valueThis example shows how to delete query parameters that match a particular name and value.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3&foo=1");
const params = new URLSearchParams(url.search);
console.log(`Query string (before):\t ${params}`);
params.delete("foo", "1");
console.log(`Query string (after):\t ${params}`);

All parameters that match both the parameter name and value should be deleted (there is no reason to specify two parameters with the same name and value as shown above).
Query string (before):  foo=1&bar=2&foo=3&foo=1
Query string (after):   bar=2&foo=3

If your browser supports the value option, the "after" string should be bar=2&foo=3.
Otherwise the result will be the same as in the previous example (bar=2).SpecificationsSpecificationURL # dom-urlsearchparams-deleteBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js\n\nURLSearchParams: delete() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The delete() method of the URLSearchParams interface deletes specified parameters and their associated value(s) from the list of all search parameters.
A parameter name and optional value are used to match parameters.
If only a parameter name is specified, then all search parameters that match the name are deleted, along with their associated values.
If both a parameter name and value are specified, then all search parameters that match both the parameter name and value are deleted.Syntaxjsdelete(name)
delete(name, value)
Parameters
name

The name of the parameters to be deleted.

value Optional

The value that parameters must match, along with the given name, to be deleted.

Return valueNone (undefined).ExamplesDelete all parameters with specified nameThis example shows how to delete all query parameters (and values) that have a particular name.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);
console.log(`Query string (before):\t ${params}`);
params.delete("foo");
console.log(`Query string (after):\t ${params}`);

The log below shows that all parameters that have the name of foo are deleted.
Query string (before):  foo=1&bar=2&foo=3
Query string (after):   bar=2
Delete parameters with specified name and valueThis example shows how to delete query parameters that match a particular name and value.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3&foo=1");
const params = new URLSearchParams(url.search);
console.log(`Query string (before):\t ${params}`);
params.delete("foo", "1");
console.log(`Query string (after):\t ${params}`);

All parameters that match both the parameter name and value should be deleted (there is no reason to specify two parameters with the same name and value as shown above).
Query string (before):  foo=1&bar=2&foo=3&foo=1
Query string (after):   bar=2&foo=3

If your browser supports the value option, the "after" string should be bar=2&foo=3.
Otherwise the result will be the same as in the previous example (bar=2).SpecificationsSpecificationURL # dom-urlsearchparams-deleteBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 1, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: delete() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2020.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The delete() method of the URLSearchParams interface deletes specified parameters and their associated value(s) from the list of all search parameters.
A parameter name and optional value are used to match parameters.
If only a parameter name is specified, then all search parameters that match the name are deleted, along with their associated values.
If both a parameter name and value are specified, then all search parameters that match both the parameter name and value are deleted.Syntaxjsdelete(name)
delete(name, value)
Parameters
name

The name of the parameters to be deleted.

value Optional

The value that parameters must match, along with the given name, to be deleted.

Return valueNone (undefined).ExamplesDelete all parameters with specified nameThis example shows how to delete all query parameters (and values) that have a particular name.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);
console.log(`Query string (before):\t ${params}`);
params.delete("foo");
console.log(`Query string (after):\t ${params}`);

The log below shows that all parameters that have the name of foo are deleted.
Query string (before):  foo=1&bar=2&foo=3
Query string (after):   bar=2
Delete parameters with specified name and valueThis example shows how to delete query parameters that match a particular name and value.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3&foo=1");
const params = new URLSearchParams(url.search);
console.log(`Query string (before):\t ${params}`);
params.delete("foo", "1");
console.log(`Query string (after):\t ${params}`);

All parameters that match both the parameter name and value should be deleted (there is no reason to specify two parameters with the same name and value as shown above).
Query string (before):  foo=1&bar=2&foo=3&foo=1
Query string (after):   bar=2&foo=3

If your browser supports the value option, the "after" string should be bar=2&foo=3.
Otherwise the result will be the same as in the previous example (bar=2).SpecificationsSpecificationURL # dom-urlsearchparams-deleteBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 1, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: entries() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The entries() method of the
URLSearchParams interface returns an
iterator allowing iteration through all key/value
pairs contained in this object. The iterator returns key/value pairs in the same order as they appear in the query string. The key and value of each pair are strings.Syntaxjsentries()
ParametersNone.Return valueReturns an iterator.Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Display the key/value pairs
for (const [key, value] of searchParams.entries()) {
  console.log(`${key}, ${value}`);
}

The result is:
key1, value1
key2, value2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.\n\nURLSearchParams: entries() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The entries() method of the
URLSearchParams interface returns an
iterator allowing iteration through all key/value
pairs contained in this object. The iterator returns key/value pairs in the same order as they appear in the query string. The key and value of each pair are strings.Syntaxjsentries()
ParametersNone.Return valueReturns an iterator.Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Display the key/value pairs
for (const [key, value] of searchParams.entries()) {
  console.log(`${key}, ${value}`);
}

The result is:
key1, value1
key2, value2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: entries() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The entries() method of the
URLSearchParams interface returns an
iterator allowing iteration through all key/value
pairs contained in this object. The iterator returns key/value pairs in the same order as they appear in the query string. The key and value of each pair are strings.Syntaxjsentries()
ParametersNone.Return valueReturns an iterator.Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Display the key/value pairs
for (const [key, value] of searchParams.entries()) {
  console.log(`${key}, ${value}`);
}

The result is:
key1, value1
key2, value2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: forEach() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The forEach() method of the
URLSearchParams interface allows iteration through all values contained
in this object via a callback function.SyntaxjsforEach(callback)
forEach(callback, thisArg)
Parameters
callback

Function to execute on each element, which is passed the following arguments:

value

The value of the current entry being processed in the URLSearchParams object.

key

The key of the current entry being processed in the URLSearchParams object.

searchParams

The URLSearchParams object the forEach() was called upon.



thisArg Optional

Value to use as this when executing callback.

Return valueNone (undefined).Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Log the values
searchParams.forEach((value, key) => {
  console.log(value, key);
});

The result is:
value1 key1
value2 key2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.\n\nURLSearchParams: forEach() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The forEach() method of the
URLSearchParams interface allows iteration through all values contained
in this object via a callback function.SyntaxjsforEach(callback)
forEach(callback, thisArg)
Parameters
callback

Function to execute on each element, which is passed the following arguments:

value

The value of the current entry being processed in the URLSearchParams object.

key

The key of the current entry being processed in the URLSearchParams object.

searchParams

The URLSearchParams object the forEach() was called upon.



thisArg Optional

Value to use as this when executing callback.

Return valueNone (undefined).Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Log the values
searchParams.forEach((value, key) => {
  console.log(value, key);
});

The result is:
value1 key1
value2 key2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: forEach() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The forEach() method of the
URLSearchParams interface allows iteration through all values contained
in this object via a callback function.SyntaxjsforEach(callback)
forEach(callback, thisArg)
Parameters
callback

Function to execute on each element, which is passed the following arguments:

value

The value of the current entry being processed in the URLSearchParams object.

key

The key of the current entry being processed in the URLSearchParams object.

searchParams

The URLSearchParams object the forEach() was called upon.



thisArg Optional

Value to use as this when executing callback.

Return valueNone (undefined).Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Log the values
searchParams.forEach((value, key) => {
  console.log(value, key);
});

The result is:
value1 key1
value2 key2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: get() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The get() method of the URLSearchParams
interface returns the first value associated to the given search parameter.Syntaxjsget(name)
Parameters
name

The name of the parameter to return.

Return valueA string if the given search parameter is found; otherwise,
null.ExamplesIf the URL of your page is https://example.com/?name=Jonathan&age=18
you could parse out the 'name' and 'age' parameters using:
jslet params = new URLSearchParams(document.location.search);
let name = params.get("name"); // is the string "Jonathan"
let age = parseInt(params.get("age"), 10); // is the number 18

Requesting a parameter that isn't present in the query string will return
null:
jslet address = params.get("address"); // null
SpecificationsSpecificationURL # dom-urlsearchparams-getBrowser compatibility\n\nURLSearchParams: get() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The get() method of the URLSearchParams
interface returns the first value associated to the given search parameter.Syntaxjsget(name)
Parameters
name

The name of the parameter to return.

Return valueA string if the given search parameter is found; otherwise,
null.ExamplesIf the URL of your page is https://example.com/?name=Jonathan&age=18
you could parse out the 'name' and 'age' parameters using:
jslet params = new URLSearchParams(document.location.search);
let name = params.get("name"); // is the string "Jonathan"
let age = parseInt(params.get("age"), 10); // is the number 18

Requesting a parameter that isn't present in the query string will return
null:
jslet address = params.get("address"); // null
SpecificationsSpecificationURL # dom-urlsearchparams-getBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: get() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The get() method of the URLSearchParams
interface returns the first value associated to the given search parameter.Syntaxjsget(name)
Parameters
name

The name of the parameter to return.

Return valueA string if the given search parameter is found; otherwise,
null.ExamplesIf the URL of your page is https://example.com/?name=Jonathan&age=18
you could parse out the 'name' and 'age' parameters using:
jslet params = new URLSearchParams(document.location.search);
let name = params.get("name"); // is the string "Jonathan"
let age = parseInt(params.get("age"), 10); // is the number 18

Requesting a parameter that isn't present in the query string will return
null:
jslet address = params.get("address"); // null
SpecificationsSpecificationURL # dom-urlsearchparams-getBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: getAll() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The getAll() method of the URLSearchParams
interface returns all the values associated with a given search parameter as an array.SyntaxjsgetAll(name)
Parameters
name

The name of the parameter to return.

Return valueAn array of strings, which may be empty if no values for the given parameter are found.Examplesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);

console.log(params.getAll("foo")); // ["1", "4"]
SpecificationsSpecificationURL # dom-urlsearchparams-getallBrowser compatibility\n\nURLSearchParams: getAll() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The getAll() method of the URLSearchParams
interface returns all the values associated with a given search parameter as an array.SyntaxjsgetAll(name)
Parameters
name

The name of the parameter to return.

Return valueAn array of strings, which may be empty if no values for the given parameter are found.Examplesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);

console.log(params.getAll("foo")); // ["1", "4"]
SpecificationsSpecificationURL # dom-urlsearchparams-getallBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: getAll() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The getAll() method of the URLSearchParams
interface returns all the values associated with a given search parameter as an array.SyntaxjsgetAll(name)
Parameters
name

The name of the parameter to return.

Return valueAn array of strings, which may be empty if no values for the given parameter are found.Examplesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);

console.log(params.getAll("foo")); // ["1", "4"]
SpecificationsSpecificationURL # dom-urlsearchparams-getallBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: has() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The has() method of the URLSearchParams interface returns a boolean value that indicates whether the specified parameter is in the search parameters.
A parameter name and optional value are used to match parameters.
If only a parameter name is specified, then the method will return true if any parameters in the query string match the name, and false otherwise.
If both a parameter name and value are specified, then the method will return true if a parameter matches both the name and value.Syntaxjshas(name)
has(name, value)
Parameters
name

The name of the parameter to match.

value

The value of the parameter, along with the given name, to match.

Return valueA boolean value.ExamplesCheck for parameter with specified nameThis example shows how to check if the query string has any parameters with a particular name.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);

// has() returns true if the parameter is in the query string
console.log(`bar?:\t${params.has("bar")}`);
console.log(`bark?:\t${params.has("bark")}`);
console.log(`foo?:\t${params.has("foo")}`);

The log below shows whether the parameters bar, bark, and foo, are present in the query string.
bar?:  true
bark?: false
foo?:  true
Check for parameter with specified name and valueThis example shows how to check whether the query string has a parameter that matches both a particular name and value.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);

// has() returns true if a parameter with the matching name and value is in the query string
console.log(`bar=1?:\t${params.has("bar", "1")}`);
console.log(`bar=2?:\t${params.has("bar", "2")}`);
console.log(`foo=4?:\t${params.has("foo", "4")}`);

Only the second value above should be true, as only the parameter name bar with value 2 is matched.
bar=1?: false
bar=2?: true
foo=4?: false

If your browser does not support the value option the method will match on the name, and all the results should be true.SpecificationsSpecificationURL # dom-urlsearchparams-hasBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js\n\nURLSearchParams: has() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The has() method of the URLSearchParams interface returns a boolean value that indicates whether the specified parameter is in the search parameters.
A parameter name and optional value are used to match parameters.
If only a parameter name is specified, then the method will return true if any parameters in the query string match the name, and false otherwise.
If both a parameter name and value are specified, then the method will return true if a parameter matches both the name and value.Syntaxjshas(name)
has(name, value)
Parameters
name

The name of the parameter to match.

value

The value of the parameter, along with the given name, to match.

Return valueA boolean value.ExamplesCheck for parameter with specified nameThis example shows how to check if the query string has any parameters with a particular name.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);

// has() returns true if the parameter is in the query string
console.log(`bar?:\t${params.has("bar")}`);
console.log(`bark?:\t${params.has("bark")}`);
console.log(`foo?:\t${params.has("foo")}`);

The log below shows whether the parameters bar, bark, and foo, are present in the query string.
bar?:  true
bark?: false
foo?:  true
Check for parameter with specified name and valueThis example shows how to check whether the query string has a parameter that matches both a particular name and value.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);

// has() returns true if a parameter with the matching name and value is in the query string
console.log(`bar=1?:\t${params.has("bar", "1")}`);
console.log(`bar=2?:\t${params.has("bar", "2")}`);
console.log(`foo=4?:\t${params.has("foo", "4")}`);

Only the second value above should be true, as only the parameter name bar with value 2 is matched.
bar=1?: false
bar=2?: true
foo=4?: false

If your browser does not support the value option the method will match on the name, and all the results should be true.SpecificationsSpecificationURL # dom-urlsearchparams-hasBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 2, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: has() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The has() method of the URLSearchParams interface returns a boolean value that indicates whether the specified parameter is in the search parameters.
A parameter name and optional value are used to match parameters.
If only a parameter name is specified, then the method will return true if any parameters in the query string match the name, and false otherwise.
If both a parameter name and value are specified, then the method will return true if a parameter matches both the name and value.Syntaxjshas(name)
has(name, value)
Parameters
name

The name of the parameter to match.

value

The value of the parameter, along with the given name, to match.

Return valueA boolean value.ExamplesCheck for parameter with specified nameThis example shows how to check if the query string has any parameters with a particular name.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);

// has() returns true if the parameter is in the query string
console.log(`bar?:\t${params.has("bar")}`);
console.log(`bark?:\t${params.has("bark")}`);
console.log(`foo?:\t${params.has("foo")}`);

The log below shows whether the parameters bar, bark, and foo, are present in the query string.
bar?:  true
bark?: false
foo?:  true
Check for parameter with specified name and valueThis example shows how to check whether the query string has a parameter that matches both a particular name and value.
jsconst url = new URL("https://example.com?foo=1&bar=2&foo=3");
const params = new URLSearchParams(url.search);

// has() returns true if a parameter with the matching name and value is in the query string
console.log(`bar=1?:\t${params.has("bar", "1")}`);
console.log(`bar=2?:\t${params.has("bar", "2")}`);
console.log(`foo=4?:\t${params.has("foo", "4")}`);

Only the second value above should be true, as only the parameter name bar with value 2 is matched.
bar=1?: false
bar=2?: true
foo=4?: false

If your browser does not support the value option the method will match on the name, and all the results should be true.SpecificationsSpecificationURL # dom-urlsearchparams-hasBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 2, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: keys() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The keys() method of the URLSearchParams
interface returns an iterator allowing iteration
through all keys contained in this object. The keys are strings.Syntaxjskeys()
ParametersNone.Return valueReturns an iterator.Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Display the keys
for (const key of searchParams.keys()) {
  console.log(key);
}

The result is:
key1
key2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.\n\nURLSearchParams: keys() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The keys() method of the URLSearchParams
interface returns an iterator allowing iteration
through all keys contained in this object. The keys are strings.Syntaxjskeys()
ParametersNone.Return valueReturns an iterator.Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Display the keys
for (const key of searchParams.keys()) {
  console.log(key);
}

The result is:
key1
key2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: keys() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The keys() method of the URLSearchParams
interface returns an iterator allowing iteration
through all keys contained in this object. The keys are strings.Syntaxjskeys()
ParametersNone.Return valueReturns an iterator.Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("key1=value1&key2=value2");

// Display the keys
for (const key of searchParams.keys()) {
  console.log(key);
}

The result is:
key1
key2
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: set() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The set() method of the URLSearchParams
interface sets the value associated with a given search parameter to the given value.
If there were several matching values, this method deletes the others. If the search
parameter doesn't exist, this method creates it.Syntaxjsset(name, value)
Parameters
name

The name of the parameter to set.

value

The value of the parameter to set.

Return valueNone (undefined).Examplesjslet url = new URL("https://example.com?foo=1&bar=2");
let params = new URLSearchParams(url.search);

// Add a third parameter.
params.set("baz", 3);
params.toString(); // "foo=1&bar=2&baz=3"
SpecificationsSpecificationURL # dom-urlsearchparams-setBrowser compatibility\n\nURLSearchParams: set() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The set() method of the URLSearchParams
interface sets the value associated with a given search parameter to the given value.
If there were several matching values, this method deletes the others. If the search
parameter doesn't exist, this method creates it.Syntaxjsset(name, value)
Parameters
name

The name of the parameter to set.

value

The value of the parameter to set.

Return valueNone (undefined).Examplesjslet url = new URL("https://example.com?foo=1&bar=2");
let params = new URLSearchParams(url.search);

// Add a third parameter.
params.set("baz", 3);
params.toString(); // "foo=1&bar=2&baz=3"
SpecificationsSpecificationURL # dom-urlsearchparams-setBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: set() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The set() method of the URLSearchParams
interface sets the value associated with a given search parameter to the given value.
If there were several matching values, this method deletes the others. If the search
parameter doesn't exist, this method creates it.Syntaxjsset(name, value)
Parameters
name

The name of the parameter to set.

value

The value of the parameter to set.

Return valueNone (undefined).Examplesjslet url = new URL("https://example.com?foo=1&bar=2");
let params = new URLSearchParams(url.search);

// Add a third parameter.
params.set("baz", 3);
params.toString(); // "foo=1&bar=2&baz=3"
SpecificationsSpecificationURL # dom-urlsearchparams-setBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: sort() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams.sort() method sorts all key/value
pairs contained in this object in place and returns undefined. The sort
order is according to unicode code points of the keys. This method uses a stable sorting
algorithm (i.e., the relative order between key/value pairs with equal keys will be
preserved).Syntaxjssort()
ParametersNone.Return valueNone (undefined).Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("c=4&a=2&b=3&a=1");

// Sort the key/value pairs
searchParams.sort();

// Display the sorted query string
console.log(searchParams.toString());

The result is:
a=2&a=1&b=3&c=4
SpecificationsSpecificationURL # dom-urlsearchparams-sortBrowser compatibility\n\nURLSearchParams: sort() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams.sort() method sorts all key/value
pairs contained in this object in place and returns undefined. The sort
order is according to unicode code points of the keys. This method uses a stable sorting
algorithm (i.e., the relative order between key/value pairs with equal keys will be
preserved).Syntaxjssort()
ParametersNone.Return valueNone (undefined).Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("c=4&a=2&b=3&a=1");

// Sort the key/value pairs
searchParams.sort();

// Display the sorted query string
console.log(searchParams.toString());

The result is:
a=2&a=1&b=3&c=4
SpecificationsSpecificationURL # dom-urlsearchparams-sortBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: sort() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams.sort() method sorts all key/value
pairs contained in this object in place and returns undefined. The sort
order is according to unicode code points of the keys. This method uses a stable sorting
algorithm (i.e., the relative order between key/value pairs with equal keys will be
preserved).Syntaxjssort()
ParametersNone.Return valueNone (undefined).Examplesjs// Create a test URLSearchParams object
const searchParams = new URLSearchParams("c=4&a=2&b=3&a=1");

// Sort the key/value pairs
searchParams.sort();

// Display the sorted query string
console.log(searchParams.toString());

The result is:
a=2&a=1&b=3&c=4
SpecificationsSpecificationURL # dom-urlsearchparams-sortBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: toString() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The toString() method of the
URLSearchParams interface returns a query string suitable for use in a
URL.

Note:
This method returns the query string without the question mark. This is different from Location.search, HTMLAnchorElement.search, and URL.search, which all include the question mark.
SyntaxjstoString()
ParametersNone.Return valueA string, without the question mark. Returns an empty string if no search parameters have been set. Characters in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _) are percent-encoded, and U+0020 SPACE is encoded as +.Examplesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);
console.log(params.toString()); // Prints 'foo=1&bar=2&foo=4'
SpecificationsSpecificationURL # urlsearchparams-stringification-behaviorBrowser compatibilitySee also
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParams: toString() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The toString() method of the
URLSearchParams interface returns a query string suitable for use in a
URL.

Note:
This method returns the query string without the question mark. This is different from Location.search, HTMLAnchorElement.search, and URL.search, which all include the question mark.
SyntaxjstoString()
ParametersNone.Return valueA string, without the question mark. Returns an empty string if no search parameters have been set. Characters in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _) are percent-encoded, and U+0020 SPACE is encoded as +.Examplesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);
console.log(params.toString()); // Prints 'foo=1&bar=2&foo=4'
SpecificationsSpecificationURL # urlsearchparams-stringification-behaviorBrowser compatibilitySee also
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: toString() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The toString() method of the
URLSearchParams interface returns a query string suitable for use in a
URL.

Note:
This method returns the query string without the question mark. This is different from Location.search, HTMLAnchorElement.search, and URL.search, which all include the question mark.
SyntaxjstoString()
ParametersNone.Return valueA string, without the question mark. Returns an empty string if no search parameters have been set. Characters in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _) are percent-encoded, and U+0020 SPACE is encoded as +.Examplesjsconst url = new URL("https://example.com?foo=1&bar=2");
const params = new URLSearchParams(url.search);

// Add a second foo parameter.
params.append("foo", 4);
console.log(params.toString()); // Prints 'foo=1&bar=2&foo=4'
SpecificationsSpecificationURL # urlsearchparams-stringification-behaviorBrowser compatibilitySee also
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParams: values() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The values() method of the URLsearchParams
interface returns an iterator allowing iteration
through all values contained in this object. The values are strings.Syntaxjsvalues()
ParametersNone.Return valueReturns an iterator.ExamplesThe following example passes a URL search string to the URLSearchParams constructor, then uses the iterator returned by values() to print the values to the console.
jsconst searchParams = new URLSearchParams("key1=value1&key2=value2");

for (const value of searchParams.values()) {
  console.log(value);
}

The result is:
value1
value2

This example does much the same as above, but first casts the iterator into an array.
jsconst searchParams = new URLSearchParams("key1=value1&key2=value2");

console.log(Array.from(searchParams.values()));

The result is:
['value1', 'value2']
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.\n\nURLSearchParams: values() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The values() method of the URLsearchParams
interface returns an iterator allowing iteration
through all values contained in this object. The values are strings.Syntaxjsvalues()
ParametersNone.Return valueReturns an iterator.ExamplesThe following example passes a URL search string to the URLSearchParams constructor, then uses the iterator returned by values() to print the values to the console.
jsconst searchParams = new URLSearchParams("key1=value1&key2=value2");

for (const value of searchParams.values()) {
  console.log(value);
}

The result is:
value1
value2

This example does much the same as above, but first casts the iterator into an array.
jsconst searchParams = new URLSearchParams("key1=value1&key2=value2");

console.log(Array.from(searchParams.values()));

The result is:
['value1', 'value2']
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParams: values() methodBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The values() method of the URLsearchParams
interface returns an iterator allowing iteration
through all values contained in this object. The values are strings.Syntaxjsvalues()
ParametersNone.Return valueReturns an iterator.ExamplesThe following example passes a URL search string to the URLSearchParams constructor, then uses the iterator returned by values() to print the values to the console.
jsconst searchParams = new URLSearchParams("key1=value1&key2=value2");

for (const value of searchParams.values()) {
  console.log(value);
}

The result is:
value1
value2

This example does much the same as above, but first casts the iterator into an array.
jsconst searchParams = new URLSearchParams("key1=value1&key2=value2");

console.log(Array.from(searchParams.values()));

The result is:
['value1', 'value2']
SpecificationsSpecificationURL # dom-urlsearchparams-urlsearchparamsBrowser compatibilitySee also
The URL interface.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 12, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URL interface is used to parse, construct, normalize, and encode URLs. It works by providing properties which allow you to easily read and modify the components of a URL.
You normally create a new URL object by specifying the URL as a string when calling its constructor, or by providing a relative URL and a base URL. You can then easily read the parsed components of the URL or make changes to the URL.Constructor
URL()

Creates and returns a URL object from a URL string and optional base URL string.
Throws if the passed arguments don't define a valid URL.

Instance properties
hash

A string containing a '#' followed by the fragment identifier of the URL.

host

A string containing the domain (that is the hostname) followed by (if a port was specified) a ':' and the port of the URL.

hostname

A string containing the domain of the URL.

href

A stringifier that returns a string containing the whole URL.

origin Read only

Returns a string containing the origin of the URL, that is its scheme, its domain and its port.

password

A string containing the password specified before the domain name.

pathname

A string containing an initial '/' followed by the path of the URL, not including the query string or fragment.

port

A string containing the port number of the URL.

protocol

A string containing the protocol scheme of the URL, including the final ':'.

search

A string indicating the URL's parameter string; if any parameters are provided, this string includes all of them, beginning with the leading ? character.

searchParams Read only

A URLSearchParams object which can be used to access the individual query parameters found in search.

username

A string containing the username specified before the domain name.

Static methods
canParse()

Returns a boolean indicating whether or not a URL defined from a URL string and optional base URL string is parsable and valid.

createObjectURL()

Returns a string containing a unique blob URL, that is a URL with blob: as its scheme, followed by an opaque string uniquely identifying the object in the browser.

parse()

Creates and returns a URL object from a URL string and optional base URL string, or returns null if the passed parameters define an invalid URL.

revokeObjectURL()

Revokes an object URL previously created using URL.createObjectURL().

Instance methods
toString()

Returns a string containing the whole URL. It is a synonym for URL.href, though it can't be used to modify the value.

toJSON()

Returns a string containing the whole URL. It returns the same string as the href property.

Usage notesThe constructor takes a url parameter, and an optional base parameter to use as a base if the url parameter is a relative URL:
jsconst url = new URL("../cats", "http://www.example.com/dogs");
console.log(url.hostname); // "www.example.com"
console.log(url.pathname); // "/cats"

The constructor will raise an exception if the URL cannot be parsed to a valid URL.
You can either call the above code in a try...catch block or use the canParse() static method to first check the URL is valid:
jsif (URL.canParse("../cats", "http://www.example.com/dogs")) {
  const url = new URL("../cats", "http://www.example.com/dogs");
  console.log(url.hostname); // "www.example.com"
  console.log(url.pathname); // "/cats"
} else {
  console.log("Invalid URL");
}

URL properties can be set to construct the URL:
jsurl.hash = "tabby";
console.log(url.href); // "http://www.example.com/cats#tabby"

URLs are encoded according to the rules found in RFC 3986. For instance:
jsurl.pathname = "démonstration.html";
console.log(url.href); // "http://www.example.com/d%C3%A9monstration.html"

The URLSearchParams interface can be used to build and manipulate the URL query string.
To get the search params from the current window's URL, you can do this:
js// https://some.site/?id=123
const parsedUrl = new URL(window.location.href);
console.log(parsedUrl.searchParams.get("id")); // "123"

The toString() method of URL just returns the value of the href property, so the constructor can be used to normalize and encode a URL directly.
jsconst response = await fetch(
  new URL("http://www.example.com/démonstration.html"),
);
SpecificationsSpecificationURL # urlBrowser compatibilitySee also
Polyfill of URL in core-js
URL API
What is a URL?
URLSearchParams.\n\nURLBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URL interface is used to parse, construct, normalize, and encode URLs. It works by providing properties which allow you to easily read and modify the components of a URL.
You normally create a new URL object by specifying the URL as a string when calling its constructor, or by providing a relative URL and a base URL. You can then easily read the parsed components of the URL or make changes to the URL.Constructor
URL()

Creates and returns a URL object from a URL string and optional base URL string.
Throws if the passed arguments don't define a valid URL.

Instance properties
hash

A string containing a '#' followed by the fragment identifier of the URL.

host

A string containing the domain (that is the hostname) followed by (if a port was specified) a ':' and the port of the URL.

hostname

A string containing the domain of the URL.

href

A stringifier that returns a string containing the whole URL.

origin Read only

Returns a string containing the origin of the URL, that is its scheme, its domain and its port.

password

A string containing the password specified before the domain name.

pathname

A string containing an initial '/' followed by the path of the URL, not including the query string or fragment.

port

A string containing the port number of the URL.

protocol

A string containing the protocol scheme of the URL, including the final ':'.

search

A string indicating the URL's parameter string; if any parameters are provided, this string includes all of them, beginning with the leading ? character.

searchParams Read only

A URLSearchParams object which can be used to access the individual query parameters found in search.

username

A string containing the username specified before the domain name.

Static methods
canParse()

Returns a boolean indicating whether or not a URL defined from a URL string and optional base URL string is parsable and valid.

createObjectURL()

Returns a string containing a unique blob URL, that is a URL with blob: as its scheme, followed by an opaque string uniquely identifying the object in the browser.

parse()

Creates and returns a URL object from a URL string and optional base URL string, or returns null if the passed parameters define an invalid URL.

revokeObjectURL()

Revokes an object URL previously created using URL.createObjectURL().

Instance methods
toString()

Returns a string containing the whole URL. It is a synonym for URL.href, though it can't be used to modify the value.

toJSON()

Returns a string containing the whole URL. It returns the same string as the href property.

Usage notesThe constructor takes a url parameter, and an optional base parameter to use as a base if the url parameter is a relative URL:
jsconst url = new URL("../cats", "http://www.example.com/dogs");
console.log(url.hostname); // "www.example.com"
console.log(url.pathname); // "/cats"

The constructor will raise an exception if the URL cannot be parsed to a valid URL.
You can either call the above code in a try...catch block or use the canParse() static method to first check the URL is valid:
jsif (URL.canParse("../cats", "http://www.example.com/dogs")) {
  const url = new URL("../cats", "http://www.example.com/dogs");
  console.log(url.hostname); // "www.example.com"
  console.log(url.pathname); // "/cats"
} else {
  console.log("Invalid URL");
}

URL properties can be set to construct the URL:
jsurl.hash = "tabby";
console.log(url.href); // "http://www.example.com/cats#tabby"

URLs are encoded according to the rules found in RFC 3986. For instance:
jsurl.pathname = "démonstration.html";
console.log(url.href); // "http://www.example.com/d%C3%A9monstration.html"

The URLSearchParams interface can be used to build and manipulate the URL query string.
To get the search params from the current window's URL, you can do this:
js// https://some.site/?id=123
const parsedUrl = new URL(window.location.href);
console.log(parsedUrl.searchParams.get("id")); // "123"

The toString() method of URL just returns the value of the href property, so the constructor can be used to normalize and encode a URL directly.
jsconst response = await fetch(
  new URL("http://www.example.com/démonstration.html"),
);
SpecificationsSpecificationURL # urlBrowser compatibilitySee also
Polyfill of URL in core-js
URL API
What is a URL?
URLSearchParams.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URL interface is used to parse, construct, normalize, and encode URLs. It works by providing properties which allow you to easily read and modify the components of a URL.
You normally create a new URL object by specifying the URL as a string when calling its constructor, or by providing a relative URL and a base URL. You can then easily read the parsed components of the URL or make changes to the URL.Constructor
URL()

Creates and returns a URL object from a URL string and optional base URL string.
Throws if the passed arguments don't define a valid URL.

Instance properties
hash

A string containing a '#' followed by the fragment identifier of the URL.

host

A string containing the domain (that is the hostname) followed by (if a port was specified) a ':' and the port of the URL.

hostname

A string containing the domain of the URL.

href

A stringifier that returns a string containing the whole URL.

origin Read only

Returns a string containing the origin of the URL, that is its scheme, its domain and its port.

password

A string containing the password specified before the domain name.

pathname

A string containing an initial '/' followed by the path of the URL, not including the query string or fragment.

port

A string containing the port number of the URL.

protocol

A string containing the protocol scheme of the URL, including the final ':'.

search

A string indicating the URL's parameter string; if any parameters are provided, this string includes all of them, beginning with the leading ? character.

searchParams Read only

A URLSearchParams object which can be used to access the individual query parameters found in search.

username

A string containing the username specified before the domain name.

Static methods
canParse()

Returns a boolean indicating whether or not a URL defined from a URL string and optional base URL string is parsable and valid.

createObjectURL()

Returns a string containing a unique blob URL, that is a URL with blob: as its scheme, followed by an opaque string uniquely identifying the object in the browser.

parse()

Creates and returns a URL object from a URL string and optional base URL string, or returns null if the passed parameters define an invalid URL.

revokeObjectURL()

Revokes an object URL previously created using URL.createObjectURL().

Instance methods
toString()

Returns a string containing the whole URL. It is a synonym for URL.href, though it can't be used to modify the value.

toJSON()

Returns a string containing the whole URL. It returns the same string as the href property.

Usage notesThe constructor takes a url parameter, and an optional base parameter to use as a base if the url parameter is a relative URL:
jsconst url = new URL("../cats", "http://www.example.com/dogs");
console.log(url.hostname); // "www.example.com"
console.log(url.pathname); // "/cats"

The constructor will raise an exception if the URL cannot be parsed to a valid URL.
You can either call the above code in a try...catch block or use the canParse() static method to first check the URL is valid:
jsif (URL.canParse("../cats", "http://www.example.com/dogs")) {
  const url = new URL("../cats", "http://www.example.com/dogs");
  console.log(url.hostname); // "www.example.com"
  console.log(url.pathname); // "/cats"
} else {
  console.log("Invalid URL");
}

URL properties can be set to construct the URL:
jsurl.hash = "tabby";
console.log(url.href); // "http://www.example.com/cats#tabby"

URLs are encoded according to the rules found in RFC 3986. For instance:
jsurl.pathname = "démonstration.html";
console.log(url.href); // "http://www.example.com/d%C3%A9monstration.html"

The URLSearchParams interface can be used to build and manipulate the URL query string.
To get the search params from the current window's URL, you can do this:
js// https://some.site/?id=123
const parsedUrl = new URL(window.location.href);
console.log(parsedUrl.searchParams.get("id")); // "123"

The toString() method of URL just returns the value of the href property, so the constructor can be used to normalize and encode a URL directly.
jsconst response = await fetch(
  new URL("http://www.example.com/démonstration.html"),
);
SpecificationsSpecificationURL # urlBrowser compatibilitySee also
Polyfill of URL in core-js
URL API
What is a URL?
URLSearchParams.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb Workers APIWeb Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down.Concepts and usageA worker is an object created using a constructor (e.g., Worker()) that runs a named JavaScript file — this file contains the code that will run in the worker thread.
In addition to the standard JavaScript set of functions (such as String, Array, Object, JSON, etc.), you can run almost any code you like inside a worker thread. There are some exceptions: for example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the Window object. For information about the code that you can run see supported functions, and supported Web APIs.
Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data property). The data is copied rather than shared.
Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page.
In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null).Worker typesThere are a number of different types of workers:

Dedicated workers are workers that are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
Shared workers are workers that can be utilized by multiple scripts running in different windows, IFrames, etc., as long as they are in the same domain as the worker. They are a little more complex than dedicated workers — scripts must communicate via an active port.
Service Workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.
Worker contextsWhile Window is not directly available to workers, many of the same methods are defined in a shared mixin (WindowOrWorkerGlobalScope), and made available to workers through their own WorkerGlobalScope-derived contexts:

DedicatedWorkerGlobalScope for dedicated workers
SharedWorkerGlobalScope for shared workers
ServiceWorkerGlobalScope for service workers
Interfaces
Worker

Represents a running worker thread, allowing you to pass messages to the running worker code.

WorkerLocation

Defines the absolute location of the script executed by the Worker.

SharedWorker

Represents a specific kind of worker that can be accessed from several browsing contexts (i.e., windows, tabs, or iframes) or even other workers.

WorkerGlobalScope

Represents the generic scope of any worker (doing the same job as Window does for normal web content). Different types of worker have scope objects that inherit from this interface and add more specific features.

DedicatedWorkerGlobalScope

Represents the scope of a dedicated worker, inheriting from WorkerGlobalScope and adding some dedicated features.

SharedWorkerGlobalScope

Represents the scope of a shared worker, inheriting from WorkerGlobalScope and adding some dedicated features.

WorkerNavigator

Represents the identity and state of the user agent (the client).

ExamplesWe have created a couple of demos to show web worker usage:

Basic dedicated worker example (run dedicated worker).
Basic shared worker example (run shared worker).
OffscreenCanvas worker example (run OffscreenCanvas worker).

You can find out more information on how these demos work in Using Web Workers.SpecificationsSpecificationHTML # workersSee also
Using Web Workers
Worker interface
SharedWorker interface
Service Worker API\n\nWeb Workers APIWeb Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down.Concepts and usageA worker is an object created using a constructor (e.g., Worker()) that runs a named JavaScript file — this file contains the code that will run in the worker thread.
In addition to the standard JavaScript set of functions (such as String, Array, Object, JSON, etc.), you can run almost any code you like inside a worker thread. There are some exceptions: for example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the Window object. For information about the code that you can run see supported functions, and supported Web APIs.
Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data property). The data is copied rather than shared.
Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page.
In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null).Worker typesThere are a number of different types of workers:

Dedicated workers are workers that are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
Shared workers are workers that can be utilized by multiple scripts running in different windows, IFrames, etc., as long as they are in the same domain as the worker. They are a little more complex than dedicated workers — scripts must communicate via an active port.
Service Workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.
Worker contextsWhile Window is not directly available to workers, many of the same methods are defined in a shared mixin (WindowOrWorkerGlobalScope), and made available to workers through their own WorkerGlobalScope-derived contexts:

DedicatedWorkerGlobalScope for dedicated workers
SharedWorkerGlobalScope for shared workers
ServiceWorkerGlobalScope for service workers
Interfaces
Worker

Represents a running worker thread, allowing you to pass messages to the running worker code.

WorkerLocation

Defines the absolute location of the script executed by the Worker.

SharedWorker

Represents a specific kind of worker that can be accessed from several browsing contexts (i.e., windows, tabs, or iframes) or even other workers.

WorkerGlobalScope

Represents the generic scope of any worker (doing the same job as Window does for normal web content). Different types of worker have scope objects that inherit from this interface and add more specific features.

DedicatedWorkerGlobalScope

Represents the scope of a dedicated worker, inheriting from WorkerGlobalScope and adding some dedicated features.

SharedWorkerGlobalScope

Represents the scope of a shared worker, inheriting from WorkerGlobalScope and adding some dedicated features.

WorkerNavigator

Represents the identity and state of the user agent (the client).

ExamplesWe have created a couple of demos to show web worker usage:

Basic dedicated worker example (run dedicated worker).
Basic shared worker example (run shared worker).
OffscreenCanvas worker example (run OffscreenCanvas worker).

You can find out more information on how these demos work in Using Web Workers.SpecificationsSpecificationHTML # workersSee also
Using Web Workers
Worker interface
SharedWorker interface
Service Worker API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb Workers APIWeb Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down.Concepts and usageA worker is an object created using a constructor (e.g., Worker()) that runs a named JavaScript file — this file contains the code that will run in the worker thread.
In addition to the standard JavaScript set of functions (such as String, Array, Object, JSON, etc.), you can run almost any code you like inside a worker thread. There are some exceptions: for example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the Window object. For information about the code that you can run see supported functions, and supported Web APIs.
Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data property). The data is copied rather than shared.
Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page.
In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null).Worker typesThere are a number of different types of workers:

Dedicated workers are workers that are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
Shared workers are workers that can be utilized by multiple scripts running in different windows, IFrames, etc., as long as they are in the same domain as the worker. They are a little more complex than dedicated workers — scripts must communicate via an active port.
Service Workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.
Worker contextsWhile Window is not directly available to workers, many of the same methods are defined in a shared mixin (WindowOrWorkerGlobalScope), and made available to workers through their own WorkerGlobalScope-derived contexts:

DedicatedWorkerGlobalScope for dedicated workers
SharedWorkerGlobalScope for shared workers
ServiceWorkerGlobalScope for service workers
Interfaces
Worker

Represents a running worker thread, allowing you to pass messages to the running worker code.

WorkerLocation

Defines the absolute location of the script executed by the Worker.

SharedWorker

Represents a specific kind of worker that can be accessed from several browsing contexts (i.e., windows, tabs, or iframes) or even other workers.

WorkerGlobalScope

Represents the generic scope of any worker (doing the same job as Window does for normal web content). Different types of worker have scope objects that inherit from this interface and add more specific features.

DedicatedWorkerGlobalScope

Represents the scope of a dedicated worker, inheriting from WorkerGlobalScope and adding some dedicated features.

SharedWorkerGlobalScope

Represents the scope of a shared worker, inheriting from WorkerGlobalScope and adding some dedicated features.

WorkerNavigator

Represents the identity and state of the user agent (the client).

ExamplesWe have created a couple of demos to show web worker usage:

Basic dedicated worker example (run dedicated worker).
Basic shared worker example (run shared worker).
OffscreenCanvas worker example (run OffscreenCanvas worker).

You can find out more information on how these demos work in Using Web Workers.SpecificationsSpecificationHTML # workersSee also
Using Web Workers
Worker interface
SharedWorker interface
Service Worker API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nfor...ofBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe for...of statement executes a loop that operates on a sequence of values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), as well as the arguments object, generators produced by generator functions, and user-defined iterables.Try it
const array1 = ["a", "b", "c"];

for (const element of array1) {
  console.log(element);
}

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"
Syntaxjsfor (variable of iterable)
  statement


variable

Receives a value from the sequence on each iteration. May be either a declaration with const, let, or var, or an assignment target (e.g., a previously declared variable, an object property, or a destructuring pattern). Variables declared with var are not local to the loop, i.e., they are in the same scope the for...of loop is in.

iterable

An iterable object. The source of the sequence of values on which the loop operates.

statement

A statement to be executed on every iteration. May reference variable. You can use a block statement to execute multiple statements.

DescriptionA for...of loop operates on the values sourced from an iterable one by one in sequential order. Each operation of the loop on a value is called an iteration, and the loop is said to iterate over the iterable. Each iteration executes statements that may refer to the current sequence value.
When a for...of loop iterates over an iterable, it first calls the iterable's [Symbol.iterator]() method, which returns an iterator, and then repeatedly calls the resulting iterator's next() method to produce the sequence of values to be assigned to variable.
A for...of loop exits when the iterator has completed (the next() result is an object with done: true). Like other looping statements, you can use control flow statements inside statement:

break stops statement execution and goes to the first statement after the loop.
continue stops statement execution and goes to the next iteration of the loop.

If the for...of loop exited early (e.g., a break statement is encountered or an error is thrown), the return() method of the iterator is called to perform any cleanup.
The variable part of for...of accepts anything that can come before the = operator. You can use const to declare the variable as long as it's not reassigned within the loop body (it can change between iterations, because those are two separate variables). Otherwise, you can use let.
jsconst iterable = [10, 20, 30];

for (let value of iterable) {
  value += 1;
  console.log(value);
}
// 11
// 21
// 31


Note:
Each iteration creates a new variable. Reassigning the variable inside the loop body does not affect the original value in the iterable (an array, in this case).

You can use destructuring to assign multiple local variables, or use a property accessor like for (x.y of iterable) to assign the value to an object property.
However, a special rule forbids using async as the variable name. This is invalid syntax:
jslet async;
for (async of [1, 2, 3]); // SyntaxError: The left-hand side of a for-of loop may not be 'async'.

This is to avoid syntax ambiguity with the valid code for (async of => {};;), which is a for loop.ExamplesIterating over an Arrayjsconst iterable = [10, 20, 30];

for (const value of iterable) {
  console.log(value);
}
// 10
// 20
// 30
Iterating over a stringStrings are iterated by Unicode code points.
jsconst iterable = "boo";

for (const value of iterable) {
  console.log(value);
}
// "b"
// "o"
// "o"
Iterating over a TypedArrayjsconst iterable = new Uint8Array([0x00, 0xff]);

for (const value of iterable) {
  console.log(value);
}
// 0
// 255
Iterating over a Mapjsconst iterable = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);

for (const entry of iterable) {
  console.log(entry);
}
// ['a', 1]
// ['b', 2]
// ['c', 3]

for (const [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a Setjsconst iterable = new Set([1, 1, 2, 2, 3, 3]);

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over the arguments objectYou can iterate over the arguments object to examine all parameters passed into a function.
jsfunction foo() {
  for (const value of arguments) {
    console.log(value);
  }
}

foo(1, 2, 3);
// 1
// 2
// 3
Iterating over a NodeListThe following example adds a read class to paragraphs that are direct descendants of the <article> element by iterating over a NodeList DOM collection.
jsconst articleParagraphs = document.querySelectorAll("article > p");
for (const paragraph of articleParagraphs) {
  paragraph.classList.add("read");
}
Iterating over a user-defined iterableIterating over an object with an [Symbol.iterator]() method that returns a custom iterator:
jsconst iterable = {
  [Symbol.iterator]() {
    let i = 1;
    return {
      next() {
        if (i <= 3) {
          return { value: i++, done: false };
        }
        return { value: undefined, done: true };
      },
    };
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterating over an object with an [Symbol.iterator]() generator method:
jsconst iterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterable iterators (iterators with a [Symbol.iterator]() method that returns this) are a fairly common technique to make iterators usable in syntaxes expecting iterables, such as for...of.
jslet i = 1;

const iterator = {
  next() {
    if (i <= 3) {
      return { value: i++, done: false };
    }
    return { value: undefined, done: true };
  },
  [Symbol.iterator]() {
    return this;
  },
};

for (const value of iterator) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a generatorjsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
}
// 1
// 2
// 3
Early exitingExecution of the break statement in the first loop causes it to exit early. The iterator is not finished yet, so the second loop will continue from where the first one stopped at.
jsconst source = [1, 2, 3];

const iterator = source[Symbol.iterator]();

for (const value of iterator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// Another loop using the same iterator
// picks up where the last loop left off.
for (const value of iterator) {
  console.log(value);
}
// 2
// 3

// The iterator is used up.
// This loop will execute no iterations.
for (const value of iterator) {
  console.log(value);
}
// [No output]

Generators implement the return() method, which causes the generator function to early return when the loop exits. This makes generators not reusable between loops.
jsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// The generator is used up.
// This loop will execute no iterations.
for (const value of generator) {
  console.log(value);
}
// [No output]
Difference between for...of and for...inBoth for...in and for...of statements iterate over something. The main difference between them is in what they iterate over.
The for...in statement iterates over the enumerable string properties of an object, while the for...of statement iterates over values that the iterable object defines to be iterated over.
The following example shows the difference between a for...of loop and a for...in loop when used with an Array.
jsObject.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

const iterable = [3, 5, 7];
iterable.foo = "hello";

for (const i in iterable) {
  console.log(i);
}
// "0", "1", "2", "foo", "arrCustom", "objCustom"

for (const i in iterable) {
  if (Object.hasOwn(iterable, i)) {
    console.log(i);
  }
}
// "0" "1" "2" "foo"

for (const i of iterable) {
  console.log(i);
}
// 3 5 7

The object iterable inherits the properties objCustom and arrCustom because it contains both Object.prototype and Array.prototype in its prototype chain.
The for...in loop logs only enumerable properties of the iterable object. It doesn't log array elements 3, 5, 7 or "hello" because those are not properties — they are values. It logs array indexes as well as arrCustom and objCustom, which are actual properties. If you're not sure why these properties are iterated over, there's a more thorough explanation of how array iteration and for...in work.
The second loop is similar to the first one, but it uses Object.hasOwn() to check if the found enumerable property is the object's own, i.e., not inherited. If it is, the property is logged. Properties 0, 1, 2 and foo are logged because they are own properties. Properties arrCustom and objCustom are not logged because they are inherited.
The for...of loop iterates and logs values that iterable, as an array (which is iterable), defines to be iterated over. The object's elements 3, 5, 7 are shown, but none of the object's properties are.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-for-in-and-for-of-statementsBrowser compatibilitySee also
Array.prototype.forEach()
Map.prototype.forEach()
Object.entries()\n\nfor...ofBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe for...of statement executes a loop that operates on a sequence of values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), as well as the arguments object, generators produced by generator functions, and user-defined iterables.Try it
const array1 = ["a", "b", "c"];

for (const element of array1) {
  console.log(element);
}

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"
Syntaxjsfor (variable of iterable)
  statement


variable

Receives a value from the sequence on each iteration. May be either a declaration with const, let, or var, or an assignment target (e.g., a previously declared variable, an object property, or a destructuring pattern). Variables declared with var are not local to the loop, i.e., they are in the same scope the for...of loop is in.

iterable

An iterable object. The source of the sequence of values on which the loop operates.

statement

A statement to be executed on every iteration. May reference variable. You can use a block statement to execute multiple statements.

DescriptionA for...of loop operates on the values sourced from an iterable one by one in sequential order. Each operation of the loop on a value is called an iteration, and the loop is said to iterate over the iterable. Each iteration executes statements that may refer to the current sequence value.
When a for...of loop iterates over an iterable, it first calls the iterable's [Symbol.iterator]() method, which returns an iterator, and then repeatedly calls the resulting iterator's next() method to produce the sequence of values to be assigned to variable.
A for...of loop exits when the iterator has completed (the next() result is an object with done: true). Like other looping statements, you can use control flow statements inside statement:

break stops statement execution and goes to the first statement after the loop.
continue stops statement execution and goes to the next iteration of the loop.

If the for...of loop exited early (e.g., a break statement is encountered or an error is thrown), the return() method of the iterator is called to perform any cleanup.
The variable part of for...of accepts anything that can come before the = operator. You can use const to declare the variable as long as it's not reassigned within the loop body (it can change between iterations, because those are two separate variables). Otherwise, you can use let.
jsconst iterable = [10, 20, 30];

for (let value of iterable) {
  value += 1;
  console.log(value);
}
// 11
// 21
// 31


Note:
Each iteration creates a new variable. Reassigning the variable inside the loop body does not affect the original value in the iterable (an array, in this case).

You can use destructuring to assign multiple local variables, or use a property accessor like for (x.y of iterable) to assign the value to an object property.
However, a special rule forbids using async as the variable name. This is invalid syntax:
jslet async;
for (async of [1, 2, 3]); // SyntaxError: The left-hand side of a for-of loop may not be 'async'.

This is to avoid syntax ambiguity with the valid code for (async of => {};;), which is a for loop.ExamplesIterating over an Arrayjsconst iterable = [10, 20, 30];

for (const value of iterable) {
  console.log(value);
}
// 10
// 20
// 30
Iterating over a stringStrings are iterated by Unicode code points.
jsconst iterable = "boo";

for (const value of iterable) {
  console.log(value);
}
// "b"
// "o"
// "o"
Iterating over a TypedArrayjsconst iterable = new Uint8Array([0x00, 0xff]);

for (const value of iterable) {
  console.log(value);
}
// 0
// 255
Iterating over a Mapjsconst iterable = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);

for (const entry of iterable) {
  console.log(entry);
}
// ['a', 1]
// ['b', 2]
// ['c', 3]

for (const [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a Setjsconst iterable = new Set([1, 1, 2, 2, 3, 3]);

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over the arguments objectYou can iterate over the arguments object to examine all parameters passed into a function.
jsfunction foo() {
  for (const value of arguments) {
    console.log(value);
  }
}

foo(1, 2, 3);
// 1
// 2
// 3
Iterating over a NodeListThe following example adds a read class to paragraphs that are direct descendants of the <article> element by iterating over a NodeList DOM collection.
jsconst articleParagraphs = document.querySelectorAll("article > p");
for (const paragraph of articleParagraphs) {
  paragraph.classList.add("read");
}
Iterating over a user-defined iterableIterating over an object with an [Symbol.iterator]() method that returns a custom iterator:
jsconst iterable = {
  [Symbol.iterator]() {
    let i = 1;
    return {
      next() {
        if (i <= 3) {
          return { value: i++, done: false };
        }
        return { value: undefined, done: true };
      },
    };
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterating over an object with an [Symbol.iterator]() generator method:
jsconst iterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterable iterators (iterators with a [Symbol.iterator]() method that returns this) are a fairly common technique to make iterators usable in syntaxes expecting iterables, such as for...of.
jslet i = 1;

const iterator = {
  next() {
    if (i <= 3) {
      return { value: i++, done: false };
    }
    return { value: undefined, done: true };
  },
  [Symbol.iterator]() {
    return this;
  },
};

for (const value of iterator) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a generatorjsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
}
// 1
// 2
// 3
Early exitingExecution of the break statement in the first loop causes it to exit early. The iterator is not finished yet, so the second loop will continue from where the first one stopped at.
jsconst source = [1, 2, 3];

const iterator = source[Symbol.iterator]();

for (const value of iterator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// Another loop using the same iterator
// picks up where the last loop left off.
for (const value of iterator) {
  console.log(value);
}
// 2
// 3

// The iterator is used up.
// This loop will execute no iterations.
for (const value of iterator) {
  console.log(value);
}
// [No output]

Generators implement the return() method, which causes the generator function to early return when the loop exits. This makes generators not reusable between loops.
jsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// The generator is used up.
// This loop will execute no iterations.
for (const value of generator) {
  console.log(value);
}
// [No output]
Difference between for...of and for...inBoth for...in and for...of statements iterate over something. The main difference between them is in what they iterate over.
The for...in statement iterates over the enumerable string properties of an object, while the for...of statement iterates over values that the iterable object defines to be iterated over.
The following example shows the difference between a for...of loop and a for...in loop when used with an Array.
jsObject.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

const iterable = [3, 5, 7];
iterable.foo = "hello";

for (const i in iterable) {
  console.log(i);
}
// "0", "1", "2", "foo", "arrCustom", "objCustom"

for (const i in iterable) {
  if (Object.hasOwn(iterable, i)) {
    console.log(i);
  }
}
// "0" "1" "2" "foo"

for (const i of iterable) {
  console.log(i);
}
// 3 5 7

The object iterable inherits the properties objCustom and arrCustom because it contains both Object.prototype and Array.prototype in its prototype chain.
The for...in loop logs only enumerable properties of the iterable object. It doesn't log array elements 3, 5, 7 or "hello" because those are not properties — they are values. It logs array indexes as well as arrCustom and objCustom, which are actual properties. If you're not sure why these properties are iterated over, there's a more thorough explanation of how array iteration and for...in work.
The second loop is similar to the first one, but it uses Object.hasOwn() to check if the found enumerable property is the object's own, i.e., not inherited. If it is, the property is logged. Properties 0, 1, 2 and foo are logged because they are own properties. Properties arrCustom and objCustom are not logged because they are inherited.
The for...of loop iterates and logs values that iterable, as an array (which is iterable), defines to be iterated over. The object's elements 3, 5, 7 are shown, but none of the object's properties are.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-for-in-and-for-of-statementsBrowser compatibilitySee also
Array.prototype.forEach()
Map.prototype.forEach()
Object.entries()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nfor...ofBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackThe for...of statement executes a loop that operates on a sequence of values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), as well as the arguments object, generators produced by generator functions, and user-defined iterables.Try it
const array1 = ["a", "b", "c"];

for (const element of array1) {
  console.log(element);
}

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"
Syntaxjsfor (variable of iterable)
  statement


variable

Receives a value from the sequence on each iteration. May be either a declaration with const, let, or var, or an assignment target (e.g., a previously declared variable, an object property, or a destructuring pattern). Variables declared with var are not local to the loop, i.e., they are in the same scope the for...of loop is in.

iterable

An iterable object. The source of the sequence of values on which the loop operates.

statement

A statement to be executed on every iteration. May reference variable. You can use a block statement to execute multiple statements.

DescriptionA for...of loop operates on the values sourced from an iterable one by one in sequential order. Each operation of the loop on a value is called an iteration, and the loop is said to iterate over the iterable. Each iteration executes statements that may refer to the current sequence value.
When a for...of loop iterates over an iterable, it first calls the iterable's [Symbol.iterator]() method, which returns an iterator, and then repeatedly calls the resulting iterator's next() method to produce the sequence of values to be assigned to variable.
A for...of loop exits when the iterator has completed (the next() result is an object with done: true). Like other looping statements, you can use control flow statements inside statement:

break stops statement execution and goes to the first statement after the loop.
continue stops statement execution and goes to the next iteration of the loop.

If the for...of loop exited early (e.g., a break statement is encountered or an error is thrown), the return() method of the iterator is called to perform any cleanup.
The variable part of for...of accepts anything that can come before the = operator. You can use const to declare the variable as long as it's not reassigned within the loop body (it can change between iterations, because those are two separate variables). Otherwise, you can use let.
jsconst iterable = [10, 20, 30];

for (let value of iterable) {
  value += 1;
  console.log(value);
}
// 11
// 21
// 31


Note:
Each iteration creates a new variable. Reassigning the variable inside the loop body does not affect the original value in the iterable (an array, in this case).

You can use destructuring to assign multiple local variables, or use a property accessor like for (x.y of iterable) to assign the value to an object property.
However, a special rule forbids using async as the variable name. This is invalid syntax:
jslet async;
for (async of [1, 2, 3]); // SyntaxError: The left-hand side of a for-of loop may not be 'async'.

This is to avoid syntax ambiguity with the valid code for (async of => {};;), which is a for loop.ExamplesIterating over an Arrayjsconst iterable = [10, 20, 30];

for (const value of iterable) {
  console.log(value);
}
// 10
// 20
// 30
Iterating over a stringStrings are iterated by Unicode code points.
jsconst iterable = "boo";

for (const value of iterable) {
  console.log(value);
}
// "b"
// "o"
// "o"
Iterating over a TypedArrayjsconst iterable = new Uint8Array([0x00, 0xff]);

for (const value of iterable) {
  console.log(value);
}
// 0
// 255
Iterating over a Mapjsconst iterable = new Map([
  ["a", 1],
  ["b", 2],
  ["c", 3],
]);

for (const entry of iterable) {
  console.log(entry);
}
// ['a', 1]
// ['b', 2]
// ['c', 3]

for (const [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a Setjsconst iterable = new Set([1, 1, 2, 2, 3, 3]);

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over the arguments objectYou can iterate over the arguments object to examine all parameters passed into a function.
jsfunction foo() {
  for (const value of arguments) {
    console.log(value);
  }
}

foo(1, 2, 3);
// 1
// 2
// 3
Iterating over a NodeListThe following example adds a read class to paragraphs that are direct descendants of the <article> element by iterating over a NodeList DOM collection.
jsconst articleParagraphs = document.querySelectorAll("article > p");
for (const paragraph of articleParagraphs) {
  paragraph.classList.add("read");
}
Iterating over a user-defined iterableIterating over an object with an [Symbol.iterator]() method that returns a custom iterator:
jsconst iterable = {
  [Symbol.iterator]() {
    let i = 1;
    return {
      next() {
        if (i <= 3) {
          return { value: i++, done: false };
        }
        return { value: undefined, done: true };
      },
    };
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterating over an object with an [Symbol.iterator]() generator method:
jsconst iterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

for (const value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

Iterable iterators (iterators with a [Symbol.iterator]() method that returns this) are a fairly common technique to make iterators usable in syntaxes expecting iterables, such as for...of.
jslet i = 1;

const iterator = {
  next() {
    if (i <= 3) {
      return { value: i++, done: false };
    }
    return { value: undefined, done: true };
  },
  [Symbol.iterator]() {
    return this;
  },
};

for (const value of iterator) {
  console.log(value);
}
// 1
// 2
// 3
Iterating over a generatorjsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
}
// 1
// 2
// 3
Early exitingExecution of the break statement in the first loop causes it to exit early. The iterator is not finished yet, so the second loop will continue from where the first one stopped at.
jsconst source = [1, 2, 3];

const iterator = source[Symbol.iterator]();

for (const value of iterator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// Another loop using the same iterator
// picks up where the last loop left off.
for (const value of iterator) {
  console.log(value);
}
// 2
// 3

// The iterator is used up.
// This loop will execute no iterations.
for (const value of iterator) {
  console.log(value);
}
// [No output]

Generators implement the return() method, which causes the generator function to early return when the loop exits. This makes generators not reusable between loops.
jsfunction* source() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = source();

for (const value of generator) {
  console.log(value);
  if (value === 1) {
    break;
  }
  console.log("This string will not be logged.");
}
// 1

// The generator is used up.
// This loop will execute no iterations.
for (const value of generator) {
  console.log(value);
}
// [No output]
Difference between for...of and for...inBoth for...in and for...of statements iterate over something. The main difference between them is in what they iterate over.
The for...in statement iterates over the enumerable string properties of an object, while the for...of statement iterates over values that the iterable object defines to be iterated over.
The following example shows the difference between a for...of loop and a for...in loop when used with an Array.
jsObject.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

const iterable = [3, 5, 7];
iterable.foo = "hello";

for (const i in iterable) {
  console.log(i);
}
// "0", "1", "2", "foo", "arrCustom", "objCustom"

for (const i in iterable) {
  if (Object.hasOwn(iterable, i)) {
    console.log(i);
  }
}
// "0" "1" "2" "foo"

for (const i of iterable) {
  console.log(i);
}
// 3 5 7

The object iterable inherits the properties objCustom and arrCustom because it contains both Object.prototype and Array.prototype in its prototype chain.
The for...in loop logs only enumerable properties of the iterable object. It doesn't log array elements 3, 5, 7 or "hello" because those are not properties — they are values. It logs array indexes as well as arrCustom and objCustom, which are actual properties. If you're not sure why these properties are iterated over, there's a more thorough explanation of how array iteration and for...in work.
The second loop is similar to the first one, but it uses Object.hasOwn() to check if the found enumerable property is the object's own, i.e., not inherited. If it is, the property is logged. Properties 0, 1, 2 and foo are logged because they are own properties. Properties arrCustom and objCustom are not logged because they are inherited.
The for...of loop iterates and logs values that iterable, as an array (which is iterable), defines to be iterated over. The object's elements 3, 5, 7 are shown, but none of the object's properties are.SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-for-in-and-for-of-statementsBrowser compatibilitySee also
Array.prototype.forEach()
Map.prototype.forEach()
Object.entries()
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMapBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Map object holds key-value pairs and remembers the original insertion order of the keys.
Any value (both objects and primitive values) may be used as either a key or a value.Try it
const map1 = new Map();

map1.set("a", 1);
map1.set("b", 2);
map1.set("c", 3);

console.log(map1.get("a"));
// Expected output: 1

map1.set("a", 97);

console.log(map1.get("a"));
// Expected output: 97

console.log(map1.size);
// Expected output: 3

map1.delete("b");

console.log(map1.size);
// Expected output: 2
DescriptionMap objects are collections of key-value pairs. A key in the Map may only occur once; it is unique in the Map's collection. A Map object is iterated by key-value pairs — a for...of loop returns a 2-member array of [key, value] for each iteration. Iteration happens in insertion order, which corresponds to the order in which each key-value pair was first inserted into the map by the set() method (that is, there wasn't a key with the same value already in the map when set() was called).
The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Key equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.Objects vs. MapsObject is similar to Map—both let you set keys to
values, retrieve those values, delete keys, and detect whether something is
stored at a key. For this reason (and because there were no built-in
alternatives), Object has been used as Map historically.
However, there are important differences that make Map preferable in some
cases:

  
    
      
      Map
      Object
    
  
  
    
      Accidental Keys
      
        A Map does not contain any keys by default. It only
        contains what is explicitly put into it.
      
      
        
          An Object has a prototype, so it contains default keys
          that could collide with your own keys if you're not careful.
        
        
          
            Note: This can be bypassed by using
            Object.create(null),
            but this is seldom done.
          
        
      
    
    
      Security
      
        A Map is safe to use with user-provided keys and values.
      
      
        
          Setting user-provided key-value pairs on an Object may allow
          an attacker to override the object's prototype, which can lead to
          
            object injection attacks
          . Like the accidental keys issue, this can also be mitigated by using
          a null-prototype object.
        
      
    
    
      Key Types
      
        A Map's keys can be any value (including functions,
        objects, or any primitive).
      
      
        The keys of an Object must be either a
        String or a Symbol.
      
    
    
      Key Order
      
        
          The keys in Map are ordered in a straightforward
          way: A Map object iterates entries, keys, and values in
          the order of entry insertion.
        
      
      
        
          Although the keys of an ordinary Object are ordered now,
          this was not always the case, and the order is complex. As a result,
          it's best not to rely on property order.
        
        
          The order was first defined for own properties only in ECMAScript
          2015; ECMAScript 2020 defines order for inherited properties as well.
          But note that no single mechanism
          iterates
          all of an object's properties; the various mechanisms
          each include different subsets of properties.
          (for-in
          includes only enumerable string-keyed properties;
          Object.keys includes only own, enumerable,
          string-keyed properties;
          Object.getOwnPropertyNames includes own,
          string-keyed properties even if non-enumerable;
          Object.getOwnPropertySymbols does the same
          for just Symbol-keyed properties, etc.)
        
      
    
    
      Size
      
        The number of items in a Map is easily retrieved from its
        size property.
      
      
        Determining the number of items in an Object is more roundabout and less efficient. A common way to do it is through the length of the array returned from Object.keys().
      
    
    
      Iteration
      
        A Map is an
        iterable, so it can be directly iterated.
      
      
        
          Object does not implement an iteration protocol, and so objects are not directly iterable using the JavaScript
          for...of
          statement (by default).
        
        
          Note:
          
            
              An object can implement the iteration protocol, or you can get an
              iterable for an object using Object.keys or Object.entries.
            
            
              The
              for...in
              statement allows you to iterate over the
              enumerable properties of an object.
            
          
        
      
    
    
      Performance
      
        
          Performs better in scenarios involving frequent additions and removals
          of key-value pairs.
        
      
      
        
          Not optimized for frequent additions and removals of key-value pairs.
        
      
    
    
      Serialization and parsing
      
        No native support for serialization or parsing.
        
          (But you can build your own serialization and parsing support for
          Map by using JSON.stringify()
          with its replacer argument, and by using
          JSON.parse() with its
          reviver argument. See the Stack Overflow question
          How do you JSON.stringify an ES6 Map?).
        
      
      
        
          Native support for serialization from Object to
          JSON, using JSON.stringify().
        
        
          Native support for parsing from JSON to Object,
          using JSON.parse().
        
      
    
  
Setting object propertiesSetting Object properties works for Map objects as well, and can cause
considerable confusion.
Therefore, this appears to work in a way:
jsconst wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

But that way of setting a property does not interact with the Map data
structure. It uses the feature of the generic object. The value of 'bla' is not
stored in the Map for queries. Other operations on the data fail:
jswrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

The correct usage for storing data in the Map is through the set(key, value)
method.
jsconst contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
Map-like browser APIsBrowser Map-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a Map.
Just like Map, entries can be iterated in the same order that they were added to the object.
Map-like objects and Map also have properties and methods that share the same name and behavior.
However unlike Map they only allow specific predefined types for the keys and values of each entry.
The allowed types are set in the specification IDL definition.
For example, RTCStatsReport is a Map-like object that must use strings for keys and objects for values.
This is defined in the specification IDL below:
webidlinterface RTCStatsReport {
  readonly maplike<DOMString, object>;
};

Map-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Map-like objects have the property size, and the methods: entries(), forEach(), get(), has(), keys(), values(), and Symbol.iterator().
Writeable Map-like objects additionally have the methods: clear(), delete(), and set().

The methods and properties have the same behavior as the equivalent entities in Map, except for the restriction on the types of the keys and values.
The following are examples of read-only Map-like browser objects:

AudioParamMap
RTCStatsReport
EventCounts
KeyboardLayoutMap
MIDIInputMap
MIDIOutputMap
Constructor
Map()

Creates a new Map object.

Static properties
Map[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
Map.groupBy()

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned Map uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

Instance propertiesThese properties are defined on Map.prototype and shared by all Map instances.

Map.prototype.constructor

The constructor function that created the instance object. For Map instances, the initial value is the Map constructor.

Map.prototype.size

Returns the number of key/value pairs in the Map object.

Map.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Map". This property is used in Object.prototype.toString().

Instance methods
Map.prototype.clear()

Removes all key-value pairs from the Map object.

Map.prototype.delete()

Returns true if an element in the Map object existed and has been
removed, or false if the element does not exist. map.has(key)
will return false afterwards.

Map.prototype.entries()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

Map.prototype.forEach()

Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.

Map.prototype.get()

Returns the value associated to the passed key, or undefined if there is none.

Map.prototype.has()

Returns a boolean indicating whether a value has been associated with the passed key in the Map object or not.

Map.prototype.keys()

Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.

Map.prototype.set()

Sets the value for the passed key in the Map object. Returns the Map object.

Map.prototype.values()

Returns a new Iterator object that contains the values for each element in the Map object in insertion order.

Map.prototype[Symbol.iterator]()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

ExamplesUsing the Map objectjsconst myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(function () {})); // undefined, because keyFunc !== function () {}
Using NaN as Map keysNaN can also be used as a key. Even though every NaN is
not equal to itself (NaN !== NaN is true), the following example works because
NaNs are indistinguishable from each other:
jsconst myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
Iterating Map with for...ofMaps can be iterated using a for...of loop:
jsconst myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
Iterating Map with forEach()Maps can be iterated using the
forEach() method:
jsmyMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
Relation with Array objectsjsconst kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
Cloning and merging MapsJust like Arrays, Maps can be cloned:
jsconst original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)


Note:
Keep in mind that the data itself is not cloned. In other words, it is only a shallow copy of the Map.

Maps can be merged, maintaining key uniqueness:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three

Maps can be merged with Arrays, too:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "un"]]);

console.log(merged.get(1)); // un
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-map-objectsBrowser compatibilitySee also
Polyfill for Map in core-js
es-shims polyfill of Map
Set
WeakMap
WeakSet\n\nMapBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Map object holds key-value pairs and remembers the original insertion order of the keys.
Any value (both objects and primitive values) may be used as either a key or a value.Try it
const map1 = new Map();

map1.set("a", 1);
map1.set("b", 2);
map1.set("c", 3);

console.log(map1.get("a"));
// Expected output: 1

map1.set("a", 97);

console.log(map1.get("a"));
// Expected output: 97

console.log(map1.size);
// Expected output: 3

map1.delete("b");

console.log(map1.size);
// Expected output: 2
DescriptionMap objects are collections of key-value pairs. A key in the Map may only occur once; it is unique in the Map's collection. A Map object is iterated by key-value pairs — a for...of loop returns a 2-member array of [key, value] for each iteration. Iteration happens in insertion order, which corresponds to the order in which each key-value pair was first inserted into the map by the set() method (that is, there wasn't a key with the same value already in the map when set() was called).
The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Key equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.Objects vs. MapsObject is similar to Map—both let you set keys to
values, retrieve those values, delete keys, and detect whether something is
stored at a key. For this reason (and because there were no built-in
alternatives), Object has been used as Map historically.
However, there are important differences that make Map preferable in some
cases:

  
    
      
      Map
      Object
    
  
  
    
      Accidental Keys
      
        A Map does not contain any keys by default. It only
        contains what is explicitly put into it.
      
      
        
          An Object has a prototype, so it contains default keys
          that could collide with your own keys if you're not careful.
        
        
          
            Note: This can be bypassed by using
            Object.create(null),
            but this is seldom done.
          
        
      
    
    
      Security
      
        A Map is safe to use with user-provided keys and values.
      
      
        
          Setting user-provided key-value pairs on an Object may allow
          an attacker to override the object's prototype, which can lead to
          
            object injection attacks
          . Like the accidental keys issue, this can also be mitigated by using
          a null-prototype object.
        
      
    
    
      Key Types
      
        A Map's keys can be any value (including functions,
        objects, or any primitive).
      
      
        The keys of an Object must be either a
        String or a Symbol.
      
    
    
      Key Order
      
        
          The keys in Map are ordered in a straightforward
          way: A Map object iterates entries, keys, and values in
          the order of entry insertion.
        
      
      
        
          Although the keys of an ordinary Object are ordered now,
          this was not always the case, and the order is complex. As a result,
          it's best not to rely on property order.
        
        
          The order was first defined for own properties only in ECMAScript
          2015; ECMAScript 2020 defines order for inherited properties as well.
          But note that no single mechanism
          iterates
          all of an object's properties; the various mechanisms
          each include different subsets of properties.
          (for-in
          includes only enumerable string-keyed properties;
          Object.keys includes only own, enumerable,
          string-keyed properties;
          Object.getOwnPropertyNames includes own,
          string-keyed properties even if non-enumerable;
          Object.getOwnPropertySymbols does the same
          for just Symbol-keyed properties, etc.)
        
      
    
    
      Size
      
        The number of items in a Map is easily retrieved from its
        size property.
      
      
        Determining the number of items in an Object is more roundabout and less efficient. A common way to do it is through the length of the array returned from Object.keys().
      
    
    
      Iteration
      
        A Map is an
        iterable, so it can be directly iterated.
      
      
        
          Object does not implement an iteration protocol, and so objects are not directly iterable using the JavaScript
          for...of
          statement (by default).
        
        
          Note:
          
            
              An object can implement the iteration protocol, or you can get an
              iterable for an object using Object.keys or Object.entries.
            
            
              The
              for...in
              statement allows you to iterate over the
              enumerable properties of an object.
            
          
        
      
    
    
      Performance
      
        
          Performs better in scenarios involving frequent additions and removals
          of key-value pairs.
        
      
      
        
          Not optimized for frequent additions and removals of key-value pairs.
        
      
    
    
      Serialization and parsing
      
        No native support for serialization or parsing.
        
          (But you can build your own serialization and parsing support for
          Map by using JSON.stringify()
          with its replacer argument, and by using
          JSON.parse() with its
          reviver argument. See the Stack Overflow question
          How do you JSON.stringify an ES6 Map?).
        
      
      
        
          Native support for serialization from Object to
          JSON, using JSON.stringify().
        
        
          Native support for parsing from JSON to Object,
          using JSON.parse().
        
      
    
  
Setting object propertiesSetting Object properties works for Map objects as well, and can cause
considerable confusion.
Therefore, this appears to work in a way:
jsconst wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

But that way of setting a property does not interact with the Map data
structure. It uses the feature of the generic object. The value of 'bla' is not
stored in the Map for queries. Other operations on the data fail:
jswrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

The correct usage for storing data in the Map is through the set(key, value)
method.
jsconst contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
Map-like browser APIsBrowser Map-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a Map.
Just like Map, entries can be iterated in the same order that they were added to the object.
Map-like objects and Map also have properties and methods that share the same name and behavior.
However unlike Map they only allow specific predefined types for the keys and values of each entry.
The allowed types are set in the specification IDL definition.
For example, RTCStatsReport is a Map-like object that must use strings for keys and objects for values.
This is defined in the specification IDL below:
webidlinterface RTCStatsReport {
  readonly maplike<DOMString, object>;
};

Map-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Map-like objects have the property size, and the methods: entries(), forEach(), get(), has(), keys(), values(), and Symbol.iterator().
Writeable Map-like objects additionally have the methods: clear(), delete(), and set().

The methods and properties have the same behavior as the equivalent entities in Map, except for the restriction on the types of the keys and values.
The following are examples of read-only Map-like browser objects:

AudioParamMap
RTCStatsReport
EventCounts
KeyboardLayoutMap
MIDIInputMap
MIDIOutputMap
Constructor
Map()

Creates a new Map object.

Static properties
Map[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
Map.groupBy()

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned Map uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

Instance propertiesThese properties are defined on Map.prototype and shared by all Map instances.

Map.prototype.constructor

The constructor function that created the instance object. For Map instances, the initial value is the Map constructor.

Map.prototype.size

Returns the number of key/value pairs in the Map object.

Map.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Map". This property is used in Object.prototype.toString().

Instance methods
Map.prototype.clear()

Removes all key-value pairs from the Map object.

Map.prototype.delete()

Returns true if an element in the Map object existed and has been
removed, or false if the element does not exist. map.has(key)
will return false afterwards.

Map.prototype.entries()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

Map.prototype.forEach()

Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.

Map.prototype.get()

Returns the value associated to the passed key, or undefined if there is none.

Map.prototype.has()

Returns a boolean indicating whether a value has been associated with the passed key in the Map object or not.

Map.prototype.keys()

Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.

Map.prototype.set()

Sets the value for the passed key in the Map object. Returns the Map object.

Map.prototype.values()

Returns a new Iterator object that contains the values for each element in the Map object in insertion order.

Map.prototype[Symbol.iterator]()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

ExamplesUsing the Map objectjsconst myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(function () {})); // undefined, because keyFunc !== function () {}
Using NaN as Map keysNaN can also be used as a key. Even though every NaN is
not equal to itself (NaN !== NaN is true), the following example works because
NaNs are indistinguishable from each other:
jsconst myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
Iterating Map with for...ofMaps can be iterated using a for...of loop:
jsconst myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
Iterating Map with forEach()Maps can be iterated using the
forEach() method:
jsmyMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
Relation with Array objectsjsconst kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
Cloning and merging MapsJust like Arrays, Maps can be cloned:
jsconst original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)


Note:
Keep in mind that the data itself is not cloned. In other words, it is only a shallow copy of the Map.

Maps can be merged, maintaining key uniqueness:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three

Maps can be merged with Arrays, too:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "un"]]);

console.log(merged.get(1)); // un
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-map-objectsBrowser compatibilitySee also
Polyfill for Map in core-js
es-shims polyfill of Map
Set
WeakMap
WeakSet
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMapBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Map object holds key-value pairs and remembers the original insertion order of the keys.
Any value (both objects and primitive values) may be used as either a key or a value.Try it
const map1 = new Map();

map1.set("a", 1);
map1.set("b", 2);
map1.set("c", 3);

console.log(map1.get("a"));
// Expected output: 1

map1.set("a", 97);

console.log(map1.get("a"));
// Expected output: 97

console.log(map1.size);
// Expected output: 3

map1.delete("b");

console.log(map1.size);
// Expected output: 2
DescriptionMap objects are collections of key-value pairs. A key in the Map may only occur once; it is unique in the Map's collection. A Map object is iterated by key-value pairs — a for...of loop returns a 2-member array of [key, value] for each iteration. Iteration happens in insertion order, which corresponds to the order in which each key-value pair was first inserted into the map by the set() method (that is, there wasn't a key with the same value already in the map when set() was called).
The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).Key equalityValue equality is based on the SameValueZero algorithm. (It used to use SameValue, which treated 0 and -0 as different. Check browser compatibility.) This means NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.Objects vs. MapsObject is similar to Map—both let you set keys to
values, retrieve those values, delete keys, and detect whether something is
stored at a key. For this reason (and because there were no built-in
alternatives), Object has been used as Map historically.
However, there are important differences that make Map preferable in some
cases:

  
    
      
      Map
      Object
    
  
  
    
      Accidental Keys
      
        A Map does not contain any keys by default. It only
        contains what is explicitly put into it.
      
      
        
          An Object has a prototype, so it contains default keys
          that could collide with your own keys if you're not careful.
        
        
          
            Note: This can be bypassed by using
            Object.create(null),
            but this is seldom done.
          
        
      
    
    
      Security
      
        A Map is safe to use with user-provided keys and values.
      
      
        
          Setting user-provided key-value pairs on an Object may allow
          an attacker to override the object's prototype, which can lead to
          
            object injection attacks
          . Like the accidental keys issue, this can also be mitigated by using
          a null-prototype object.
        
      
    
    
      Key Types
      
        A Map's keys can be any value (including functions,
        objects, or any primitive).
      
      
        The keys of an Object must be either a
        String or a Symbol.
      
    
    
      Key Order
      
        
          The keys in Map are ordered in a straightforward
          way: A Map object iterates entries, keys, and values in
          the order of entry insertion.
        
      
      
        
          Although the keys of an ordinary Object are ordered now,
          this was not always the case, and the order is complex. As a result,
          it's best not to rely on property order.
        
        
          The order was first defined for own properties only in ECMAScript
          2015; ECMAScript 2020 defines order for inherited properties as well.
          But note that no single mechanism
          iterates
          all of an object's properties; the various mechanisms
          each include different subsets of properties.
          (for-in
          includes only enumerable string-keyed properties;
          Object.keys includes only own, enumerable,
          string-keyed properties;
          Object.getOwnPropertyNames includes own,
          string-keyed properties even if non-enumerable;
          Object.getOwnPropertySymbols does the same
          for just Symbol-keyed properties, etc.)
        
      
    
    
      Size
      
        The number of items in a Map is easily retrieved from its
        size property.
      
      
        Determining the number of items in an Object is more roundabout and less efficient. A common way to do it is through the length of the array returned from Object.keys().
      
    
    
      Iteration
      
        A Map is an
        iterable, so it can be directly iterated.
      
      
        
          Object does not implement an iteration protocol, and so objects are not directly iterable using the JavaScript
          for...of
          statement (by default).
        
        
          Note:
          
            
              An object can implement the iteration protocol, or you can get an
              iterable for an object using Object.keys or Object.entries.
            
            
              The
              for...in
              statement allows you to iterate over the
              enumerable properties of an object.
            
          
        
      
    
    
      Performance
      
        
          Performs better in scenarios involving frequent additions and removals
          of key-value pairs.
        
      
      
        
          Not optimized for frequent additions and removals of key-value pairs.
        
      
    
    
      Serialization and parsing
      
        No native support for serialization or parsing.
        
          (But you can build your own serialization and parsing support for
          Map by using JSON.stringify()
          with its replacer argument, and by using
          JSON.parse() with its
          reviver argument. See the Stack Overflow question
          How do you JSON.stringify an ES6 Map?).
        
      
      
        
          Native support for serialization from Object to
          JSON, using JSON.stringify().
        
        
          Native support for parsing from JSON to Object,
          using JSON.parse().
        
      
    
  
Setting object propertiesSetting Object properties works for Map objects as well, and can cause
considerable confusion.
Therefore, this appears to work in a way:
jsconst wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

But that way of setting a property does not interact with the Map data
structure. It uses the feature of the generic object. The value of 'bla' is not
stored in the Map for queries. Other operations on the data fail:
jswrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }

The correct usage for storing data in the Map is through the set(key, value)
method.
jsconst contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
Map-like browser APIsBrowser Map-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a Map.
Just like Map, entries can be iterated in the same order that they were added to the object.
Map-like objects and Map also have properties and methods that share the same name and behavior.
However unlike Map they only allow specific predefined types for the keys and values of each entry.
The allowed types are set in the specification IDL definition.
For example, RTCStatsReport is a Map-like object that must use strings for keys and objects for values.
This is defined in the specification IDL below:
webidlinterface RTCStatsReport {
  readonly maplike<DOMString, object>;
};

Map-like objects are either read-only or read-writable (see the readonly keyword in the IDL above).

Read-only Map-like objects have the property size, and the methods: entries(), forEach(), get(), has(), keys(), values(), and Symbol.iterator().
Writeable Map-like objects additionally have the methods: clear(), delete(), and set().

The methods and properties have the same behavior as the equivalent entities in Map, except for the restriction on the types of the keys and values.
The following are examples of read-only Map-like browser objects:

AudioParamMap
RTCStatsReport
EventCounts
KeyboardLayoutMap
MIDIInputMap
MIDIOutputMap
Constructor
Map()

Creates a new Map object.

Static properties
Map[Symbol.species]

The constructor function that is used to create derived objects.

Static methods
Map.groupBy()

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned Map uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

Instance propertiesThese properties are defined on Map.prototype and shared by all Map instances.

Map.prototype.constructor

The constructor function that created the instance object. For Map instances, the initial value is the Map constructor.

Map.prototype.size

Returns the number of key/value pairs in the Map object.

Map.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Map". This property is used in Object.prototype.toString().

Instance methods
Map.prototype.clear()

Removes all key-value pairs from the Map object.

Map.prototype.delete()

Returns true if an element in the Map object existed and has been
removed, or false if the element does not exist. map.has(key)
will return false afterwards.

Map.prototype.entries()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

Map.prototype.forEach()

Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.

Map.prototype.get()

Returns the value associated to the passed key, or undefined if there is none.

Map.prototype.has()

Returns a boolean indicating whether a value has been associated with the passed key in the Map object or not.

Map.prototype.keys()

Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.

Map.prototype.set()

Sets the value for the passed key in the Map object. Returns the Map object.

Map.prototype.values()

Returns a new Iterator object that contains the values for each element in the Map object in insertion order.

Map.prototype[Symbol.iterator]()

Returns a new Iterator object that contains a two-member array of [key, value] for each element in the Map object in insertion order.

ExamplesUsing the Map objectjsconst myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(function () {})); // undefined, because keyFunc !== function () {}
Using NaN as Map keysNaN can also be used as a key. Even though every NaN is
not equal to itself (NaN !== NaN is true), the following example works because
NaNs are indistinguishable from each other:
jsconst myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
Iterating Map with for...ofMaps can be iterated using a for...of loop:
jsconst myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
Iterating Map with forEach()Maps can be iterated using the
forEach() method:
jsmyMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
Relation with Array objectsjsconst kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
Cloning and merging MapsJust like Arrays, Maps can be cloned:
jsconst original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)


Note:
Keep in mind that the data itself is not cloned. In other words, it is only a shallow copy of the Map.

Maps can be merged, maintaining key uniqueness:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three

Maps can be merged with Arrays, too:
jsconst first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "un"]]);

console.log(merged.get(1)); // un
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-map-objectsBrowser compatibilitySee also
Polyfill for Map in core-js
es-shims polyfill of Map
Set
WeakMap
WeakSet
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nIteration protocolsIteration protocols aren't new built-ins or syntax, but protocols. These protocols can be implemented by any object by following some conventions.
There are two protocols: The iterable protocol and the iterator protocol.The iterable protocolThe iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.
In order to be iterable, an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator:

[Symbol.iterator]()

A zero-argument function that returns an object, conforming to the iterator protocol.


Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.
Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.
This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield.The iterator protocolThe iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.
An object is an iterator when it implements a next() method with the following semantics:

next()

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined) when a built-in language feature (such as for...of) is using the iterator, a TypeError ("iterator.next() returned a non-object value") will be thrown.


All iterator protocol methods (next(), return(), and throw()) are expected to return an object implementing the IteratorResult interface. It must have the following properties:

done Optional

A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.)
Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator.

value Optional

Any JavaScript value returned by the iterator. Can be omitted when done is true.


In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined }.
If an iterator returns a result with done: true, any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level.
The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression.
Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).

return(value) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true. Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined.

throw(exception) Optional

A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true. Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return/throw.



Note:
It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol.

It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this.
js// Satisfies both the Iterator Protocol and Iterable
const myIterator = {
  next() {
    // …
  },
  [Symbol.iterator]() {
    return this;
  },
};

Such object is called an iterable iterator. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables, not iterators.) The generator object is an example:
jsconst aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

console.log(typeof aGeneratorObject.next);
// "function" — it has a next method (which returns the right result), so it's an iterator

console.log(typeof aGeneratorObject[Symbol.iterator]);
// "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable

console.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);
// true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator

All built-in iterators inherit from Iterator.prototype, which implements the [Symbol.iterator]() method as returning this, so that built-in iterators are also iterable.
However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does.The async iterator and async iterable protocolsThere are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.
An object implements the async iterable protocol when it implements the following methods:

[Symbol.asyncIterator]()

A zero-argument function that returns an object, conforming to the async iterator protocol.


An object implements the async iterator protocol when it implements the following methods:

next()

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

return(value) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

throw(exception) Optional

A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's.

Interactions between the language and iteration protocolsThe language specifies APIs that either produce or consume iterables and iterators.Built-in iterablesString, Array, TypedArray, Map, Set, and Segments (returned by Intl.Segmenter.prototype.segment()) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables.
There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream, have the Symbol.asyncIterator method set by default.
Generator functions return generator objects, which are iterable iterators. Async generator functions return async generator objects, which are async iterable iterators.
The iterators returned from built-in iterables actually all inherit from a common class Iterator, which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.
console.log([][Symbol.iterator]());

Array Iterator {}
  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators
    next: ƒ next()
    Symbol(Symbol.toStringTag): "Array Iterator"
    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators
      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()
      [[Prototype]]: Object         ==> This is Object.prototype
Built-in APIs accepting iterablesThere are many APIs that accept iterables. Some examples include:

Map()
WeakMap()
Set()
WeakSet()
Promise.all()
Promise.allSettled()
Promise.race()
Promise.any()
Array.from()
Object.groupBy()
Map.groupBy()

jsconst myObj = {};

new WeakSet(
  (function* () {
    yield {};
    yield myObj;
    yield {};
  })(),
).has(myObj); // true
Syntaxes expecting iterablesSome statements and expressions expect iterables, for example the for...of loops, array and parameter spreading, yield*, and array destructuring:
jsfor (const value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

console.log([..."abc"]); // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

console.log(gen().next()); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
console.log(a); // "a"

When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring.
jsconst obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next() {
        i++;
        console.log("Returning", i);
        if (i === 3) return { done: true, value: i };
        return { done: false, value: i };
      },
      return() {
        console.log("Closing");
        return { done: true };
      },
    };
  },
};

const [a] = obj;
// Returning 1
// Closing

const [b, c, d] = obj;
// Returning 1
// Returning 2
// Returning 3
// Already reached the end (the last call returned `done: true`),
// so `return` is not called
console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable

for (const b of obj) {
  break;
}
// Returning 1
// Closing

The for await...of loop and yield* in async generator functions (but not sync generator functions) are the only ways to interact with async iterables. Using for...of, array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]()) will throw a TypeError: x is not iterable.Error handlingBecause iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants. We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator.Non-well-formed iterablesErrors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator:

It has a callable [Symbol.iterator]() method.
The [Symbol.iterator]() method returns an object.
The object returned by [Symbol.iterator]() has a callable next() method.

When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown.
jsconst nonWellFormedIterable = { [Symbol.iterator]: 1 };
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable
nonWellFormedIterable[Symbol.iterator] = () => 1;
[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value
nonWellFormedIterable[Symbol.iterator] = () => ({});
[...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function

For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null, JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too.
This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided.Errors during iterationMost errors happen when stepping the iterator (calling next()). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown.
If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next(), you may catch the error and retry calling next(), but in general you should assume the iterator is already closed.
If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true, the return() method is not called, with the assumption that the iterator has already cleaned up.
The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method.
Usually, the caller implements error handling like this:
jstry {
  for (const value of iterable) {
    // …
  }
} catch (e) {
  // Handle the error
}

The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error.
Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors:
jsfunction* gen() {
  try {
    yield doSomething();
    yield doSomethingElse();
  } finally {
    cleanup();
  }
}

The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen. If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called.Forwarding errorsSome built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from(), iterator helper methods (map(), filter(), take(), drop(), and flatMap()), yield*, and a hidden wrapper when you use async iteration (for await...of, Array.fromAsync) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller.

All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors.
Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined }. This is consistent with generator functions where execution hasn't entered the yield* expression yet.
yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference.
ExamplesUser-defined iterablesYou can make your own iterables like this:
jsconst myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};

console.log([...myIterable]); // [1, 2, 3]
Basic iteratorIterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure.
jsfunction makeIterator(array) {
  let nextIndex = 0;
  return {
    next() {
      return nextIndex < array.length
        ? {
            value: array[nextIndex++],
            done: false,
          }
        : {
            done: true,
          };
    },
  };
}

const it = makeIterator(["yo", "ya"]);

console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
Infinite iteratorjsfunction idMaker() {
  let index = 0;
  return {
    next() {
      return {
        value: index++,
        done: false,
      };
    },
  };
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a generatorjsfunction* makeGenerator(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}

const gen = makeGenerator(["yo", "ya"]);

console.log(gen.next().value); // 'yo'
console.log(gen.next().value); // 'ya'
console.log(gen.next().done); // true

function* idMaker() {
  let index = 0;
  while (true) {
    yield index++;
  }
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// …
Defining an iterable with a classState encapsulation can be done with private properties as well.
jsclass SimpleClass {
  #data;

  constructor(data) {
    this.#data = data;
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    let index = 0;

    return {
      // Note: using an arrow function allows `this` to point to the
      // one of `[Symbol.iterator]()` instead of `next()`
      next: () => {
        if (index < this.#data.length) {
          return { value: this.#data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}
Overriding built-in iterablesFor example, a String is a built-in iterable object:
jsconst someString = "hi";
console.log(typeof someString[Symbol.iterator]); // "function"

String's default iterator returns the string's code points one by one:
jsconst iterator = someString[Symbol.iterator]();
console.log(`${iterator}`); // "[object String Iterator]"

console.log(iterator.next()); // { value: "h", done: false }
console.log(iterator.next()); // { value: "i", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

You can redefine the iteration behavior by supplying our own [Symbol.iterator]():
js// need to construct a String object explicitly to avoid auto-boxing
const someString = new String("hi");

someString[Symbol.iterator] = function () {
  return {
    // this is the iterator object, returning a single element (the string "bye")
    next() {
      return this._first
        ? { value: "bye", done: (this._first = false) }
        : { done: true };
    },
    _first: true,
  };
};

Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol:
jsconsole.log([...someString]); // ["bye"]
console.log(`${someString}`); // "hi"
Concurrent modifications when iteratingAlmost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work.
Consider the following case using a URLSearchParams:
jsconst searchParams = new URLSearchParams(
  "deleteme1=value1&key2=value2&key3=value3",
);

// Delete unwanted keys
for (const [key, value] of searchParams) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    searchParams.delete(key);
  }
}

// Output:
// deleteme1
// key3

Note how it never logs key2. This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3.
Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map:
jsconst myMap = new Map([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);

for (const [key, value] of myMap) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myMap.delete(key);
  }
}

// Output:
// deleteme1
// key2
// key3

Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look:
jsconst tombstone = Symbol("tombstone");

class MyIterable {
  #data;
  constructor(data) {
    this.#data = data;
  }
  delete(deletedKey) {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i][0] === deletedKey) {
        this.#data[i] = tombstone;
        return true;
      }
    }
    return false;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.#data.length; i++) {
      if (this.#data[i] !== tombstone) {
        yield this.#data[i];
      }
    }
  }
}

const myIterable = new MyIterable([
  ["deleteme1", "value1"],
  ["key2", "value2"],
  ["key3", "value3"],
]);
for (const [key, value] of myIterable) {
  console.log(key);
  if (key.startsWith("deleteme")) {
    myIterable.delete(key);
  }
}


Warning:
Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-iterationSee also
Iterators and generators guide
function*
Symbol.iterator
Iterator
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLocationBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Location interface represents the location (URL) of the object it is linked to. Changes done on it are reflected on the object it relates to. Both the Document and Window interface have such a linked Location, accessible via Document.location and Window.location respectively.Location anatomyHover over the URL segments below to highlight their meaning:
<span id="href" title="href"
  ><span id="origin" title="origin"
    ><span id="protocol" title="protocol">https:</span>//<span
      id="host"
      title="host"
      ><span id="hostname" title="hostname">example.org</span>:<span
        id="port"
        title="port"
        >8080</span
      ></span
    ></span
  ><span id="pathname" title="pathname">/foo/bar</span
  ><span id="search" title="search">?q=baz</span
  ><span id="hash" title="hash">#bang</span></span
>

html {
  display: table;
  width: 100%;
}

body {
  display: table-cell;
  text-align: center;
  vertical-align: middle;
  font-family: Georgia;
  font-size: 200%;
  line-height: 1em;
  white-space: nowrap;
}

[title] {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
  line-height: 2em;
  cursor: pointer;
  color: gray;
}

[title]::before {
  content: attr(title);
  font-family: monospace;
  position: absolute;
  top: 100%;
  width: 100%;
  left: 50%;
  margin-left: -50%;
  font-size: 50%;
  line-height: 1.5;
  background: black;
}

[title]:hover::before,
:target::before {
  background: black;
  color: yellow;
}

[title] [title]::before {
  margin-top: 1.5em;
}

[title] [title] [title]::before {
  margin-top: 3em;
}

[title] [title] [title] [title]::before {
  margin-top: 4.5em;
}

[title]:hover,
:target {
  position: relative;
  z-index: 1;
  outline: 50em solid rgb(255 255 255 / 80%);
}

document.body.addEventListener("click", (event) => {
  event.preventDefault();

  window.location.hash = event.target.hasAttribute("id")
    ? `#${event.target.getAttribute("id")}`
    : "";
});

Instance properties
Location.ancestorOrigins Read only

A static DOMStringList containing, in reverse order, the origins of all ancestor browsing contexts of the document associated with the given Location object.

Location.href

A stringifier that returns a string containing the entire URL. If changed, the associated document navigates to the new page. It can be set from a different origin than the associated document.

Location.protocol

A string containing the protocol scheme of the URL, including the final ':'.

Location.host

A string containing the host, that is the hostname, a ':', and the port of the URL.

Location.hostname

A string containing the domain of the URL.

Location.port

A string containing the port number of the URL.

Location.pathname

A string containing an initial '/' followed by the path of the URL, not including the query string or fragment.

Location.search

A string containing a '?' followed by the parameters or "query string" of the URL. Modern browsers provide URLSearchParams and URL.searchParams to make it easy to parse out the parameters from the query string.

Location.hash

A string containing a '#' followed by the fragment identifier of the URL.

Location.origin Read only

Returns a string containing the canonical form of the origin of the specific location.

Instance methods
Location.assign()

Loads the resource at the URL provided in parameter.

Location.reload()

Reloads the current URL, like the Refresh button.

Location.replace()

Replaces the current resource with the one at the provided URL (redirects to the provided URL). The difference from the assign() method and setting the href property is that after using replace() the current page will not be saved in session History, meaning the user won't be able to use the back button to navigate to it.

Location.toString()

Returns a string containing the whole URL. It is a synonym for Location.href, though it can't be used to modify the value.

Examplesjs// location: https://developer.mozilla.org:8080/en-US/search?q=URL#search-results-close-container
const loc = document.location;
console.log(loc.href); // https://developer.mozilla.org:8080/en-US/search?q=URL#search-results-close-container
console.log(loc.protocol); // https:
console.log(loc.host); // developer.mozilla.org:8080
console.log(loc.hostname); // developer.mozilla.org
console.log(loc.port); // 8080
console.log(loc.pathname); // /en-US/search
console.log(loc.search); // ?q=URL
console.log(loc.hash); // #search-results-close-container
console.log(loc.origin); // https://developer.mozilla.org:8080

location.assign("http://another.site"); // load another page
SpecificationsSpecificationHTML # the-location-interfaceBrowser compatibilitySee also
Two Location properties: Window.location and Document.location.
URL manipulation interfaces: URL and URLSearchParams.\n\nLocationBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Location interface represents the location (URL) of the object it is linked to. Changes done on it are reflected on the object it relates to. Both the Document and Window interface have such a linked Location, accessible via Document.location and Window.location respectively.Location anatomyHover over the URL segments below to highlight their meaning:
<span id="href" title="href"
  ><span id="origin" title="origin"
    ><span id="protocol" title="protocol">https:</span>//<span
      id="host"
      title="host"
      ><span id="hostname" title="hostname">example.org</span>:<span
        id="port"
        title="port"
        >8080</span
      ></span
    ></span
  ><span id="pathname" title="pathname">/foo/bar</span
  ><span id="search" title="search">?q=baz</span
  ><span id="hash" title="hash">#bang</span></span
>

html {
  display: table;
  width: 100%;
}

body {
  display: table-cell;
  text-align: center;
  vertical-align: middle;
  font-family: Georgia;
  font-size: 200%;
  line-height: 1em;
  white-space: nowrap;
}

[title] {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
  line-height: 2em;
  cursor: pointer;
  color: gray;
}

[title]::before {
  content: attr(title);
  font-family: monospace;
  position: absolute;
  top: 100%;
  width: 100%;
  left: 50%;
  margin-left: -50%;
  font-size: 50%;
  line-height: 1.5;
  background: black;
}

[title]:hover::before,
:target::before {
  background: black;
  color: yellow;
}

[title] [title]::before {
  margin-top: 1.5em;
}

[title] [title] [title]::before {
  margin-top: 3em;
}

[title] [title] [title] [title]::before {
  margin-top: 4.5em;
}

[title]:hover,
:target {
  position: relative;
  z-index: 1;
  outline: 50em solid rgb(255 255 255 / 80%);
}

document.body.addEventListener("click", (event) => {
  event.preventDefault();

  window.location.hash = event.target.hasAttribute("id")
    ? `#${event.target.getAttribute("id")}`
    : "";
});

Instance properties
Location.ancestorOrigins Read only

A static DOMStringList containing, in reverse order, the origins of all ancestor browsing contexts of the document associated with the given Location object.

Location.href

A stringifier that returns a string containing the entire URL. If changed, the associated document navigates to the new page. It can be set from a different origin than the associated document.

Location.protocol

A string containing the protocol scheme of the URL, including the final ':'.

Location.host

A string containing the host, that is the hostname, a ':', and the port of the URL.

Location.hostname

A string containing the domain of the URL.

Location.port

A string containing the port number of the URL.

Location.pathname

A string containing an initial '/' followed by the path of the URL, not including the query string or fragment.

Location.search

A string containing a '?' followed by the parameters or "query string" of the URL. Modern browsers provide URLSearchParams and URL.searchParams to make it easy to parse out the parameters from the query string.

Location.hash

A string containing a '#' followed by the fragment identifier of the URL.

Location.origin Read only

Returns a string containing the canonical form of the origin of the specific location.

Instance methods
Location.assign()

Loads the resource at the URL provided in parameter.

Location.reload()

Reloads the current URL, like the Refresh button.

Location.replace()

Replaces the current resource with the one at the provided URL (redirects to the provided URL). The difference from the assign() method and setting the href property is that after using replace() the current page will not be saved in session History, meaning the user won't be able to use the back button to navigate to it.

Location.toString()

Returns a string containing the whole URL. It is a synonym for Location.href, though it can't be used to modify the value.

Examplesjs// location: https://developer.mozilla.org:8080/en-US/search?q=URL#search-results-close-container
const loc = document.location;
console.log(loc.href); // https://developer.mozilla.org:8080/en-US/search?q=URL#search-results-close-container
console.log(loc.protocol); // https:
console.log(loc.host); // developer.mozilla.org:8080
console.log(loc.hostname); // developer.mozilla.org
console.log(loc.port); // 8080
console.log(loc.pathname); // /en-US/search
console.log(loc.search); // ?q=URL
console.log(loc.hash); // #search-results-close-container
console.log(loc.origin); // https://developer.mozilla.org:8080

location.assign("http://another.site"); // load another page
SpecificationsSpecificationHTML # the-location-interfaceBrowser compatibilitySee also
Two Location properties: Window.location and Document.location.
URL manipulation interfaces: URL and URLSearchParams.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Oct 16, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLocationBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Location interface represents the location (URL) of the object it is linked to. Changes done on it are reflected on the object it relates to. Both the Document and Window interface have such a linked Location, accessible via Document.location and Window.location respectively.Location anatomyHover over the URL segments below to highlight their meaning:
<span id="href" title="href"
  ><span id="origin" title="origin"
    ><span id="protocol" title="protocol">https:</span>//<span
      id="host"
      title="host"
      ><span id="hostname" title="hostname">example.org</span>:<span
        id="port"
        title="port"
        >8080</span
      ></span
    ></span
  ><span id="pathname" title="pathname">/foo/bar</span
  ><span id="search" title="search">?q=baz</span
  ><span id="hash" title="hash">#bang</span></span
>

html {
  display: table;
  width: 100%;
}

body {
  display: table-cell;
  text-align: center;
  vertical-align: middle;
  font-family: Georgia;
  font-size: 200%;
  line-height: 1em;
  white-space: nowrap;
}

[title] {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
  line-height: 2em;
  cursor: pointer;
  color: gray;
}

[title]::before {
  content: attr(title);
  font-family: monospace;
  position: absolute;
  top: 100%;
  width: 100%;
  left: 50%;
  margin-left: -50%;
  font-size: 50%;
  line-height: 1.5;
  background: black;
}

[title]:hover::before,
:target::before {
  background: black;
  color: yellow;
}

[title] [title]::before {
  margin-top: 1.5em;
}

[title] [title] [title]::before {
  margin-top: 3em;
}

[title] [title] [title] [title]::before {
  margin-top: 4.5em;
}

[title]:hover,
:target {
  position: relative;
  z-index: 1;
  outline: 50em solid rgb(255 255 255 / 80%);
}

document.body.addEventListener("click", (event) => {
  event.preventDefault();

  window.location.hash = event.target.hasAttribute("id")
    ? `#${event.target.getAttribute("id")}`
    : "";
});

Instance properties
Location.ancestorOrigins Read only

A static DOMStringList containing, in reverse order, the origins of all ancestor browsing contexts of the document associated with the given Location object.

Location.href

A stringifier that returns a string containing the entire URL. If changed, the associated document navigates to the new page. It can be set from a different origin than the associated document.

Location.protocol

A string containing the protocol scheme of the URL, including the final ':'.

Location.host

A string containing the host, that is the hostname, a ':', and the port of the URL.

Location.hostname

A string containing the domain of the URL.

Location.port

A string containing the port number of the URL.

Location.pathname

A string containing an initial '/' followed by the path of the URL, not including the query string or fragment.

Location.search

A string containing a '?' followed by the parameters or "query string" of the URL. Modern browsers provide URLSearchParams and URL.searchParams to make it easy to parse out the parameters from the query string.

Location.hash

A string containing a '#' followed by the fragment identifier of the URL.

Location.origin Read only

Returns a string containing the canonical form of the origin of the specific location.

Instance methods
Location.assign()

Loads the resource at the URL provided in parameter.

Location.reload()

Reloads the current URL, like the Refresh button.

Location.replace()

Replaces the current resource with the one at the provided URL (redirects to the provided URL). The difference from the assign() method and setting the href property is that after using replace() the current page will not be saved in session History, meaning the user won't be able to use the back button to navigate to it.

Location.toString()

Returns a string containing the whole URL. It is a synonym for Location.href, though it can't be used to modify the value.

Examplesjs// location: https://developer.mozilla.org:8080/en-US/search?q=URL#search-results-close-container
const loc = document.location;
console.log(loc.href); // https://developer.mozilla.org:8080/en-US/search?q=URL#search-results-close-container
console.log(loc.protocol); // https:
console.log(loc.host); // developer.mozilla.org:8080
console.log(loc.hostname); // developer.mozilla.org
console.log(loc.port); // 8080
console.log(loc.pathname); // /en-US/search
console.log(loc.search); // ?q=URL
console.log(loc.hash); // #search-results-close-container
console.log(loc.origin); // https://developer.mozilla.org:8080

location.assign("http://another.site"); // load another page
SpecificationsSpecificationHTML # the-location-interfaceBrowser compatibilitySee also
Two Location properties: Window.location and Document.location.
URL manipulation interfaces: URL and URLSearchParams.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Oct 16, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nPercent-encodingPercent-encoding is a mechanism to encode 8-bit characters that have specific meaning in the context of URLs. It is sometimes called URL encoding. The encoding consists of substitution: A '%' followed by the hexadecimal representation of the ASCII value of the replace character.
Special characters needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', as well as '%' itself. Other characters don't need to be encoded, though they could.



Character
Encoding




':'
%3A


'/'
%2F


'?'
%3F


'#'
%23


'['
%5B


']'
%5D


'@'
%40


'!'
%21


'$'
%24


'&'
%26


"'"
%27


'('
%28


')'
%29


'*'
%2A


'+'
%2B


','
%2C


';'
%3B


'='
%3D


'%'
%25


' '
%20 or +



Depending on the context, the character ' ' is translated to a '+' (like in the percent-encoding version used in an application/x-www-form-urlencoded message), or in '%20' like on URLs.See also
Definition of percent-encoding in Wikipedia.
RFC 3986, section 2.1, where this encoding is defined.
encodeURI() and encodeURIComponent() — functions to percent-encode URLs\n\nPercent-encodingPercent-encoding is a mechanism to encode 8-bit characters that have specific meaning in the context of URLs. It is sometimes called URL encoding. The encoding consists of substitution: A '%' followed by the hexadecimal representation of the ASCII value of the replace character.
Special characters needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', as well as '%' itself. Other characters don't need to be encoded, though they could.



Character
Encoding




':'
%3A


'/'
%2F


'?'
%3F


'#'
%23


'['
%5B


']'
%5D


'@'
%40


'!'
%21


'$'
%24


'&'
%26


"'"
%27


'('
%28


')'
%29


'*'
%2A


'+'
%2B


','
%2C


';'
%3B


'='
%3D


'%'
%25


' '
%20 or +



Depending on the context, the character ' ' is translated to a '+' (like in the percent-encoding version used in an application/x-www-form-urlencoded message), or in '%20' like on URLs.See also
Definition of percent-encoding in Wikipedia.
RFC 3986, section 2.1, where this encoding is defined.
encodeURI() and encodeURIComponent() — functions to percent-encode URLs
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nPercent-encodingPercent-encoding is a mechanism to encode 8-bit characters that have specific meaning in the context of URLs. It is sometimes called URL encoding. The encoding consists of substitution: A '%' followed by the hexadecimal representation of the ASCII value of the replace character.
Special characters needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', as well as '%' itself. Other characters don't need to be encoded, though they could.



Character
Encoding




':'
%3A


'/'
%2F


'?'
%3F


'#'
%23


'['
%5B


']'
%5D


'@'
%40


'!'
%21


'$'
%24


'&'
%26


"'"
%27


'('
%28


')'
%29


'*'
%2A


'+'
%2B


','
%2C


';'
%3B


'='
%3D


'%'
%25


' '
%20 or +



Depending on the context, the character ' ' is translated to a '+' (like in the percent-encoding version used in an application/x-www-form-urlencoded message), or in '%20' like on URLs.See also
Definition of percent-encoding in Wikipedia.
RFC 3986, section 2.1, where this encoding is defined.
encodeURI() and encodeURIComponent() — functions to percent-encode URLs
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLexical grammarThis page describes JavaScript's lexical grammar. JavaScript source text is just a sequence of characters — in order for the interpreter to understand it, the string has to be parsed to a more structured representation. The initial step of parsing is called lexical analysis, in which the text gets scanned from left to right and is converted into a sequence of individual, atomic input elements. Some input elements are insignificant to the interpreter, and will be stripped after this step — they include white space and comments. The others, including identifiers, keywords, literals, and punctuators (mostly operators), will be used for further syntax analysis. Line terminators and multiline comments are also syntactically insignificant, but they guide the process for automatic semicolons insertion to make certain invalid token sequences become valid.Format-control charactersFormat-control characters have no visual representation but are used to control the interpretation of the text.



Code point
Name
Abbreviation
Description




U+200C
Zero width non-joiner
<ZWNJ>
Placed between characters to prevent being connected into ligatures in certain languages (Wikipedia).


U+200D
Zero width joiner
<ZWJ>
Placed between characters that would not normally be connected in order to cause the characters to be rendered using their connected form in certain languages (Wikipedia).


U+FEFF
Byte order mark
<BOM>
Used at the start of the script to mark it as Unicode and to allow detection of the text's encoding and byte order (Wikipedia).



In JavaScript source text, <ZWNJ> and <ZWJ> are treated as identifier parts, while <BOM> (also called a zero-width no-break space <ZWNBSP> when not at the start of text) is treated as white space.White spaceWhite space characters improve the readability of source text and separate tokens from each other. These characters are usually unnecessary for the functionality of the code. Minification tools are often used to remove whitespace in order to reduce the amount of data that needs to be transferred.



Code point
Name
Abbreviation
Description
Escape sequence




U+0009
Character tabulation
<TAB>
Horizontal tabulation
\t


U+000B
Line tabulation
<VT>
Vertical tabulation
\v


U+000C
Form feed
<FF>
Page breaking control character (Wikipedia).
\f


U+0020
Space
<SP>
Normal space



U+00A0
No-break space
<NBSP>
Normal space, but no point at which a line may break



U+FEFF
Zero-width no-break space
<ZWNBSP>
When not at the start of a script, the BOM marker is a normal whitespace character.



Others
Other Unicode space characters
<USP>
Characters in the "Space_Separator" general category





Note:
Of those characters with the "White_Space" property but are not in the "Space_Separator" general category, U+0009, U+000B, and U+000C are still treated as white space in JavaScript; U+0085 NEXT LINE has no special role; others become the set of line terminators.


Note:
Changes to the Unicode standard used by the JavaScript engine may affect programs' behavior. For example, ES2016 upgraded the reference Unicode standard from 5.1 to 8.0.0, which caused U+180E MONGOLIAN VOWEL SEPARATOR to be moved from the "Space_Separator" category to the "Format (Cf)" category, and made it a non-whitespace. Subsequently, the result of "\u180E".trim().length changed from 0 to 1.
Line terminatorsIn addition to white space characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of automatic semicolon insertion.
Outside the context of lexical grammar, white space and line terminators are often conflated. For example, String.prototype.trim() removes all white space and line terminators from the beginning and end of a string. The   character class escape in regular expressions matches all white space and line terminators.
Only the following Unicode code points are treated as line terminators in ECMAScript, other line breaking characters are treated as white space (for example, Next Line, NEL, U+0085 is considered as white space).



Code point
Name
Abbreviation
Description
Escape sequence




U+000A
Line Feed
<LF>
New line character in UNIX systems.
\n


U+000D
Carriage Return
<CR>
New line character in Commodore and early Mac systems.
\r


U+2028
Line Separator
<LS>
Wikipedia



U+2029
Paragraph Separator
<PS>
Wikipedia



CommentsComments are used to add hints, notes, suggestions, or warnings to JavaScript code. This can make it easier to read and understand. They can also be used to disable code to prevent it from being executed; this can be a valuable debugging tool.
JavaScript has two long-standing ways to add comments to code: line comments and block comments. In addition, there's a special hashbang comment syntax.Line commentsThe first way is the // comment; this makes all text following it on the same line into a comment. For example:
jsfunction comment() {
  // This is a one line JavaScript comment
  console.log("Hello world!");
}
comment();
Block commentsThe second way is the /* */ style, which is much more flexible.
For example, you can use it on a single line:
jsfunction comment() {
  /* This is a one line JavaScript comment */
  console.log("Hello world!");
}
comment();

You can also make multiple-line comments, like this:
jsfunction comment() {
  /* This comment spans multiple lines. Notice
     that we don't need to end the comment until we're done. */
  console.log("Hello world!");
}
comment();

You can also use it in the middle of a line, if you wish, although this can make your code harder to read so it should be used with caution:
jsfunction comment(x) {
  console.log("Hello " + x /* insert the value of x */ + " !");
}
comment("world");

In addition, you can use it to disable code to prevent it from running, by wrapping code in a comment, like this:
jsfunction comment() {
  /* console.log("Hello world!"); */
}
comment();

In this case, the console.log() call is never issued, since it's inside a comment. Any number of lines of code can be disabled this way.
Block comments that contain at least one line terminator behave like line terminators in automatic semicolon insertion.Hashbang commentsThere's a special third comment syntax, the hashbang comment. A hashbang comment behaves exactly like a single line-only (//) comment, except that it begins with #! and is only valid at the absolute start of a script or module. Note also that no whitespace of any kind is permitted before the #!. The comment consists of all the characters after #! up to the end of the first line; only one such comment is permitted.
Hashbang comments in JavaScript resemble shebangs in Unix which provide the path to a specific JavaScript interpreter that you want to use to execute the script. Before the hashbang comment became standardized, it had already been de-facto implemented in non-browser hosts like Node.js, where it was stripped from the source text before being passed to the engine. An example is as follows:
js#!/usr/bin/env node

console.log("Hello world");

The JavaScript interpreter will treat it as a normal comment — it only has semantic meaning to the shell if the script is directly run in a shell.

Warning:
If you want scripts to be runnable directly in a shell environment, encode them in UTF-8 without a BOM. Although a BOM will not cause any problems for code running in a browser — because it's stripped during UTF-8 decoding, before the source text is analyzed — a Unix/Linux shell will not recognize the hashbang if it's preceded by a BOM character.

You must only use the #! comment style to specify a JavaScript interpreter. In all other cases just use a // comment (or multiline comment).IdentifiersAn identifier is used to link a value with a name. Identifiers can be used in various places:
jsconst decl = 1; // Variable declaration (may also be `let` or `var`)
function fn() {} // Function declaration
const obj = { key: "value" }; // Object keys
// Class declaration
class C {
  #priv = "value"; // Private property
}
lbl: console.log(1); // Label

In JavaScript, identifiers are commonly made of alphanumeric characters, underscores (_), and dollar signs ($). Identifiers are not allowed to start with numbers. However, JavaScript identifiers are not only limited to ASCII — many Unicode code points are allowed as well. Namely:

Start characters can be any character in the ID_Start category plus _ and $.
After the first character, you can use any character in the ID_Continue category plus U+200C (ZWNJ) and U+200D (ZWJ).


Note:
If, for some reason, you need to parse some JavaScript source yourself, do not assume all identifiers follow the pattern /[A-Za-z_$][\w$]*/ (i.e., ASCII-only)! The range of identifiers can be described by the regex /[$_\p{ID_Start}][$\p{ID_Continue}]*/u (excluding unicode escape sequences).

In addition, JavaScript allows using Unicode escape sequences in the form of \u0000 or \u{000000} in identifiers, which encode the same string value as the actual Unicode characters. For example, 你好 and \u4f60\u597d are the same identifiers:
jsconst 你好 = "Hello";
console.log(\u4f60\u597d); // Hello

Not all places accept the full range of identifiers. Certain syntaxes, such as function declarations, function expressions, and variable declarations require using identifiers names that are not reserved words.
jsfunction import() {} // Illegal: import is a reserved word.

Most notably, private properties and object properties allow reserved words.
jsconst obj = { import: "value" }; // Legal despite `import` being reserved
class C {
  #import = "value";
}
KeywordsKeywords are tokens that look like identifiers but have special meanings in JavaScript. For example, the keyword async before a function declaration indicates that the function is asynchronous.
Some keywords are reserved, meaning that they cannot be used as an identifier for variable declarations, function declarations, etc. They are often called reserved words. A list of these reserved words is provided below. Not all keywords are reserved — for example, async can be used as an identifier anywhere. Some keywords are only contextually reserved — for example, await is only reserved within the body of an async function, and let is only reserved in strict mode code, or const and let declarations.
Identifiers are always compared by string value, so escape sequences are interpreted. For example, this is still a syntax error:
jsconst els\u{65} = 1;
// `els\u{65}` encodes the same identifier as `else`
Reserved wordsThese keywords cannot be used as identifiers for variables, functions, classes, etc. anywhere in JavaScript source.

break
case
catch
class
const
continue
debugger
default
delete
do
else
export
extends
false
finally
for
function
if
import
in
instanceof
new
null
return
super
switch
this
throw
true
try
typeof
var
void
while
with

The following are only reserved when they are found in strict mode code:

let (also reserved in const, let, and class declarations)
static
yield (also reserved in generator function bodies)

The following are only reserved when they are found in module code or async function bodies:

await
Future reserved wordsThe following are reserved as future keywords by the ECMAScript specification. They have no special functionality at present, but they might at some future time, so they cannot be used as identifiers.
These are always reserved:

enum

The following are only reserved when they are found in strict mode code:

implements
interface
package
private
protected
public

Future reserved words in older standards
The following are reserved as future keywords by older ECMAScript specifications (ECMAScript 1 till 3).

abstract
boolean
byte
char
double
final
float
goto
int
long
native
short
synchronized
throws
transient
volatile
Identifiers with special meaningsA few identifiers have a special meaning in some contexts without being reserved words of any kind. They include:

arguments (not a keyword, but cannot be declared as identifier in strict mode)
as (import * as ns from "mod")
async
eval (not a keyword, but cannot be declared as identifier in strict mode)
from (import x from "mod")
get
of
set
Literals
Note:
This section discusses literals that are atomic tokens. Object literals and array literals are expressions that consist of a series of tokens.
Null literalSee also null for more information.
jsnull
Boolean literalSee also boolean type for more information.
jstrue
false
Numeric literalsThe Number and BigInt types use numeric literals.
Decimal
js1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal

Exponential
The decimal exponential literal is specified by the following format: beN; where b is a base number (integer or floating), followed by an E or e character (which serves as separator or exponent indicator) and N, which is exponent or power number – a signed integer.
js0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000

Binary
Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). Any character after the 0b that is not 0 or 1 will terminate the literal sequence.
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607

Octal
Octal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "O" (0o or 0O). Any character after the 0o that is outside the range (01234567) will terminate the literal sequence.
js0O755 // 493
0o644 // 420

Hexadecimal
Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). Any character after the 0x that is outside the range (0123456789ABCDEF) will terminate the literal sequence.
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10

BigInt literal
The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision. BigInt literals are created by appending n to the end of an integer.
js123456789123456789n     // 123456789123456789
0o777777777777n         // 68719476735
0x123456789ABCDEFn      // 81985529216486895
0b11101001010101010101n // 955733

BigInt literals cannot start with 0 to avoid confusion with legacy octal literals.
js0755n; // SyntaxError: invalid BigInt syntax

For octal BigInt numbers, always use zero followed by the letter "o" (uppercase or lowercase):
js0o755n;

For more information about BigInt, see also JavaScript data structures.
Numeric separators
To improve readability for numeric literals, underscores (_, U+005F) can be used as separators:
js1_000_000_000_000
1_050.95
0b1010_0001_1000_0101
0o2_2_5_6
0xA0_B0_C0
1_000_000_000_000_000_000_000n

Note these limitations:
js// More than one underscore in a row is not allowed
100__000; // SyntaxError

// Not allowed at the end of numeric literals
100_; // SyntaxError

// Can not be used after leading 0
0_1; // SyntaxError
String literalsA string literal is zero or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for these code points:

U+005C \ (backslash)
U+000D <CR>
U+000A <LF>
The same kind of quote that begins the string literal

Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded.
js'foo'
"bar"

The following subsections describe various escape sequences (\ followed by one or more characters) available in string literals. Any escape sequence not listed below becomes an "identity escape" that becomes the code point itself. For example, \z is the same as z. There's a deprecated octal escape sequence syntax described in the Deprecated and obsolete features page. Many of these escape sequences are also valid in regular expressions — see Character escape.
Escape sequences
Special characters can be encoded using escape sequences:



Escape sequence
Unicode code point




\0
null character (U+0000 NULL)


\'
single quote (U+0027 APOSTROPHE)


\"
double quote (U+0022 QUOTATION MARK)


\\
backslash (U+005C REVERSE SOLIDUS)


\n
newline (U+000A LINE FEED; LF)


\r
carriage return (U+000D CARRIAGE RETURN; CR)


\v
vertical tab (U+000B LINE TABULATION)


\t
tab (U+0009 CHARACTER TABULATION)


\b
backspace (U+0008 BACKSPACE)


\f
form feed (U+000C FORM FEED)


\ followed by a line terminator
empty string



The last escape sequence, \ followed by a line terminator, is useful for splitting a string literal across multiple lines without changing its meaning.
jsconst longString =
  "This is a very long string which needs \
to wrap across multiple lines because \
otherwise my code is unreadable.";

Make sure there is no space or any other character after the backslash (except for a line break), otherwise it will not work. If the next line is indented, the extra spaces will also be present in the string's value.
You can also use the + operator to append multiple strings together, like this:
jsconst longString =
  "This is a very long string which needs " +
  "to wrap across multiple lines because " +
  "otherwise my code is unreadable.";

Both of the above methods result in identical strings.
Hexadecimal escape sequences
Hexadecimal escape sequences consist of \x followed by exactly two hexadecimal digits representing a code unit or code point in the range 0x0000 to 0x00FF.
js"\xA9"; // "©"

Unicode escape sequences
A Unicode escape sequence consists of exactly four hexadecimal digits following \u. It represents a code unit in the UTF-16 encoding. For code points U+0000 to U+FFFF, the code unit is equal to the code point. Code points U+10000 to U+10FFFF require two escape sequences representing the two code units (a surrogate pair) used to encode the character; the surrogate pair is distinct from the code point.
See also String.fromCharCode() and String.prototype.charCodeAt().
js"\u00A9"; // "©" (U+A9)

Unicode code point escapes
A Unicode code point escape consists of \u{, followed by a code point in hexadecimal base, followed by }. The value of the hexadecimal digits must be in the range 0 and 0x10FFFF inclusive. Code points in the range U+10000 to U+10FFFF do not need to be represented as a surrogate pair.
See also String.fromCodePoint() and String.prototype.codePointAt().
js"\u{2F804}"; // CJK COMPATIBILITY IDEOGRAPH-2F804 (U+2F804)

// the same character represented as a surrogate pair
"\uD87E\uDC04";
Regular expression literalsRegular expression literals are enclosed by two forward slashes (/). The lexer consumes all characters up to the next unescaped forward slash or the end of the line, unless the forward slash appears within a character class ([]). Some characters (namely, those that are identifier parts) can appear after the closing slash, denoting flags.
The lexical grammar is very lenient: not all regular expression literals that get identified as one token are valid regular expressions.
See also RegExp for more information.
js/ab+c/g;
/[/]/;

A regular expression literal cannot start with two forward slashes (//), because that would be a line comment. To specify an empty regular expression, use /(?:)/.Template literalsOne template literal consists of several tokens: `xxx${ (template head), }xxx${ (template middle), and }xxx` (template tail) are individual tokens, while any expression may come between them.
See also template literals for more information.
js`string text`;

`string text line 1
 string text line 2`;

`string text ${expression} string text`;

tag`string text ${expression} string text`;
Automatic semicolon insertionSome JavaScript statements' syntax definitions require semicolons (;) at the end. They include:

var, let, const
Expression statements
do...while
continue, break, return, throw
debugger
Class field declarations (public or private)
import, export

However, to make the language more approachable and convenient, JavaScript is able to automatically insert semicolons when consuming the token stream, so that some invalid token sequences can be "fixed" to valid syntax. This step happens after the program text has been parsed to tokens according to the lexical grammar. There are three cases when semicolons are automatically inserted:
1. When a token not allowed by the grammar is encountered, and it's separated from the previous token by at least one line terminator (including a block comment that includes at least one line terminator), or the token is "}", then a semicolon is inserted before the token.
js{ 1
2 } 3

// is transformed by ASI into:

{ 1
;2 ;} 3;

// Which is valid grammar encoding three statements,
// each consisting of a number literal

The ending ")" of do...while is taken care of as a special case by this rule as well.
jsdo {
  // …
} while (condition) /* ; */ // ASI here
const a = 1

However, semicolons are not inserted if the semicolon would then become the separator in the for statement's head.
jsfor (
  let a = 1 // No ASI here
  a < 10 // No ASI here
  a++
) {}

Semicolons are also never inserted as empty statements. For example, in the code below, if a semicolon is inserted after ")", then the code would be valid, with an empty statement as the if body and the const declaration being a separate statement. However, because automatically inserted semicolons cannot become empty statements, this causes a declaration to become the body of the if statement, which is not valid.
jsif (Math.random() > 0.5)
const x = 1 // SyntaxError: Unexpected token 'const'

2. When the end of the input stream of tokens is reached, and the parser is unable to parse the single input stream as a complete program, a semicolon is inserted at the end.
jsconst a = 1 /* ; */ // ASI here

This rule is a complement to the previous rule, specifically for the case where there's no "offending token" but the end of input stream.
3. When the grammar forbids line terminators in some place but a line terminator is found, a semicolon is inserted. These places include:

expr <here> ++, expr <here> --
continue <here> lbl
break <here> lbl
return <here> expr
throw <here> expr
yield <here> expr
yield <here> * expr
(param) <here> => {}
async <here> function, async <here> prop(), async <here> function*, async <here> *prop(), async <here> (param) <here> => {}

Here ++ is not treated as a postfix operator applying to variable b, because a line terminator occurs between b and ++.
jsa = b
++c

// is transformed by ASI into

a = b;
++c;

Here, the return statement returns undefined, and the a + b becomes an unreachable statement.
jsreturn
a + b

// is transformed by ASI into

return;
a + b;

Note that ASI would only be triggered if a line break separates tokens that would otherwise produce invalid syntax. If the next token can be parsed as part of a valid structure, semicolons would not be inserted. For example:
jsconst a = 1
(1).toString()

const b = 1
[1, 2, 3].forEach(console.log)

Because () can be seen as a function call, it would usually not trigger ASI. Similarly, [] may be a member access. The code above is equivalent to:
jsconst a = 1(1).toString();

const b = 1[1, 2, 3].forEach(console.log);

This happens to be valid syntax. 1[1, 2, 3] is a property accessor with a comma-joined expression. Therefore, you would get errors like "1 is not a function" and "Cannot read properties of undefined (reading 'forEach')" when running the code.
Within classes, class fields and generator methods can be a pitfall as well.
jsclass A {
  a = 1
  *gen() {}
}

It is seen as:
jsclass A {
  a = 1 * gen() {}
}

And therefore will be a syntax error around {.
There are the following rules-of-thumb for dealing with ASI, if you want to enforce semicolon-less style:


Write postfix ++ and -- on the same line as their operands.
jsconst a = b
++
console.log(a) // ReferenceError: Invalid left-hand side expression in prefix operation

jsconst a = b++
console.log(a)



The expressions after return, throw, or yield should be on the same line as the keyword.
jsfunction foo() {
  return
    1 + 1 // Returns undefined; 1 + 1 is ignored
}

jsfunction foo() {
  return 1 + 1
}

function foo() {
  return (
    1 + 1
  )
}



Similarly, the label identifier after break or continue should be on the same line as the keyword.
jsouterBlock: {
  innerBlock: {
    break
      outerBlock // SyntaxError: Illegal break statement
  }
}

jsouterBlock: {
  innerBlock: {
    break outerBlock
  }
}



The => of an arrow function should be on the same line as the end of its parameters.
jsconst foo = (a, b)
  => a + b

jsconst foo = (a, b) =>
  a + b



The async of async functions, methods, etc. cannot be directly followed by a line terminator.
jsasync
function foo() {}

jsasync function
foo() {}



If a line starts with one of (, [, `, +, -, / (as in regex literals), prefix it with a semicolon, or end the previous line with a semicolon.
js// The () may be merged with the previous line as a function call
(() => {
  // …
})()

// The [ may be merged with the previous line as a property access
[1, 2, 3].forEach(console.log)

// The ` may be merged with the previous line as a tagged template literal
`string text ${data}`.match(pattern).forEach(console.log)

// The + may be merged with the previous line as a binary + expression
+a.toString()

// The - may be merged with the previous line as a binary - expression
-a.toString()

// The / may be merged with the previous line as a division expression
/pattern/.exec(str).forEach(console.log)

js;(() => {
  // …
})()
;[1, 2, 3].forEach(console.log)
;`string text ${data}`.match(pattern).forEach(console.log)
;+a.toString()
;-a.toString()
;/pattern/.exec(str).forEach(console.log)



Class fields should preferably always be ended with semicolons — in addition to the previous rule (which includes a field declaration followed by a computed property, since the latter starts with [), semicolons are also required between a field declaration and a generator method.
jsclass A {
  a = 1
  [b] = 2
  *gen() {} // Seen as a = 1[b] = 2 * gen() {}
}

jsclass A {
  a = 1;
  [b] = 2;
  *gen() {}
}


SpecificationsSpecificationECMAScript® 2026 Language Specification Browser compatibilitySee also
Grammar and types guide
Micro-feature from ES6, now in Firefox Aurora and Nightly: binary and octal numbers by Jeff Walden (2013)
JavaScript character escape sequences by Mathias Bynens (2011)\n\nLexical grammarThis page describes JavaScript's lexical grammar. JavaScript source text is just a sequence of characters — in order for the interpreter to understand it, the string has to be parsed to a more structured representation. The initial step of parsing is called lexical analysis, in which the text gets scanned from left to right and is converted into a sequence of individual, atomic input elements. Some input elements are insignificant to the interpreter, and will be stripped after this step — they include white space and comments. The others, including identifiers, keywords, literals, and punctuators (mostly operators), will be used for further syntax analysis. Line terminators and multiline comments are also syntactically insignificant, but they guide the process for automatic semicolons insertion to make certain invalid token sequences become valid.Format-control charactersFormat-control characters have no visual representation but are used to control the interpretation of the text.



Code point
Name
Abbreviation
Description




U+200C
Zero width non-joiner
<ZWNJ>
Placed between characters to prevent being connected into ligatures in certain languages (Wikipedia).


U+200D
Zero width joiner
<ZWJ>
Placed between characters that would not normally be connected in order to cause the characters to be rendered using their connected form in certain languages (Wikipedia).


U+FEFF
Byte order mark
<BOM>
Used at the start of the script to mark it as Unicode and to allow detection of the text's encoding and byte order (Wikipedia).



In JavaScript source text, <ZWNJ> and <ZWJ> are treated as identifier parts, while <BOM> (also called a zero-width no-break space <ZWNBSP> when not at the start of text) is treated as white space.White spaceWhite space characters improve the readability of source text and separate tokens from each other. These characters are usually unnecessary for the functionality of the code. Minification tools are often used to remove whitespace in order to reduce the amount of data that needs to be transferred.



Code point
Name
Abbreviation
Description
Escape sequence




U+0009
Character tabulation
<TAB>
Horizontal tabulation
\t


U+000B
Line tabulation
<VT>
Vertical tabulation
\v


U+000C
Form feed
<FF>
Page breaking control character (Wikipedia).
\f


U+0020
Space
<SP>
Normal space



U+00A0
No-break space
<NBSP>
Normal space, but no point at which a line may break



U+FEFF
Zero-width no-break space
<ZWNBSP>
When not at the start of a script, the BOM marker is a normal whitespace character.



Others
Other Unicode space characters
<USP>
Characters in the "Space_Separator" general category





Note:
Of those characters with the "White_Space" property but are not in the "Space_Separator" general category, U+0009, U+000B, and U+000C are still treated as white space in JavaScript; U+0085 NEXT LINE has no special role; others become the set of line terminators.


Note:
Changes to the Unicode standard used by the JavaScript engine may affect programs' behavior. For example, ES2016 upgraded the reference Unicode standard from 5.1 to 8.0.0, which caused U+180E MONGOLIAN VOWEL SEPARATOR to be moved from the "Space_Separator" category to the "Format (Cf)" category, and made it a non-whitespace. Subsequently, the result of "\u180E".trim().length changed from 0 to 1.
Line terminatorsIn addition to white space characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of automatic semicolon insertion.
Outside the context of lexical grammar, white space and line terminators are often conflated. For example, String.prototype.trim() removes all white space and line terminators from the beginning and end of a string. The   character class escape in regular expressions matches all white space and line terminators.
Only the following Unicode code points are treated as line terminators in ECMAScript, other line breaking characters are treated as white space (for example, Next Line, NEL, U+0085 is considered as white space).



Code point
Name
Abbreviation
Description
Escape sequence




U+000A
Line Feed
<LF>
New line character in UNIX systems.
\n


U+000D
Carriage Return
<CR>
New line character in Commodore and early Mac systems.
\r


U+2028
Line Separator
<LS>
Wikipedia



U+2029
Paragraph Separator
<PS>
Wikipedia



CommentsComments are used to add hints, notes, suggestions, or warnings to JavaScript code. This can make it easier to read and understand. They can also be used to disable code to prevent it from being executed; this can be a valuable debugging tool.
JavaScript has two long-standing ways to add comments to code: line comments and block comments. In addition, there's a special hashbang comment syntax.Line commentsThe first way is the // comment; this makes all text following it on the same line into a comment. For example:
jsfunction comment() {
  // This is a one line JavaScript comment
  console.log("Hello world!");
}
comment();
Block commentsThe second way is the /* */ style, which is much more flexible.
For example, you can use it on a single line:
jsfunction comment() {
  /* This is a one line JavaScript comment */
  console.log("Hello world!");
}
comment();

You can also make multiple-line comments, like this:
jsfunction comment() {
  /* This comment spans multiple lines. Notice
     that we don't need to end the comment until we're done. */
  console.log("Hello world!");
}
comment();

You can also use it in the middle of a line, if you wish, although this can make your code harder to read so it should be used with caution:
jsfunction comment(x) {
  console.log("Hello " + x /* insert the value of x */ + " !");
}
comment("world");

In addition, you can use it to disable code to prevent it from running, by wrapping code in a comment, like this:
jsfunction comment() {
  /* console.log("Hello world!"); */
}
comment();

In this case, the console.log() call is never issued, since it's inside a comment. Any number of lines of code can be disabled this way.
Block comments that contain at least one line terminator behave like line terminators in automatic semicolon insertion.Hashbang commentsThere's a special third comment syntax, the hashbang comment. A hashbang comment behaves exactly like a single line-only (//) comment, except that it begins with #! and is only valid at the absolute start of a script or module. Note also that no whitespace of any kind is permitted before the #!. The comment consists of all the characters after #! up to the end of the first line; only one such comment is permitted.
Hashbang comments in JavaScript resemble shebangs in Unix which provide the path to a specific JavaScript interpreter that you want to use to execute the script. Before the hashbang comment became standardized, it had already been de-facto implemented in non-browser hosts like Node.js, where it was stripped from the source text before being passed to the engine. An example is as follows:
js#!/usr/bin/env node

console.log("Hello world");

The JavaScript interpreter will treat it as a normal comment — it only has semantic meaning to the shell if the script is directly run in a shell.

Warning:
If you want scripts to be runnable directly in a shell environment, encode them in UTF-8 without a BOM. Although a BOM will not cause any problems for code running in a browser — because it's stripped during UTF-8 decoding, before the source text is analyzed — a Unix/Linux shell will not recognize the hashbang if it's preceded by a BOM character.

You must only use the #! comment style to specify a JavaScript interpreter. In all other cases just use a // comment (or multiline comment).IdentifiersAn identifier is used to link a value with a name. Identifiers can be used in various places:
jsconst decl = 1; // Variable declaration (may also be `let` or `var`)
function fn() {} // Function declaration
const obj = { key: "value" }; // Object keys
// Class declaration
class C {
  #priv = "value"; // Private property
}
lbl: console.log(1); // Label

In JavaScript, identifiers are commonly made of alphanumeric characters, underscores (_), and dollar signs ($). Identifiers are not allowed to start with numbers. However, JavaScript identifiers are not only limited to ASCII — many Unicode code points are allowed as well. Namely:

Start characters can be any character in the ID_Start category plus _ and $.
After the first character, you can use any character in the ID_Continue category plus U+200C (ZWNJ) and U+200D (ZWJ).


Note:
If, for some reason, you need to parse some JavaScript source yourself, do not assume all identifiers follow the pattern /[A-Za-z_$][\w$]*/ (i.e., ASCII-only)! The range of identifiers can be described by the regex /[$_\p{ID_Start}][$\p{ID_Continue}]*/u (excluding unicode escape sequences).

In addition, JavaScript allows using Unicode escape sequences in the form of \u0000 or \u{000000} in identifiers, which encode the same string value as the actual Unicode characters. For example, 你好 and \u4f60\u597d are the same identifiers:
jsconst 你好 = "Hello";
console.log(\u4f60\u597d); // Hello

Not all places accept the full range of identifiers. Certain syntaxes, such as function declarations, function expressions, and variable declarations require using identifiers names that are not reserved words.
jsfunction import() {} // Illegal: import is a reserved word.

Most notably, private properties and object properties allow reserved words.
jsconst obj = { import: "value" }; // Legal despite `import` being reserved
class C {
  #import = "value";
}
KeywordsKeywords are tokens that look like identifiers but have special meanings in JavaScript. For example, the keyword async before a function declaration indicates that the function is asynchronous.
Some keywords are reserved, meaning that they cannot be used as an identifier for variable declarations, function declarations, etc. They are often called reserved words. A list of these reserved words is provided below. Not all keywords are reserved — for example, async can be used as an identifier anywhere. Some keywords are only contextually reserved — for example, await is only reserved within the body of an async function, and let is only reserved in strict mode code, or const and let declarations.
Identifiers are always compared by string value, so escape sequences are interpreted. For example, this is still a syntax error:
jsconst els\u{65} = 1;
// `els\u{65}` encodes the same identifier as `else`
Reserved wordsThese keywords cannot be used as identifiers for variables, functions, classes, etc. anywhere in JavaScript source.

break
case
catch
class
const
continue
debugger
default
delete
do
else
export
extends
false
finally
for
function
if
import
in
instanceof
new
null
return
super
switch
this
throw
true
try
typeof
var
void
while
with

The following are only reserved when they are found in strict mode code:

let (also reserved in const, let, and class declarations)
static
yield (also reserved in generator function bodies)

The following are only reserved when they are found in module code or async function bodies:

await
Future reserved wordsThe following are reserved as future keywords by the ECMAScript specification. They have no special functionality at present, but they might at some future time, so they cannot be used as identifiers.
These are always reserved:

enum

The following are only reserved when they are found in strict mode code:

implements
interface
package
private
protected
public

Future reserved words in older standards
The following are reserved as future keywords by older ECMAScript specifications (ECMAScript 1 till 3).

abstract
boolean
byte
char
double
final
float
goto
int
long
native
short
synchronized
throws
transient
volatile
Identifiers with special meaningsA few identifiers have a special meaning in some contexts without being reserved words of any kind. They include:

arguments (not a keyword, but cannot be declared as identifier in strict mode)
as (import * as ns from "mod")
async
eval (not a keyword, but cannot be declared as identifier in strict mode)
from (import x from "mod")
get
of
set
Literals
Note:
This section discusses literals that are atomic tokens. Object literals and array literals are expressions that consist of a series of tokens.
Null literalSee also null for more information.
jsnull
Boolean literalSee also boolean type for more information.
jstrue
false
Numeric literalsThe Number and BigInt types use numeric literals.
Decimal
js1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal

Exponential
The decimal exponential literal is specified by the following format: beN; where b is a base number (integer or floating), followed by an E or e character (which serves as separator or exponent indicator) and N, which is exponent or power number – a signed integer.
js0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000

Binary
Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). Any character after the 0b that is not 0 or 1 will terminate the literal sequence.
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607

Octal
Octal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "O" (0o or 0O). Any character after the 0o that is outside the range (01234567) will terminate the literal sequence.
js0O755 // 493
0o644 // 420

Hexadecimal
Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). Any character after the 0x that is outside the range (0123456789ABCDEF) will terminate the literal sequence.
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10

BigInt literal
The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision. BigInt literals are created by appending n to the end of an integer.
js123456789123456789n     // 123456789123456789
0o777777777777n         // 68719476735
0x123456789ABCDEFn      // 81985529216486895
0b11101001010101010101n // 955733

BigInt literals cannot start with 0 to avoid confusion with legacy octal literals.
js0755n; // SyntaxError: invalid BigInt syntax

For octal BigInt numbers, always use zero followed by the letter "o" (uppercase or lowercase):
js0o755n;

For more information about BigInt, see also JavaScript data structures.
Numeric separators
To improve readability for numeric literals, underscores (_, U+005F) can be used as separators:
js1_000_000_000_000
1_050.95
0b1010_0001_1000_0101
0o2_2_5_6
0xA0_B0_C0
1_000_000_000_000_000_000_000n

Note these limitations:
js// More than one underscore in a row is not allowed
100__000; // SyntaxError

// Not allowed at the end of numeric literals
100_; // SyntaxError

// Can not be used after leading 0
0_1; // SyntaxError
String literalsA string literal is zero or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for these code points:

U+005C \ (backslash)
U+000D <CR>
U+000A <LF>
The same kind of quote that begins the string literal

Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded.
js'foo'
"bar"

The following subsections describe various escape sequences (\ followed by one or more characters) available in string literals. Any escape sequence not listed below becomes an "identity escape" that becomes the code point itself. For example, \z is the same as z. There's a deprecated octal escape sequence syntax described in the Deprecated and obsolete features page. Many of these escape sequences are also valid in regular expressions — see Character escape.
Escape sequences
Special characters can be encoded using escape sequences:



Escape sequence
Unicode code point




\0
null character (U+0000 NULL)


\'
single quote (U+0027 APOSTROPHE)


\"
double quote (U+0022 QUOTATION MARK)


\\
backslash (U+005C REVERSE SOLIDUS)


\n
newline (U+000A LINE FEED; LF)


\r
carriage return (U+000D CARRIAGE RETURN; CR)


\v
vertical tab (U+000B LINE TABULATION)


\t
tab (U+0009 CHARACTER TABULATION)


\b
backspace (U+0008 BACKSPACE)


\f
form feed (U+000C FORM FEED)


\ followed by a line terminator
empty string



The last escape sequence, \ followed by a line terminator, is useful for splitting a string literal across multiple lines without changing its meaning.
jsconst longString =
  "This is a very long string which needs \
to wrap across multiple lines because \
otherwise my code is unreadable.";

Make sure there is no space or any other character after the backslash (except for a line break), otherwise it will not work. If the next line is indented, the extra spaces will also be present in the string's value.
You can also use the + operator to append multiple strings together, like this:
jsconst longString =
  "This is a very long string which needs " +
  "to wrap across multiple lines because " +
  "otherwise my code is unreadable.";

Both of the above methods result in identical strings.
Hexadecimal escape sequences
Hexadecimal escape sequences consist of \x followed by exactly two hexadecimal digits representing a code unit or code point in the range 0x0000 to 0x00FF.
js"\xA9"; // "©"

Unicode escape sequences
A Unicode escape sequence consists of exactly four hexadecimal digits following \u. It represents a code unit in the UTF-16 encoding. For code points U+0000 to U+FFFF, the code unit is equal to the code point. Code points U+10000 to U+10FFFF require two escape sequences representing the two code units (a surrogate pair) used to encode the character; the surrogate pair is distinct from the code point.
See also String.fromCharCode() and String.prototype.charCodeAt().
js"\u00A9"; // "©" (U+A9)

Unicode code point escapes
A Unicode code point escape consists of \u{, followed by a code point in hexadecimal base, followed by }. The value of the hexadecimal digits must be in the range 0 and 0x10FFFF inclusive. Code points in the range U+10000 to U+10FFFF do not need to be represented as a surrogate pair.
See also String.fromCodePoint() and String.prototype.codePointAt().
js"\u{2F804}"; // CJK COMPATIBILITY IDEOGRAPH-2F804 (U+2F804)

// the same character represented as a surrogate pair
"\uD87E\uDC04";
Regular expression literalsRegular expression literals are enclosed by two forward slashes (/). The lexer consumes all characters up to the next unescaped forward slash or the end of the line, unless the forward slash appears within a character class ([]). Some characters (namely, those that are identifier parts) can appear after the closing slash, denoting flags.
The lexical grammar is very lenient: not all regular expression literals that get identified as one token are valid regular expressions.
See also RegExp for more information.
js/ab+c/g;
/[/]/;

A regular expression literal cannot start with two forward slashes (//), because that would be a line comment. To specify an empty regular expression, use /(?:)/.Template literalsOne template literal consists of several tokens: `xxx${ (template head), }xxx${ (template middle), and }xxx` (template tail) are individual tokens, while any expression may come between them.
See also template literals for more information.
js`string text`;

`string text line 1
 string text line 2`;

`string text ${expression} string text`;

tag`string text ${expression} string text`;
Automatic semicolon insertionSome JavaScript statements' syntax definitions require semicolons (;) at the end. They include:

var, let, const
Expression statements
do...while
continue, break, return, throw
debugger
Class field declarations (public or private)
import, export

However, to make the language more approachable and convenient, JavaScript is able to automatically insert semicolons when consuming the token stream, so that some invalid token sequences can be "fixed" to valid syntax. This step happens after the program text has been parsed to tokens according to the lexical grammar. There are three cases when semicolons are automatically inserted:
1. When a token not allowed by the grammar is encountered, and it's separated from the previous token by at least one line terminator (including a block comment that includes at least one line terminator), or the token is "}", then a semicolon is inserted before the token.
js{ 1
2 } 3

// is transformed by ASI into:

{ 1
;2 ;} 3;

// Which is valid grammar encoding three statements,
// each consisting of a number literal

The ending ")" of do...while is taken care of as a special case by this rule as well.
jsdo {
  // …
} while (condition) /* ; */ // ASI here
const a = 1

However, semicolons are not inserted if the semicolon would then become the separator in the for statement's head.
jsfor (
  let a = 1 // No ASI here
  a < 10 // No ASI here
  a++
) {}

Semicolons are also never inserted as empty statements. For example, in the code below, if a semicolon is inserted after ")", then the code would be valid, with an empty statement as the if body and the const declaration being a separate statement. However, because automatically inserted semicolons cannot become empty statements, this causes a declaration to become the body of the if statement, which is not valid.
jsif (Math.random() > 0.5)
const x = 1 // SyntaxError: Unexpected token 'const'

2. When the end of the input stream of tokens is reached, and the parser is unable to parse the single input stream as a complete program, a semicolon is inserted at the end.
jsconst a = 1 /* ; */ // ASI here

This rule is a complement to the previous rule, specifically for the case where there's no "offending token" but the end of input stream.
3. When the grammar forbids line terminators in some place but a line terminator is found, a semicolon is inserted. These places include:

expr <here> ++, expr <here> --
continue <here> lbl
break <here> lbl
return <here> expr
throw <here> expr
yield <here> expr
yield <here> * expr
(param) <here> => {}
async <here> function, async <here> prop(), async <here> function*, async <here> *prop(), async <here> (param) <here> => {}

Here ++ is not treated as a postfix operator applying to variable b, because a line terminator occurs between b and ++.
jsa = b
++c

// is transformed by ASI into

a = b;
++c;

Here, the return statement returns undefined, and the a + b becomes an unreachable statement.
jsreturn
a + b

// is transformed by ASI into

return;
a + b;

Note that ASI would only be triggered if a line break separates tokens that would otherwise produce invalid syntax. If the next token can be parsed as part of a valid structure, semicolons would not be inserted. For example:
jsconst a = 1
(1).toString()

const b = 1
[1, 2, 3].forEach(console.log)

Because () can be seen as a function call, it would usually not trigger ASI. Similarly, [] may be a member access. The code above is equivalent to:
jsconst a = 1(1).toString();

const b = 1[1, 2, 3].forEach(console.log);

This happens to be valid syntax. 1[1, 2, 3] is a property accessor with a comma-joined expression. Therefore, you would get errors like "1 is not a function" and "Cannot read properties of undefined (reading 'forEach')" when running the code.
Within classes, class fields and generator methods can be a pitfall as well.
jsclass A {
  a = 1
  *gen() {}
}

It is seen as:
jsclass A {
  a = 1 * gen() {}
}

And therefore will be a syntax error around {.
There are the following rules-of-thumb for dealing with ASI, if you want to enforce semicolon-less style:


Write postfix ++ and -- on the same line as their operands.
jsconst a = b
++
console.log(a) // ReferenceError: Invalid left-hand side expression in prefix operation

jsconst a = b++
console.log(a)



The expressions after return, throw, or yield should be on the same line as the keyword.
jsfunction foo() {
  return
    1 + 1 // Returns undefined; 1 + 1 is ignored
}

jsfunction foo() {
  return 1 + 1
}

function foo() {
  return (
    1 + 1
  )
}



Similarly, the label identifier after break or continue should be on the same line as the keyword.
jsouterBlock: {
  innerBlock: {
    break
      outerBlock // SyntaxError: Illegal break statement
  }
}

jsouterBlock: {
  innerBlock: {
    break outerBlock
  }
}



The => of an arrow function should be on the same line as the end of its parameters.
jsconst foo = (a, b)
  => a + b

jsconst foo = (a, b) =>
  a + b



The async of async functions, methods, etc. cannot be directly followed by a line terminator.
jsasync
function foo() {}

jsasync function
foo() {}



If a line starts with one of (, [, `, +, -, / (as in regex literals), prefix it with a semicolon, or end the previous line with a semicolon.
js// The () may be merged with the previous line as a function call
(() => {
  // …
})()

// The [ may be merged with the previous line as a property access
[1, 2, 3].forEach(console.log)

// The ` may be merged with the previous line as a tagged template literal
`string text ${data}`.match(pattern).forEach(console.log)

// The + may be merged with the previous line as a binary + expression
+a.toString()

// The - may be merged with the previous line as a binary - expression
-a.toString()

// The / may be merged with the previous line as a division expression
/pattern/.exec(str).forEach(console.log)

js;(() => {
  // …
})()
;[1, 2, 3].forEach(console.log)
;`string text ${data}`.match(pattern).forEach(console.log)
;+a.toString()
;-a.toString()
;/pattern/.exec(str).forEach(console.log)



Class fields should preferably always be ended with semicolons — in addition to the previous rule (which includes a field declaration followed by a computed property, since the latter starts with [), semicolons are also required between a field declaration and a generator method.
jsclass A {
  a = 1
  [b] = 2
  *gen() {} // Seen as a = 1[b] = 2 * gen() {}
}

jsclass A {
  a = 1;
  [b] = 2;
  *gen() {}
}


SpecificationsSpecificationECMAScript® 2026 Language Specification Browser compatibilitySee also
Grammar and types guide
Micro-feature from ES6, now in Firefox Aurora and Nightly: binary and octal numbers by Jeff Walden (2013)
JavaScript character escape sequences by Mathias Bynens (2011)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLexical grammarThis page describes JavaScript's lexical grammar. JavaScript source text is just a sequence of characters — in order for the interpreter to understand it, the string has to be parsed to a more structured representation. The initial step of parsing is called lexical analysis, in which the text gets scanned from left to right and is converted into a sequence of individual, atomic input elements. Some input elements are insignificant to the interpreter, and will be stripped after this step — they include white space and comments. The others, including identifiers, keywords, literals, and punctuators (mostly operators), will be used for further syntax analysis. Line terminators and multiline comments are also syntactically insignificant, but they guide the process for automatic semicolons insertion to make certain invalid token sequences become valid.Format-control charactersFormat-control characters have no visual representation but are used to control the interpretation of the text.



Code point
Name
Abbreviation
Description




U+200C
Zero width non-joiner
<ZWNJ>
Placed between characters to prevent being connected into ligatures in certain languages (Wikipedia).


U+200D
Zero width joiner
<ZWJ>
Placed between characters that would not normally be connected in order to cause the characters to be rendered using their connected form in certain languages (Wikipedia).


U+FEFF
Byte order mark
<BOM>
Used at the start of the script to mark it as Unicode and to allow detection of the text's encoding and byte order (Wikipedia).



In JavaScript source text, <ZWNJ> and <ZWJ> are treated as identifier parts, while <BOM> (also called a zero-width no-break space <ZWNBSP> when not at the start of text) is treated as white space.White spaceWhite space characters improve the readability of source text and separate tokens from each other. These characters are usually unnecessary for the functionality of the code. Minification tools are often used to remove whitespace in order to reduce the amount of data that needs to be transferred.



Code point
Name
Abbreviation
Description
Escape sequence




U+0009
Character tabulation
<TAB>
Horizontal tabulation
\t


U+000B
Line tabulation
<VT>
Vertical tabulation
\v


U+000C
Form feed
<FF>
Page breaking control character (Wikipedia).
\f


U+0020
Space
<SP>
Normal space



U+00A0
No-break space
<NBSP>
Normal space, but no point at which a line may break



U+FEFF
Zero-width no-break space
<ZWNBSP>
When not at the start of a script, the BOM marker is a normal whitespace character.



Others
Other Unicode space characters
<USP>
Characters in the "Space_Separator" general category





Note:
Of those characters with the "White_Space" property but are not in the "Space_Separator" general category, U+0009, U+000B, and U+000C are still treated as white space in JavaScript; U+0085 NEXT LINE has no special role; others become the set of line terminators.


Note:
Changes to the Unicode standard used by the JavaScript engine may affect programs' behavior. For example, ES2016 upgraded the reference Unicode standard from 5.1 to 8.0.0, which caused U+180E MONGOLIAN VOWEL SEPARATOR to be moved from the "Space_Separator" category to the "Format (Cf)" category, and made it a non-whitespace. Subsequently, the result of "\u180E".trim().length changed from 0 to 1.
Line terminatorsIn addition to white space characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of automatic semicolon insertion.
Outside the context of lexical grammar, white space and line terminators are often conflated. For example, String.prototype.trim() removes all white space and line terminators from the beginning and end of a string. The   character class escape in regular expressions matches all white space and line terminators.
Only the following Unicode code points are treated as line terminators in ECMAScript, other line breaking characters are treated as white space (for example, Next Line, NEL, U+0085 is considered as white space).



Code point
Name
Abbreviation
Description
Escape sequence




U+000A
Line Feed
<LF>
New line character in UNIX systems.
\n


U+000D
Carriage Return
<CR>
New line character in Commodore and early Mac systems.
\r


U+2028
Line Separator
<LS>
Wikipedia



U+2029
Paragraph Separator
<PS>
Wikipedia



CommentsComments are used to add hints, notes, suggestions, or warnings to JavaScript code. This can make it easier to read and understand. They can also be used to disable code to prevent it from being executed; this can be a valuable debugging tool.
JavaScript has two long-standing ways to add comments to code: line comments and block comments. In addition, there's a special hashbang comment syntax.Line commentsThe first way is the // comment; this makes all text following it on the same line into a comment. For example:
jsfunction comment() {
  // This is a one line JavaScript comment
  console.log("Hello world!");
}
comment();
Block commentsThe second way is the /* */ style, which is much more flexible.
For example, you can use it on a single line:
jsfunction comment() {
  /* This is a one line JavaScript comment */
  console.log("Hello world!");
}
comment();

You can also make multiple-line comments, like this:
jsfunction comment() {
  /* This comment spans multiple lines. Notice
     that we don't need to end the comment until we're done. */
  console.log("Hello world!");
}
comment();

You can also use it in the middle of a line, if you wish, although this can make your code harder to read so it should be used with caution:
jsfunction comment(x) {
  console.log("Hello " + x /* insert the value of x */ + " !");
}
comment("world");

In addition, you can use it to disable code to prevent it from running, by wrapping code in a comment, like this:
jsfunction comment() {
  /* console.log("Hello world!"); */
}
comment();

In this case, the console.log() call is never issued, since it's inside a comment. Any number of lines of code can be disabled this way.
Block comments that contain at least one line terminator behave like line terminators in automatic semicolon insertion.Hashbang commentsThere's a special third comment syntax, the hashbang comment. A hashbang comment behaves exactly like a single line-only (//) comment, except that it begins with #! and is only valid at the absolute start of a script or module. Note also that no whitespace of any kind is permitted before the #!. The comment consists of all the characters after #! up to the end of the first line; only one such comment is permitted.
Hashbang comments in JavaScript resemble shebangs in Unix which provide the path to a specific JavaScript interpreter that you want to use to execute the script. Before the hashbang comment became standardized, it had already been de-facto implemented in non-browser hosts like Node.js, where it was stripped from the source text before being passed to the engine. An example is as follows:
js#!/usr/bin/env node

console.log("Hello world");

The JavaScript interpreter will treat it as a normal comment — it only has semantic meaning to the shell if the script is directly run in a shell.

Warning:
If you want scripts to be runnable directly in a shell environment, encode them in UTF-8 without a BOM. Although a BOM will not cause any problems for code running in a browser — because it's stripped during UTF-8 decoding, before the source text is analyzed — a Unix/Linux shell will not recognize the hashbang if it's preceded by a BOM character.

You must only use the #! comment style to specify a JavaScript interpreter. In all other cases just use a // comment (or multiline comment).IdentifiersAn identifier is used to link a value with a name. Identifiers can be used in various places:
jsconst decl = 1; // Variable declaration (may also be `let` or `var`)
function fn() {} // Function declaration
const obj = { key: "value" }; // Object keys
// Class declaration
class C {
  #priv = "value"; // Private property
}
lbl: console.log(1); // Label

In JavaScript, identifiers are commonly made of alphanumeric characters, underscores (_), and dollar signs ($). Identifiers are not allowed to start with numbers. However, JavaScript identifiers are not only limited to ASCII — many Unicode code points are allowed as well. Namely:

Start characters can be any character in the ID_Start category plus _ and $.
After the first character, you can use any character in the ID_Continue category plus U+200C (ZWNJ) and U+200D (ZWJ).


Note:
If, for some reason, you need to parse some JavaScript source yourself, do not assume all identifiers follow the pattern /[A-Za-z_$][\w$]*/ (i.e., ASCII-only)! The range of identifiers can be described by the regex /[$_\p{ID_Start}][$\p{ID_Continue}]*/u (excluding unicode escape sequences).

In addition, JavaScript allows using Unicode escape sequences in the form of \u0000 or \u{000000} in identifiers, which encode the same string value as the actual Unicode characters. For example, 你好 and \u4f60\u597d are the same identifiers:
jsconst 你好 = "Hello";
console.log(\u4f60\u597d); // Hello

Not all places accept the full range of identifiers. Certain syntaxes, such as function declarations, function expressions, and variable declarations require using identifiers names that are not reserved words.
jsfunction import() {} // Illegal: import is a reserved word.

Most notably, private properties and object properties allow reserved words.
jsconst obj = { import: "value" }; // Legal despite `import` being reserved
class C {
  #import = "value";
}
KeywordsKeywords are tokens that look like identifiers but have special meanings in JavaScript. For example, the keyword async before a function declaration indicates that the function is asynchronous.
Some keywords are reserved, meaning that they cannot be used as an identifier for variable declarations, function declarations, etc. They are often called reserved words. A list of these reserved words is provided below. Not all keywords are reserved — for example, async can be used as an identifier anywhere. Some keywords are only contextually reserved — for example, await is only reserved within the body of an async function, and let is only reserved in strict mode code, or const and let declarations.
Identifiers are always compared by string value, so escape sequences are interpreted. For example, this is still a syntax error:
jsconst els\u{65} = 1;
// `els\u{65}` encodes the same identifier as `else`
Reserved wordsThese keywords cannot be used as identifiers for variables, functions, classes, etc. anywhere in JavaScript source.

break
case
catch
class
const
continue
debugger
default
delete
do
else
export
extends
false
finally
for
function
if
import
in
instanceof
new
null
return
super
switch
this
throw
true
try
typeof
var
void
while
with

The following are only reserved when they are found in strict mode code:

let (also reserved in const, let, and class declarations)
static
yield (also reserved in generator function bodies)

The following are only reserved when they are found in module code or async function bodies:

await
Future reserved wordsThe following are reserved as future keywords by the ECMAScript specification. They have no special functionality at present, but they might at some future time, so they cannot be used as identifiers.
These are always reserved:

enum

The following are only reserved when they are found in strict mode code:

implements
interface
package
private
protected
public

Future reserved words in older standards
The following are reserved as future keywords by older ECMAScript specifications (ECMAScript 1 till 3).

abstract
boolean
byte
char
double
final
float
goto
int
long
native
short
synchronized
throws
transient
volatile
Identifiers with special meaningsA few identifiers have a special meaning in some contexts without being reserved words of any kind. They include:

arguments (not a keyword, but cannot be declared as identifier in strict mode)
as (import * as ns from "mod")
async
eval (not a keyword, but cannot be declared as identifier in strict mode)
from (import x from "mod")
get
of
set
Literals
Note:
This section discusses literals that are atomic tokens. Object literals and array literals are expressions that consist of a series of tokens.
Null literalSee also null for more information.
jsnull
Boolean literalSee also boolean type for more information.
jstrue
false
Numeric literalsThe Number and BigInt types use numeric literals.
Decimal
js1234567890
42

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the 0o prefix instead.
js0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal

Exponential
The decimal exponential literal is specified by the following format: beN; where b is a base number (integer or floating), followed by an E or e character (which serves as separator or exponent indicator) and N, which is exponent or power number – a signed integer.
js0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000

Binary
Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). Any character after the 0b that is not 0 or 1 will terminate the literal sequence.
js0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607

Octal
Octal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "O" (0o or 0O). Any character after the 0o that is outside the range (01234567) will terminate the literal sequence.
js0O755 // 493
0o644 // 420

Hexadecimal
Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). Any character after the 0x that is outside the range (0123456789ABCDEF) will terminate the literal sequence.
js0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10

BigInt literal
The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision. BigInt literals are created by appending n to the end of an integer.
js123456789123456789n     // 123456789123456789
0o777777777777n         // 68719476735
0x123456789ABCDEFn      // 81985529216486895
0b11101001010101010101n // 955733

BigInt literals cannot start with 0 to avoid confusion with legacy octal literals.
js0755n; // SyntaxError: invalid BigInt syntax

For octal BigInt numbers, always use zero followed by the letter "o" (uppercase or lowercase):
js0o755n;

For more information about BigInt, see also JavaScript data structures.
Numeric separators
To improve readability for numeric literals, underscores (_, U+005F) can be used as separators:
js1_000_000_000_000
1_050.95
0b1010_0001_1000_0101
0o2_2_5_6
0xA0_B0_C0
1_000_000_000_000_000_000_000n

Note these limitations:
js// More than one underscore in a row is not allowed
100__000; // SyntaxError

// Not allowed at the end of numeric literals
100_; // SyntaxError

// Can not be used after leading 0
0_1; // SyntaxError
String literalsA string literal is zero or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for these code points:

U+005C \ (backslash)
U+000D <CR>
U+000A <LF>
The same kind of quote that begins the string literal

Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded.
js'foo'
"bar"

The following subsections describe various escape sequences (\ followed by one or more characters) available in string literals. Any escape sequence not listed below becomes an "identity escape" that becomes the code point itself. For example, \z is the same as z. There's a deprecated octal escape sequence syntax described in the Deprecated and obsolete features page. Many of these escape sequences are also valid in regular expressions — see Character escape.
Escape sequences
Special characters can be encoded using escape sequences:



Escape sequence
Unicode code point




\0
null character (U+0000 NULL)


\'
single quote (U+0027 APOSTROPHE)


\"
double quote (U+0022 QUOTATION MARK)


\\
backslash (U+005C REVERSE SOLIDUS)


\n
newline (U+000A LINE FEED; LF)


\r
carriage return (U+000D CARRIAGE RETURN; CR)


\v
vertical tab (U+000B LINE TABULATION)


\t
tab (U+0009 CHARACTER TABULATION)


\b
backspace (U+0008 BACKSPACE)


\f
form feed (U+000C FORM FEED)


\ followed by a line terminator
empty string



The last escape sequence, \ followed by a line terminator, is useful for splitting a string literal across multiple lines without changing its meaning.
jsconst longString =
  "This is a very long string which needs \
to wrap across multiple lines because \
otherwise my code is unreadable.";

Make sure there is no space or any other character after the backslash (except for a line break), otherwise it will not work. If the next line is indented, the extra spaces will also be present in the string's value.
You can also use the + operator to append multiple strings together, like this:
jsconst longString =
  "This is a very long string which needs " +
  "to wrap across multiple lines because " +
  "otherwise my code is unreadable.";

Both of the above methods result in identical strings.
Hexadecimal escape sequences
Hexadecimal escape sequences consist of \x followed by exactly two hexadecimal digits representing a code unit or code point in the range 0x0000 to 0x00FF.
js"\xA9"; // "©"

Unicode escape sequences
A Unicode escape sequence consists of exactly four hexadecimal digits following \u. It represents a code unit in the UTF-16 encoding. For code points U+0000 to U+FFFF, the code unit is equal to the code point. Code points U+10000 to U+10FFFF require two escape sequences representing the two code units (a surrogate pair) used to encode the character; the surrogate pair is distinct from the code point.
See also String.fromCharCode() and String.prototype.charCodeAt().
js"\u00A9"; // "©" (U+A9)

Unicode code point escapes
A Unicode code point escape consists of \u{, followed by a code point in hexadecimal base, followed by }. The value of the hexadecimal digits must be in the range 0 and 0x10FFFF inclusive. Code points in the range U+10000 to U+10FFFF do not need to be represented as a surrogate pair.
See also String.fromCodePoint() and String.prototype.codePointAt().
js"\u{2F804}"; // CJK COMPATIBILITY IDEOGRAPH-2F804 (U+2F804)

// the same character represented as a surrogate pair
"\uD87E\uDC04";
Regular expression literalsRegular expression literals are enclosed by two forward slashes (/). The lexer consumes all characters up to the next unescaped forward slash or the end of the line, unless the forward slash appears within a character class ([]). Some characters (namely, those that are identifier parts) can appear after the closing slash, denoting flags.
The lexical grammar is very lenient: not all regular expression literals that get identified as one token are valid regular expressions.
See also RegExp for more information.
js/ab+c/g;
/[/]/;

A regular expression literal cannot start with two forward slashes (//), because that would be a line comment. To specify an empty regular expression, use /(?:)/.Template literalsOne template literal consists of several tokens: `xxx${ (template head), }xxx${ (template middle), and }xxx` (template tail) are individual tokens, while any expression may come between them.
See also template literals for more information.
js`string text`;

`string text line 1
 string text line 2`;

`string text ${expression} string text`;

tag`string text ${expression} string text`;
Automatic semicolon insertionSome JavaScript statements' syntax definitions require semicolons (;) at the end. They include:

var, let, const
Expression statements
do...while
continue, break, return, throw
debugger
Class field declarations (public or private)
import, export

However, to make the language more approachable and convenient, JavaScript is able to automatically insert semicolons when consuming the token stream, so that some invalid token sequences can be "fixed" to valid syntax. This step happens after the program text has been parsed to tokens according to the lexical grammar. There are three cases when semicolons are automatically inserted:
1. When a token not allowed by the grammar is encountered, and it's separated from the previous token by at least one line terminator (including a block comment that includes at least one line terminator), or the token is "}", then a semicolon is inserted before the token.
js{ 1
2 } 3

// is transformed by ASI into:

{ 1
;2 ;} 3;

// Which is valid grammar encoding three statements,
// each consisting of a number literal

The ending ")" of do...while is taken care of as a special case by this rule as well.
jsdo {
  // …
} while (condition) /* ; */ // ASI here
const a = 1

However, semicolons are not inserted if the semicolon would then become the separator in the for statement's head.
jsfor (
  let a = 1 // No ASI here
  a < 10 // No ASI here
  a++
) {}

Semicolons are also never inserted as empty statements. For example, in the code below, if a semicolon is inserted after ")", then the code would be valid, with an empty statement as the if body and the const declaration being a separate statement. However, because automatically inserted semicolons cannot become empty statements, this causes a declaration to become the body of the if statement, which is not valid.
jsif (Math.random() > 0.5)
const x = 1 // SyntaxError: Unexpected token 'const'

2. When the end of the input stream of tokens is reached, and the parser is unable to parse the single input stream as a complete program, a semicolon is inserted at the end.
jsconst a = 1 /* ; */ // ASI here

This rule is a complement to the previous rule, specifically for the case where there's no "offending token" but the end of input stream.
3. When the grammar forbids line terminators in some place but a line terminator is found, a semicolon is inserted. These places include:

expr <here> ++, expr <here> --
continue <here> lbl
break <here> lbl
return <here> expr
throw <here> expr
yield <here> expr
yield <here> * expr
(param) <here> => {}
async <here> function, async <here> prop(), async <here> function*, async <here> *prop(), async <here> (param) <here> => {}

Here ++ is not treated as a postfix operator applying to variable b, because a line terminator occurs between b and ++.
jsa = b
++c

// is transformed by ASI into

a = b;
++c;

Here, the return statement returns undefined, and the a + b becomes an unreachable statement.
jsreturn
a + b

// is transformed by ASI into

return;
a + b;

Note that ASI would only be triggered if a line break separates tokens that would otherwise produce invalid syntax. If the next token can be parsed as part of a valid structure, semicolons would not be inserted. For example:
jsconst a = 1
(1).toString()

const b = 1
[1, 2, 3].forEach(console.log)

Because () can be seen as a function call, it would usually not trigger ASI. Similarly, [] may be a member access. The code above is equivalent to:
jsconst a = 1(1).toString();

const b = 1[1, 2, 3].forEach(console.log);

This happens to be valid syntax. 1[1, 2, 3] is a property accessor with a comma-joined expression. Therefore, you would get errors like "1 is not a function" and "Cannot read properties of undefined (reading 'forEach')" when running the code.
Within classes, class fields and generator methods can be a pitfall as well.
jsclass A {
  a = 1
  *gen() {}
}

It is seen as:
jsclass A {
  a = 1 * gen() {}
}

And therefore will be a syntax error around {.
There are the following rules-of-thumb for dealing with ASI, if you want to enforce semicolon-less style:


Write postfix ++ and -- on the same line as their operands.
jsconst a = b
++
console.log(a) // ReferenceError: Invalid left-hand side expression in prefix operation

jsconst a = b++
console.log(a)



The expressions after return, throw, or yield should be on the same line as the keyword.
jsfunction foo() {
  return
    1 + 1 // Returns undefined; 1 + 1 is ignored
}

jsfunction foo() {
  return 1 + 1
}

function foo() {
  return (
    1 + 1
  )
}



Similarly, the label identifier after break or continue should be on the same line as the keyword.
jsouterBlock: {
  innerBlock: {
    break
      outerBlock // SyntaxError: Illegal break statement
  }
}

jsouterBlock: {
  innerBlock: {
    break outerBlock
  }
}



The => of an arrow function should be on the same line as the end of its parameters.
jsconst foo = (a, b)
  => a + b

jsconst foo = (a, b) =>
  a + b



The async of async functions, methods, etc. cannot be directly followed by a line terminator.
jsasync
function foo() {}

jsasync function
foo() {}



If a line starts with one of (, [, `, +, -, / (as in regex literals), prefix it with a semicolon, or end the previous line with a semicolon.
js// The () may be merged with the previous line as a function call
(() => {
  // …
})()

// The [ may be merged with the previous line as a property access
[1, 2, 3].forEach(console.log)

// The ` may be merged with the previous line as a tagged template literal
`string text ${data}`.match(pattern).forEach(console.log)

// The + may be merged with the previous line as a binary + expression
+a.toString()

// The - may be merged with the previous line as a binary - expression
-a.toString()

// The / may be merged with the previous line as a division expression
/pattern/.exec(str).forEach(console.log)

js;(() => {
  // …
})()
;[1, 2, 3].forEach(console.log)
;`string text ${data}`.match(pattern).forEach(console.log)
;+a.toString()
;-a.toString()
;/pattern/.exec(str).forEach(console.log)



Class fields should preferably always be ended with semicolons — in addition to the previous rule (which includes a field declaration followed by a computed property, since the latter starts with [), semicolons are also required between a field declaration and a generator method.
jsclass A {
  a = 1
  [b] = 2
  *gen() {} // Seen as a = 1[b] = 2 * gen() {}
}

jsclass A {
  a = 1;
  [b] = 2;
  *gen() {}
}


SpecificationsSpecificationECMAScript® 2026 Language Specification Browser compatibilitySee also
Grammar and types guide
Micro-feature from ES6, now in Firefox Aurora and Nightly: binary and octal numbers by Jeff Walden (2013)
JavaScript character escape sequences by Mathias Bynens (2011)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURL: searchParams propertyBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The searchParams read-only property of the
URL interface returns a URLSearchParams object allowing
access to the GET decoded query arguments contained in the URL.ValueA URLSearchParams object.ExamplesBasic usagejsconst params = new URL("https://example.com/?name=Jonathan%20Smith&age=18")
  .searchParams;
const name = params.get("name");
const age = parseInt(params.get("age"));

console.log(`name: ${name}`); // name: Jonathan Smith
console.log(`age: ${age}`); // age: 18
Interaction with searchThe searchParams property exposes the URL.search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
SpecificationsSpecificationURL # dom-url-searchparamsBrowser compatibility\n\nURL: searchParams propertyBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The searchParams read-only property of the
URL interface returns a URLSearchParams object allowing
access to the GET decoded query arguments contained in the URL.ValueA URLSearchParams object.ExamplesBasic usagejsconst params = new URL("https://example.com/?name=Jonathan%20Smith&age=18")
  .searchParams;
const name = params.get("name");
const age = parseInt(params.get("age"));

console.log(`name: ${name}`); // name: Jonathan Smith
console.log(`age: ${age}`); // age: 18
Interaction with searchThe searchParams property exposes the URL.search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
SpecificationsSpecificationURL # dom-url-searchparamsBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURL: searchParams propertyBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The searchParams read-only property of the
URL interface returns a URLSearchParams object allowing
access to the GET decoded query arguments contained in the URL.ValueA URLSearchParams object.ExamplesBasic usagejsconst params = new URL("https://example.com/?name=Jonathan%20Smith&age=18")
  .searchParams;
const name = params.get("name");
const age = parseInt(params.get("age"));

console.log(`name: ${name}`); // name: Jonathan Smith
console.log(`age: ${age}`); // age: 18
Interaction with searchThe searchParams property exposes the URL.search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
SpecificationsSpecificationURL # dom-url-searchparamsBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 2, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURL: search propertyBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The search property of the URL interface is a search string, also called a query string, that is a string containing a "?" followed by the parameters of the URL. If the URL does not have a search query, this property contains an empty string, "".
This property can be set to change the query string of the URL. When setting, a single "?" prefix is added to the provided value, if not already present. Setting it to "" removes the query string.
The query is percent-encoded when setting but not percent-decoded when reading.
Modern browsers provide the URL.searchParams property to make it easy to
parse out the parameters from the query string.ValueA string.ExamplesBasic usagejsconst url = new URL(
  "https://developer.mozilla.org/en-US/docs/Web/API/URL/search?q=123",
);
console.log(url.search); // Logs "?q=123"
Interaction with searchParamsThe URL.searchParams property exposes the search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
SpecificationsSpecificationURL # dom-url-searchBrowser compatibilitySee also
The URL interface it belongs to.\n\nURL: search propertyBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The search property of the URL interface is a search string, also called a query string, that is a string containing a "?" followed by the parameters of the URL. If the URL does not have a search query, this property contains an empty string, "".
This property can be set to change the query string of the URL. When setting, a single "?" prefix is added to the provided value, if not already present. Setting it to "" removes the query string.
The query is percent-encoded when setting but not percent-decoded when reading.
Modern browsers provide the URL.searchParams property to make it easy to
parse out the parameters from the query string.ValueA string.ExamplesBasic usagejsconst url = new URL(
  "https://developer.mozilla.org/en-US/docs/Web/API/URL/search?q=123",
);
console.log(url.search); // Logs "?q=123"
Interaction with searchParamsThe URL.searchParams property exposes the search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
SpecificationsSpecificationURL # dom-url-searchBrowser compatibilitySee also
The URL interface it belongs to.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURL: search propertyBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since September 2016.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The search property of the URL interface is a search string, also called a query string, that is a string containing a "?" followed by the parameters of the URL. If the URL does not have a search query, this property contains an empty string, "".
This property can be set to change the query string of the URL. When setting, a single "?" prefix is added to the provided value, if not already present. Setting it to "" removes the query string.
The query is percent-encoded when setting but not percent-decoded when reading.
Modern browsers provide the URL.searchParams property to make it easy to
parse out the parameters from the query string.ValueA string.ExamplesBasic usagejsconst url = new URL(
  "https://developer.mozilla.org/en-US/docs/Web/API/URL/search?q=123",
);
console.log(url.search); // Logs "?q=123"
Interaction with searchParamsThe URL.searchParams property exposes the search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
SpecificationsSpecificationURL # dom-url-searchBrowser compatibilitySee also
The URL interface it belongs to.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURLSearchParamsBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The URLSearchParams interface defines utility methods to work with the query string of a URL.
URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent:
jsfor (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}

Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented.Constructor
URLSearchParams()

Returns a URLSearchParams object instance.

Instance properties
size Read only

Indicates the total number of search parameter entries.

Instance methods
URLSearchParams[Symbol.iterator]()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.append()

Appends a specified key/value pair as a new search parameter.

URLSearchParams.delete()

Deletes search parameters that match a name, and optional value, from the list of all search parameters.

URLSearchParams.entries()

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string.

URLSearchParams.forEach()

Allows iteration through all values contained in this object via a callback function.

URLSearchParams.get()

Returns the first value associated with the given search parameter.

URLSearchParams.getAll()

Returns all the values associated with a given search parameter.

URLSearchParams.has()

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists.

URLSearchParams.keys()

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object.

URLSearchParams.set()

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted.

URLSearchParams.sort()

Sorts all key/value pairs, if any, by their keys.

URLSearchParams.toString()

Returns a string containing a query string suitable for use in a URL.

URLSearchParams.values()

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object.

ExamplesUsing URLSearchParamsjsconst paramsString = "q=URLUtils.searchParams&topic=api";
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has("topic")); // true
console.log(searchParams.has("topic", "fish")); // false
console.log(searchParams.get("topic") === "api"); // true
console.log(searchParams.getAll("topic")); // ["api"]
console.log(searchParams.get("foo") === null); // true
console.log(searchParams.append("topic", "webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=api&topic=webdev"
console.log(searchParams.set("topic", "More webdev"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams&topic=More+webdev"
console.log(searchParams.delete("topic"));
console.log(searchParams.toString()); // "q=URLUtils.searchParams"

Search parameters can also be an object.
jsconst paramsObj = { foo: "bar", baz: "bar" };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // "foo=bar&baz=bar"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // "bar"
Parsing window.locationUnlike URL, the Location interface does not provide a readily-available searchParams property. We can parse location.search with URLSearchParams.
js// Assume page has location:
// https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams?foo=a
const paramsString = window.location.search;
const searchParams = new URLSearchParams(paramsString);
console.log(searchParams.get("foo")); // a
Duplicate search parametersjsconst paramStr = "foo=bar&foo=baz";
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // "foo=bar&foo=baz"
console.log(searchParams.has("foo")); // true
console.log(searchParams.get("foo")); // bar, only returns the first value
console.log(searchParams.getAll("foo")); // ["bar", "baz"]
No URL parsingThe URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present.
jsconst paramsString1 = "http://example.com/search?query=%40";
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has("query")); // false
console.log(searchParams1.has("http://example.com/search?query")); // true

console.log(searchParams1.get("query")); // null
console.log(searchParams1.get("http://example.com/search?query")); // "@" (equivalent to decodeURIComponent('%40'))

const paramsString2 = "?query=value";
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has("query")); // true

const url = new URL("http://example.com/search?query=%40");
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has("query")); // true
Percent encodingURLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +. However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version.
js// Creation from parsing a string: percent-encoding is decoded
const params = new URLSearchParams("%24%25%26=%28%29%2B");
// Retrieving all keys/values: only decoded values are returned
console.log([...params]); // [["$%&", "()+"]]
// Getting an individual value: use the decoded key and get the decoded value
console.log(params.get("$%&")); // "()+"
console.log(params.get("%24%25%26")); // null
// Setting an individual value: use the unencoded key and value
params.append("$%&$#@+", "$#&*@#()+");
// Serializing: percent-encoding is applied
console.log(params.toString());
// "%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B"

If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.
jsconst params = new URLSearchParams();

params.append("%24%26", "value");
params.toString(); // "%2524%2526=value"
Preserving plus signsThe URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by btoa() contains + and isn't preserved by URLSearchParams.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A'
const binQuery = searchParams.get("bin"); // 'E AXQB A', '+' is replaced by spaces

console.log(atob(binQuery) === rawData); // false

Never construct URLSearchParams objects using dynamically interpolated strings. Instead, use the append() method, which as mentioned above, interprets all characters as-is.
jsconst rawData = "\x13à\x17@\x1F\x80";
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append("bin", base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get("bin"); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
Interaction with URL.searchParamsThe URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization. However, URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently.
jsconst url = new URL("https://example.com/?a=b ~");
console.log(url.href); // "https://example.com/?a=b%20~"
console.log(url.searchParams.toString()); // "a=b+%7E"
// This should be a no-op, but it changes the URL's query to the
// serialization of its searchParams
url.searchParams.sort();
console.log(url.href); // "https://example.com/?a=b+%7E"

const url2 = new URL("https://example.com?search=1234&param=my%20param");
console.log(url2.search); // "?search=1234&param=my%20param"
url2.searchParams.delete("search");
console.log(url2.search); // "?param=my+param"
Empty value vs. no valueURLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether.
jsconst emptyVal = new URLSearchParams("foo=&bar=baz");
console.log(emptyVal.get("foo")); // returns ''
const noEquals = new URLSearchParams("foo&bar=baz");
console.log(noEquals.get("foo")); // also returns ''
console.log(noEquals.toString()); // 'foo=&bar=baz'
SpecificationsSpecificationURL # urlsearchparamsBrowser compatibilitySee also
Polyfill of URLSearchParams in core-js
The URL interface.
Google Developers: Easy URL manipulation with URLSearchParams
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 26, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\n\n\n\n\n\n\n\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.

If you want to suggest new documentation or ways to improve the website, see Proposing new content or features.Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.

If you want to suggest new documentation or ways to improve the website, see Proposing new content or features.Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.

If you want to suggest new documentation or ways to improve the website, see Proposing new content or features.Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs
Christine Belzie https://github.com/CBID2
Yash Raj Bharti https://github.com/yashrajbharti Liquid Galaxy

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs
Christine Belzie https://github.com/CBID2
Yash Raj Bharti https://github.com/yashrajbharti Liquid Galaxy

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\n\n\n\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skill set for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org5 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org7 months agoRecent contributionstypomdn/content21 hours agoadd "default value"mdn/content18 hours agoFix content issuesmdn/content15 hours agofix(workflows): disable cache in privileged workflowsmdn/content13 hours agoBump lefthook from 1.11.12 to 1.11.13mdn/content10 hours ago[ja] sync translated contentmdn/translated-content9 hours agofix(workflows): disable cache in privileged workflowsmdn/translated-content8 hours agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\n\n\nJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy ControlPrevious Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\nIn this articleWhat is JavaScript Temporal?Core conceptsTemporal examplesTrying Temporal and browser supportAcknowledgementsSee alsoJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\nJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\n\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loadingPrevious Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\nIn this article2024 MDN content areasMathMLManifest (web app manifests)Other 2024 content highlights on MDNKicking off 2025MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\nMDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\n\n\nA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projectsPrevious Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\nIn this articleOverview of learning material on MDNDeveloping the MDN curriculumWhy the update?The new state of learning material on MDNWhat's next for learners on MDNSummaryA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\nA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\n\n\nIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer jobPrevious Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\nIn this articleWhat's new for the MDN Community?Want to start contributing to MDN?Join the conversationLicensing and reuseIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\nIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\n\n\nContributor profile@yashrajbhartiHi! I'm Yash, a UXE and a Senior Mentor of the Liquid Galaxy, where I work on GIS applications, making immersive data viz projects on Google Maps, Street View, and Earth. Liquid Galaxy is a Google-founded open-source project and was my primary reason for falling in love with open-source. I work on the web with HTML, CSS, and JS, and I believe that honing strong basics can make even the most complex tasks easy.
I still remember my first contribution to MDN. I was so proud of myself. Even though the fix was small, the cheer from Will Bamberg at the time meant a lot. It was for PWA docs, where I corrected that the iTunes value associated with the App Store for platform members of related apps has been dropped since it's currently not supported by Safari.
Since then, I have been lurking to find a way to contribute to MDN. I also contributed to web.dev to learn more. I am not new to MDN, W3C, or web.dev (HTML5Rocks), and have been learning like a nerd for the last 9 years, but a couple of years back, I started finally contributing. I felt like helping the community, making explainers, and I worked alongside people like Adam Argyle on a CSS motion blur proposal and Thomas Steiner (Project Fugu). I discovered, that when I put my passion and heart into something, I can achieve it. The grit to solve challenges isn't new to me.
My work at Liquid Galaxy, documentation, and creating an innovative UX to control Google Earth using Google Maps led me to get invited as a Speaker to Google, CA, USA, which was my first time outside India. I got to speak at Talks at Google, and most importantly, to network! I met Kristi Progri who was previously a Mozilla Representative, and I thought "that's so cool, I read MDN every day" and I was confident that I could get involved, too.
After an incredible journey to Google, knowing the roots of the Liquid Galaxy from 2008, I was mesmerized and was full of energy to do something, so I went to MDN and saw some small bugs like buttontext details, where I met Estelle Weyl (and I'm so thankful I did, as I had all the passion and pure knowledge waiting to test the waters). They helped me with the contributions by stating how buttontext for accessibility reasons will be fixed by filing a bug in WebKit. After some PRs like this, I mailed them asking to create an issue about the <model> tag. They told me it's still a WIP but there are some Baseline 'Widely Available' PRs I can contribute to. They trusted me, created a Google Sheet, and gave me edit access. And I delivered. The rest is history, I found my chance and took it, I knew Estelle because I had read her book on CSS, and was amazed to work alongside her on this. This sheet holds value to me and is the most up-to-date record of the work we are doing.
I love it because just think about how many future developers can be helped with it, those who truly learn like me and do not rely on crash courses to just get it "done". I thank Estelle for my journey and I want to stay in this community and help make MDN the library, a well-organized library I know it as, where you just know where each book is.Yash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.How did you start using MDN?I started just like others, but using it as a source of learning, from those little tooltips that say "MDN reference" in VS Code, all the way to contributing and making the docs correct, wherever I can find a way to contribute, to hopefully be a part of it.What do you like about MDN?I like that it has all the implementation knowledge needed. When documenting, what I truly got to know from Will was, we are not just paraphrasing W3C specs, we are building it with an abstraction keeping in mind developers (and UXEs like me too) are our end users.Why do you contribute to Open Source or MDN?Anything open source is where we can ask "why should we not contribute"? There's all the reasons in the world to help and let everyone prosper, and that's what I love, whether it's for Google or Mozilla.What do you enjoy about contributing to MDN?I loved making DOMQuad as I was learning first hand and I believe I will become an encyclopedia as a by-product of helping others! That's rad.\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensible\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensibleHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensibleHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 1월 19일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 1월 19일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

Web 開發者指南提供實用教學，幫助你實際使用 Web 技術來達成你的目標或需求。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述 Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

Web 開發者指南提供實用教學，幫助你實際使用 Web 技術來達成你的目標或需求。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述 Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年5月6日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

Web 開發者指南提供實用教學，幫助你實際使用 Web 技術來達成你的目標或需求。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述 Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年5月6日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
TutorialsThe MathML tutorials are designed to walk you through topics assuming that you have no prior experience, starting from the basics and progressing to more advanced techniques.

MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

GuidesThe MathML guides are resources that help you author MathML on your web pages, including guidance on writing, editors, fonts and more.

Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

ReferenceThe MathML reference is a comprehensive list of MathML elements and attributes that are documented on MDN.

MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibility\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
TutorialsThe MathML tutorials are designed to walk you through topics assuming that you have no prior experience, starting from the basics and progressing to more advanced techniques.

MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

GuidesThe MathML guides are resources that help you author MathML on your web pages, including guidance on writing, editors, fonts and more.

Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

ReferenceThe MathML reference is a comprehensive list of MathML elements and attributes that are documented on MDN.

MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
TutorialsThe MathML tutorials are designed to walk you through topics assuming that you have no prior experience, starting from the basics and progressing to more advanced techniques.

MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

GuidesThe MathML guides are resources that help you author MathML on your web pages, including guidance on writing, editors, fonts and more.

Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

ReferenceThe MathML reference is a comprehensive list of MathML elements and attributes that are documented on MDN.

MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.GuidesThe Media guides are resources that help you understand, transform, and optimize media on the web, including audio, video, and images using modern web technologies.

Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThe following HTML elements are used for including media on a page.

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.GuidesThe Media guides are resources that help you understand, transform, and optimize media on the web, including audio, video, and images using modern web technologies.

Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThe following HTML elements are used for including media on a page.

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.GuidesThe Media guides are resources that help you understand, transform, and optimize media on the web, including audio, video, and images using modern web technologies.

Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThe following HTML elements are used for including media on a page.

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.TutorialsThe SVG tutorials are designed to walk you through subjects assuming that you have no prior experience, starting from the basics and progressing to more advanced techniques.

Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

GuidesThe SVG guides help you work with SVG on the web, covering topics such as embedding, MIME (media) types, handling scripts, animations, filters, and more.

Applying SVG effects to HTML content

Modern browsers support using SVG within CSS styles to apply graphical effects to HTML content.

Content type

SVG makes use of a number of data types. This article lists these types along with their syntax and descriptions of what they're used for.

Namespaces crash course

Namespaces are essential to user agents that support multiple XML dialects.
Browsers must be very strict; taking the time to understand namespaces now will save you from future headaches.

Scripting

There are several ways to create an manipulate SVG using JavaScript.
This document describes event handling, interactivity and working with embedded SVG content.

SVG animation with SMIL

SMIL is an XML-based language for writing interactive multimedia presentations.
Authors can use SMIL syntax in SVG to define the timing and layout of elements for animation.

SVG as an image

SVG can be used as an image format in HTML, CSS, certain SVG elements, and via the Canvas API.
This page lists the features where you can provide SVG as an image source.

SVG filters

SVG supports filters so authors can apply effects such as a shadow or blur, or even merge the results of different filters.

SVG in HTML introduction

This article shows how to use inline SVG and includes examples for illustration.

ReferenceThe SVG reference documentation contains comprehensive information about elements, attributes, and DOM interfaces, and lists relevant specifications and standards documents.

SVG elements

The SVG elements used to construct, draw, and layout vector graphics.

SVG attributes

The SVG attributes available that can be used to specify how an element should be handled or rendered.

SVG DOM interface

The SVG DOM API for interacting with SVG using JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.TutorialsThe SVG tutorials are designed to walk you through subjects assuming that you have no prior experience, starting from the basics and progressing to more advanced techniques.

Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

GuidesThe SVG guides help you work with SVG on the web, covering topics such as embedding, MIME (media) types, handling scripts, animations, filters, and more.

Applying SVG effects to HTML content

Modern browsers support using SVG within CSS styles to apply graphical effects to HTML content.

Content type

SVG makes use of a number of data types. This article lists these types along with their syntax and descriptions of what they're used for.

Namespaces crash course

Namespaces are essential to user agents that support multiple XML dialects.
Browsers must be very strict; taking the time to understand namespaces now will save you from future headaches.

Scripting

There are several ways to create an manipulate SVG using JavaScript.
This document describes event handling, interactivity and working with embedded SVG content.

SVG animation with SMIL

SMIL is an XML-based language for writing interactive multimedia presentations.
Authors can use SMIL syntax in SVG to define the timing and layout of elements for animation.

SVG as an image

SVG can be used as an image format in HTML, CSS, certain SVG elements, and via the Canvas API.
This page lists the features where you can provide SVG as an image source.

SVG filters

SVG supports filters so authors can apply effects such as a shadow or blur, or even merge the results of different filters.

SVG in HTML introduction

This article shows how to use inline SVG and includes examples for illustration.

ReferenceThe SVG reference documentation contains comprehensive information about elements, attributes, and DOM interfaces, and lists relevant specifications and standards documents.

SVG elements

The SVG elements used to construct, draw, and layout vector graphics.

SVG attributes

The SVG attributes available that can be used to specify how an element should be handled or rendered.

SVG DOM interface

The SVG DOM API for interacting with SVG using JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.TutorialsThe SVG tutorials are designed to walk you through subjects assuming that you have no prior experience, starting from the basics and progressing to more advanced techniques.

Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

GuidesThe SVG guides help you work with SVG on the web, covering topics such as embedding, MIME (media) types, handling scripts, animations, filters, and more.

Applying SVG effects to HTML content

Modern browsers support using SVG within CSS styles to apply graphical effects to HTML content.

Content type

SVG makes use of a number of data types. This article lists these types along with their syntax and descriptions of what they're used for.

Namespaces crash course

Namespaces are essential to user agents that support multiple XML dialects.
Browsers must be very strict; taking the time to understand namespaces now will save you from future headaches.

Scripting

There are several ways to create an manipulate SVG using JavaScript.
This document describes event handling, interactivity and working with embedded SVG content.

SVG animation with SMIL

SMIL is an XML-based language for writing interactive multimedia presentations.
Authors can use SMIL syntax in SVG to define the timing and layout of elements for animation.

SVG as an image

SVG can be used as an image format in HTML, CSS, certain SVG elements, and via the Canvas API.
This page lists the features where you can provide SVG as an image source.

SVG filters

SVG supports filters so authors can apply effects such as a shadow or blur, or even merge the results of different filters.

SVG in HTML introduction

This article shows how to use inline SVG and includes examples for illustration.

ReferenceThe SVG reference documentation contains comprehensive information about elements, attributes, and DOM interfaces, and lists relevant specifications and standards documents.

SVG elements

The SVG elements used to construct, draw, and layout vector graphics.

SVG attributes

The SVG attributes available that can be used to specify how an element should be handled or rendered.

SVG DOM interface

The SVG DOM API for interacting with SVG using JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.ReferenceThe URI reference provides details about the components that make up a URI.

Schemes

The first part of the URI, before the : character, which indicates the protocol the browser must use to fetch the resource.

Authority

The section that comes after the scheme and before the path.
It may have up to three parts: user information, host, and port.

Path

The section after the authority.
Contains data, usually organized in hierarchical form, to identify a resource within the scope of the URI's scheme and authority.

Fragment

An optional part at the end of a URI starting with a # character.
It is used to identify a specific part of the resource, such as a section of a document or a position in a video.

GuidesThe URI guides help you work with URIs on the web.

Choosing between www and non-www URLs

Guidance on when sites should use a www. prefix in URLs (www.example.com vs example.com).

SpecificationsSpecificationUnknown specification See also
What is a URL?\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.ReferenceThe URI reference provides details about the components that make up a URI.

Schemes

The first part of the URI, before the : character, which indicates the protocol the browser must use to fetch the resource.

Authority

The section that comes after the scheme and before the path.
It may have up to three parts: user information, host, and port.

Path

The section after the authority.
Contains data, usually organized in hierarchical form, to identify a resource within the scope of the URI's scheme and authority.

Fragment

An optional part at the end of a URI starting with a # character.
It is used to identify a specific part of the resource, such as a section of a document or a position in a video.

GuidesThe URI guides help you work with URIs on the web.

Choosing between www and non-www URLs

Guidance on when sites should use a www. prefix in URLs (www.example.com vs example.com).

SpecificationsSpecificationUnknown specification See also
What is a URL?
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.ReferenceThe URI reference provides details about the components that make up a URI.

Schemes

The first part of the URI, before the : character, which indicates the protocol the browser must use to fetch the resource.

Authority

The section that comes after the scheme and before the path.
It may have up to three parts: user information, host, and port.

Path

The section after the authority.
Contains data, usually organized in hierarchical form, to identify a resource within the scope of the URI's scheme and authority.

Fragment

An optional part at the end of a URI starting with a # character.
It is used to identify a specific part of the resource, such as a section of a document or a position in a video.

GuidesThe URI guides help you work with URIs on the web.

Choosing between www and non-www URLs

Guidance on when sites should use a www. prefix in URLs (www.example.com vs example.com).

SpecificationsSpecificationUnknown specification See also
What is a URL?
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guidesThe Performance guides are resources that describe how browsers work, what affects performance, and how to measure, optimize, and monitor performance across various aspects of your application.

Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guidesThe Performance guides are resources that describe how browsers work, what affects performance, and how to measure, optimize, and monitor performance across various aspects of your application.

Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guidesThe Performance guides are resources that describe how browsers work, what affects performance, and how to measure, optimize, and monitor performance across various aspects of your application.

Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on May 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT organized into modules that provide functions for performing transformations on an XML document.
To use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function.XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT organized into modules that provide functions for performing transformations on an XML document.
To use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function.XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT organized into modules that provide functions for performing transformations on an XML document.
To use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function.XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n