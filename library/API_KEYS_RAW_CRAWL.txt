API Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Development forEveryone
                    
                        Simplify your API development with our open‑source and professional tools, built to help
                        you and your
                        team efficiently design and document APIs at scale.
                    
                    
                        Find your
                            tool
                        Read the
                            docs
                    

                    
                        Trusted by
                    
                        
                        
                        
                    
                
                
                        
                
            
        
    

    
    
    
        
            Features
            
                Scale your API with confidence
        
        
            
                

                
                    Design

                
                    Design and model APIs according to specification-based standards.
            
            
                

                
                    Test

                Ensure API quality with scalable, automated testing.
            
            
                

                
                    Document

                Improve developer
                    experience with interactive
                    API documentation.
            
        
    
    


    

    
        Empowering API
            Development

        
            Streamline your workflow with unparalleled API specification support
        
            
                
                    
                        
                            API Specifications
                            
                        
                        
                            
                                Swagger places API specifications such as OpenAPI, AsyncAPI, and JSON
                                    Schema at the core of its architecture, which are crucial for guiding teams through
                                    the entire lifecycle of API design and documentation. This strategic focus ensures
                                    that our suite, including open source tools and API Hub, delivers unparalleled
                                    efficiency and a seamless user experience.
                                Explore the API Specifications
                                            
                                
                            
                        
                    
                    
                        
                            Swagger Open Source Tools
                            
                        
                        
                            
                                Discover the power of Swagger’s open source tools, built upon the core of
                                    API specifications and in collaboration with the community, which offer a rich set
                                    of features that address the unique challenges of API design and development. These
                                    open source offerings include:
                                Swagger Editor
                                Craft your APIs directly in your browser with real-time feedback and
                                    syntax auto-completion. 
                                Swagger UI
                                Visualize and interact with the API's resources without having any of the
                                    implementation logic in place. 
                                Swagger Codegen
                                Generate client libraries, server stubs, and API documentation from an
                                    OpenAPI Specification. 
                                Explore Open Source Tools
                                            
                                
                            
                        
                    
                    
                        
                            API Hub
                            
                        
                        
                            
                                API Hub is built for teams of all sizes, integrating the core
                                    functionality of Swagger open source tools with advanced capabilities to support
                                    teamwork, enterprise API development and API discoverability.
                                Standards & Governance
                                Enforce consistent API design standards across your organization to
                                    simplify development and ensure compliance.
                                Team Collaboration
                                Streamline your API development with role-based access controls and
                                    sophisticated collaboration tools.
                                Effortless Integration
                                Deploy directly to popular API gateways, version control systems,
                                    webhooks, and more, ensuring your APIs are ready to scale.
                                Discover API Hub
                                            
                                
                            
                        
                    
                
            
            
                
                
                
            
        
    

    
    
        
            
                
                    
                        
                            

                            
                                SmartBear Named a Leader by Gartner® in the 2024 Magic
                                    Quadrant™ for API Management
                            
                        

                        Learn More
                        
                    

                
            
        
    

    
    
        
            
                
            
            
                
                    Swagger and OpenAPI go hand‑in‑hand.
                Swagger offers powerful and easy
                    to use tools to take full advantage of the OpenAPI
                    Specification. See how we do it 
            
        
    

    
    
        
        
        
        
        
            
            
                SmartBear is committed to open source development.
                Create more with us.
            Learn More\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nGet More 
From Your APIsFind, govern, and collaborate on APIs faster than ever - powered by Swagger, Spectral, and Pact.Start Free TrialLearn more  SmartBear Named a Leader by Gartner® in the 2024 Magic Quadrant™ for API ManagementLearn More    Design with API HubFrom code-first to API-first: Collaborate and standardize on API design, built on open standards and powerful integrations that support your workflow, wherever it starts.Learn more Enhance team collaborationAPI Design for Everyone: Empower cross-functional teams with a visual, code-optional editor, making it easier for non-technical users to contribute to API design from the start.One API Catalog, One Source Of Truth: Organize and manage all your API descriptions in a centralized catalog that promotes consistency, reuse, and discoverability across teams.Faster Feedback Loops: Accelerate reviews with in-line commenting on API descriptions, streamlining team input and enabling quicker iteration.Ensure high-quality, consistent APIsEnforce Standards With Ease: Apply pre-built templates and style guides to drive consistency, reusability, and faster API delivery.Work Across Multiple Specifications: Support both OpenAPI and AsyncAPI to accommodate a wide range of API styles and architectural patterns.Build Once, Reuse Everywhere: Standardize core components like data models, parameters, and headers to reduce duplication and accelerate development.Simplify your workflowSeamless Integrations: Connect with version control systems, CI/CD pipelines, and API gateways.Flexible Export Options: Export designs in multiple formats to meet development needs.Automated Mock APIs: Generate mock servers instantly to test endpoints without manual setup.Portal with API HubCreate a customizable portal that makes APIs easy to discover, accelerates onboarding with clear documentation, and delivers an experience that drives adoption and engagement.Learn more Productize APIs for accelerated consumptionControl API Visibility: Decide whether to expose your APIs publicly or restrict them to authorized users—ensuring the right level of access for every use case.Centralize And Simplify Documentation: Consolidate all your API assets in a single, searchable portal for better discoverability, version control, and lifecycle management.Improve Developer Experience: Provide intuitive guides and actionable resources to simplify onboarding and accelerate integration.Enhance discoverabilityBranded API Portal: Customize the portal to reflect your brand, providing a cohesive experience.Centralized API Catalog: Organize and showcase all your APIs in one accessible location.Search and Filter: Allow users to easily find APIs and endpoints relevant to their needs.Streamline API documentation and access controlAssign Roles And Permissions: Tailor access and editing rights across your team to simplify documentation workflows and maintain governance.Flexible Rendering Options: Choose between multiple documentation formats—like Swagger UI or markdown-style rendering—to suit both internal and external audiences.Unified API Documentation: Consolidate all your API specs and related content in one portal to improve discoverability, reduce context switching, and keep consumers aligned.
                        
                        
                            “API Hub for Portal is promising to be a game changer for our onboarding process and developer experience. The use of the product concept to describe different parts of our system, combined with seamless integration with other API Hub products, means that developers have a one stop shop to get all the latest API information alongside visually appealing up to date documentation.”
                        
                        
                        —Senior Tech & Developer Experience Lead, Webio
                        Read more
                        
                        
                            “With the entire suite of SmartBear tools in play, we are improving release quality and receiving positive customer feedback.”
                        
                        
                        —Head of Delivery, Triquestra
                        Read more
                        
                        
                            “We can easily standardize the API design and achieve the level of quality we expect, more efficiently and more easily.”
                        
                        
                        —Industry Standards Manager, IATA
                        Read more
                        
                        
                            “Adding API Hub for Contract Testing to our test automation strategy gives the team the confidence to move forward when they see validation between the provider and consumer."”
                        
                        
                        —Head of Test Engineering, M1 FinanceContract Testing with API HubReplace your flaky and time-consuming end-to-end tests with fast, simple and reliable contract tests. Find and fix integration issues before you commit code, instead of in production.Learn more Deploy with confidenceProactive Validation: Catch breaking changes early by validating API contracts throughout development, reducing production risks.Bulletproof Pipelines: Orchestrate complex CI and CD pipelines and use can-i-deploy to tell you when a component is safe to release.Protocol Versatility: Validate APIs across HTTP, Kafka, and more, ensuring broad compatibility and real-world readiness.Say goodbye to painful release processesScalable Workflows: The bi-directional contract testing workflow makes it simple for new teams to get started.Reduced Complexity: Remove the need for complex, costly and hard-to-manage integration test environments.AI-Driven Reliability: Use HaloAI to automate test generation and maintenance, keeping tests in sync with evolving APIs and enabling more reliable deployments.Accelerate release cyclesAI-Enhanced Efficiency: Detect testing gaps, optimize workflows, and accelerate time-to-market with minimal manual effort and HaloAI-driven accuracy.Proactive Issue Detection: Understand the impact of any change at the point of design or code modification, enabling faster resolution and smoother releases.Remove Testing Bottlenecks: Contract tests can be written during development - no need to wait for the other side of your integration to be ready.Explore with API HubExplore APIs effortlessly with integrated documentation and discovery tools, enabling users to quickly understand, validate, and integrate APIs while boosting engagement and speeding up onboarding.Learn more Get to know your APIsQuick Endpoint Insights: Instantly visualize API responses to evaluate functionality.Increase Collaboration: Share a set of API requests and responses with team members using Explore Spaces.Multi-Protocol Support: Interact with REST and Kafka APIs.Confident integrationsMitigate Integration Errors: Reduce errors by evaluating API capabilities before integration.Save Time and Resources: Make informed API decisions quickly to focus on development.Understand API Behavior: Gain real-time insights into API responses to ensure functionality and integration readiness. Share data, reduce duplicated effortsIntegrated Exploration: Combine API documentation and live call testing in a single workspace to better understand how APIs behave before integration.Generate OpenAPI: Use Explore to generate an OpenAPI description for a service that doesn’t have one yet, and import it straight into Design to enhance your workflow.Collaborative API Discovery: Share API details across teams to accelerate learning and integration efforts.Test with API HubAutomate, scale, and streamline functional, integration, and regression API testing—right within your development workflows. Ensure API quality from the first design to final deployment.Learn more Enhance Testing EfficiencyBuilt-in API Alignment: Generate tests directly from your API designs to reduce rework and avoid outdated failures.Real-Time Collaboration: Share test results across QA, Dev, and Product teams to catch issues early.Version-Aware Testing: Validate APIs across versions without starting from scratch.Accelerate DeliverySeamless CI/CD Automation: Trigger API tests at every stage of your pipeline to prevent late-stage defects.Low-Code/No-Code: Build reliable tests faster, with less scripting overhead.Parallel & Sequential Test Execution: Flexible test execution accelerates feedback loops and regression testing, boosting dev speed and cutting time-to-market.Collaborate Across the LifecycleCentralized Test Management: Monitor all test runs, results, and failures in one place.Role-Based Access Controls: Empower collaboration with intuitive access controls that keep teams aligned.Unified Experience: Teams can collaborate effortlessly across design, documentation, exploration, and testing—all within a single Hub.  API Hub Integrations Seamless Connections for Smarter DevelopmentAPI Hub integrates effortlessly with the tools your team depends on, enabling streamlined workflows and optimized collaboration.Learn more   Ready to transform your API lifecycle?Unlock advanced features and scale your API management with API Hub’s integrated solution. Manage design, testing, and documentation from one central hub.Start Free Trial\n\n\n\nDesign The Blueprint for Better APIs.  Simplify API design and governance with tools that drive quality and foster collaboration across teams.Start Free Trial   Trusted by the world’s most innovative teams  Standardized APIsDeliver consistency. 
Build with confidence.Create APIs that meet industry and organizational standards to ensure quality, alignment, and synchronization across every team.Enforce design standards with style validators, reusable templates, and domains for scalable consistency.Support multiple specifications, including OpenAPI and AsyncAPI, for flexible, forward-compatible development.Automate quality checks with built-in mocking, linting, and validation tools that streamline every step of the API lifecycle.  EbookOptimize your API workflow from design to deployment.Learn how   Collaborative DesignTeamwork made effortlessEmpower your team to build better APIs together.Assign roles and permissions to control access and ensure consistency across projects.Simplify API design for all stakeholders with Form Editor, a visual, code-free tool for both technical and non-technical users.Align teams around one source of truth with real-time commenting to accelerate feedback cycles. Seamless integrationConnect. Automate. Simplify.Easily integrate with tools across your API development lifecycle to simplify workflows.Integrate with popular API gateways and source control systems.Automate workflows using CI/CD pipelines and API management platforms.Simplify transitions from design to production. API Hub Integrations Seamless Connections for Smarter DevelopmentAPI Hub integrates effortlessly with the tools your team depends on, enabling streamlined workflows and optimized collaboration.Learn more   "With the entire suite of SmartBear tools in play, we are improving release quality and receiving positive customer feedback."Head of DeliveryTriquestra"We can easily standardize the API design and achieve the level of quality we expect, more efficiently and more easily."Industry Standards Manager IATA  Resources for Design8 min readFrom Design to Discovery: Mastering API Development​Ebook3 min readThe 5 key areas to optimize your API lifecycleBlog60 minAPI-first: shifting your focus from UI to product valueWebinar  Ready to Transform Your API Lifecycle?Unlock advanced features and scale your API management with API Hub’s integrated solution. Manage design, testing, and documentation from one central hub.Start Free Trial\n\n\n\nPortal Create Your API Showroom in Minutes. Make it easy for consumers to find and use your APIs with a centralized, customizable documentation portal.Start Free Trial   Trusted by the world’s most innovative teams  Showcase your APIsMake your APIs easy to find and useDrive adoption by simplifying API discovery and showcasing their value.Create fully branded portals with public and private visibility options.Customize landing pages and use custom domains to align with your brand.Improve API visibility and usability to drive adoption and foster engagement.  WebinarStreamline API onboarding, improve discoverability, and drive adoption. Learn more   Seamless onboardingDeliver clear, up-to-date API documentationSimplify onboarding with accurate, interactive resources that reduce friction and save time.Enhance the consumer experience with intuitive documentation that builds trust and drives faster adoption.Sync API updates in real time to ensure consistency and speed.Enable faster integration while reducing support costs. Streamline API DevelopmentSmarter collaboration, faster innovationEmpower your teams with tools that simplify workflows and centralize API management.Foster teamwork with collaborative tools for API design and documentation.Maintain a single, centralized catalog of all your APIs across the company.Ensure consistency and unlock innovation with streamlined processes. API Hub Integrations Seamless Connections for Smarter DevelopmentAPI Hub integrates effortlessly with the tools your team depends on, enabling streamlined workflows and optimized collaboration.Learn more   "API Hub for Portal is promising to be a game changer for our onboarding process and developer experience. The use of the product concept to describe different parts of our system, combined with seamless integration with other API Hub products, means that developers have a one stop shop to get all the latest API information alongside visually appealing up to date documentation."Senior Tech & Developer Experience Lead Webio  Resources for Portal60 minHow to create an optimized API development processWebinar2 min readDriving better developer experience with SwaggerHub PortalBlog8 min readFrom Design to Discovery: Mastering API Development​Ebook  Ready to Transform Your API Lifecycle?Unlock advanced features and scale your API management with API Hub’s integrated solution. Manage design, testing, and documentation from one central hub.Start Free Trial\n\n\n\nContract Testing Integration Testing Done Properly. Fast, easy and reliable testing for integrating web apps, APIs and microservices.Start Free Trial   Trusted by the world’s most innovative teams  Consumer-Driven TestingDeploy faster, safer and more oftenConsumer-driven contract testing provides a guarantee that systems are compatible, so you can deploy your microservices and web apps independently and safely.Catch Bugs Sooner: Contract tests run on developer machines, prior to pushing code.Reduce End-To-End Testing Efforts: Developers don’t need access to the entire production ecosystem to run their tests.Increased Confidence: Consumer expectations are validated against real Providers, meaning you can release with confidence. Bi-directional testingMake it easier for teams to get started with contract testingBi-directional contract testing removes some of the most common challenges that teams encounter when getting started.Reuse existing assets: Leverage existing tools and processes and upgrade them into a contract testing workflow.Increased Collaboration: Direct access to code isn’t required, so more of the team can join.Faster Time to Value: See the value and ROI of contract testing faster.  EbookTake the pain out of API integration testing with proven contract testing strategies.Get your free eBook   AI AutomationSmarter, faster contract testing with HaloAIAI-augmented testing automates contract test creation and maintenance to reduce manual effort and ensure reliable API integrations.Effortless Scaling: Automate contract test creation and maintenance as APIs expand.Precision Validation: Enhance accuracy with HaloAI-driven test generation.Accelerated Onboarding: Simplify adoption of contract testing across teams and assure best practices. API Hub Integrations Seamless Connections for Smarter DevelopmentAPI Hub integrates effortlessly with the tools your team depends on, enabling streamlined workflows and optimized collaboration.Learn more   "Adding API Hub for Contract Testing to our test automation strategy gives the team the confidence to move forward when they see validation between the provider and consumer."Head of Test EngineeringM1 Finance"API Hub's AI-augmented contract testing solution can significantly reduce Java's boilerplate code and save a substantial amount of time by establishing the groundwork."Alejandro PenaSolutions Architect, Sngular  Resources for Contract Testing60 minContract testing essentials: Tools & strategies for developersWebinar8 min readAPI contract testing for a design-first worldBlog30 minIntroducing AI-Augmented Contract Testing: Save Time, Boost Accuracy, & Deliver QualityWebinar  Ready to Transform Your API Lifecycle?Unlock advanced features and scale your API management with API Hub’s integrated solution. Manage design, testing, and documentation from one central hub.Start Free Trial\n\n\n\nExplore Free, Simple, Useful: The API Client Anyone Can Master. Make it easy for consumers and developers to explore, debug, and test APIs.Start Exploring   Trusted by the world’s most innovative teams  API ExplorationAPIs made easyConnect to multi-protocol APIs through a user-friendly interface that integrates with your API catalog.Save time with no learning curve: Non-technical team members can start using Explore immediately, eliminating training delays and technical roadblocks.Break down communication barriers: Create a shared language between developers, testers, business analysts and technical writers when everyone uses the same straightforward tool.Focus on what matters: Spend less time wrestling with complex API tools and more time on your actual work, whether testing, documenting, or analyzing data.  VideoRemove the guesswork - learn to explore API functionality like a pro. Learn more   Instant AlignmentBring your API documentation to lifeEmpower your consumers by making it simple for them to see how an API actually works.See APIs in action instantly: Watch API responses come to life right next to their documentation, making complex endpoints immediately understandable.Learn by doing, not just reading: Test responses directly alongside explanations, helping consumers grasp concepts faster than through text alone.One workflow: No more switching between documentation and testing tools—everything your consumers need is in one place. Confident IntegrationsEnhance your API design workflowRemove the guesswork from your API design process. Explore gives developers and designers a quick and easy way to see what an endpoint is doing before you share it with the world.Test as you build: Validate your API design decisions in real-time with immediate visual feedback, catching issues before they become problems.Streamline your workflow: Design, test, and refine your API all in one place, eliminating the constant switching between development tools.Share your vision clearly: Demonstrate your API's functionality to stakeholders and team members with a tool that everyone can understand, making feedback more meaningful. API Hub Integrations Seamless Connections for Smarter DevelopmentAPI Hub integrates effortlessly with the tools your team depends on, enabling streamlined workflows and optimized collaboration.Learn more   "With the entire suite of SmartBear tools in play, we are improving release quality and receiving positive customer feedback."Head of DeliveryTriquestra  Resources for API Explore2 min readThe power of API exploration: From roadblocks to successBlog6 min readAPI exploration for designersBlog8 min readFrom Design to Discovery: Mastering API DevelopmentEbook  Ready to Transform Your API Lifecycle?Unlock advanced features and scale your API management with API Hub’s integrated solution. Manage design, testing, and documentation from one central hub.Start Free Trial\n\n\n\nAPI Management Build APIs That Lead.
Deliver Business Impact. Build your APIs on an industry-leading API management hub with advanced design, customizable portals, test automation, API exploration, and complete visibility, scalability, and governance to streamline workflows and elevate software quality.Start Free TrialContact us   Trusted by the world’s most innovative teams  SmartBear Named a Leader by Gartner® in the 2024 Magic Quadrant™ for API ManagementLearn More  Accelerate API Delivery at ScaleGovern and Scale APIs Across Teams and DepartmentsStandardize your API development with centralized governance and streamlined workflows—so teams can innovate faster without sacrificing quality or consistency.Multi-Team Governance: Manage and enforce API style guides, version control, and access permissions across distributed teams.Scalable Templates: Use customizable domains and templates to ensure consistency and accelerate API development.Centralized Catalog: Maintain a single, searchable catalog of APIs to simplify discovery, reduce duplication, and improve enterprise-wide visibility. Integrated API ManagementA Connected Solution for Design, Testing, Documentation, and GovernanceAPI Hub streamlines the API development lifecycle, enabling teams to collaborate seamlessly and prevent workflow silos.Design and Test Together: Validate API contracts early with integrated bi-directional contract testing, ensuring accuracy throughout the design process.Real-Time Documentation: Automatically update consumer-facing documentation portals as API designs evolve, keeping your resources accurate and up-to-date.Version Control: Manage multiple API versions with clarity and precision, ensuring smooth transitions and reliable integrations. Enterprise Management & SupportSimplify Complexity with Unified Oversight and Dedicated SupportFocus on delivering impactful APIs while API Hub simplifies enterprise-scale management.Streamlined Vendor Management: Consolidate tools, SLAs, and integrations under one unified contract.Dedicated Support: Access enterprise-grade support, with dedicated account management to ensure uptime and performance.Advanced Integrations: Connect API Hub seamlessly with your CI/CD pipelines, gateways, and enterprise tools for greater efficiency.  Ready to Transform Your API Lifecycle?Unlock advanced features and scale your API management with API Hub’s integrated solution. Manage design, testing, and documentation from one central hub.Start Free Trial\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nSwagger vs
                    API Hub: A complete comparison
                Explore the key features, differences, and advantages of using Swagger and API Hub for API design and documentation. This guide is tailored to help you decide which option best suits your needs.
                Compare Solutions
            
            
                
                
            
        
    

    
        
            
                
                    Compare all capabilities
                    Swagger Open Source
                    API Hub (Individual)
                    API Hub (Teams)
                    API Hub (Enterprise)
                    API Hub (Enterprise Plus)
                
                
                    
                    
                    For individual developers needing powerful tools for API design, testing, and documentation
                    Ideal for small teams looking to enhance collaboration and documentation
                    For larger teams needing advanced features for complex API management
                    For enterprises needing maximum control, scalability, and dedicated support
                
                
                    
                    
                        Learn More
                    
                    
                        Try Free
                    
                    
                        Try Free
                    
                    
                        Try Free
                    
                    
                        Contact Us
                    
                
                
                    
                        
                            Standardization & Governance
                            
                        
                        
                            
                                API Catalog (with advanced elastic search)
                                
                                3 public APIs
                                up to 50 public/private
                                
                                
                            
                            
                                Style Guide and Ruleset Enforcement 
                                
                                
                                
                                
                                
                            
                            
                                Public Style Guides
                                
                                
                                
                                
                                
                            
                            
                                Reusable Domains
                                
                                5 domains
                                10 domains
                                50 domains
                                
                            
                            
                                API Design Templates (pre-defined, customizable)
                                
                                
                                
                                
                                
                            
                            
                                Code Generation Templates (customizable) *
                                
                                
                                
                                
                                
                            
                            
                                Project grouping (APIs, templates, components)
                                
                                
                                
                                
                                
                            
                            
                                Versioning
                                
                                
                                
                                
                                
                            
                            
                                Design Insight (Contract Testing at Design Time)
                                
                                
                                
                                
                                
                            
                            
                                Advanced Developer Portal **
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            General Capabilities
                            
                        
                        
                            
                                YAML/JSON editor with specification validation
                                
                                
                                
                                
                                
                            
                            
                                Swagger 2.0, OpenAPI 3.* Specification support
                                
                                
                                
                                
                                
                            
                            
                                AsyncAPI 2.* Specification support
                                
                                
                                
                                
                                
                            
                            
                                Real-time semantic validation & highlighting
                                
                                
                                
                                
                                
                            
                            
                                Smart Auto-Complete
                                
                                
                                
                                
                                
                            
                            
                                Document Navigation (go to reference, symbols, peeking, etc.)
                                
                                
                                
                                
                                
                            
                            
                                Auto-Generated Interactive API Documentation
                                
                                
                                
                                
                                
                            
                            
                                Editor themes (light/dark)
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            
                                Advanced Editing

                            
                            
                        
                        
                            
                                JSON / YAML seamless conversion
                                
                                
                                
                                
                                
                                
                            
                            
                                Reference resolving
                                
                                
                                
                                
                                
                                
                            
                            
                                Auto spec version upgrades
                                
                                
                                
                                
                                
                            
                            
                                Client & Server Code Generation
                                
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            Mocking
                            
                        
                        
                            
                                Codeless Mocking
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            Hosting & Maintenance
                            
                        
                        
                            
                                Cloud Hosting
                                
                                
                                
                                
                                
                            
                            
                                Centralized Artifact Storage
                                
                                
                                
                                
                                
                            
                            
                                On-premise
                                
                                
                                
                                
                                
                            
                            
                                Single Sign-On**
                                
                                
                                
                                
                                
                            
                            
                                Customized Landing Page & URL**
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            Collaboration & Sharing
                            
                        
                        
                            
                                Advance Role Based Access Control (RBAC)
                                
                                
                                basic configuration
                                
                                
                            
                            
                                Secure Sharing
                                
                                
                                up to 20 consumers
                                
                                
                            
                            
                                Issue Tracking & Commenting
                                
                                
                                
                                
                                
                            
                            
                                Change Notifications
                                
                                
                                
                                
                                
                            
                            
                                API Exploration
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            Automation
                            
                        
                        
                            
                                Registry and User Management APIs
                                
                                
                                
                                
                                
                            
                            
                                Command Line Interface
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            Third-Party Integrations
                            
                        
                        
                            
                                Sync with Source Control (GitHub, GitLab,
                                    BitBucket, etc.)
                                
                                GitHub only
                                
                                
                                
                            
                            
                                Deploy to API Gateways
                                
                                
                                
                                
                                
                            
                            
                                Webhooks
                                
                                
                                
                                
                                
                            
                            
                                Visual Studio Code
                                
                                
                                
                                
                                
                            
                            
                                IntelliJ
                                
                                
                                
                                
                                
                            
                        
                    
                    
                        
                            Support
                            
                        
                        
                            
                                Community Support
                                
                                
                                
                                
                                
                            
                            
                                Live Trainings
                                
                                
                                
                                
                                
                            
                            
                                Email Support
                                
                                
                                
                                
                                
                            
                            
                                Live Chat Support
                                
                                
                                
                                
                                
                            
                            
                                Priority Chat Support
                                
                                
                                
                                
                                
                            
                            
                                Dedicated Account Manager
                                
                                
                                
                                
                                
                            
                            
                                Enterprise Support
                                
                                
                                
                                
                                
                            
                        
                    
                
                
                    Cost
                
                
                    
                        Explore API Hub plans
                    
                    
                        $0
                    
                    
                        Starting at $19/month
                    
                    
                        Starting at $29/month
                    
                    
                        Starting at $49/month
                    
                    
                        Contact us for pricing
                    
                
                
                    
                    
                        Learn
                            More
                    
                    
                        Try Free
                    
                    
                        Try Free
                    
                    
                        Try Free
                    
                    
                        Contact Us
                    

                
            
            
                * on-premise only
                ** add on capability\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                            
                                API Catalog (with advanced elastic search)
                                
                                3 public APIs
                                up to 50 public/private
                                
                                
                            
                            
                                Style Guide and Ruleset Enforcement 
                                
                                
                                
                                
                                
                            
                            
                                Public Style Guides
                                
                                
                                
                                
                                
                            
                            
                                Reusable Domains
                                
                                5 domains
                                10 domains
                                50 domains
                                
                            
                            
                                API Design Templates (pre-defined, customizable)
                                
                                
                                
                                
                                
                            
                            
                                Code Generation Templates (customizable) *
                                
                                
                                
                                
                                
                            
                            
                                Project grouping (APIs, templates, components)
                                
                                
                                
                                
                                
                            
                            
                                Versioning
                                
                                
                                
                                
                                
                            
                            
                                Design Insight (Contract Testing at Design Time)
                                
                                
                                
                                
                                
                            
                            
                                Advanced Developer Portal **
                                
                                
                                
                                
                                
                            
                        
                            
                                YAML/JSON editor with specification validation
                                
                                
                                
                                
                                
                            
                            
                                Swagger 2.0, OpenAPI 3.* Specification support
                                
                                
                                
                                
                                
                            
                            
                                AsyncAPI 2.* Specification support
                                
                                
                                
                                
                                
                            
                            
                                Real-time semantic validation & highlighting
                                
                                
                                
                                
                                
                            
                            
                                Smart Auto-Complete
                                
                                
                                
                                
                                
                            
                            
                                Document Navigation (go to reference, symbols, peeking, etc.)
                                
                                
                                
                                
                                
                            
                            
                                Auto-Generated Interactive API Documentation
                                
                                
                                
                                
                                
                            
                            
                                Editor themes (light/dark)
                                
                                
                                
                                
                                
                            
                        
                            
                                JSON / YAML seamless conversion
                                
                                
                                
                                
                                
                                
                            
                            
                                Reference resolving
                                
                                
                                
                                
                                
                                
                            
                            
                                Auto spec version upgrades
                                
                                
                                
                                
                                
                            
                            
                                Client & Server Code Generation
                                
                                
                                
                                
                                
                                
                            
                        
                            
                                Codeless Mocking
                                
                                
                                
                                
                                
                            
                        
                            
                                Cloud Hosting
                                
                                
                                
                                
                                
                            
                            
                                Centralized Artifact Storage
                                
                                
                                
                                
                                
                            
                            
                                On-premise
                                
                                
                                
                                
                                
                            
                            
                                Single Sign-On**
                                
                                
                                
                                
                                
                            
                            
                                Customized Landing Page & URL**
                                
                                
                                
                                
                                
                            
                        
                            
                                Advance Role Based Access Control (RBAC)
                                
                                
                                basic configuration
                                
                                
                            
                            
                                Secure Sharing
                                
                                
                                up to 20 consumers
                                
                                
                            
                            
                                Issue Tracking & Commenting
                                
                                
                                
                                
                                
                            
                            
                                Change Notifications
                                
                                
                                
                                
                                
                            
                            
                                API Exploration
                                
                                
                                
                                
                                
                            
                        
                            
                                Registry and User Management APIs
                                
                                
                                
                                
                                
                            
                            
                                Command Line Interface
                                
                                
                                
                                
                                
                            
                        
                            
                                Sync with Source Control (GitHub, GitLab,
                                    BitBucket, etc.)
                                
                                GitHub only
                                
                                
                                
                            
                            
                                Deploy to API Gateways
                                
                                
                                
                                
                                
                            
                            
                                Webhooks
                                
                                
                                
                                
                                
                            
                            
                                Visual Studio Code
                                
                                
                                
                                
                                
                            
                            
                                IntelliJ
                                
                                
                                
                                
                                
                            
                        
                            
                                Community Support
                                
                                
                                
                                
                                
                            
                            
                                Live Trainings
                                
                                
                                
                                
                                
                            
                            
                                Email Support
                                
                                
                                
                                
                                
                            
                            
                                Live Chat Support
                                
                                
                                
                                
                                
                            
                            
                                Priority Chat Support
                                
                                
                                
                                
                                
                            
                            
                                Dedicated Account Manager
                                
                                
                                
                                
                                
                            
                            
                                Enterprise Support\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nSwagger Documentation              
Swagger Documentation
           OpenAPI SpecificationA standard format for defining APIs, ensuring structured and consistent endpoints, methods, parameters, and responses.   View Docs       View on GitHub      API Hub for DesignStandardize and collaborate on API designs using the Swagger Editor, built on open standards with powerful integrations to streamline development.   View Docs       Try Free       API Hub for ExploreEasily connect to multi-protocol APIs with a user-friendly interface designed for fast and seamless API exploration.   View Docs       Try Free         Swagger EditorA user-friendly tool for creating, editing, and visualizing API definitions, streamlining the validation of API documentation.   View Docs       Download      Swagger UIAn interactive interface for exploring and testing APIs, making it easy to visualize and understand their functionality.   View Docs       Download       Swagger CodeGenAutomate the generation of client libraries, server stubs, and API documentation efficiently based on API definitions.   View Docs       Download              
SmartBear is committed to open source development. Create more with us.
   SmartBear CommunityJoin the SmartBear Community to discuss products, share best practices, ask questions, and get support from peers and experts.Learn More SmartBear AcademyAccess training and resources to improve your skills and efficiency with SmartBear's testing and development tools.Learn More         Edit page\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nAccelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.\n\nLearn
                    
                        
                            
                                
                                    
                                        
                                                
                                            API Design
                                        
                                                
                                            API Development
                                        
                                                
                                            API Documentation
                                        
                                                
                                            API Testing
                                        
                                                
                                            API Mocking and
                                                Virtualization
                                        
                                                
                                            API Governance
                                        
                                                
                                            API Monitoring
                                        
                                                
                                            OpenAPI & Swagger
                                    
                                
                            
                        
                    
                
                
                    Tools
                    
                        
                            
                                
                                
                                    
                                        
                                            Pro
                                            
                                        
                                    
                                    
                                        
                                            
                                                Open
                                                Source
                                        
                                    
                                
                                
                                
                                    
                                        API Hub
                                            Accelerate API development with quality and consistency
                                                across OpenAPI and AsyncAPI.
                                        
                                        
                                            
                                                
                                                    Design
                                                    Collaborate on API Design
                                                
                                            
                                            
                                                
                                                    Portal
                                                    Deliver Up-to-date API Documentation
                                                
                                            
                                            
                                                
                                                    Explore
                                                    Quickly Test and Explore APIs
                                                
                                            
                                            
                                                
                                                    Testing
                                                    Automated API Testing
                                                
                                            
                                            
                                                
                                                    Contract Testing
                                                    Block API Breaking Changes
                                                
                                            
                                        
                                        API Hub Enterprise
                                            
                                                Standardize your APIs with projects,
                                                style checks, and reusable domains.
                                            
                                        
                                    
                                    
                                        Swagger Open Source
                                             Ideal for individuals and small teams to design, build,
                                                and document APIs.
                                            
                                        
                                        
                                            
                                                

                                                    Swagger
                                                        Codegen
                                                    Generate server
                                                        stubs and client SDKs from OpenAPI Specification
                                                        definitions.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        Editor
                                                    API editor for
                                                        designing APIs with the OpenAPI and AsyncAPI
                                                        specifications.
                                                
                                            
                                            
                                                
                                                    Swagger
                                                        UI
                                                    Visualize OpenAPI
                                                        Specification definitions in an interactive UI.
                                                
                                            
                                        
                                    
                                
                            
                        
                        
                            Explore all
                                    tools
                        
                    
                
                
                    Resources
                    
                        
                            
                                
                                    
                                        Resources
                                    
                                    
                                        
                                                
                                            OpenAPI Specification
                                        
                                                
                                            Docs
                                        
                                                
                                            Blog
                                        
                                                
                                            Support
                                    
                                
                            
                        
                    
                
                
                    
                      
                    
                
                
                    Sign In
                
                
                    Get started\n\n\n\nWhy API Hub? Because APIs Are
  Good For Your Business. API Hub integrates effortlessly with the tools your team depends on, centralizing design, testing, documentation, and exploration in one unified experience. Eliminate silos and unlock innovation.Start Free Trial   Trusted by the world’s most innovative teams  API DesignThe single source of truth for API developmentDesign, standardize, and collaborate on APIs faster. Ensure API quality and consistency across your team at scale.Learn more about API Hub for Design  API DocumentationEmpower API discoverabilityDeliver a seamless API onboarding experience through a branded portal that provides consumers with clear, interactive documentation to drive adoption.Learn more about API Hub for Portal  SmartBear Named a Leader by Gartner® in the 2024 Magic Quadrant™ for API ManagementLearn More  Contract TestingDeploy distributed systems with confidenceStreamline API integration and microservices testing with bi-directional validation and AI-driven automation. Detect errors early, reduce end-to-end testing, and accelerate development.Learn more about API Hub for Contract Testing  API ExplorationAccelerate API discoveryInstantly evaluate the functionality and capabilities of multi-protocol APIs to integrate with confidence and streamline workflows.Learn more about API Hub for Explore  API TESTConfidently test APIs from design to deploymentAutomate scalable, low-maintenance API tests that align with your source of truth. Seamlessly integrate testing into CI/CD workflows to catch defects early and release high-quality APIs faster.Learn more about API Hub for Test  API Hub Integrations Seamless Connections for Smarter DevelopmentAPI Hub integrates effortlessly with the tools your team depends on, enabling streamlined workflows and optimized collaboration.Learn more  Additional Resources60 minHow to create an optimized API development processWebinar90 minCollaborative API delivery: From ideation to consumption​Webinar8 min readAPI Contract Testing for a design-first worldArticle  Ready to transform your API lifecycle?Unlock advanced features and scale your API management with API Hub’s integrated solution. Manage design, testing, and documentation from one central hub.Start Free Trial\n\n\n\nSwagger Editor Documentation        This page is about the current Swagger Editor. If you’re looking for Swagger Editor Next (beta) (otherwise known as SwaggerEditor@5) docs, visit Swagger
Editor Next (beta).
The Swagger Editor is an open source editor to design, define and document HTTP (RESTful) APIs in the OpenAPI Specification.
The source code for the Swagger Editor can be found in GitHub.
GitHub: https://github.com/swagger-api/swagger-editor
Only Swagger Editor Next supports OpenAPI 3.1.0.
SwaggerEditor@4 will not receive OpenAPI 3.1.0 support and is considered legacy at this point.
The plan is to continually migrate fully to SwaggerEditor@5 and deprecate the SwaggerEditor@4 in the future.
Using the Editor on the Web
The Editor works in any web browser, and can be hosted locally or accessed from the web.
Take Me To The Web Version
Running locally
Prerequisites

git, any version
Node.js >=20.3.0 and npm >=9.6.7 are the minimum required versions that this repo runs on, but we always recommend using the latest version of Node.js.

Terminal window1 $ npm i --legacy-peer-deps
If you have Node.js and npm installed, you can run npm start to spin up a static server.
Otherwise, you can open index.html directly from your filesystem in your browser.
If you’d like to make code changes to Swagger Editor, you can start up a Webpack hot-reloading dev server via npm run dev.
Browser support
Swagger Editor works in the latest versions of Chrome, Safari, Firefox, and Edge.
Known Issues
To help with the migration, here are the currently known issues with 3.X. This list will update regularly, and will not include features that were not implemented in previous versions.

Everything listed in Swagger UI’s Known Issues.
The integration with the codegen is still missing.

Helpful scripts
Any of the scripts below can be run by typing npm run <script name> in the project’s root directory.
Developing

































Script nameDescriptiondevSpawn a hot-reloading dev server on port 3200.deps-checkGenerate a size and licensing report on Swagger Editors’s dependencies.lintReport ESLint style errors and warnings.lint-errorsReport ESLint style errors, without warnings.lint-fixAttempt to fix style errors automatically.watchRebuild the core files in /dist when the source code changes. Useful for npm link.
Building





































Script nameDescriptionbuildBuild a new set of JS and CSS assets, and output them to /dist.build:bundleBuild swagger-editor-bundle.js only (commonJS).build:coreBuild swagger-editor.(js|css) only (commonJS).build:standaloneBuild swagger-editor-standalone-preset.js only (commonJS).build:stylesheetsBuild swagger-editor.css only.build:es:bundleBuild swagger-editor-es-bundle.js only (es2015).build:es:bundle:coreBuild swagger-editor-es-bundle-core.js only (es2015).
Testing













































Script nameDescriptiontestRun unit tests in Node, run Cypress end-to-end tests, and run ESLint in errors-only mode.test:unit-mochaRun Mocha-based unit tests in Node.test:unit-jestRun Jest-based unit tests in Node.e2eRun end-to-end browser tests with Cypress.lintRun ESLint testtest:artifactRun list of bundle artifact tests in Jesttest:artifact:umd:bundleRun unit test that confirms swagger-editor-bundle exports as a Functiontest:artifact:es:bundleRun unit test that confirms swagger-editor-es-bundle exports as a Functiontest:artifact:es:bundle:coreRun unit test that confirms swagger-editor-es-bundle-core exports as a Function
Docker
Running the image from DockerHub
There is a docker image published in docker.swagger.io registry.
To use this, run the following:
1docker pull docker.swagger.io/swaggerapi/swagger-editor2docker run -d -p 80:8080 docker.swagger.io/swaggerapi/swagger-editor
This will run Swagger Editor (in detached mode) on port 80 on your machine, so you can open it by navigating to http://localhost in your browser.

You can provide a URL pointing to an API definition (may not be available if some security policies such as CSP or CORS are enforced):

1docker run -d -p 80:8080 -e URL="https://petstore3.swagger.io/api/v3/openapi.json" docker.swagger.io/swaggerapi/swagger-editor

You can provide your own json or yaml definition file from your local host:

1docker run -d -p 80:8080 -v $(pwd):/tmp -e SWAGGER_FILE=/tmp/swagger.json docker.swagger.io/swaggerapi/swagger-editor
Note: When both URL and SWAGGER_FILE environment variables are set, URL has priority and SWAGGER_FILE is ignored.

You can specify a different base url via BASE_URL variable for accessing the application - for example if you want the application to be available at http://localhost/swagger-editor/:

1docker run -d -p 80:8080 -e BASE_URL=/swagger-editor docker.swagger.io/swaggerapi/swagger-editor

You can specify a different port via PORT variable for accessing the application, default is 8080.

1docker run -d -p 80:80 -e PORT=80 docker.swagger.io/swaggerapi/swagger-editor

You can specify Google Tag Manager ID via GTM variable for tracking the usage of the swagger-editor.

1docker run -d -p 80:8080 -e GTM=GTM-XXXXXX docker.swagger.io/swaggerapi/swagger-editor
You can also customize the different endpoints used by the Swagger Editor with the following environment variables. For instance, this can be useful if you have your own Swagger generator server:





















Environment variableDefault valueURL_SWAGGER2_GENERATORhttps://generator.swagger.io/api/swagger.jsonURL_OAS3_GENERATORhttps://generator3.swagger.io/openapi.jsonURL_SWAGGER2_CONVERTERhttps://converter.swagger.io/api/convert
If you want to run the Swagger Editor locally without the Codegen features (Generate Server and Generate Client) you can set the above environment variables to null (URL_SWAGGER2_CONVERTER=null).
Building and running an image locally
To build and run a docker image with the code checked out on your machine, run the following from the root directory of the project:
1# Install npm packages (if needed)2npm install3
4# Build the app5npm run build6
7# Build an image8docker build -t swagger-editor .9
10# Run the container11docker run -d -p 80:8080 swagger-editor
You can then view the app by navigating to http://localhost in your browser.
Documentation


Importing your OpenAPI document


Contributing


Using older version of React

[!IMPORTANT]
By older versions we specifically refer to React >=17 <18.

By default swagger-editor@4 npm package comes with latest version of React@18.
It’s possible to use swagger-editor@4 npm package with older version of React.
Let’s say my application integrates with swagger-editor@4 npm package and uses React@17.0.2.
npm
In order to inform swagger-editor@4 npm package that I require it to use my React version, I need to use npm overrides.
1{2  "dependencies": {3    "react": "=17.0.2",4    "react-dom": "=17.0.2"5  },6  "overrides": {7    "swagger-editor": {8      "react": "$react",9      "react": "$react-dom",10      "react-redux": "^8"11    }12  }13}

[!NOTE]
The React and ReactDOM override are defined as a reference to the dependency. Since react-redux@9 only supports React >= 18, we need to use react-redux@8.

yarn
In order to inform swagger-editor@4 npm package that I require it to use my specific React version, I need to use yarn resolutions.
1{2  "dependencies": {3    "react": "17.0.2",4    "react-dom": "17.0.2"5  },6  "resolutions": {7    "swagger-editor/react": "17.0.2",8    "swagger-editor/react-dom": "17.0.2",9    "swagger-editor/react-redux": "^8"10  }11}

[!NOTE]
The React and ReactDOM resolution cannot be defined as a reference to the dependency. Unfortunately yarn does not support aliasing like $react or $react-dom as npm does. You’ll need to specify the exact versions.

Security contact
Please disclose any security-related issues or vulnerabilities by emailing security@swagger.io, instead of using the public issue tracker.
Anonymized analytics
Swagger Editor uses Scarf to collect anonymized installation analytics. These analytics help support the maintainers of this library and ONLY run during installation. To opt out, you can set the scarfSettings.enabled field to false in your project’s package.json:
package.json1{2  // ...3  "scarfSettings": {4    "enabled": false5  }6  // ...7}
Alternatively, you can set the environment variable SCARF_ANALYTICS to false as part of the environment that installs your npm packages, e.g., SCARF_ANALYTICS=false npm install.     Edit page        Previous  SwaggerHub Explore       Next  Swagger Editor Next\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwaggerEditor        SwaggerEditor is using forked Create React App as it’s building infrastructure.
Anonymized analytics
Swagger Editor uses Scarf to collect anonymized installation analytics. These analytics help support the maintainers of this library and ONLY run during installation. To opt out, you can set the scarfSettings.enabled field to false in your project’s package.json:
package.json1{2  // ...3  "scarfSettings": {4    "enabled": false5  }6  // ...7}
Alternatively, you can set the environment variable SCARF_ANALYTICS to false as part of the environment that installs your npm packages, e.g., SCARF_ANALYTICS=false npm install.
Getting started
Prerequisites
These prerequisites are required both for installing SwaggerEditor as a npm package and local development setup.

node-gyp with Python 3.x
GLIBC >=2.29
emscripten or docker needs to be installed, we recommend going with a docker option

Installation
Assuming prerequisites are already installed, SwaggerEditor npm package is installable and works with Node.js >= 12.22.0.
You can install SwaggerEditor via npm CLI by running the following command:
Terminal window1 $ npm install swagger-editor@alpha

NOTE: when using bundler to build your project which is using swagger-editor@5 npm package,
you might run into following Node.js error: Reached heap limit Allocation failed - JavaScript heap out of memory.
It is caused by significant amount of code that needs to be bundled. This error can be resolved
by extending the Node.js max heap limit: export NODE_OPTIONS="--max_old_space_size=4096".

Usage
Use the package in you application:
index.js:
1import React from 'react';2import ReactDOM from 'react-dom';3import SwaggerEditor from 'swagger-editor';4import 'swagger-editor/swagger-editor.css';5
6const url = "https://raw.githubusercontent.com/asyncapi/spec/v2.2.0/examples/streetlights-kafka.yml";7
8const MyApp = () => (9  <div>10    <h1>SwaggerEditor Integration</h1>11    <SwaggerEditor url={url} />12  </div>13);14
15self.MonacoEnvironment = {16  /**17   * We're building into the dist/ folder. When application starts on18   * URL=https://example.com then SwaggerEditor will look for19   * `apidom.worker.js` on https://example.com/dist/apidom.worker.js and20   * `editor.worker` on https://example.com/dist/editor.worker.js.21   */22  baseUrl: `${document.baseURI || location.href}dist/`,23}24
25ReactDOM.render(<MyApp />, document.getElementById('swagger-editor'));
webpack.config.js (webpack@5)
Install dependencies needed for webpack@5 to properly build SwaggerEditor.
Terminal window1 $ npm i stream-browserify --save-dev2 $ npm i https-browserify --save-dev3 $ npm i stream-http --save-dev4 $ npm i util --save-dev
1const path = require('path');2const webpack = require('webpack');3
4module.exports = {5  mode: 'production',6  entry: {7    app: './index.js',8    'apidom.worker': 'swagger-editor/apidom.worker',9    'editor.worker': 'swagger-editor/editor.worker',10  },11  output: {12    globalObject: 'self',13    filename: '[name].js',14    path: path.resolve(__dirname, 'dist')15  },16  resolve: {17    fallback: {18      path: false,19      fs: false,20      http: require.resolve('stream-http'), // required for asyncapi parser21      https: require.resolve('https-browserify'), // required for asyncapi parser22      stream: require.resolve('stream-browserify'),23      util: require.resolve('util'),24      url: require.resolve('url'),25      zlib: false,26    },27    alias: {28      // This alias make sure we don't pull two different versions of monaco-editor29      'monaco-editor': '/node_modules/monaco-editor',30      // This alias makes sure we're avoiding a runtime error related to this package31      '@stoplight/ordered-object-literal$': '/node_modules/@stoplight/ordered-object-literal/src/index.mjs',32    },33  },34  plugins: [35    new webpack.ProvidePlugin({36      Buffer: ['buffer', 'Buffer'],37    }),38  ],39  module: {40    rules: [41      {42        test: /\.css$/,43        use: ['style-loader', 'css-loader']44      },45      /**46       * The default way in which webpack loads wasm files won’t work in a worker,47       * so we will have to disable webpack’s default handling of wasm files and48       * then fetch the wasm file by using the file path that we get using file-loader.49       *50       * Resource: https://pspdfkit.com/blog/2020/webassembly-in-a-web-worker/51       *52       * Alternatively, WASM file can be bundled directly into JavaScript bundle as data URLs.53       * This configuration reduces the complexity of WASM file loading54       * but increases the overal bundle size:55       *56       * {57       *   test: /\.wasm$/,58       *   type: 'asset/inline',59       * }60       */61      {62        test: /\.wasm$/,63        loader: 'file-loader',64        type: 'javascript/auto', // this disables webpacks default handling of wasm65      },66    ]67  }68};
Alternative webpack.config.js (webpack@5)
We’ve already built Web Workers fragments for you, and they’re located inside our npm distribution
package in dist/umd/ directory. In order to avoid complexity of building the Web Worker fragments you can
use those fragments directly. This setup will work both for production and development (webpack-dev-server)
and will significantly shorten your build process.
Install copy-webpack-plugin and other needed dependencies.
Terminal window1 $ npm i copy-webpack-plugin --save-dev2 $ npm i stream-browserify --save-dev3 $ npm i https-browserify --save-dev4 $ npm i stream-http --save-dev5 $ npm i util --save-dev
1const path = require('path');2const webpack = require('webpack');3const CopyWebpackPlugin = require('copy-webpack-plugin');4
5module.exports = {6  mode: 'production',7  entry: {8    app: './index.js',9  },10  output: {11    globalObject: 'self',12    filename: 'static/js/[name].js',13    path: path.resolve(__dirname, 'dist')14  },15  resolve: {16    fallback: {17      path: false,18      fs: false,19      http: require.resolve('stream-http'), // required for asyncapi parser20      https: require.resolve('https-browserify'), // required for asyncapi parser21      stream: require.resolve('stream-browserify'),22      util: require.resolve('util'),23      url: require.resolve('url'),24      zlib: false,25    },26    alias: {27      // This alias make sure we don't pull two different versions of monaco-editor28      'monaco-editor': '/node_modules/monaco-editor',29      // This alias makes sure we're avoiding a runtime error related to this package30      '@stoplight/ordered-object-literal$': '/node_modules/@stoplight/ordered-object-literal/src/index.mjs',31    }32  },33  plugins: [34    new webpack.ProvidePlugin({35      Buffer: ['buffer', 'Buffer'],36    }),37    new CopyWebpackPlugin({38      patterns: [39        {40          from: 'node_modules/swagger-editor/dist/umd/apidom.worker.js',41          to: 'static/js',42        },43        {44          from: 'node_modules/swagger-editor/dist/umd/editor.worker.js',45          to: 'static/js',46        }47      ]48    }),49  ],50  module: {51    rules: [52      {53        test: /\.css$/,54        use: ['style-loader', 'css-loader']55      },56    ]57  }58};
Development
Prerequisites
Assuming prerequisites are already installed, Node.js >=20.3.0 and npm >=9.6.7
are the minimum required versions that this repo runs on, but we recommend using the latest version of Node.js@20.
Setting up
If you use nvm, running following command inside this repository
will automatically pick the right Node.js version for you:
Terminal window1 $ nvm use
Run the following commands to set up the repository for local development:
Terminal window1 $ git clone https://github.com/swagger-api/swagger-editor.git2 $ cd swagger-editor3 $ git checkout next4 $ git submodule init5 $ git submodule update6 $ npm i7 $ npm start
npm scripts
Lint
Terminal window1 $ npm run lint
Runs unit and integration tests
Terminal window1 $ npm test
Runs E2E Cypress tests
Usage in development environment:
Terminal window1 $ npm run cy:dev
Usage in Continuos Integration (CI) environment:
Terminal window1 $ npm run cy:ci
Build
Terminal window1 $ npm run build
This script will build all the SwaggerEditor build artifacts - app, esm and umd.
Build artifacts
After building artifacts, every two new directories will be created: build/ and dist/.
build/
Terminal window1$ npm run build:app2$ npm run build:app:serve
Builds and serves standalone SwaggerEditor application and all it’s assets on http://localhost:3050/.
dist/esm/
Terminal window1$ npm run build:bundle:esm
This bundle is suited for consumption by 3rd parties,
which want to use SwaggerEditor as a library in their own applications and have their own build process.
dist/umd/
Terminal window1$ npm run build:bundle:umd
SwaggerEditor UMD bundle exports SwaggerEditor symbol on global object.
It’s bundled with React defined as external. This allows consumer to use his own version of React + ReactDOM and mount SwaggerEditor lazily.
1<!DOCTYPE html>2<html lang="en">3<head>4  <meta charset="utf-8" />5  <meta name="viewport" content="width=device-width, initial-scale=1" />6  <meta7    name="description"8    content="SwaggerEditor"9  />10  <title>SwaggerEditor</title>11  <link rel="stylesheet" href="./swagger-editor.css" />12</head>13<body>14  <div id="swagger-editor"></div>15  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>16  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>17  <script src="./dist/umd/swagger-editor.js"></script>18  <script>19    const props = {20      url: 'https://raw.githubusercontent.com/asyncapi/spec/v2.2.0/examples/streetlights-kafka.yml',21    };22    const element = React.createElement(SwaggerEditor, props);23    const domContainer = document.querySelector('#swagger-editor');24
25    ReactDOM.render(element, domContainer);26  </script>27</body>28</html>
npm
SwaggerEditor is released as swagger-editor@5 npm package on npmjs.com.
Package can also be produced manually by running following commands (assuming you’re already followed setting up steps):
Terminal window1 $ npm run build:bundle:esm2 $ npm run build:bundle:umd3 $ npm pack
Package mapping
SwaggerEditor maps its build artifacts in package.json file in following way:
1"unpkg": "./dist/umd/swagger-editor.js",2"module": "./dist/esm/swagger-editor.js",3"browser": "./dist/esm/swagger-editor.js",4"jsnext:main": "./dist/esm/swagger-editor.js",5"exports": {6  "./package.json": "./package.json",7  "./swagger-editor.css": "./dist/swagger-editor.css",8  ".": {9    "browser": "./dist/esm/swagger-editor.js"10  },11  "./plugins/*": {12    "browser": "./dist/esm/plugins/*/index.js"13  },14  "./presets/*": {15    "browser": "./dist/esm/presets/*/index.js"16  },17  "./apidom.worker": {18    "browser": "./dist/esm/apidom.worker.js"19  },20  "./editor.worker": {21    "browser": "./dist/esm/editor.worker.js"22  }23}
To learn more about these fields please refer to webpack mainFields documentation
or to Node.js Modules: Packages documentation.
Documentation
Using older version of React

[!IMPORTANT]
By older versions we specifically refer to React >=17 <18.

By default swagger-editor@5 npm package comes with latest version of React@18.
It’s possible to use swagger-editor@5 npm package with older version of React.
Let’s say my application integrates with swagger-editor@5 npm package and uses React@17.0.2.
npm
In order to inform swagger-editor@5 npm package that I require it to use my React version, I need to use npm overrides.
1{2  "dependencies": {3    "react": "=17.0.2",4    "react-dom": "=17.0.2"5  },6  "overrides": {7    "swagger-editor": {8      "react": "$react",9      "react": "$react-dom",10      "react-redux": "^8"11    }12  }13}

[!NOTE]
The React and ReactDOM override are defined as a reference to the dependency. Since react-redux@9 only supports React >= 18, we need to use react-redux@8.

yarn
In order to inform swagger-editor@5 npm package that I require it to use my specific React version, I need to use yarn resolutions.
1{2  "dependencies": {3    "react": "17.0.2",4    "react-dom": "17.0.2"5  },6  "resolutions": {7    "swagger-editor/react": "17.0.2",8    "swagger-editor/react-dom": "17.0.2",9    "swagger-editor/react-redux": "^8"10  }11}

[!NOTE]
The React and ReactDOM resolution cannot be defined as a reference to the dependency. Unfortunately yarn does not support aliasing like $react or $react-dom as npm does. You’ll need to specify the exact versions.

Customization

Plug points

Environment Variables
It is possible to use an environment variable to specify a local JSON/YAML file or a remote URL for SwaggerEditor to load on startup.
These environment variables will get baked in during build time into build artifacts.
Environment variables currently available:





















Variable nameDescriptionREACT_APP_DEFINITION_FILESpecifies a local file path, and the specified file must also be present in the /public/static directoryREACT_APP_DEFINITION_URLSpecifies a remote URL. This environment variable currently takes precedence over REACT_APP_SWAGGER_FILEREACT_APP_VERSIONSpecifies the version of this app. The version is read from package.json file.
Sample environment variable values can be found in .env file. For more information about using
environment variables, please refer to adding Custom Environment Variables
section of Create React App documentation.
Using preview plugins in SwaggerUI
SwaggerEditor comes with number of preview plugins that are responsible for rendering
the definition that’s being created in the editor. These plugins include:

EditorPreviewAsyncAPIPlugin - AsyncAPI specification rendering support
EditorPreviewAPIDesignSystemsPlugin - API Design Systems rendering support

With a bit of adapting, we can use these plugins with SwaggerUI to provide ability
to render AsyncAPI or API Design Systems definitions with SwaggerUI.
1import SwaggerUI from 'swagger-ui';2import SwaggerUIStandalonePreset from 'swagger-ui/dist/swagger-ui-standalone-preset';3import 'swagger-editor/swagger-editor.css';4import EditorContentTypePlugin from 'swagger-editor/plugins/editor-content-type';5import EditorPreviewAsyncAPIPlugin from 'swagger-editor/plugins/editor-preview-asyncapi';6import EditorPreviewAPIDesignSystemsPlugin from 'swagger-editor/plugins/editor-preview-api-design-systems';7import SwaggerUIAdapterPlugin from 'swagger-editor/plugins/swagger-ui-adapter';8
9SwaggerUI({10  url: 'https://petstore.swagger.io/v2/swagger.json',11  dom_id: '#swagger-ui',12  presets: [SwaggerUI.presets.apis, SwaggerUIStandalonePreset],13  plugins: [14    EditorContentTypePlugin,15    EditorPreviewAsyncAPIPlugin,16    EditorPreviewAPIDesignSystemsPlugin,17    SwaggerUIAdapterPlugin,18    SwaggerUI.plugins.DownloadUrl,19  ],20});
The key here is SwaggerUIAdapter plugin which adapts SwaggerEditor plugins to use
directly with SwaggerUI.
Standalone mode
SwaggerUI standalone mode is supported as well. With standalone mode you’ll get a TopBar with
an input where URL of the definition can be provided and this definition is subsequently loaded
by the SwaggerUI.
1import SwaggerUI from 'swagger-ui';2import SwaggerUIStandalonePreset from 'swagger-ui/dist/swagger-ui-standalone-preset';3import 'swagger-ui/dist/swagger-ui.css';4import 'swagger-editor/swagger-editor.css';5import EditorContentTypePlugin from 'swagger-editor/plugins/editor-content-type';6import EditorPreviewAsyncAPIPlugin from 'swagger-editor/plugins/editor-preview-asyncapi';7import EditorPreviewAPIDesignSystemsPlugin from 'swagger-editor/plugins/editor-preview-api-design-systems';8import SwaggerUIAdapterPlugin from 'swagger-editor/plugins/swagger-ui-adapter';9
10SwaggerUI({11  url: 'https://petstore.swagger.io/v2/swagger.json',12  dom_id: '#swagger-ui',13  presets: [SwaggerUI.presets.apis, SwaggerUIStandalonePreset],14  plugins: [15    EditorContentTypePlugin,16    EditorPreviewAsyncAPIPlugin,17    EditorPreviewAPIDesignSystemsPlugin,18    SwaggerUIAdapterPlugin,19    SwaggerUI.plugins.DownloadUrl,20  ],21  layout: 'StandaloneLayout',22});
Utilizing preview plugins via unpkg.com
It’s possible to utilize preview plugins in a build-free way via unpkg.com to create a standalone
multi-spec supporting version of SwaggerUI.
1<!DOCTYPE html>2<html >3  <head>4    <meta charset="utf-8" />5    <meta name="viewport" content="width=device-width, initial-scale=1" />6    <meta name="theme-color" content="#000000" />7    <meta name="description" content="SwaggerUIMultifold" />8    <link rel="stylesheet" href="//unpkg.com/swagger-editor@5.0.0-alpha.86/dist/swagger-editor.css" />9  </head>10  <body style="margin:0; padding:0;">11    <section id="swagger-ui"></section>12
13    <script src="//unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js"></script>14    <script src="//unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-standalone-preset.js"></script>15    <script>16      ui = SwaggerUIBundle({});17      // expose SwaggerUI React globally for SwaggerEditor to use18      window.React = ui.React;19    </script>20    <script src="//unpkg.com/swagger-editor@5.0.0-alpha.86/dist/umd/swagger-editor.js"></script>21    <script>22      SwaggerUIBundle({23        url: 'https://petstore3.swagger.io/api/v3/openapi.json',24        dom_id: '#swagger-ui',25        presets: [26          SwaggerUIBundle.presets.apis,27          SwaggerUIStandalonePreset,28        ],29        plugins: [30          SwaggerEditor.plugins.EditorContentType,31          SwaggerEditor.plugins.EditorPreviewAsyncAPI,32          SwaggerEditor.plugins.EditorPreviewApiDesignSystems,33          SwaggerEditor.plugins.SwaggerUIAdapter,34          SwaggerUIBundle.plugins.DownloadUrl,35        ],36        layout: 'StandaloneLayout',37      });38    </script>39  </body>40</html>
Composing customized SwaggerEditor version
SwaggerEditor is just a number of SwaggerUI plugins used with swagger-ui-react.
Customized SwaggerEditor can be created by composing individual plugins with either swagger-ui and swagger-ui-react.
Plugins
List of available plugins:

dialogs
dropdown-menu
dropzone
editor-content-fixtures
editor-content-origin
editor-content-persistence
editor-content-read-only
editor-content-type
editor-monaco
editor-monaco-language-apidom
editor-preview
editor-preview-api-design-systems
editor-preview-asyncapi
editor-preview-swagger-ui
editor-safe-render
editor-textarea
layout
modals
splash-screen
swagger-ui-adapter
top-bar
versions

Individual plugins can be imported in the following way:
1import EditorContentTypePlugin from 'swagger-editor/plugins/editor-content-type';2import EditorContentReadOnlyPlugin from 'swagger-editor/plugins/editor-content-read-only';
Presets
Along with plugins, presets are available as well. Preset is a collection of plugins
that are design to work together to provide a compound feature.
List of available presets:

textarea
monaco

Individual presets can be imported in the following way:
1import TextareaPreset from 'swagger-editor/presets/textarea';2import MonacoPreset from 'swagger-editor/presets/monaco';

NOTE: Please refer to the Plug points documentation
of SwaggerUI to understand how presets are passed to SwaggerUI.

Composing with swagger-ui
1import SwaggerUI from 'swagger-ui';2import 'swagger-ui/dist/swagger-ui.css';3import ModalsPlugin from 'swagger-editor/plugins/modals';4import DialogsPlugin from 'swagger-editor/plugins/dialogs';5import DropdownMenuPlugin from 'swagger-editor/plugins/dropdown-menu';6import DropzonePlugin from 'swagger-editor/plugins/dropzone';7import VersionsPlugin from 'swagger-editor/plugins/versions';8import EditorTextareaPlugin from 'swagger-editor/plugins/editor-textarea';9import EditorMonacoPlugin from 'swagger-editor/plugins/editor-monaco';10import EditorMonacoLanguageApiDOMPlugin from 'swagger-editor/plugins/editor-monaco-language-apidom';11import EditorContentReadOnlyPlugin from 'swagger-editor/plugins/editor-content-read-only';12import EditorContentOriginPlugin from 'swagger-editor/plugins/editor-content-origin';13import EditorContentTypePlugin from 'swagger-editor/plugins/editor-content-type';14import EditorContentPersistencePlugin from 'swagger-editor/plugins/editor-content-persistence';15import EditorContentFixturesPlugin from 'swagger-editor/plugins/editor-content-fixtures';16import EditorPreviewPlugin from 'swagger-editor/plugins/editor-preview';17import EditorPreviewSwaggerUIPlugin from 'swagger-editor/plugins/editor-preview-swagger-ui';18import EditorPreviewAsyncAPIPlugin from 'swagger-editor/plugins/editor-preview-asyncapi';19import EditorPreviewApiDesignSystemsPlugin from 'swagger-editor/plugins/editor-preview-api-design-systems';20import TopBarPlugin from 'swagger-editor/plugins/top-bar';21import SplashScreenPlugin from 'swagger-editor/plugins/splash-screen';22import LayoutPlugin from 'swagger-editor/plugins/layout';23import EditorSafeRenderPlugin from 'swagger-editor/plugins/editor-safe-render';24
25SwaggerUI({26  url: 'https://petstore.swagger.io/v2/swagger.json',27  dom_id: '#swagger-editor',28  plugins: [29    ModalsPlugin,30    DialogsPlugin,31    DropdownMenuPlugin,32    DropzonePlugin,33    VersionsPlugin,34    EditorTextareaPlugin,35    EditorMonacoPlugin,36    EditorMonacoLanguageApiDOMPlugin,37    EditorContentReadOnlyPlugin,38    EditorContentOriginPlugin,39    EditorContentTypePlugin,40    EditorContentPersistencePlugin,41    EditorContentFixturesPlugin,42    EditorPreviewPlugin,43    EditorPreviewSwaggerUIPlugin,44    EditorPreviewAsyncAPIPlugin,45    EditorPreviewApiDesignSystemsPlugin,46    TopBarPlugin,47    SplashScreenPlugin,48    LayoutPlugin,49    EditorSafeRenderPlugin,50  ],51  layout: 'StandaloneLayout',52});
Composing with swagger-ui-react
1import React from 'react';2import ReactDOM from 'react-dom';3import SwaggerUI from 'swagger-ui-react';4import 'swagger-ui-react/swagger-ui.css';5import ModalsPlugin from 'swagger-editor/plugins/modals';6import DialogsPlugin from 'swagger-editor/plugins/dialogs';7import DropdownMenuPlugin from 'swagger-editor/plugins/dropdown-menu';8import DropzonePlugin from 'swagger-editor/plugins/dropzone';9import VersionsPlugin from 'swagger-editor/plugins/versions';10import EditorTextareaPlugin from 'swagger-editor/plugins/editor-textarea';11import EditorMonacoPlugin from 'swagger-editor/plugins/editor-monaco';12import EditorMonacoLanguageApiDOMPlugin from 'swagger-editor/plugins/editor-monaco-language-apidom';13import EditorContentReadOnlyPlugin from 'swagger-editor/plugins/editor-content-read-only';14import EditorContentOriginPlugin from 'swagger-editor/plugins/editor-content-origin';15import EditorContentTypePlugin from 'swagger-editor/plugins/editor-content-type';16import EditorContentPersistencePlugin from 'swagger-editor/plugins/editor-content-persistence';17import EditorContentFixturesPlugin from 'swagger-editor/plugins/editor-content-fixtures';18import EditorPreviewPlugin from 'swagger-editor/plugins/editor-preview';19import EditorPreviewSwaggerUIPlugin from 'swagger-editor/plugins/editor-preview-swagger-ui';20import EditorPreviewAsyncAPIPlugin from 'swagger-editor/plugins/editor-preview-asyncapi';21import EditorPreviewApiDesignSystemsPlugin from 'swagger-editor/plugins/editor-preview-api-design-systems';22import TopBarPlugin from 'swagger-editor/plugins/top-bar';23import SplashScreenPlugin from 'swagger-editor/plugins/splash-screen';24import LayoutPlugin from 'swagger-editor/plugins/layout';25import EditorSafeRenderPlugin from 'swagger-editor/plugins/editor-safe-render';26
27const SwaggerEditor = () => {28  return (29    <SwaggerUI30      url={url}31      plugins={[32        ModalsPlugin,33        DialogsPlugin,34        DropdownMenuPlugin,35        DropzonePlugin,36        VersionsPlugin,37        EditorTextareaPlugin,38        EditorMonacoPlugin,39        EditorMonacoLanguageApiDOMPlugin,40        EditorContentReadOnlyPlugin,41        EditorContentOriginPlugin,42        EditorContentTypePlugin,43        EditorContentPersistencePlugin,44        EditorContentFixturesPlugin,45        EditorPreviewPlugin,46        EditorPreviewSwaggerUIPlugin,47        EditorPreviewAsyncAPIPlugin,48        EditorPreviewApiDesignSystemsPlugin,49        TopBarPlugin,50        SplashScreenPlugin,51        LayoutPlugin,52        EditorSafeRenderPlugin,53      ]}54      layout="StandaloneLayout"55    />56  );57};58
59ReactDOM.render(<SwaggerEditor />, document.getElementById('swagger-editor'));
Docker
Pre-built DockerHub image
SwaggerEditor is available as a pre-built docker image hosted on docker.swagger.io.
Terminal window1$ docker pull docker.swagger.io/swaggerapi/swagger-editor:next-v52$ docker run -d -p 8080:80 docker.swagger.io/swaggerapi/swagger-editor:next-v5
Building locally
Privileged image:
Terminal window1 $ npm run build:app2 $ docker build . -t swaggerapi/swagger-editor:next-v53 $ docker run -d -p 8080:80 swaggerapi/swagger-editor:next-v5
Now open your browser at http://localhost:8080/.
Unprivileged image:
Terminal window1 $ npm run build:app2 $ docker build . -f Dockerfile.unprivileged -t swaggerapi/swagger-editor:next-v5-unprivileged3 $ docker run -d -p 8080:8080 swaggerapi/swagger-editor:next-v5-unprivileged
Now open your browser at http://localhost:8080/.

No custom environment variables are currently supported by SwaggerEditor.

License
SwaggerEditor is licensed under Apache 2.0 license.
SwaggerEditor comes with an explicit NOTICE file
containing additional legal notifications and information.
This project uses REUSE specification that defines a standardized method
for declaring copyright and licensing for software projects.
Software Bill Of Materials (SBOM)
Software Bill Of materials is available in this repository dependency graph.
Click on Export SBOM button to download the SBOM in SPDX format.     Edit page        Previous  Swagger Editor       Next  Swagger UI Installation\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nInstallation        Distribution channels
NPM Registry
We publish three modules to npm: swagger-ui, swagger-ui-dist and swagger-ui-react.
swagger-ui is meant for consumption by JavaScript web projects that include module bundlers,
such as Webpack, Browserify, and Rollup. Its main file exports Swagger UI’s main function,
and the module also includes a namespaced stylesheet at swagger-ui/dist/swagger-ui.css. Here’s an example:
Installation
You can now install SwaggerUI packages using npm:
Terminal window1 $ npm install swagger-ui
Terminal window1 $ npm install swagger-ui-react
Terminal window1 $ npm install swagger-ui-dist
1import SwaggerUI from 'swagger-ui'2// or use require if you prefer3const SwaggerUI = require('swagger-ui')4
5SwaggerUI({6  dom_id: '#myDomId'7})
See the Webpack Getting Started sample for details.
In contrast, swagger-ui-dist is meant for server-side projects that need assets to serve to clients. The module, when imported, includes an absolutePath helper function that returns the absolute filesystem path to where the swagger-ui-dist module is installed.
Note: we suggest using swagger-ui when your tooling makes it possible, as swagger-ui-dist
will result in more code going across the wire.
The module’s contents mirror the dist folder you see in the Git repository. The most useful file is swagger-ui-bundle.js, which is a build of Swagger UI that includes all the code it needs to run in one file. The folder also has an index.html asset, to make it easy to serve Swagger UI like so:
1const express = require('express')2const pathToSwaggerUi = require('swagger-ui-dist').absolutePath()3
4const app = express()5
6app.use(express.static(pathToSwaggerUi))7
8app.listen(3000)
The module also exports SwaggerUIBundle and SwaggerUIStandalonePreset, so
if you’re in a JavaScript project that can’t handle a traditional npm module,
you could do something like this:
1var SwaggerUIBundle = require('swagger-ui-dist').SwaggerUIBundle2
3const ui = SwaggerUIBundle({4    url: "https://petstore.swagger.io/v2/swagger.json",5    dom_id: '#swagger-ui',6    presets: [7      SwaggerUIBundle.presets.apis,8      SwaggerUIBundle.SwaggerUIStandalonePreset9    ],10    layout: "StandaloneLayout"11  })
SwaggerUIBundle is equivalent to SwaggerUI.
Docker
You can pull a pre-built docker image of the swagger-ui directly from docker.swagger.io:
Terminal window1docker pull docker.swagger.io/swaggerapi/swagger-ui2docker run -p 80:8080 docker.swagger.io/swaggerapi/swagger-ui
Will start nginx with Swagger UI on port 80.
Or you can provide your own swagger.json on your host
Terminal window1docker run -p 80:8080 -e SWAGGER_JSON=/foo/swagger.json -v /bar:/foo docker.swagger.io/swaggerapi/swagger-ui
You can also provide a URL to a swagger.json on an external host:
Terminal window1docker run -p 80:8080 -e SWAGGER_JSON_URL=https://petstore3.swagger.io/api/v3/openapi.json docker.swagger.io/swaggerapi/swagger-ui
The base URL of the web application can be changed by specifying the BASE_URL environment variable:
Terminal window1docker run -p 80:8080 -e BASE_URL=/swagger -e SWAGGER_JSON=/foo/swagger.json -v /bar:/foo docker.swagger.io/swaggerapi/swagger-ui
This will serve Swagger UI at /swagger instead of /.
You can specify a different port via PORT variable for accessing the application, default is 8080.
Terminal window1docker run -p 80:80 -e PORT=80 docker.swagger.io/swaggerapi/swagger-ui
You can specify an IPv6 port via PORT_IPV6 variable. By default, IPv6 port is not set.
Terminal window1docker run -p 80:80 -e PORT_IPV6=8080 docker.swagger.io/swaggerapi/swagger-ui
You can allow/disallow embedding via EMBEDDING variable. By default, embedding is disabled.
Terminal window1docker run -p 80:80 -e EMBEDDING=true docker.swagger.io/swaggerapi/swagger-ui
For more information on controlling Swagger UI through the Docker image, see the Docker section of the Configuration documentation.
unpkg
You can embed Swagger UI’s code directly in your HTML by using unpkg’s interface:
1<!DOCTYPE html>2<html lang="en">3<head>4  <meta charset="utf-8" />5  <meta name="viewport" content="width=device-width, initial-scale=1" />6  <meta name="description" content="SwaggerUI" />7  <title>SwaggerUI</title>8  <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css" />9</head>10<body>11<div id="swagger-ui"></div>12<script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js" crossorigin></script>13<script>14  window.onload = () => {15    window.ui = SwaggerUIBundle({16      url: 'https://petstore3.swagger.io/api/v3/openapi.json',17      dom_id: '#swagger-ui',18    });19  };20</script>21</body>22</html>
Using StandalonePreset will render TopBar and ValidatorBadge as well.
1<!DOCTYPE html>2<html lang="en">3  <head>4    <meta charset="utf-8" />5    <meta name="viewport" content="width=device-width, initial-scale=1" />6    <meta name="description" content="SwaggerUI" />7    <title>SwaggerUI</title>8    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css" />9  </head>10  <body>11  <div id="swagger-ui"></div>12  <script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js" crossorigin></script>13  <script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-standalone-preset.js" crossorigin></script>14  <script>15    window.onload = () => {16      window.ui = SwaggerUIBundle({17        url: 'https://petstore3.swagger.io/api/v3/openapi.json',18        dom_id: '#swagger-ui',19        presets: [20          SwaggerUIBundle.presets.apis,21          SwaggerUIStandalonePreset22        ],23        layout: "StandaloneLayout",24      });25    };26  </script>27  </body>28</html>
See unpkg’s main page for more information on how to use unpkg.
Static files without HTTP or HTML
Once swagger-ui has successfully generated the /dist directory, you can copy this to your own file system and host from there.
Plain old HTML/CSS/JS (Standalone)
The folder /dist includes all the HTML, CSS and JS files needed to run SwaggerUI on a static website or CMS, without requiring NPM.

Download the latest release.
Copy the contents of the /dist folder to your server.
Open swagger-initializer.js in your text editor and replace “https://petstore.swagger.io/v2/swagger.json” with the URL for your OpenAPI 3.0 spec.
     Edit page        Previous  Swagger Editor Next       Next  Configuration\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nConfiguration        How to configure
Swagger UI accepts configuration parameters in three locations.
From lowest to highest precedence:

configuration object passed as an argument to Swagger UI (SwaggerUI({ ... }))
configuration document fetched from a specified configUrl
configuration items passed as key/value pairs in the URL query string

Parameters
Parameters with dots in their names are single strings used to organize subordinate parameters, and are not indicative of a nested structure.
For readability, parameters are grouped by category and sorted alphabetically.
Type notations are formatted like so:

String="" means a String type with a default value of "".
String=["a"*, "b", "c", "d"] means a String type that can be a, b, c, or d, with the * indicating that a is the default value.

Core


















































Parameter nameDocker variableDescriptionconfigUrlCONFIG_URLString. URL to fetch external configuration document from.dom_idDOM_IDString, REQUIRED if domNode is not provided. The ID of a DOM element inside which SwaggerUI will put its user interface.domNodeUnavailableElement, REQUIRED if dom_id is not provided. The HTML DOM element inside which SwaggerUI will put its user interface. Overrides dom_id.specSPECObject={}. A JavaScript object describing the OpenAPI definition. When used, the url parameter will not be parsed. This is useful for testing manually-generated definitions without hosting them.urlURLString. The URL pointing to API definition (normally swagger.json or swagger.yaml). Will be ignored if urls or spec is used.urlsURLSArray. An array of API definition objects ([{url: "<url1>", name: "<name1>"},{url: "<url2>", name: "<name2>"}]) used by Topbar plugin. When used and Topbar plugin is enabled, the url parameter will not be parsed. Names and URLs must be unique among all items in this array, since they’re used as identifiers.urls.primaryNameURLS_PRIMARY_NAMEString. When using urls, you can use this subparameter. If the value matches the name of a spec provided in urls, that spec will be displayed when Swagger UI loads, instead of defaulting to the first spec in urls.queryConfigEnabledQUERY_CONFIG_ENABLEDBoolean=false. Enables overriding configuration parameters via URL search params.
Plugin system
Read more about the plugin system in the Customization documentation.

























Parameter nameDocker variableDescriptionlayoutUnavailableString="BaseLayout". The name of a component available via the plugin system to use as the top-level layout for Swagger UI.pluginsUnavailableArray=[]. An array of plugin functions to use in Swagger UI.presetsUnavailableArray=[SwaggerUI.presets.ApisPreset]. An array of presets to use in Swagger UI. Usually, you’ll want to include ApisPreset if you use this option.
Display

    
    
        Parameter name
        Docker variable
        Description
    
    
    
    
        deepLinking
        DEEP_LINKING
        Boolean=false. If set to true, enables
            deep linking for tags and operations. See the Deep Linking
                documentation for more information.
        
    
    
        displayOperationId
        
        DISPLAY_OPERATION_ID
        Boolean=false. Controls the display of operationId in
            operations list. The default is false.
        
    
    
        defaultModelsExpandDepth
        
        DEFAULT_MODELS_EXPAND_DEPTH
        Number=1. The default expansion depth for models (set
            to -1 completely hide the models).
        
    
    
        defaultModelExpandDepth
        
        DEFAULT_MODEL_EXPAND_DEPTH
        Number=1. The default expansion depth for the model on
            the model-example section.
        
    
    
        defaultModelRendering
        
        DEFAULT_MODEL_RENDERING
        String=["example"*, "model"]. Controls how the model is
            shown when the API is first rendered. (The user can always switch
            the rendering for a given model by clicking the 'Model' and 'Example
            Value' links.)
        
    
    
        displayRequestDuration
        
        DISPLAY_REQUEST_DURATION
        Boolean=false. Controls the display of the request
            duration (in milliseconds) for "Try it out" requests.
        
    
    
        docExpansion
        
        DOC_EXPANSION
        String=["list"*, "full", "none"]. Controls the default
            expansion setting for the operations and tags. It can be 'list'
            (expands only the tags), 'full' (expands the tags and operations) or
            'none' (expands nothing).
        
    
    
        filter
        FILTER
        Boolean=false OR String. If set, enables filtering. The
            top bar will show an edit box that you can use to filter the tagged
            operations that are shown. Can be Boolean to enable or disable, or a
            string, in which case filtering will be enabled using that string as
            the filter expression. Filtering is case sensitive matching the
            filter expression anywhere inside the tag.
        
    
    
        
            maxDisplayedTags
        
        MAX_DISPLAYED_TAGS
        Number. If set, limits the number of tagged operations
            displayed to at most this many. The default is to show all
            operations.
        
    
    
        
            operationsSorter
        
        Unavailable
        Function=(a => a). Apply a sort to the operation
            list of each API. It can be 'alpha' (sort by paths
            alphanumerically), 'method' (sort by HTTP method) or a function (see
            Array.prototype.sort() to know how sort function works). Default is
            the order returned by the server unchanged.
        
    
    
        
            showExtensions
        
        SHOW_EXTENSIONS
        Boolean=false. Controls the display of vendor extension
            (x-) fields and values for Operations, Parameters,
            Responses, and Schema.
        
    
    
        showCommonExtensions
        
        SHOW_COMMON_EXTENSIONS
        Boolean=false. Controls the display of extensions
            (pattern, maxLength,
            minLength, maximum, minimum)
            fields and values for Parameters.
        
    
    
        tagsSorter
        Unavailable
        Function=(a => a). Apply a sort to the tag list of
            each API. It can be 'alpha' (sort by paths alphanumerically) or a
            function (see Array.prototype.sort() to learn how to
            write a sort function). Two tag name strings are passed to the
            sorter for each pass. Default is the order determined by Swagger UI.
        
    
    
        
            useUnsafeMarkdown
        
        USE_UNSAFE_MARKDOWN
        Boolean=false. When enabled, sanitizer will leave
            style, class and data-*
            attributes untouched on all HTML Elements declared inside markdown
            strings. This parameter is Deprecated and will be
            removed in 4.0.0.
        
    
    
        onComplete
        Unavailable
        Function=NOOP. Provides a mechanism to be notified when
            Swagger UI has finished rendering a newly provided definition.
        
    
    
        
            syntaxHighlight
        
        Unavailable
        Set to false to deactivate syntax highlighting of
            payloads and cURL command, can be otherwise an object with the
            activated and theme properties.
        
    
    
        syntaxHighlight.activated
        
        Unavailable
        Boolean=true. Whether syntax highlighting should be
            activated or not.
        
    
    
        syntaxHighlight.theme
        
        Unavailable
        String=["agate"*, "arta", "monokai", "nord", "obsidian",
            "tomorrow-night", "idea"]. Highlight.js
            syntax coloring theme to use. (Only these 7 styles are available.)
        
    
    
        
            tryItOutEnabled
        
        TRY_IT_OUT_ENABLED
        Boolean=false. Controls whether the "Try it out"
            section should be enabled by default.
        
    
    
        requestSnippetsEnabled
        
        Unavailable
        Boolean=false. Enables the request snippet section.
            When disabled, the legacy curl snippet will be used.
        
    
    
        
            requestSnippets
        
        Unavailable
        
Object={
  generators: {
    curl_bash: {
      title: "cURL (bash)",
      syntax: "bash"
    },
    curl_powershell: {
      title: "cURL (PowerShell)",
      syntax: "powershell"
    },
    curl_cmd: {
      title: "cURL (CMD)",
      syntax: "bash"
    },
  },
  defaultExpanded: true,
  languages: null, 
  // e.g. only show curl bash = ["curl_bash"]
}


            This is the default configuration section for the
            requestSnippets plugin.
        
    
    

Network


















































Parameter nameDocker variableDescriptionoauth2RedirectUrlOAUTH2_REDIRECT_URLString. OAuth redirect URL.requestInterceptorUnavailableFunction=(a => a). MUST be a function.  Function to intercept remote definition, “Try it out”, and OAuth 2.0 requests.  Accepts one argument requestInterceptor(request) and must return the modified request, or a Promise that resolves to the modified request.request.curlOptionsUnavailableArray.  If set, MUST be an array of command line options available to the curl command.  This can be set on the mutated request in the requestInterceptor function. For example request.curlOptions = ["-g", "--limit-rate 20k"]responseInterceptorUnavailableFunction=(a => a). MUST be a function.  Function to intercept remote definition, “Try it out”, and OAuth 2.0 responses.  Accepts one argument responseInterceptor(response) and must return the modified response, or a Promise that resolves to the modified response.showMutatedRequestSHOW_MUTATED_REQUESTBoolean=true. If set to true, uses the mutated request returned from a requestInterceptor to produce the curl command in the UI, otherwise the request before the requestInterceptor was applied is used.supportedSubmitMethodsSUPPORTED_SUBMIT_METHODSArray=["get", "put", "post", "delete", "options", "head", "patch", "trace"]. List of HTTP methods that have the “Try it out” feature enabled. An empty array disables “Try it out” for all operations. This does not filter the operations from the display.validatorUrlVALIDATOR_URLString="https://validator.swagger.io/validator" OR null. By default, Swagger UI attempts to validate specs against swagger.io’s online validator. You can use this parameter to set a different validator URL, for example for locally deployed validators (Validator Badge). Setting it to either none, 127.0.0.1 or localhost will disable validation.withCredentialsWITH_CREDENTIALSBoolean=false If set to true, enables passing credentials, as defined in the Fetch standard, in CORS requests that are sent by the browser. Note that Swagger UI cannot currently set cookies cross-domain (see swagger-js#1163) - as a result, you will have to rely on browser-supplied cookies (which this setting enables sending) that Swagger UI cannot control.
Macros




















Parameter nameDocker variableDescriptionmodelPropertyMacroUnavailableFunction. Function to set default values to each property in model. Accepts one argument modelPropertyMacro(property), property is immutableparameterMacroUnavailableFunction. Function to set default value to parameters. Accepts two arguments parameterMacro(operation, parameter). Operation and parameter are objects passed for context, both remain immutable
Authorization















Parameter nameDocker variableDescriptionpersistAuthorizationPERSIST_AUTHORIZATIONBoolean=false. If set to true, it persists authorization data and it would not be lost on browser close/refresh
Instance methods
💡 Take note! These are methods, not parameters.

























Method nameDocker variableDescriptioninitOAuthSee oauth2.md(configObj) => void. Provide Swagger UI with information about your OAuth server - see the OAuth 2.0 documentation for more information.preauthorizeBasicUnavailable(authDefinitionKey, username, password) => action. Programmatically set values for a Basic authorization scheme.preauthorizeApiKeyUnavailable(authDefinitionKey, apiKeyValue) => action. Programmatically set values for an API key or Bearer authorization scheme. In case of OpenAPI 3.0 Bearer scheme, apiKeyValue must contain just the token itself without the Bearer prefix.
Docker
If you’re using the Docker image, you can also control most of these options with environment variables. Each parameter has its environment variable name noted, if available.
Below are the general guidelines for using the environment variable interface.
String variables
Set the value to whatever string you’d like, taking care to escape characters where necessary
Example:
Terminal window1FILTER="myFilterValue"2LAYOUT="BaseLayout"
Boolean variables
Set the value to true or false.
Example:
Terminal window1DISPLAY_OPERATION_ID="true"2DEEP_LINKING="false"
Number variables
Set the value to n, where n is the number you’d like to provide.
Example:
Terminal window1DEFAULT_MODELS_EXPAND_DEPTH="5"2DEFAULT_MODEL_EXPAND_DEPTH="7"
Array variables
Set the value to the literal array value you’d like, taking care to escape characters where necessary.
Example:
Terminal window1SUPPORTED_SUBMIT_METHODS="[\"get\", \"post\"]"2URLS="[ { url: \"https://petstore.swagger.io/v2/swagger.json\", name: \"Petstore\" } ]"
Object variables
Set the value to the literal object value you’d like, taking care to escape characters where necessary.
Example:
Terminal window1SPEC="{ \"openapi\": \"3.0.4\" }"
Docker-Compose
.env file example encoding
Terminal window1SUPPORTED_SUBMIT_METHODS=['get', 'post']2URLS=[ { url: 'https://petstore.swagger.io/v2/swagger.json', name: 'Petstore' } ]     Edit page        Previous  Swagger UI Installation       Next  CORS\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nCORS        CORS is a technique to prevent websites from doing bad things with your personal data.  Most browsers + JavaScript toolkits not only support CORS but enforce it, which has implications for your API server which supports Swagger.
You can read about CORS here: http://www.w3.org/TR/cors.
There are two cases where no action is needed for CORS support:

Swagger UI is hosted on the same server as the application itself (same host and port).
The application is located behind a proxy that enables the required CORS headers. This may already be covered within your organization.

Otherwise, CORS support needs to be enabled for:

Your Swagger docs. For Swagger 2.0 it’s the swagger.json/swagger.yaml and any externally $refed docs.
For the Try it now button to work, CORS needs to be enabled on your API endpoints as well.

Testing CORS Support
You can verify CORS support with one of three techniques:

Curl your API and inspect the headers.  For instance:

Terminal window1$ curl -I "https://petstore.swagger.io/v2/swagger.json"2HTTP/1.1 200 OK3Date: Sat, 31 Jan 2015 23:05:44 GMT4Access-Control-Allow-Origin: *5Access-Control-Allow-Methods: GET, POST, DELETE, PUT, PATCH, OPTIONS6Access-Control-Allow-Headers: Content-Type, api_key, Authorization7Content-Type: application/json8Content-Length: 0
This tells us that the petstore resource listing supports OPTIONS, and the following headers:  Content-Type, api_key, Authorization.

Try Swagger UI from your file system and look at the debug console.  If CORS is not enabled, you’ll see something like this:

1XMLHttpRequest cannot load http://sad.server.com/v2/api-docs. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access.
Swagger UI cannot easily show this error state.

Use the https://www.test-cors.org website to verify CORS support. Keep in mind this will show a successful result even if Access-Control-Allow-Headers is not available, which is still required for Swagger UI to function properly.

Enabling CORS
The method of enabling CORS depends on the server and/or framework you use to host your application. https://enable-cors.org provides information on how to enable CORS in some common web servers.
Other servers/frameworks may provide you information on how to enable it specifically in their use case.
CORS and Header Parameters
Swagger UI lets you easily send headers as parameters to requests.  The name of these headers MUST be supported in your CORS configuration as well.  From our example above:
1Access-Control-Allow-Headers: Content-Type, api_key, Authorization
Only headers with these names will be allowed to be sent by Swagger UI.     Edit page        Previous  Configuration       Next  OAuth 2.0\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nOAuth 2.0 configuration        You can configure OAuth 2.0 authorization by calling the initOAuth method.























































Property nameDocker variableDescriptionclientIdOAUTH_CLIENT_IDDefault clientId. MUST be a stringclientSecretOAUTH_CLIENT_SECRET🚨 Never use this parameter in your production environment. It exposes crucial security information. This feature is intended for dev/test environments only. 🚨 Default clientSecret. MUST be a stringrealmOAUTH_REALMrealm query parameter (for oauth1) added to authorizationUrl and tokenUrl. MUST be a stringappNameOAUTH_APP_NAMEapplication name, displayed in authorization popup. MUST be a stringscopeSeparatorOAUTH_SCOPE_SEPARATORscope separator for passing scopes, encoded before calling, default value is a space (encoded value %20). MUST be a stringscopesOAUTH_SCOPESstring array or scope separator (i.e. space) separated string of initially selected oauth scopes, default is empty arrayadditionalQueryStringParamsOAUTH_ADDITIONAL_PARAMSAdditional query parameters added to authorizationUrl and tokenUrl. MUST be an objectuseBasicAuthenticationWithAccessCodeGrantOAUTH_USE_BASIC_AUTHOnly activated for the accessCode flow.  During the authorization_code request to the tokenUrl, pass the Client Password using the HTTP Basic Authentication scheme (Authorization header with Basic base64encode(client_id + client_secret)).  The default is falseusePkceWithAuthorizationCodeGrantOAUTH_USE_PKCEOnly applies to Authorization Code flows. Proof Key for Code Exchange brings enhanced security for OAuth public clients. The default is false Note: This option does not hide the client secret input because neither PKCE nor client secrets are replacements for each other.
1const ui = SwaggerUI({...})2
3// Method can be called in any place after calling constructor SwaggerUIBundle4ui.initOAuth({5    clientId: "your-client-id",6    clientSecret: "your-client-secret-if-required",7    realm: "your-realms",8    appName: "your-app-name",9    scopeSeparator: " ",10    scopes: "openid profile",11    additionalQueryStringParams: {test: "hello"},12    useBasicAuthenticationWithAccessCodeGrant: true,13    usePkceWithAuthorizationCodeGrant: true14  })     Edit page        Previous  CORS       Next  Deep Linking\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDeep Linking        Swagger UI allows you to deeply link into tags and operations within a spec. When Swagger UI is provided a URL fragment at runtime, it will automatically expand and scroll to a specified tag or operation.
Usage
👉🏼 Add deepLinking: true to your Swagger UI configuration to enable this functionality. This is demonstrated in dist/index.html.
When you expand a tag or operation, Swagger UI will automatically update its URL fragment with a deep link to the item.
Conversely, when you collapse a tag or operation, Swagger UI will clear the URL fragment.
You can also right-click a tag name or operation path to copy a link to that tag or operation.
Fragment format
The fragment is formatted in one of two ways:

#/{tagName}, to trigger the focus of a specific tag
#/{tagName}/{operationId}, to trigger the focus of a specific operation within a tag

operationId is the explicit operationId provided in the spec, if one exists.
Otherwise, Swagger UI generates an implicit operationId by combining the operation’s path and method, while escaping non-alphanumeric characters.
FAQ

I’m using Swagger UI in an application that needs control of the URL fragment. How do I disable deep-linking?

This functionality is disabled by default, but you can pass deepLinking: false into Swagger UI as a configuration item to be sure.

Can I link to multiple tags or operations?

No, this is not supported.

Can I collapse everything except the operation or tag I’m linking to?

Sure - use docExpansion: none to collapse all tags and operations. Your deep link will take precedence over the setting, so only the tag or operation you’ve specified will be expanded.     Edit page        Previous  OAuth 2.0       Next  Limitations\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nLimitations        Forbidden header names
Some header names cannot be controlled by web applications, due to security
features built into web browsers.
Forbidden headers include:


Accept-Charset
Accept-Encoding
Access-Control-Request-Headers
Access-Control-Request-Method
Connection
Content-Length
Cookie
Cookie2
Date
DNT
Expect
Host
Keep-Alive
Origin
Proxy-*
Sec-*
Referer
TE
Trailer
Transfer-Encoding
Upgrade
Via

Forbidden header names (developer.mozilla.org)

The biggest impact of this is that OpenAPI 3.0 Cookie parameters cannot be
controlled when running Swagger UI in a browser.
For more context, see #3956.     Edit page        Previous  Deep Linking       Next  Version detection\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDetecting your Swagger UI version        At times, you’re going to need to know which version of Swagger UI you use.
The first step would be to detect which major version you currently use, as the method of detecting the version has changed. If your Swagger UI has been heavily modified and you cannot detect from the look and feel which major version you use, you’d have to try both methods to get the exact version.
To help you visually detect which version you’re using, we’ve included supporting images.
Swagger UI 3.x

Some distinct identifiers to Swagger UI 3.x:

The API version appears as a badge next to its title.
If there are schemes or authorizations, they’d appear in a bar above the operations.
Try it out functionality is not enabled by default.
All the response codes in the operations appear at after the parameters.
There’s a models section after the operations.

If you’ve determined this is the version you have, to find the exact version:

Open your browser’s web console (changes between browsers)
Type JSON.stringify(versions) in the console and execute the call.
The result should look similar to swaggerUi : Object { version: "3.1.6", gitRevision: "g786cd47", gitDirty: true, … }.
The version taken from that example would be 3.1.6.

Note: This functionality was added in 3.0.8. If you’re unable to execute it, you’re likely to use an older version, and in that case the first step would be to upgrade.
Swagger UI 2.x and under

Some distinct identifiers to Swagger UI 2.x:

The API version appears at the bottom of the page.
Schemes are not rendered.
Authorization, if rendered, will appear next to the navigation bar.
Try it out functionality is enabled by default.
The successful response code would appear above the parameters, the rest below them.
There’s no models section after the operations.

If you’ve determined this is the version you have, to find the exact version:

Navigate to the sources of the UI. Either on your disk or via the view page source functionality in your browser.
Find an open the swagger-ui.js
At the top of the page, there would be a comment containing the exact version of Swagger UI. This example shows version 2.2.9:

1/**2 * swagger-ui - Swagger UI is a dependency-free collection of HTML, JavaScript, and CSS assets that dynamically generate beautiful documentation from a Swagger-compliant API3 * @version v2.2.94 * @link https://swagger.io5 * @license Apache-2.06 */     Edit page        Previous  Limitations       Next  Overview\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nPlugin system overview        Prior art
Swagger UI leans heavily on concepts and patterns found in React and Redux.
If you aren’t already familiar, here’s some suggested reading:

React: Quick Start (reactjs.org)
Redux README (redux.js.org)

In the following documentation, we won’t take the time to define the fundamentals covered in the resources above.

Note: Some of the examples in this section contain JSX, which is a syntax extension to JavaScript that is useful for writing React components.
If you don’t want to set up a build pipeline capable of translating JSX to JavaScript, take a look at React without JSX (reactjs.org). You can use our system.React reference to leverage React without needing to pull a copy into your project.

The System
The system is the heart of the Swagger UI application. At runtime, it’s a JavaScript object that holds many things:

React components
Bound Redux actions and reducers
Bound Reselect state selectors
System-wide collection of available components
Built-in helpers like getComponent, makeMappedContainer, and getStore
References to the React and Immutable.js libraries (system.React, system.Im)
User-defined helper functions

The system is built up when Swagger UI is called by iterating through (“compiling”) each plugin that Swagger UI has been given, through the presets and plugins configuration options.
Presets
Presets are arrays of plugins, which are provided to Swagger UI through the presets configuration option. All plugins within presets are compiled before any plugins provided via the plugins configuration option. Consider the following example:
1const MyPreset = [FirstPlugin, SecondPlugin, ThirdPlugin]2
3SwaggerUI({4  presets: [5    MyPreset6  ]7})
By default, Swagger UI includes the internal ApisPreset, which contains a set of plugins that provide baseline functionality for Swagger UI. If you specify your own presets option, you need to add the ApisPreset manually, like so:
1SwaggerUI({2  presets: [3    SwaggerUI.presets.apis,4    MyAmazingCustomPreset5  ]6})
The need to provide the apis preset when adding other presets is an artifact of Swagger UI’s original design, and will likely be removed in the next major version.
getComponent
getComponent is a helper function injected into every container component, which is used to get references to components provided by the plugin system.
All components should be loaded through getComponent, since it allows other plugins to modify the component. It is preferred over a conventional import statement.
Container components in Swagger UI can be loaded by passing true as the second argument to getComponent, like so:
1getComponent("ContainerComponentName", true)
This will map the current system as props to the component.     Edit page        Previous  Version detection       Next  Plugin API\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nPlugins        A plugin is a function that returns an object - more specifically, the object may contain functions and components that augment and modify Swagger UI’s functionality.
Note: Semantic Versioning
Swagger UI’s internal APIs are not part of our public contract, which means that they can change without the major version change.
If your custom plugins wrap, extend, override, or consume any internal core APIs, we recommend specifying a specific minor version of Swagger UI to use in your application, because they will not change between patch versions.
If you’re installing Swagger UI via NPM, for example, you can do this by using a tilde:
1{2  "dependencies": {3    "swagger-ui": "~3.11.0"4  }5}
Format
A plugin return value may contain any of these keys, where stateKey is a name for a piece of state:
1{2  statePlugins: {3    [stateKey]: {4      actions,5      reducers,6      selectors,7      wrapActions,8      wrapSelectors9    }10  },11  components: {},12  wrapComponents: {},13  rootInjects: {},14  afterLoad: (system) => {},15  fn: {},16}
System is provided to plugins
Let’s assume we have a plugin, NormalPlugin, that exposes a doStuff action under the normal state namespace.
1const ExtendingPlugin = function(system) {2  return {3    statePlugins: {4      extending: {5        actions: {6          doExtendedThings: function(...args) {7            // you can do other things in here if you want8            return system.normalActions.doStuff(...args)9          }10        }11      }12    }13  }14}
As you can see, each plugin is passed a reference to the system being built up. As long as NormalPlugin is compiled before ExtendingPlugin, this will work without any issues.
There is no dependency management built into the plugin system, so if you create a plugin that relies on another, it is your responsibility to make sure that the dependent plugin is loaded after the plugin being depended on.
Interfaces
Actions
1const MyActionPlugin = () => {2  return {3    statePlugins: {4      example: {5        actions: {6          updateFavoriteColor: (str) => {7            return {8              type: "EXAMPLE_SET_FAV_COLOR",9              payload: str10            }11          }12        }13      }14    }15  }16}
Once an action has been defined, you can use it anywhere that you can get a system reference:
1// elsewhere2system.exampleActions.updateFavoriteColor("blue")
The Action interface enables the creation of new Redux action creators within a piece of state in the Swagger UI system.
This action creator function will be exposed to container components as exampleActions.updateFavoriteColor. When this action creator is called, the return value (which should be a Flux Standard Action) will be passed to the example reducer, which we’ll define in the next section.
For more information about the concept of actions in Redux, see the Redux Actions documentation.
Reducers
Reducers take a state (which is an Immutable.js map) and an action, then returns a new state.
Reducers must be provided to the system under the name of the action type that they handle, in this case, EXAMPLE_SET_FAV_COLOR.
1const MyReducerPlugin = function(system) {2  return {3    statePlugins: {4      example: {5        reducers: {6          "EXAMPLE_SET_FAV_COLOR": (state, action) => {7            // you're only working with the state under the namespace, in this case "example".8            // So you can do what you want, without worrying about /other/ namespaces9            return state.set("favColor", action.payload)10          }11        }12      }13    }14  }15}
Selectors
Selectors reach into their namespace’s state to retrieve or derive data from the state.
They’re an easy way to keep logic in one place, and are preferred over passing state data directly into components.
1const MySelectorPlugin = function(system) {2  return {3    statePlugins: {4      example: {5        selectors: {6          myFavoriteColor: (state) => state.get("favColor")7        }8      }9    }10  }11}
You can also use the Reselect library to memoize your selectors, which is recommended for any selectors that will see heavy use, since Reselect automatically memoizes selector calls for you:
1import { createSelector } from "reselect"2
3const MySelectorPlugin = function(system) {4  return {5    statePlugins: {6      example: {7        selectors: {8          // this selector will be memoized after it is run once for a9          // value of `state`10          myFavoriteColor: createSelector((state) => state.get("favColor"))11        }12      }13    }14  }15}
Once a selector has been defined, you can use it anywhere that you can get a system reference:
1system.exampleSelectors.myFavoriteColor() // gets `favColor` in state for you
Components
You can provide a map of components to be integrated into the system.
Be mindful of the key names for the components you provide, as you’ll need to use those names to refer to the components elsewhere.
1class HelloWorldClass extends React.Component {2  render() {3    return <h1>Hello World!</h1>4  }5}6
7const MyComponentPlugin = function(system) {8  return {9    components: {10      HelloWorldClass: HelloWorldClass11      // components can just be functions, these are called "stateless components"12      HelloWorldStateless: () => <h1>Hello World!</h1>,13    }14  }15}
1// elsewhere2const HelloWorldStateless = system.getComponent("HelloWorldStateless")3const HelloWorldClass = system.getComponent("HelloWorldClass")
You can also “cancel out” any components that you don’t want by creating a stateless component that always returns null:
1const NeverShowInfoPlugin = function(system) {2  return {3    components: {4      info: () => null5    }6  }7}
You can use config.failSilently if you don’t want a warning when a component doesn’t exist in the system.
Be mindful of getComponent arguments order. In the example below, the boolean false refers to presence of a container, and the 3rd argument is the config object used to suppress the missing component warning.
1const thisVariableWillBeNull = getComponent("not_real", false, { failSilently: true })
Wrap-Actions
Wrap Actions allow you to override the behavior of an action in the system.
They are function factories with the signature (oriAction, system) => (...args) => result.
A Wrap Action’s first argument is oriAction, which is the action being wrapped. It is your responsibility to call the oriAction - if you don’t, the original action will not fire!
This mechanism is useful for conditionally overriding built-in behaviors, or listening to actions.
1// FYI: in an actual Swagger UI, `updateSpec` is already defined in the core code2// it's just here for clarity on what's behind the scenes3const MySpecPlugin = function(system) {4  return {5    statePlugins: {6      spec: {7        actions: {8          updateSpec: (str) => {9            return {10              type: "SPEC_UPDATE_SPEC",11              payload: str12            }13          }14        }15      }16    }17  }18}19
20// this plugin allows you to watch changes to the spec that is in memory21const MyWrapActionPlugin = function(system) {22  return {23    statePlugins: {24      spec: {25        wrapActions: {26          updateSpec: (oriAction, system) => (str) => {27            // here, you can hand the value to some function that exists outside of Swagger UI28            console.log("Here is my API definition", str)29            return oriAction(str) // don't forget! otherwise, Swagger UI won't update30          }31        }32      }33    }34  }35}
Wrap-Selectors
Wrap Selectors allow you to override the behavior of a selector in the system.
They are function factories with the signature (oriSelector, system) => (state, ...args) => result.
This interface is useful for controlling what data flows into components. We use this in the core code to disable selectors based on the API definition’s version.
1import { createSelector } from 'reselect'2
3// FYI: in an actual Swagger UI, the `url` spec selector is already defined4// it's just here for clarity on what's behind the scenes5const MySpecPlugin = function(system) {6  return {7    statePlugins: {8      spec: {9        selectors: {10          url: createSelector(11            state => state.get("url")12          )13        }14      }15    }16  }17}18
19const MyWrapSelectorsPlugin = function(system) {20  return {21    statePlugins: {22      spec: {23        wrapSelectors: {24          url: (oriSelector, system) => (state, ...args) => {25            console.log('someone asked for the spec url!!! it is', state.get('url'))26            // you can return other values here...27            // but let's just enable the default behavior28            return oriSelector(state, ...args)29          }30        }31      }32    }33  }34}
Wrap-Components
Wrap Components allow you to override a component registered within the system.
Wrap Components are function factories with the signature (OriginalComponent, system) => props => ReactElement. If you’d prefer to provide a React component class, (OriginalComponent, system) => ReactClass works as well.
1const MyWrapBuiltinComponentPlugin = function(system) {2  return {3    wrapComponents: {4      info: (Original, system) => (props) => {5        return <div>6          <h3>Hello world! I am above the Info component.</h3>7          <Original {...props} />8        </div>9      }10    }11  }12}
Here’s another example that includes a code sample of a component that will be wrapped:
1/////  Overriding a component from a plugin2
3// Here's our normal, unmodified component.4const MyNumberDisplayPlugin = function(system) {5  return {6    components: {7      NumberDisplay: ({ number }) => <span>{number}</span>8    }9  }10}11
12// Here's a component wrapper defined as a function.13const MyWrapComponentPlugin = function(system) {14  return {15    wrapComponents: {16      NumberDisplay: (Original, system) => (props) => {17        if(props.number > 10) {18          return <div>19            <h3>Warning! Big number ahead.</h3>20            <Original {...props} />21          </div>22        } else {23          return <Original {...props} />24        }25      }26    }27  }28}29
30// Alternatively, here's the same component wrapper defined as a class.31const MyWrapComponentPlugin = function(system) {32  return {33    wrapComponents: {34      NumberDisplay: (Original, system) => class WrappedNumberDisplay extends React.component {35        render() {36          if(props.number > 10) {37            return <div>38              <h3>Warning! Big number ahead.</h3>39              <Original {...props} />40            </div>41          } else {42            return <Original {...props} />43          }44        }45      }46    }47  }48}
rootInjects
The rootInjects interface allows you to inject values at the top level of the system.
This interface takes an object, which will be merged in with the top-level system object at runtime.
1const MyRootInjectsPlugin = function(system) {2  return {3    rootInjects: {4      myConstant: 123,5      myMethod: (...params) => console.log(...params)6    }7  }8}
afterLoad
The afterLoad plugin method allows you to get a reference to the system after your plugin has been registered.
This interface is used in the core code to attach methods that are driven by bound selectors or actions. You can also use it to execute logic that requires your plugin to already be ready, for example fetching initial data from a remote endpoint and passing it to an action your plugin creates.
The plugin context, which is bound to this, is undocumented, but below is an example of how to attach a bound action as a top-level method:
1const MyMethodProvidingPlugin = function() {2  return {3    afterLoad(system) {4      // at this point in time, your actions have been bound into the system5      // so you can do things with them6      this.rootInjects = this.rootInjects || {}7      this.rootInjects.myMethod = system.exampleActions.updateFavoriteColor8    },9    statePlugins: {10      example: {11        actions: {12          updateFavoriteColor: (str) => {13            return {14              type: "EXAMPLE_SET_FAV_COLOR",15              payload: str16            }17          }18        }19      }20    }21  }22}
fn
The fn interface allows you to add helper functions to the system for use elsewhere.
1import leftPad from "left-pad"2
3const MyFnPlugin = function(system) {4  return {5    fn: {6      leftPad: leftPad7    }8  }9}     Edit page        Previous  Overview       Next  Plug points\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nPlug points        Swagger UI exposes most of its internal logic through the plugin system.
Often, it is beneficial to override the core internals to achieve custom behavior.
Note: Semantic Versioning
Swagger UI’s internal APIs are not part of our public contract, which means that they can change without the major version change.
If your custom plugins wrap, extend, override, or consume any internal core APIs, we recommend specifying a specific minor version of Swagger UI to use in your application, because they will not change between patch versions.
If you’re installing Swagger UI via NPM, for example, you can do this by using a tilde:
1{2  "dependencies": {3    "swagger-ui": "~3.11.0"4  }5}
fn.opsFilter
When using the filter option, tag names will be filtered by the user-provided value. If you’d like to customize this behavior, you can override the default opsFilter function.
For example, you can implement a multiple-phrase filter:
1const MultiplePhraseFilterPlugin = function() {2  return {3    fn: {4      opsFilter: (taggedOps, phrase) => {5        const phrases = phrase.split(", ")6
7        return taggedOps.filter((val, key) => {8          return phrases.some(item => key.indexOf(item) > -1)9        })10      }11    }12  }13}
Logo component
While using the Standalone Preset the SwaggerUI logo is rendered in the Top Bar.
The logo can be exchanged by replacing the Logo component via the plugin api:
1import React from "react";2const MyLogoPlugin = {3  components: {4    Logo: () => (5      <img alt="My Logo" height="40" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTM3IiBoZWlnaHQ9IjEzNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCiA8Zz4KICA8dGl0bGU+TGF5ZXIgMTwvdGl0bGU+CiAgPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMy40Nzc2OSAwIDAgMy4yNjA2NyAtNjczLjEyOCAtNjkxLjk5MykiIHN0cm9rZT0iIzAwMCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmb250LXdlaWdodD0ibm9ybWFsIiB4bWw6c3BhY2U9InByZXNlcnZlIiB0ZXh0LWFuY2hvcj0ic3RhcnQiIGZvbnQtZmFtaWx5PSInT3BlbiBTYW5zIEV4dHJhQm9sZCciIGZvbnQtc2l6ZT0iMjQiIGlkPSJzdmdfMSIgeT0iMjQxLjIyMTkyIiB4PSIxOTYuOTY5MjEiIHN0cm9rZS13aWR0aD0iMCIgZmlsbD0iIzYyYTAzZiI+TXkgTG9nbzwvdGV4dD4KICA8cGF0aCBpZD0ic3ZnXzIiIGQ9Im0zOTUuNjAyNSw1MS4xODM1OWw1My44Nzc3MSwwbDE2LjY0ODYzLC01MS4xODM1OGwxNi42NDg2NCw1MS4xODM1OGw1My44Nzc3LDBsLTQzLjU4NzksMzEuNjMyODNsMTYuNjQ5NDksNTEuMTgzNThsLTQzLjU4NzkyLC0zMS42MzM2OWwtNDMuNTg3OTEsMzEuNjMzNjlsMTYuNjQ5NDksLTUxLjE4MzU4bC00My41ODc5MiwtMzEuNjMyODN6IiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZT0iIzAwMCIgZmlsbD0iIzYyYTAzZiIvPgogPC9nPgo8L3N2Zz4="/>6    )7  }8}
JSON Schema components
In swagger there are so called JSON Schema components. These are used to render inputs for parameters and components of request bodies with application/x-www-form-urlencoded or multipart/* media-type.
Internally swagger uses following mapping to find the JSON Schema component from OpenAPI Specification schema information:
For each schema’s type(eg. string, array, …) and if defined schema’s format (eg. ‘date’, ‘uuid’, …) there is a corresponding component mapping:
If format defined:
1`JsonSchema_${type}_${format}`
Fallback if JsonSchema_${type}_${format} component does not exist or format not defined:
1`JsonSchema_${type}`
Default:
1`JsonSchema_string`
With this, one can define custom input components or override existing.
Example Date-Picker plugin
If one would like to input date values you could provide a custom plugin to integrate react-datepicker into swagger-ui.
All you need to do is to create a component to wrap react-datepicker accordingly to the format.
There are two cases:


1type: string2format: date
The resulting name for mapping to succeed: JsonSchema_string_date

1type: string2format: date-time
The resulting name for mapping to succeed: JsonSchema_string_date-time

This creates the need for two components and simple logic to strip any time input in case the format is date:
1import React from "react";2import DatePicker from "react-datepicker";3import "react-datepicker/dist/react-datepicker.css";4
5const JsonSchema_string_date = (props) => {6  const dateNumber = Date.parse(props.value);7  const date = dateNumber8    ? new Date(dateNumber)9    : new Date();10
11  return (12    <DatePicker13      selected={date}14      onChange={d => props.onChange(d.toISOString().substring(0, 10))}15    />16  );17}18
19const JsonSchema_string_date_time = (props) => {20  const dateNumber = Date.parse(props.value);21  const date = dateNumber22    ? new Date(dateNumber)23    : new Date();24
25  return (26    <DatePicker27      selected={date}28      onChange={d => props.onChange(d.toISOString())}29      showTimeSelect30      timeFormat="p"31      dateFormat="Pp"32    />33  );34}35
36
37export const DateTimeSwaggerPlugin = {38  components: {39    JsonSchema_string_date: JsonSchema_string_date,40    "JsonSchema_string_date-time": JsonSchema_string_date_time41  }42};
Request Snippets
SwaggerUI can be configured with the requestSnippetsEnabled: true option to activate Request Snippets.
Instead of the generic curl that is generated upon doing a request. It gives you more granular options:

curl for bash
curl for cmd
curl for powershell

There might be the case where you want to provide your own snipped generator. This can be done by using the plugin api.
A Request Snipped generator consists of the configuration and a fn,
which takes the internal request object and transforms it to the desired snippet.
1// Add config to Request Snippets Configuration with an unique key like "node_native"2const snippetConfig = {3  requestSnippetsEnabled: true,4  requestSnippets: {5    generators: {6      "node_native": {7        title: "NodeJs Native",8        syntax: "javascript"9      }10    }11  }12}13
14const SnippedGeneratorNodeJsPlugin = {15  fn: {16    // use `requestSnippetGenerator_` + key from config (node_native) for generator fn17    requestSnippetGenerator_node_native: (request) => {18      const url = new Url(request.get("url"))19      let isMultipartFormDataRequest = false20      const headers = request.get("headers")21      if(headers && headers.size) {22        request.get("headers").map((val, key) => {23          isMultipartFormDataRequest = isMultipartFormDataRequest || /^content-type$/i.test(key) && /^multipart\/form-data$/i.test(val)24        })25      }26      const packageStr = url.protocol === "https:" ? "https" : "http"27      let reqBody = request.get("body")28      if (request.get("body")) {29        if (isMultipartFormDataRequest && ["POST", "PUT", "PATCH"].includes(request.get("method"))) {30          return "throw new Error(\"Currently unsupported content-type: /^multipart\\/form-data$/i\");"31        } else {32          if (!Map.isMap(reqBody)) {33            if (typeof reqBody !== "string") {34              reqBody = JSON.stringify(reqBody)35            }36          } else {37            reqBody = getStringBodyOfMap(request)38          }39        }40      } else if (!request.get("body") && request.get("method") === "POST") {41        reqBody = ""42      }43
44      const stringBody = "`" + (reqBody || "")45          .replace(/\\n/g, "\n")46          .replace(/`/g, "\\`")47        + "`"48
49      return `const http = require("${packageStr}");50const options = {51  "method": "${request.get("method")}",52  "hostname": "${url.host}",53  "port": ${url.port || "null"},54  "path": "${url.pathname}"${headers && headers.size ? `,55  "headers": {56    ${request.get("headers").map((val, key) => `"${key}": "${val}"`).valueSeq().join(",\n    ")}57  }` : ""}58};59const req = http.request(options, function (res) {60  const chunks = [];61  res.on("data", function (chunk) {62    chunks.push(chunk);63  });64  res.on("end", function () {65    const body = Buffer.concat(chunks);66    console.log(body.toString());67  });68});69${reqBody ? `\nreq.write(${stringBody});` : ""}70req.end();`71    }72  }73}74
75const ui = SwaggerUIBundle({76  "dom_id": "#swagger-ui",77  deepLinking: true,78  presets: [79    SwaggerUIBundle.presets.apis,80    SwaggerUIStandalonePreset81  ],82  plugins: [83    SwaggerUIBundle.plugins.DownloadUrl,84    SnippedGeneratorNodeJsPlugin85  ],86  layout: "StandaloneLayout",87  validatorUrl: "https://validator.swagger.io/validator",88  url: "https://petstore.swagger.io/v2/swagger.json",89  ...snippetConfig,90})
Error handling
SwaggerUI comes with a safe-render plugin that handles error handling allows plugging into error handling system and modify it.
The plugin accepts a list of component names that should be protected by error boundaries.
Its public API looks like this:
1{2  fn: {3    componentDidCatch,4    withErrorBoundary: withErrorBoundary(getSystem),5  },6  components: {7    ErrorBoundary,8    Fallback,9  },10}
safe-render plugin is automatically utilized by base and standalone SwaggerUI presets and
should always be used as the last plugin, after all the components are already known to the SwaggerUI.
The plugin defines a default list of components that should be protected by error boundaries:
1[2  "App",3  "BaseLayout",4  "VersionPragmaFilter",5  "InfoContainer",6  "ServersContainer",7  "SchemesContainer",8  "AuthorizeBtnContainer",9  "FilterContainer",10  "Operations",11  "OperationContainer",12  "parameters",13  "responses",14  "OperationServers",15  "Models",16  "ModelWrapper",17  "Topbar",18  "StandaloneLayout",19  "onlineValidatorBadge"20]
As demonstrated below, additional components can be protected by utilizing the safe-render plugin
with configuration options. This gets really handy if you are a SwaggerUI integrator and you maintain a number of
plugins with additional custom components.
1const swaggerUI = SwaggerUI({2  url: "https://petstore.swagger.io/v2/swagger.json",3  dom_id: '#swagger-ui',4  plugins: [5    () => ({6      components: {7        MyCustomComponent1: () => 'my custom component',8      },9    }),10    SwaggerUI.plugins.SafeRender({11      fullOverride: true, // only the component list defined here will apply (not the default list)12      componentList: [13        "MyCustomComponent1",14      ],15    }),16  ],17});
componentDidCatch
This static function is invoked after a component has thrown an error.
It receives two parameters:

error - The error that was thrown.
info - An object with a componentStack key containing information about which component threw the error.

It has precisely the same signature as error boundaries componentDidCatch lifecycle method,
except it’s a static function and not a class method.
Default implement of componentDidCatch uses console.error to display the received error:
1export const componentDidCatch = console.error;
To utilize your own error handling logic (e.g. bugsnag), create new SwaggerUI plugin that overrides componentDidCatch:
{% highlight js linenos %}
const BugsnagErrorHandlerPlugin = () => {
// init bugsnag
return {
fn: {
componentDidCatch = (error, info) => {
Bugsnag.notify(error);
Bugsnag.notify(info);
},
},
};
};
{% endhighlight %}
withErrorBoundary
This function is HOC (Higher Order Component). It wraps a particular component into the ErrorBoundary component.
It can be overridden via a plugin system to control how components are wrapped by the ErrorBoundary component.
In 99.9% of situations, you won’t need to override this function, but if you do, please read the source code of this function first.
Fallback
The component is displayed when the error boundary catches an error. It can be overridden via a plugin system.
Its default implementation is trivial:
1import React from "react"2import PropTypes from "prop-types"3
4const Fallback = ({ name }) => (5  <div className="fallback">6    😱 <i>Could not render { name === "t" ? "this component" : name }, see the console.</i>7  </div>8)9Fallback.propTypes = {10  name: PropTypes.string.isRequired,11}12export default Fallback
Feel free to override it to match your look & feel:
1const CustomFallbackPlugin = () => ({2  components: {3    Fallback: ({ name } ) => `This is my custom fallback. ${name} failed to render`,4  },5});6
7const swaggerUI = SwaggerUI({8  url: "https://petstore.swagger.io/v2/swagger.json",9  dom_id: '#swagger-ui',10  plugins: [11    CustomFallbackPlugin,12  ]13});
ErrorBoundary
This is the component that implements React error boundaries. Uses componentDidCatch and Fallback
under the hood. In 99.9% of situations, you won’t need to override this component, but if you do,
please read the source code of this component first.
Change in behavior
In prior releases of SwaggerUI (before v4.3.0), almost all components have been protected, and when thrown error,
Fallback component was displayed. This changes with SwaggerUI v4.3.0. Only components defined
by the safe-render plugin are now protected and display fallback. If a small component somewhere within
SwaggerUI React component tree fails to render and throws an error. The error bubbles up to the closest
error boundary, and that error boundary displays the Fallback component and invokes componentDidCatch.     Edit page        Previous  Plugin API       Next  Custom layout\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nCreating a custom layout        Layouts are a special type of component that Swagger UI uses as the root component for the entire application. You can define custom layouts in order to have high-level control over what ends up on the page.
By default, Swagger UI uses BaseLayout, which is built into the application. You can specify a different layout to be used by passing the layout’s name as the layout parameter to Swagger UI. Be sure to provide your custom layout as a component to Swagger UI.

For example, if you wanted to create a custom layout that only displayed operations, you could define an OperationsLayout:
1import React from "react"2
3// Create the layout component4class OperationsLayout extends React.Component {5  render() {6    const {7      getComponent8    } = this.props9
10    const Operations = getComponent("operations", true)11
12    return (13      <div className="swagger-ui">14        <Operations />15      </div>16    )17  }18}19
20// Create the plugin that provides our layout component21const OperationsLayoutPlugin = () => {22  return {23    components: {24      OperationsLayout: OperationsLayout25    }26  }27}28
29// Provide the plugin to Swagger-UI, and select OperationsLayout30// as the layout for Swagger-UI31SwaggerUI({32  url: "https://petstore.swagger.io/v2/swagger.json",33  plugins: [ OperationsLayoutPlugin ],34  layout: "OperationsLayout"35})
Augmenting the default layout
If you’d like to build around the BaseLayout instead of replacing it, you can pull the BaseLayout into your custom layout and use it:
1import React from "react"2
3// Create the layout component4class AugmentingLayout extends React.Component {5  render() {6    const {7      getComponent8    } = this.props9
10    const BaseLayout = getComponent("BaseLayout", true)11
12    return (13      <div>14        <div className="myCustomHeader">15          <h1>I have a custom header above Swagger-UI!</h1>16        </div>17        <BaseLayout />18      </div>19    )20  }21}22
23// Create the plugin that provides our layout component24const AugmentingLayoutPlugin = () => {25  return {26    components: {27      AugmentingLayout: AugmentingLayout28    }29  }30}31
32// Provide the plugin to Swagger-UI, and select AugmentingLayout33// as the layout for Swagger-UI34SwaggerUI({35  url: "https://petstore.swagger.io/v2/swagger.json",36  plugins: [ AugmentingLayoutPlugin ],37  layout: "AugmentingLayout"38})     Edit page        Previous  Plug points       Next  Setting up\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSetting up a dev environment        SwaggerUI includes a development server that provides hot module reloading and unminified stack traces, for easier development.
Prerequisites

git, any version
Node.js >=22.11.0 and npm >=10.9.0 are the minimum required versions that this repo runs on, but we always recommend using the latest version of Node.js.

Steps

git clone https://github.com/swagger-api/swagger-ui.git
cd swagger-ui
npm install
npx husky init (optional)
npm run dev
Wait a bit
Open http://localhost:3200/

Using your own local api definition with local dev build
You can specify a local file in dev-helpers/dev-helper-initializer.js by changing the url parameter. This local file MUST be located in the dev-helpers directory or a subdirectory. As a convenience and best practice, we recommend that you create a subdirectory, dev-helpers/examples, which is already specified in .gitignore.
replace
1url: "https://petstore.swagger.io/v2/swagger.json",
with
1url: "./examples/your-local-api-definition.yaml",
Files in dev-helpers should NOT be committed to git. The exception is if you are fixing something in index.html, oauth2-redirect.html, dev-helper-initializer.js, or introducing a new support file.
Bonus points

Swagger UI includes an ESLint rule definition. If you use a graphical editor, consider installing an ESLint plugin, which will point out syntax and style errors for you as you code.

The linter runs as part of the PR test sequence, so don’t think you can get away with not paying attention to it!


     Edit page        Previous  Custom layout       Next  Scripts\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nHelpful scripts        Any of the scripts below can be run by typing npm run <script name> in the project’s root directory.
Developing









































Script nameDescriptiondevSpawn a hot-reloading dev server on port 3200.deps-checkGenerate a size and licensing report on Swagger UI’s dependencies.lintReport ESLint style errors and warnings.lint-errorsReport ESLint style errors, without warnings.lint-fixAttempt to fix style errors automatically.lint-stylesReport Stylelint style errors and warnings.lint-styles-fixAttempt to fix Stylelint errors and warnings automatically.watchRebuild the core files in /dist when the source code changes. Useful for npm link with Swagger Editor.
Building





































Script nameDescriptionbuildBuild a new set of JS and CSS assets, and output them to /dist.build-bundleBuild swagger-ui-bundle.js only (commonJS).build-coreBuild swagger-ui.(js|css) only (commonJS).build-standaloneBuild swagger-ui-standalone-preset.js only (commonJS).build-stylesheetsBuild swagger-ui.css only.build:es:bundleBuild swagger-ui-es-bundle.js only (es2015).build:es:bundle:coreBuild swagger-ui-es-bundle-core.js only (es2015).
Testing

















































Script nameDescriptiontestRun unit tests in Node, run Cypress end-to-end tests, and run ESLint in errors-only mode.test:unitRun Jest unit tests in Node.e2eRun end-to-end tests (requires JDK and Selenium).e2e-cypressRun end-to-end browser tests with Cypress.dev-e2e-cypressDev mode, open Cypress runner and manually select tests to run.lintRun ESLint testtest:artifactRun list of bundle artifact tests in Jesttest:artifact:umd:bundleRun unit test that confirms swagger-ui-bundle exports as a Functiontest:artifact:es:bundleRun unit test that confirms swagger-ui-es-bundle exports as a Functiontest:artifact:es:bundle:coreRun unit test that confirms swagger-ui-es-bundle-core exports as a Function     Edit page        Previous  Setting up       Next  What is Swagger Codegen?\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen        This is the Swagger Codegen project, which allows generation of API client libraries (SDK generation), server stubs and documentation automatically given an OpenAPI Description.
💚 If you would like to contribute, please refer to guidelines and a list of open tasks.💚
📔 For more information, please refer to the Wiki page and FAQ 📔
⚠️ If the OpenAPI Description or Swagger file is obtained from an untrusted source, please make sure you’ve reviewed the artefact before using Swagger Codegen to generate the API client, server stub or documentation as code injection may occur. ⚠️
Versioning

⚠️ this document refers to version 3.X, check here for 2.X.

Both 2.X and 3.X version lines of Swagger Codegen are available and are independently maintained.
NOTES:

Versions 2.X (io.swagger) and 3.X (io.swagger.codegen.v3) have different group ids.
OpenAPI 3.0.X is supported from the 3.X version only

For full versioning info, please refer to the versioning documentation.
Supported Languages and Frameworks
Here’s a summary of the supported languages/frameworks.


API clients: “csharp”, “csharp-dotnet2”, “dart”, “go”, “java”, “javascript”, “jaxrs-cxf-client”, “kotlin-client”, “php”, “python”, “r”, “ruby” “scala”, “swift3”, “swift4”, “swift5”, “typescript-angular”, “typescript-axios”, “typescript-fetch”


Server stubs: “aspnetcore”,
“go-server”,
“inflector”,
“java-vertx”,
“jaxrs-cxf”,
“jaxrs-cxf-cdi”,
“jaxrs-di”,
“jaxrs-jersey”,
“jaxrs-resteasy”,
“jaxrs-resteasy-eap”,
“jaxrs-spec”,
“kotlin-server”,
“micronaut”,
“nodejs-server”,
“python-flask”,
“scala-akka-http-server”,
“spring”


API documentation generators: “dynamic-html”,
“html”,
“html2”,
“openapi”,
“openapi-yaml”


To get a complete and/or realtime listing of supported languages/frameworks, you can directly query the online generator API or via a cURL command.
1curl -X 'GET' \2  'https://generator3.swagger.io/api/client/V3' \3  -H 'accept: application/json'
Check out the OpenAPI Specification for additional information about the OpenAPI project.
Compatibility
The OpenAPI Specification has undergone 3 revisions since initial creation in 2010.  The current stable versions of Swagger Codegen project have the following compatibilities with the OpenAPI Specification:























Swagger Codegen VersionRelease DateSwagger / OpenAPI Spec compatibilityNotes3.0.68 (current stable)2025-03-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.682.4.44 (current stable)2024-12-181.0, 1.1, 1.2, 2.0tag v2.4.44
💁 Here’s also an overview of what’s coming around the corner:























Swagger Codegen VersionRelease DateSwagger / OpenAPI Spec compatibilityNotes3.0.69-SNAPSHOT (current 3.0.0, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0, 3.0Minor release2.4.45-SNAPSHOT (current master, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0Minor release
For detailed breakdown of all versions, please see the full compatibility listing.
Getting Started
To get up and running with Swagger Codegen, check out the following guides and instructions:

Prerequisites
Building
Using Docker

Once you’ve your environment setup, you’re ready to start generating clients and/or servers.
As a quick example, to generate a PHP client for Swagger Petstore, please run the following:
Terminal window1git clone https://github.com/swagger-api/swagger-codegen2cd swagger-codegen3git checkout 3.0.04mvn clean package5java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \6   -i http://petstore.swagger.io/v2/swagger.json \7   -l php \8   -o /var/tmp/php_api_client
Note: if you’re on Windows, replace the last command with:
Terminal window1java -jar modules wagger-codegen-cli\target wagger-codegen-cli.jar generate -i http://petstore.swagger.io/v2/swagger.json -l php -o c:\temp\php_api_client
You can also download the JAR (latest release) directly from maven.org.
To get a list of general options available, please run:
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate --help
To get a list of PHP specified options (which can be passed to the generator with a config file via the -c option), please run:
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar config-help -l php
Generators
To generate a sample client library
You can build a client against the swagger sample petstore API as follows:
Terminal window1./bin/java-petstore.sh
On Windows, run .\bin\windows\java-petstore.bat instead.
This will run the generator with this command:
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \2  -i http://petstore.swagger.io/v2/swagger.json \                               # The location of the Swagger specifcation file (JSON/YAML).3  -l java \                                                                     # The desired language for the library.4  -o samples/client/petstore/java                                               # The output destination.
You can get the options with the generate --help command (below only shows partial results):
1NAME2        swagger-codegen-cli generate - Generate code with chosen lang3
4SYNOPSIS5        swagger-codegen-cli generate6                [(-a <authorization> | --auth <authorization>)]7                [--additional-properties <additional properties>...]8                [--api-package <api package>] [--artifact-id <artifact id>]9                [--artifact-version <artifact version>]10                [(-c <configuration file> | --config <configuration file>)]11                [-D <system properties>...] [--git-repo-id <git repo id>]12                [--git-user-id <git user id>] [--group-id <group id>]13                [--http-user-agent <http user agent>]14                (-i <spec file> | --input-spec <spec file>)15                [--ignore-file-override <ignore file override location>]16                [--import-mappings <import mappings>...]17                [--instantiation-types <instantiation types>...]18                [--invoker-package <invoker package>]19                (-l <language> | --lang <language>)20                [--language-specific-primitives <language specific primitives>...]21                [--library <library>] [--model-name-prefix <model name prefix>]22                [--model-name-suffix <model name suffix>]23                [--model-package <model package>]24                [(-o <output directory> | --output <output directory>)]25                [--release-note <release note>] [--remove-operation-id-prefix]26                [--reserved-words-mappings <reserved word mappings>...]27                [(-s | --skip-overwrite)]28                [(-t <template directory> | --template-dir <template directory>)]29                [--type-mappings <type mappings>...] [(-v | --verbose)]30
31OPTIONS32        -a <authorization>, --auth <authorization>33            adds authorization headers when fetching the swagger definitions34            remotely. Pass in a URL-encoded string of name:header with a comma35            separating multiple values36
37...... (results omitted)38
39        -v, --verbose40            verbose mode
You can then compile and run the client, as well as unit tests against it:
Terminal window1cd samples/client/petstore/java2mvn package
Other languages have petstore samples, too:
Terminal window1./bin/android-petstore.sh2./bin/java-petstore.sh3./bin/objc-petstore.sh
Generating libraries from your server
It’s just as easy! Use the -i flag to point to either a server or file.
🔧 Swagger Codegen comes with a tonne of flexibility to support your code generation preferences. Checkout the generators documentation which takes you through some of the possibilities as well as showcasing how to generate from local files.
Selective generation
You may not want to generate all models in your project. Likewise you may want just one or two apis to be written, or even ignore certain file formats. If that’s the case check the selective generation instructions.
Advanced Generator Customization
There are different aspects of customizing the code generator beyond just creating or modifying templates.  Each language has a supporting configuration file to handle different type mappings, or bring your own models. For more information check out the advanced configuration docs.
Validating your OpenAPI Description
You have options. The easiest is to use our online validator which not only will let you validate your OpenAPI file, but with the debug flag, you can see what’s wrong with your file. Check out Swagger Validator to validate a petstore example.
If you want to have validation directly on your own machine, then Spectral is an excellent option.
Generating dynamic html api documentation
To do so, just use the -l dynamic-html flag when reading a spec file.  This creates HTML documentation that is available as a single-page application with AJAX.  To view the documentation:
Terminal window1cd samples/dynamic-html/2npm install3node .
Which launches a node.js server so the AJAX calls have a place to go.
Workflow Integration
It’s possible to leverage Swagger Codegen directly within your preferred CI/CD workflows to streamline your auto-generation requirements. Check out the workflows integration guide to see information on our Maven, Gradle, and GitHub integration options. 🚀
Online generators
If you don’t want to run and host your own code generation instance, check our our online generators information.
Contributing
Please refer to this page.

🚧 For swagger-codegen version 3 templates and classes for code generation are being migrated to swagger-codegen-generators repo. In order to know this migration process you can refer this page.

Security contact
Please disclose any security-related issues or vulnerabilities by emailing security@swagger.io, instead of using the public issue tracker.
Thank You
💚💚💚 We’d like to give a big shout out to all those who’ve contributed to Swagger Codegen, be that in raising issues, fixing bugs, authoring templates, or crafting useful content for others to benefit from. 💚💚💚     Edit page        Previous  Scripts       Next  Versioning\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Versioning        Both 2.X and 3.X version lines of Swagger Codegen are available and are independently maintained.
NOTE: version 2.X (io.swagger) and 3.X (io.swagger.codegen.v3) have different group ids.
Swagger Codegen 2.X





























Version:2.XRepository branch:mastergroupId:io.swaggerSwagger/OpenAPI support:2.0maven central (maven plugin):swagger-codegen-maven-plugin
dependency example:
1<dependency>2    <groupId>io.swagger</groupId>3    <artifactId>swagger-codegen-maven-plugin</artifactId>4    <version>2.4.43</version>5</dependency>
Swagger Codegen 3.X





























Version:3.XRepository branch:3.0.0groupId:io.swagger.codegen.v3Swagger/OpenAPI support:2.0 (by using engine + generators of 2.X), 3.0.Xmaven central:io.swagger.codegen.v3
dependency example:
1<dependency>2    <groupId>io.swagger.codegen.v3</groupId>3    <artifactId>swagger-codegen-maven-plugin</artifactId>4    <version>3.0.61</version>5</dependency>     Edit page        Previous  What is Swagger Codegen?       Next  Compatibility\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Compatibility        The Swagger Codegen project has the following compatibilities with the OpenAPI Specification (formerly known as Swagger):

































































































































































































































































































































































































































































































































































































































































































































































Swagger Codegen VersionRelease DateOpenAPI Spec compatibilityNotes3.0.69-SNAPSHOT (current 3.0.0, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0, 3.0Minor release3.0.68 (current stable)2025-03-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.683.0.672025-01-271.0, 1.1, 1.2, 2.0, 3.0tag v3.0.673.0.662024-12-231.0, 1.1, 1.2, 2.0, 3.0tag v3.0.663.0.652024-12-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.653.0.642024-11-071.0, 1.1, 1.2, 2.0, 3.0tag v3.0.643.0.632024-10-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.633.0.622024-08-271.0, 1.1, 1.2, 2.0, 3.0tag v3.0.623.0.612024-08-091.0, 1.1, 1.2, 2.0, 3.0tag v3.0.613.0.602024-08-011.0, 1.1, 1.2, 2.0, 3.0tag v3.0.603.0.592024-07-221.0, 1.1, 1.2, 2.0, 3.0tag v3.0.593.0.582024-07-081.0, 1.1, 1.2, 2.0, 3.0tag v3.0.583.0.572024-05-271.0, 1.1, 1.2, 2.0, 3.0tag v3.0.573.0.562024-05-101.0, 1.1, 1.2, 2.0, 3.0tag v3.0.563.0.552024-04-221.0, 1.1, 1.2, 2.0, 3.0tag v3.0.553.0.542024-02-191.0, 1.1, 1.2, 2.0, 3.0tag v3.0.543.0.532024-02-141.0, 1.1, 1.2, 2.0, 3.0tag v3.0.533.0.522023-12-301.0, 1.1, 1.2, 2.0, 3.0tag v3.0.523.0.512023-11-211.0, 1.1, 1.2, 2.0, 3.0tag v3.0.513.0.502023-10-261.0, 1.1, 1.2, 2.0, 3.0tag v3.0.503.0.492023-10-231.0, 1.1, 1.2, 2.0, 3.0tag v3.0.493.0.482023-10-191.0, 1.1, 1.2, 2.0, 3.0tag v3.0.483.0.472023-10-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.473.0.462023-06-071.0, 1.1, 1.2, 2.0, 3.0tag v3.0.463.0.452023-06-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.453.0.442023-05-231.0, 1.1, 1.2, 2.0, 3.0tag v3.0.443.0.432023-05-171.0, 1.1, 1.2, 2.0, 3.0tag v3.0.433.0.422023-04-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.423.0.412023-02-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.413.0.402023-01-271.0, 1.1, 1.2, 2.0, 3.0tag v3.0.403.0.392023-01-251.0, 1.1, 1.2, 2.0, 3.0tag v3.0.393.0.382023-01-221.0, 1.1, 1.2, 2.0, 3.0tag v3.0.383.0.372023-01-191.0, 1.1, 1.2, 2.0, 3.0tag v3.0.373.0.362022-11-101.0, 1.1, 1.2, 2.0, 3.0tag v3.0.363.0.352022-08-151.0, 1.1, 1.2, 2.0, 3.0tag v3.0.353.0.342022-04-121.0, 1.1, 1.2, 2.0, 3.0tag v3.0.343.0.332022-02-071.0, 1.1, 1.2, 2.0, 3.0tag v3.0.333.0.322022-01-111.0, 1.1, 1.2, 2.0, 3.0tag v3.0.323.0.312021-12-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.313.0.302021-11-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.303.0.292021-10-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.293.0.282021-09-301.0, 1.1, 1.2, 2.0, 3.0tag v3.0.283.0.272021-06-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.273.0.262021-05-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.263.0.252021-03-041.0, 1.1, 1.2, 2.0, 3.0tag v3.0.253.0.242020-12-291.0, 1.1, 1.2, 2.0, 3.0tag v3.0.243.0.232020-11-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.233.0.222020-10-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.223.0.212020-07-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.213.0.202020-05-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.203.0.192020-04-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.193.0.182020-02-261.0, 1.1, 1.2, 2.0, 3.0tag v3.0.183.0.172020-02-231.0, 1.1, 1.2, 2.0, 3.0tag v3.0.173.0.172020-01-151.0, 1.1, 1.2, 2.0, 3.0tag v3.0.163.0.152020-01-031.0, 1.1, 1.2, 2.0, 3.0tag v3.0.153.0.142019-11-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.143.0.132019-10-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.133.0.122019-10-141.0, 1.1, 1.2, 2.0, 3.0tag v3.0.123.0.112019-08-241.0, 1.1, 1.2, 2.0, 3.0tag v3.0.113.0.102019-07-111.0, 1.1, 1.2, 2.0, 3.0tag v3.0.103.0.92019-06-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.93.0.82019-04-251.0, 1.1, 1.2, 2.0, 3.0tag v3.0.83.0.72019-03-261.0, 1.1, 1.2, 2.0, 3.0tag v3.0.73.0.52019-02-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.53.0.42019-01-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.43.0.32018-11-301.0, 1.1, 1.2, 2.0, 3.0tag v3.0.33.0.22018-10-191.0, 1.1, 1.2, 2.0, 3.0Minor release3.0.12018-10-051.0, 1.1, 1.2, 2.0, 3.0Major release with breaking changes3.0.02018-09-061.0, 1.1, 1.2, 2.0, 3.0Major release with breaking changes2.4.45-SNAPSHOT (current master, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0Minor release2.4.44 (current stable)2024-12-181.0, 1.1, 1.2, 2.0tag v2.4.442.4.432024-08-091.0, 1.1, 1.2, 2.0tag v2.4.432.4.422024-07-291.0, 1.1, 1.2, 2.0tag v2.4.422.4.412024-04-221.0, 1.1, 1.2, 2.0tag v2.4.412.4.392024-01-021.0, 1.1, 1.2, 2.0tag v2.4.392.4.382023-12-291.0, 1.1, 1.2, 2.0tag v2.4.382.4.372023-11-211.0, 1.1, 1.2, 2.0tag v2.4.372.4.362023-10-261.0, 1.1, 1.2, 2.0tag v2.4.362.4.352023-10-261.0, 1.1, 1.2, 2.0tag v2.4.352.4.342023-10-191.0, 1.1, 1.2, 2.0tag v2.4.342.4.332023-10-021.0, 1.1, 1.2, 2.0tag v2.4.332.4.322023-05-171.0, 1.1, 1.2, 2.0tag v2.4.322.4.312023-04-021.0, 1.1, 1.2, 2.0tag v2.4.312.4.302023-02-161.0, 1.1, 1.2, 2.0tag v2.4.302.4.292022-11-101.0, 1.1, 1.2, 2.0tag v2.4.292.4.282022-08-151.0, 1.1, 1.2, 2.0tag v2.4.282.4.272022-04-121.0, 1.1, 1.2, 2.0tag v2.4.272.4.262022-02-071.0, 1.1, 1.2, 2.0tag v2.4.262.4.252021-12-281.0, 1.1, 1.2, 2.0tag v2.4.252.4.242021-11-181.0, 1.1, 1.2, 2.0tag v2.4.242.4.232021-10-081.0, 1.1, 1.2, 2.0tag v2.4.232.4.222021-09-301.0, 1.1, 1.2, 2.0tag v2.4.222.4.212021-06-281.0, 1.1, 1.2, 2.0tag v2.4.212.4.202021-05-281.0, 1.1, 1.2, 2.0tag v2.4.202.4.192021-03-041.0, 1.1, 1.2, 2.0tag v2.4.192.4.182020-12-291.0, 1.1, 1.2, 2.0tag v2.4.182.4.172020-11-021.0, 1.1, 1.2, 2.0tag v2.4.172.4.162020-10-051.0, 1.1, 1.2, 2.0tag v2.4.162.4.152020-07-281.0, 1.1, 1.2, 2.0tag v2.4.152.4.142020-05-181.0, 1.1, 1.2, 2.0tag v2.4.142.4.132020-04-021.0, 1.1, 1.2, 2.0tag v2.4.132.4.122020-01-151.0, 1.1, 1.2, 2.0tag v2.4.122.4.112020-01-031.0, 1.1, 1.2, 2.0tag v2.4.112.4.102019-11-161.0, 1.1, 1.2, 2.0tag v2.4.102.4.92019-10-141.0, 1.1, 1.2, 2.0tag v2.4.92.4.82019-08-241.0, 1.1, 1.2, 2.0tag v2.4.82.4.72019-07-111.0, 1.1, 1.2, 2.0tag v2.4.72.4.62019-06-281.0, 1.1, 1.2, 2.0tag v2.4.62.4.52019-04-251.0, 1.1, 1.2, 2.0tag v2.4.52.4.42019-03-261.0, 1.1, 1.2, 2.0tag v2.4.42.4.22019-02-181.0, 1.1, 1.2, 2.0tag v2.4.22.4.12019-01-161.0, 1.1, 1.2, 2.0tag v2.4.12.4.02018-11-301.0, 1.1, 1.2, 2.0tag v2.4.02.3.12018-01-171.0, 1.1, 1.2, 2.0tag v2.3.12.3.02017-12-211.0, 1.1, 1.2, 2.0tag v2.3.02.2.32017-07-151.0, 1.1, 1.2, 2.0tag v2.2.32.2.22017-03-011.0, 1.1, 1.2, 2.0tag v2.2.22.2.12016-08-071.0, 1.1, 1.2, 2.0tag v2.2.12.1.62016-04-061.0, 1.1, 1.2, 2.0tag v2.1.62.0.172014-08-221.1, 1.2tag v2.0.171.0.42012-04-121.0, 1.1tag v1.0.4     Edit page        Previous  Versioning       Next  Prerequisites\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Prerequisites        If you’re looking for the latest stable version, you can grab it directly from Maven.org (Java 8 runtime at a minimum):
Terminal window1wget https://repo1.maven.org/maven2/io/swagger/codegen/v3/swagger-codegen-cli/3.0.68/swagger-codegen-cli-3.0.68.jar -O swagger-codegen-cli.jar2
3java -jar swagger-codegen-cli.jar --help
For Windows users, you will need to install wget or you can use Invoke-WebRequest in PowerShell (3.0+). For example:
Terminal window1Invoke-WebRequest -OutFile swagger-codegen-cli.jar https://repo1.maven.org/maven2/io/swagger/codegen/v3/swagger-codegen-cli/3.0.68/swagger-codegen-cli-3.0.68.jar
On a Mac, it’s even easier with brew:
Terminal window1brew install swagger-codegen
To build from source, you need the following installed and available in your $PATH:

Java 11
Apache maven 3.6.2 or greater

OS X Users
Don’t forget to install Java 11.
Export JAVA_HOME in order to use the supported Java version:
Terminal window1export JAVA_HOME=`/usr/libexec/java_home -v 11`2export PATH=${JAVA_HOME}/bin:$PATH     Edit page        Previous  Compatibility       Next  Building\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Building        After cloning the project, you can build it from source with this command:
Terminal window1mvn clean package
Homebrew
To install, run brew install swagger-codegen
Here is an example usage:
Terminal window1swagger-codegen generate -i http://petstore.swagger.io/v2/swagger.json -l ruby -o /tmp/test/
To build a server stub
Please refer to wiki for more information.
To build the codegen library
This will create the Swagger Codegen library from source.
Terminal window1mvn package

The templates are included in the library generated.  If you want to modify the templates, you’ll need to either repackage the library OR specify a path to your scripts.
     Edit page        Previous  Prerequisites       Next  Using Docker\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Using Docker        Development in docker
You can use run-in-docker.sh to do all development. This script maps your local repository to /gen
in the docker container. It also maps ~/.m2/repository to the appropriate container location.
To execute mvn package:
Terminal window1git clone https://github.com/swagger-api/swagger-codegen2cd swagger-codegen3./run-in-docker.sh mvn package
Build artifacts are now accessible in your working directory.
Once built, run-in-docker.sh will act as an executable for swagger-codegen-cli. To generate code, you’ll need to output to a directory under /gen (e.g. /gen/out). For example:
Terminal window1./run-in-docker.sh help # Executes 'help' command for swagger-codegen-cli2./run-in-docker.sh langs # Executes 'langs' command for swagger-codegen-cli3./run-in-docker.sh /gen/bin/go-petstore.sh  # Builds the Go client4./run-in-docker.sh generate -i modules/swagger-codegen/src/test/resources/2_0/petstore.yaml \5    -l go -o /gen/out/go-petstore -DpackageName=petstore # generates go client, outputs locally to ./out/go-petstore
Standalone generator Development in docker
See standalone generator development
Run Docker in Vagrant
Prerequisite: install Vagrant and VirtualBox.
Terminal window1git clone http://github.com/swagger-api/swagger-codegen.git2cd swagger-codegen3vagrant up4vagrant ssh5cd /vagrant6./run-in-docker.sh mvn package
Public Pre-built Docker images

Official web service
Official web service with “standard” user
Official minimal web service
Official CLI

Swagger Generator Docker Image
The Swagger Generator image provides a ready to use web application (swagger-generator) providing code generation services.
Image accepts the following env variables:

JAVA_MEM e.g. 1024m
HTTP_PORT e.g. 8080
HIDDEN_OPTIONS_PATH (alternative to HIDDEN_OPTIONS): useful if attaching a volume containing a hiddenOptions.yaml file definining which languages to hide. e.g. /data/hiddenOptions.yaml
HIDDEN_OPTIONS (alternative to HIDDEN_OPTIONS_PATH): allows to pass hidden options as an env variable, in the format {category}:{language},{language},{language}|{category}:{language},{language},{language}
e.g. servers:foo,bar|clientsV3:wtf,isthis where category can be clients, servers, clientsV3, serversV3

An example of running the container:
docker pull swaggerapi/swagger-generator-v3
docker run -e "HIDDEN_OPTIONS=servers:foo,bar|clientsV3:fgf,sdsd" -e "JAVA_MEM=1024m" -e "HTTP_PORT=80" -p 80:80 --name swagger-generator-v3 -v /tmp:/jetty_home/lib/shared swaggerapi/swagger-generator-v3
or
docker run -e "HIDDEN_OPTIONS_PATH=/hiddenOptions.yaml" -e "JAVA_MEM=1024m" -e "HTTP_PORT=80" -p 80:80 --name swagger-generator-v3  -v /tmp:/jetty_home/lib/shared swaggerapi/swagger-generator-v3
This docker image supports custom generators by dropping the generator jar into /jetty_home/lib/shared directory (typically via a docker volume); e.g having on host /my/custom/coolgenerator.jar and /my/custom/weirdgenerator.jar  the following would have them added to generator service generators:
docker run -e "HIDDEN_OPTIONS_PATH=/hiddenOptions.yaml" -e "JAVA_MEM=1024m" -e "HTTP_PORT=80" -p 80:80 --name swagger-generator-v3 -v /my/custom:/jetty_home/lib/shared swaggerapi/swagger-generator-v3
Please note that up to version 3.0.20 you need to provide-v /{WHATEVER_DIR}:/jetty_home/lib/shared even if not using custom generators.
See also online generators.
Swagger Generator “Minimal” Docker Image
The Swagger Generator “Minimal” image can act as a self-hosted web application and API for generating code.
This container can be incorporated into a CI pipeline, and requires some docker orchestration to access generated code.
Example usage:
Terminal window1# Start container and save the container id2CID=$(docker run -d swaggerapi/swagger-generator-v3-minimal)3# allow for startup4sleep 55# Get the IP of the running container6GEN_IP=$(docker inspect --format '{{.NetworkSettings.IPAddress}}'  $CID)7# Execute an HTTP request and store the download link8curl -X POST \9           http://localhost:8080/api/generate \10           -H 'content-type: application/json' \11           -d '{12           "specURL" : "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml",13           "lang" : "jaxrs-jersey",14           "type" : "SERVER",15           "codegenVersion" : "V3"16         }' > result.zip17# Shutdown the swagger generator image18docker stop $CID && docker rm $CID
In the example above, result.zip will contain the generated client.
See also online generators.
Swagger Codegen CLI Docker Image
The Swagger Codegen image acts as a standalone executable. It can be used as an alternative to installing via homebrew, or for developers who are unable to install Java or upgrade the installed version.
To generate code with this image, you’ll need to mount a local location as a volume.
Example:
Terminal window1docker run --rm -v ${PWD}:/local swaggerapi/swagger-codegen-cli-v3 generate \2    -i http://petstore.swagger.io/v2/swagger.json \3    -l go \4    -o /local/out/go
The generated code will be located under ./out/go in the current directory.     Edit page        Previous  Building       Next  Generators\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Generators        If the default generator configuration does not meet your needs, you have various options to modify or create new modules or templates.
Modifying the client library format
Don’t like the default swagger client syntax?  Want a different language supported?  No problem!
Swagger Codegen processes handlebar templates with the Handlebars.java engine.  You can modify our templates or make your own.
Take a look at swagger-codegen-generators for examples. To make your own templates, create your own files and use the -t flag to specify your template folder.  It actually is that easy!
Making your own codegen modules
If you’re starting a project with a new language and don’t see what you need, Swagger Codegen can help you create a project to generate your own libraries:
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar meta \2  -o output/myLibrary -n myClientCodegen -p com.my.company.codegen
This will write, in the folder output/myLibrary, all the files you need to get started, including a README.md. Once modified and compiled, you can load your library with the codegen and generate clients with your own, custom-rolled logic.
You would then compile your library in the output/myLibrary folder with mvn package and execute the codegen like such:
Terminal window1java -cp output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar:modules/swagger-codegen-cli/target/swagger-codegen-cli.jar io.swagger.codegen.v3.cli.SwaggerCodegen
For Windows users, you will need to use ; instead of : in the classpath, e.g.:
Terminal window1java -cp output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar;modules/swagger-codegen-cli/target/swagger-codegen-cli.jar io.swagger.codegen.v3.cli.SwaggerCodegen
Note the myClientCodegen is an option now, and you can use the usual arguments for generating your library:
Terminal window1java -cp output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar:modules/swagger-codegen-cli/target/swagger-codegen-cli.jar \2  io.swagger.codegen.v3.cli.SwaggerCodegen generate -l myClientCodegen\3  -i http://petstore.swagger.io/v2/swagger.json \4  -o myClient
See also standalone generator development.
Generating a client from local files
If you don’t want to call your server, you can save the OpenAPI Description files into a directory and pass an argument
to the code generator like this:
Terminal window1-i ./modules/swagger-codegen/src/test/resources/2_0/petstore.json
Great for creating libraries on your CI server, from the Swagger Editor … or while coding on an airplane ✈️.     Edit page        Previous  Using Docker       Next  Selective Generation\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Selective Generation        You may not want to generate all models in your project.  Likewise you may want just one or two apis to be written.  If that’s the case, you can use system properties to control the output:
The default is generate everything supported by the specific library.  Once you enable a feature, it will restrict the contents generated:
Terminal window1# generate only models2java -Dmodels {opts}3
4# generate only apis5java -Dapis {opts}6
7# generate only supporting files8java -DsupportingFiles9
10# generate models and supporting files11java -Dmodels -DsupportingFiles
To control the specific files being generated, you can pass a CSV list of what you want:
Terminal window1# generate the User and Pet models only2-Dmodels=User,Pet3
4# generate the User model and the supportingFile `StringUtil.java`:5-Dmodels=User -DsupportingFiles=StringUtil.java
To control generation of docs and tests for api and models, pass false to the option. For api, these options are  -DapiTests=false and -DapiDocs=false. For models, -DmodelTests=false and -DmodelDocs=false.
These options default to true and don’t limit the generation of the feature options listed above (like -Dapi):
Terminal window1# generate only models (with tests and documentation)2java -Dmodels {opts}3
4# generate only models (with tests but no documentation)5java -Dmodels -DmodelDocs=false {opts}6
7# generate only User and Pet models (no tests and no documentation)8java -Dmodels=User,Pet -DmodelTests=false {opts}9
10# generate only apis (without tests)11java -Dapis -DapiTests=false {opts}12
13# generate only apis (modelTests option is ignored)14java -Dapis -DmodelTests=false {opts}
When using selective generation, only the templates needed for the specific generation will be used.
Ignore file format
Swagger Codegen supports a .swagger-codegen-ignore file, similar to .gitignore or .dockerignore you’re probably already familiar with.
The ignore file allows for better control over overwriting existing files than the --skip-overwrite flag. With the ignore file, you can specify individual files or directories can be ignored. This can be useful, for example if you only want a subset of the generated code.
Examples:
Terminal window1# Swagger Codegen Ignore2# Lines beginning with a # are comments3
4# This should match build.sh located anywhere.5build.sh6
7# Matches build.sh in the root8/build.sh9
10# Exclude all recursively11docs/**12
13# Explicitly allow files excluded by other rules14!docs/UserApi.md15
16# Recursively exclude directories named Api17# You can't negate files below this directory.18src/**/Api/19
20# When this file is nested under /Api (excluded above),21# this rule is ignored because parent directory is excluded by previous rule.22!src/**/PetApiTests.cs23
24# Exclude a single, nested file explicitly25src/IO.Swagger.Test/Model/AnimalFarmTests.cs
The .swagger-codegen-ignore file must exist in the root of the output directory.
Upon first code generation, you may also pass the CLI option --ignore-file-override=/path/to/ignore_file for greater control over generated outputs. Note that this is a complete override, and will override the .swagger-codegen-ignore file in an output directory when regenerating code.
Editor support for .swagger-codegen-ignore files is available in IntelliJ via the .ignore plugin.     Edit page        Previous  Generators       Next  Advanced Generator Configuration\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Generators Configuration        There are different aspects of customizing the code generator (located in this version at swagger codegen generator repo) beyond just creating or modifying templates.  Each language has a supporting configuration file to handle different type mappings, etc:
Terminal window1s -1 modules/swagger-codegen/src/main/java/io/swagger/codegen/languages/2
3AbstractJavaCodegen.java4AbstractJavaJAXRSServerCodegen.java5... (results omitted)6JavaClientCodegen.java7JavaJAXRSSpecServerCodegen.java
Each of these files creates reasonable defaults so you can get running quickly. If you want to configure package names, prefixes, model folders, etc. you can use a JSON config file to pass the values.
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \2  -i http://petstore.swagger.io/v2/swagger.json \3  -l java \4  -o samples/client/petstore/java \5  -c path/to/config.json
and config.json contains the following as an example:
1{2  "apiPackage" : "petstore"3}
Supported config options can be different per language. Running config-help -l {lang} will show available options.
These options are applied via configuration file (e.g. config.json) or by passing them with -D{optionName}={optionValue}.

If -D{optionName} does not work, please open a ticket and we’ll look into it.

Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar config-help -l java
Output:
1CONFIG OPTIONS2modelPackage3    package for generated models4
5apiPackage6    package for generated api classes7...... (results omitted)8library9    library template (sub-template) to use:10    jersey1 - HTTP client: Jersey client 1.18. JSON processing: Jackson 2.4.211    jersey2 - HTTP client: Jersey client 2.612    feign - HTTP client: Netflix Feign 8.1.1.  JSON processing: Jackson 2.6.313    okhttp-gson (default) - HTTP client: OkHttp 2.4.0. JSON processing: Gson 2.3.114    retrofit - HTTP client: OkHttp 2.4.0. JSON processing: Gson 2.3.1 (Retrofit 1.9.0)15    retrofit2 - HTTP client: OkHttp 2.5.0. JSON processing: Gson 2.4 (Retrofit 2.0.0-beta2)16    google-api-client - HTTP client: google-api-client 1.23.0. JSON processing: Jackson 2.8.9
Your config file for Java can look like
1{2  "groupId":"com.my.company",3  "artifactId":"MyClient",4  "artifactVersion":"1.2.0",5  "library":"feign"6}
For all the unspecified options default values will be used.
Another way to override default options is to extend the config class for the specific language.
To change, for example, the prefix for the Objective-C generated files, simply subclass the ObjcClientCodegen.java:
1package com.mycompany.swagger.codegen;2
3import io.swagger.codegen.languages.*;4
5public class MyObjcCodegen extends ObjcClientCodegen {6    static {7        PREFIX = "HELO";8    }9}
and specify the classname when running the generator:
Terminal window1-l com.mycompany.swagger.codegen.MyObjcCodegen
Your subclass will now be loaded and overrides the PREFIX value in the superclass.
Bringing your own models
Sometimes you don’t want a model generated.  In this case, you can simply specify an import mapping to tell
the codegen what not to create.  When doing this, every location that references a specific model will
refer back to your classes.

Note, this may not apply to all languages!

To specify an import mapping, use the --import-mappings argument and specify the model-to-import logic as such:
Terminal window1--import-mappings Pet=my.models.MyPet
Or for multiple mappings:
Terminal window1--import-mappings Pet=my.models.MyPet,Order=my.models.MyOrder
or
Terminal window1--import-mappings Pet=my.models.MyPet --import-mappings Order=my.models.MyOrder     Edit page        Previous  Selective Generation       Next  Workflow Integration\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Workflow Integration        Maven Integration
You can use the swagger-codegen-maven-plugin for integrating with your workflow, and generating any codegen target.
Gradle Integration
Gradle Swagger Generator Plugin is available for generating source code and API document.
GitHub Integration
To push the auto-generated SDK to GitHub, we provide git_push.sh to streamline the process. For example:


Create a new repository


Generate the SDK


Terminal window1 java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \2 -i modules/swagger-codegen/src/test/resources/2_0/petstore.json -l perl \3 --git-user-id "swaggerapi" \4 --git-repo-id "petstore-perl" \5 --release-note "Github integration demo" \6 -o /var/tmp/perl/petstore

Push the SDK to GitHub

Terminal window1cd /var/tmp/perl/petstore2/bin/sh ./git_push.sh     Edit page        Previous  Advanced Generator Configuration       Next  Online Generators\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Online Generators        swagger-generator module exposes codegen as a web service, with it’s own swagger-js based web UI, and available docker image swaggerapi/swagger-generator-v3.
The web service is deployed at https://generator3.swagger.io/ui, or it can be easily deployed as docker container.
The OpenAPI specification of generator service APIs are available either via UI exposed by web service (e.g. https://generator3.swagger.io/ui), as exposed YAML (https://generator3.swagger.io/openapi.json)
or in source code repo (https://github.com/swagger-api/swagger-codegen/blob/3.0.0/modules/swagger-generator/src/main/resources/openapi.yaml).

Please note that both V2 (for v2 specs) and V3 generators (for v3 and v2 specs converted during generation) are supported, by providing property codegenVersion (e.g "codegenVersion" : "v3").

For example, to generate a java API client, simply send the following HTTP request using curl:
Terminal window1curl -X POST \2  https://generator3.swagger.io/api/generate \3  -H 'content-type: application/json' \4  -d '{5  "specURL" : "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml",6  "lang" : "java",7  "type" : "CLIENT",8  "codegenVersion" : "V3"9}'
The response will contain a zipped file containing the generated code.
To customize the SDK, you can specify language specific options  with the following HTTP body:
1{2  "specURL" : "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/examples/v3.0/petstore.yaml",3  "lang" : "java",4  "options" : {5    "additionalProperties" : {6    "useRuntimeException": true,7    "useRxJava" : true8    }9  },10  "type" : "CLIENT",11  "codegenVersion" : "V3"12}
in which the options additionalProperties for a language can be obtained by submitting a GET request to https://generator3.swagger.io/api/options?language={language}&version={codegenVersion}:
For example, curl https://generator3.swagger.io/api/options?language=java&version=V3 returns (truncated output):
1{2  "sortParamsByRequiredFlag": {3    "opt": "sortParamsByRequiredFlag",4    "description": "Sort method arguments to place required parameters before optional parameters.",5    "type": "boolean",6    "default": "true"7  },8  "ensureUniqueParams": {9    "opt": "ensureUniqueParams",10    "description": "Whether to ensure parameter names are unique in an operation (rename parameters that are not).",11    "type": "boolean",12    "default": "true"13  },14  "allowUnicodeIdentifiers": {15    "opt": "allowUnicodeIdentifiers",16    "description": "boolean, toggles whether unicode identifiers are allowed in names or not, default is false",17    "type": "boolean",18    "default": "false"19  },20  "modelPackage": {21    "opt": "modelPackage",22    "description": "package for generated models",23    "type": "string"24  },25  ...
Instead of using specURL with an URL to the OpenAPI/Swagger spec, one can include the spec in the JSON payload with spec, e.g.
1{2  "options": {},3  "spec": {4    "swagger": "2.0",5    "info": {6      "version": "1.0.0",7      "title": "Test API"8    },9    ...10  }11}     Edit page        Previous  Workflow Integration       Next  What is Swagger Codegen?\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen        This is the Swagger Codegen project, which allows generation of API client libraries (SDK generation), server stubs and documentation automatically given an OpenAPI Spec.
💚 If you would like to contribute, please refer to guidelines and a list of open tasks.💚
📔 For more information, please refer to the Wiki page and FAQ 📔
⚠️ If the OpenAPI Description or Swagger file is obtained from an untrusted source, please make sure you’ve reviewed the artefact before using Swagger Codegen to generate the API client, server stub or documentation as code injection may occur. ⚠️
Versioning

⚠️ this document refers to version 2.X, check here for 3.X.

Both 2.X and 3.X version lines of Swagger Codegen are available and are independently maintained.
NOTES:

Versions 2.X (io.swagger) and 3.X (io.swagger.codegen.v3) have different group ids.
OpenAPI 3.0.X is supported from the 3.X version only.

For full versioning information, please refer to the versioning documentation.
Supported Languages and Frameworks
Currently, the following languages/frameworks are supported:

API clients: ActionScript, Ada, Apex, Bash, C# (.net 2.0, 3.5 or later), C++ (cpprest, Qt5, Tizen), Clojure, Dart, Elixir, Elm, Eiffel, Erlang, Go, Groovy, Haskell (http-client, Servant), Java (Jersey1.x, Jersey2.x, OkHttp, Retrofit1.x, Retrofit2.x, Feign, RestTemplate, RESTEasy, Vertx, Google API Client Library for Java, Rest-assured), Kotlin, Lua, Node.js (ES5, ES6, AngularJS with Google Closure Compiler annotations) Objective-C, Perl, PHP, PowerShell, Python, R, Ruby, Rust (rust, rust-server), Scala (akka, http4s, swagger-async-httpclient), Swift (2.x, 3.x, 4.x, 5.x), Typescript (Angular1.x, Angular2.x, Fetch, jQuery, Node)
Server stubs: Ada, C# (ASP.NET Core, NancyFx), C++ (Pistache, Restbed), Erlang, Go, Haskell (Servant), Java (MSF4J, Spring, Undertow, JAX-RS: CDI, CXF, Inflector, RestEasy, Play Framework, PKMST), Kotlin, PHP (Lumen, Slim, Silex, Symfony, Zend Expressive), Python (Flask), NodeJS, Ruby (Sinatra, Rails5), Rust (rust-server), Scala (Finch, Lagom, Scalatra)
API documentation generators: HTML, Confluence Wiki
Configuration files: Apache2
Others: JMeter

Check out OpenAPI-Spec for additional information about the OpenAPI project.
Compatibility
The OpenAPI Specification has undergone 3 revisions since initial creation in 2010.  The current stable versions of Swagger Codegen project have the following compatibilities with the OpenAPI Specification:























Swagger Codegen VersionRelease DateSwagger / OpenAPI Spec compatibilityNotes3.0.65 (current stable)2024-12-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.652.4.44 (current stable)2024-12-181.0, 1.1, 1.2, 2.0tag v2.4.44
💁 Here’s also an overview of what’s coming around the corner:























Swagger Codegen VersionRelease DateSwagger / OpenAPI Spec compatibilityNotes3.0.66-SNAPSHOT (current 3.0.0, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0, 3.0Minor release2.4.45-SNAPSHOT (current master, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0Minor release
For detailed breakdown of all versions, please see the full compatibility listing.
Getting Started
To get up and running with Swagger Codegen, check out the following guides and instructions:

Prerequisites
Building
Using Docker

Once you’ve your environment setup, you’re ready to start generating clients and/or servers.
As a quick example, to generate a PHP client for https://petstore.swagger.io/v2/swagger.json, you can run the following:
Terminal window1git clone https://github.com/swagger-api/swagger-codegen2cd swagger-codegen3mvn clean package4java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \5   -i https://petstore.swagger.io/v2/swagger.json \6   -l php \7   -o /var/tmp/php_api_client
Note: if you’re on Windows, replace the last command with
Terminal window1java -jar modules wagger-codegen-cli\target wagger-codegen-cli.jar generate -i https://petstore.swagger.io/v2/swagger.json -l php -o c:\temp\php_api_client
You can also download the JAR (latest release) directly from maven.org
To get a list of general options available, you can run the following:
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar help generate
To get a list of PHP specified options (which can be passed to the generator with a config file via the -c option), please run
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar config-help -l php
Generators
To generate a sample client library
You can build a client against the swagger sample petstore API as follows:
Terminal window1./bin/java-petstore.sh
(On Windows, run .\bin\windows\java-petstore.bat instead)
This will run the generator with this command:
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \2  -i https://petstore.swagger.io/v2/swagger.json \3  -l java \4  -o samples/client/petstore/java
with a number of options. You can get the options with the help generate command (below only shows partial results):
1NAME2        swagger-codegen-cli generate - Generate code with chosen lang3
4SYNOPSIS5        swagger-codegen-cli generate6                [(-a <authorization> | --auth <authorization>)]7                [--additional-properties <additional properties>...]8                [--api-package <api package>] [--artifact-id <artifact id>]9                [--artifact-version <artifact version>]10                [(-c <configuration file> | --config <configuration file>)]11                [-D <system properties>...] [--git-repo-id <git repo id>]12                [--git-user-id <git user id>] [--group-id <group id>]13                [--http-user-agent <http user agent>]14                (-i <spec file> | --input-spec <spec file>)15                [--ignore-file-override <ignore file override location>]16                [--import-mappings <import mappings>...]17                [--instantiation-types <instantiation types>...]18                [--invoker-package <invoker package>]19                (-l <language> | --lang <language>)20                [--language-specific-primitives <language specific primitives>...]21                [--library <library>] [--model-name-prefix <model name prefix>]22                [--model-name-suffix <model name suffix>]23                [--model-package <model package>]24                [(-o <output directory> | --output <output directory>)]25                [--release-note <release note>] [--remove-operation-id-prefix]26                [--reserved-words-mappings <reserved word mappings>...]27                [(-s | --skip-overwrite)]28                [(-t <template directory> | --template-dir <template directory>)]29                [--type-mappings <type mappings>...] [(-v | --verbose)]30
31OPTIONS32        -a <authorization>, --auth <authorization>33            adds authorization headers when fetching the swagger definitions34            remotely. Pass in a URL-encoded string of name:header with a comma35            separating multiple values36
37...... (results omitted)38
39        -v, --verbose40            verbose mode
You can then compile and run the client, as well as unit tests against it:
Terminal window1cd samples/client/petstore/java2mvn package
Other languages have petstore samples, too:
Terminal window1./bin/android-petstore.sh2./bin/java-petstore.sh3./bin/objc-petstore.sh
Generating libraries from your server
It’s just as easy—just use the -i flag to point to either a server or file.
🔧 Swagger Codegen comes with a tonne of flexibility to support your code generation preferences. Checkout the generators documentation which takes you through some of the possibilities as well as showcasing how to generate from local files and ignore file formats.
Selective generation
You may not want to generate all models in your project.  Likewise you may want just one or two apis to be written. If that’s the case check the selective generation instructions.
Advanced Generator Customization
There are different aspects of customizing the code generator beyond just creating or modifying templates.  Each language has a supporting configuration file to handle different type mappings, or bring your own models. For more information check out the advanced configuration docs.
Validating your OpenAPI Spec
You have options.  The easiest is to use our online validator which not only will let you validate your spec, but with the debug flag, you can see what’s wrong with your spec.  For example check out Swagger Validator.
If you want to have validation directly on your own machine, then Spectral is an excellent option.
Generating dynamic html api documentation
To do so, just use the -l dynamic-html flag when reading a spec file.  This creates HTML documentation that is available as a single-page application with AJAX.  To view the documentation:
Terminal window1cd samples/dynamic-html/2npm install3node .
Which launches a node.js server so the AJAX calls have a place to go.
Generating static html api documentation
To do so, just use the -l html flag when reading a spec file.  This creates a single, simple HTML file with embedded css so you can ship it as an email attachment, or load it from your filesystem:
Terminal window1cd samples/html/2open index.html
Workflow Integration
It’s possible to leverage Swagger Codegen directly within your preferred CI/CD workflows to streamline your auto-generation requirements. Check out the workflows integration guide to see information on our Maven, Gradle, and GitHub integration options. 🚀
Online Generators
If you don’t want to run and host your own code generation instance, check our our online generators information.
Contributing
Please refer to this page
Security contact
Please disclose any security-related issues or vulnerabilities by emailing security@swagger.io, instead of using the public issue tracker.
Thank You
💚💚💚 We’d like to give a big shout out to all those who’ve contributed to Swagger Codegen, be that in raising issues, fixing bugs, authoring templates, or crafting useful content for others to benefit from. 💚💚💚     Edit page        Previous  Online Generators       Next  Versioning\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Versioning        Both 2.X and 3.X version lines of Swagger Codegen are available and are independently maintained.
NOTE: version 2.X (io.swagger) and 3.X (io.swagger.codegen.v3) have different group ids.
Swagger Codegen 2.X





























Version:2.XRepository branch:mastergroupId:io.swaggerSwagger/OpenAPI support:2.0maven central (maven plugin):swagger-codegen-maven-plugin
dependency example:
1<dependency>2    <groupId>io.swagger</groupId>3    <artifactId>swagger-codegen-maven-plugin</artifactId>4    <version>2.4.44</version>5</dependency>
Swagger Codegen 3.X





























Version:3.XRepository branch:3.0.0groupId:io.swagger.codegen.v3Swagger/OpenAPI support:2.0 (by using engine + generators of 2.X), 3.0.Xmaven central:io.swagger.codegen.v3
dependency example:
1<dependency>2    <groupId>io.swagger.codegen.v3</groupId>3    <artifactId>swagger-codegen-maven-plugin</artifactId>4    <version>3.0.61</version>5</dependency>     Edit page        Previous  What is Swagger Codegen?       Next  Compatibility\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Compatibility        The Swagger Codegen project has the following compatibilities with the OpenAPI Specification (formerly known as Swagger):















































































































































































































































































































































































































































































































































































































































































































































Swagger Codegen VersionRelease DateOpenAPI Spec compatibilityNotes3.0.66-SNAPSHOT (current 3.0.0, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0, 3.0Minor release3.0.65 (current stable)2024-12-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.653.0.642024-11-071.0, 1.1, 1.2, 2.0, 3.0tag v3.0.643.0.632024-10-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.633.0.622024-08-271.0, 1.1, 1.2, 2.0, 3.0tag v3.0.623.0.612024-08-091.0, 1.1, 1.2, 2.0, 3.0tag v3.0.613.0.602024-08-011.0, 1.1, 1.2, 2.0, 3.0tag v3.0.603.0.592024-07-221.0, 1.1, 1.2, 2.0, 3.0tag v3.0.593.0.582024-07-081.0, 1.1, 1.2, 2.0, 3.0tag v3.0.583.0.572024-05-271.0, 1.1, 1.2, 2.0, 3.0tag v3.0.573.0.562024-05-101.0, 1.1, 1.2, 2.0, 3.0tag v3.0.563.0.552024-04-221.0, 1.1, 1.2, 2.0, 3.0tag v3.0.553.0.542024-02-191.0, 1.1, 1.2, 2.0, 3.0tag v3.0.543.0.532024-02-141.0, 1.1, 1.2, 2.0, 3.0tag v3.0.533.0.522023-12-301.0, 1.1, 1.2, 2.0, 3.0tag v3.0.523.0.512023-11-211.0, 1.1, 1.2, 2.0, 3.0tag v3.0.513.0.502023-10-261.0, 1.1, 1.2, 2.0, 3.0tag v3.0.503.0.492023-10-231.0, 1.1, 1.2, 2.0, 3.0tag v3.0.493.0.482023-10-191.0, 1.1, 1.2, 2.0, 3.0tag v3.0.483.0.472023-10-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.473.0.462023-06-071.0, 1.1, 1.2, 2.0, 3.0tag v3.0.463.0.452023-06-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.453.0.442023-05-231.0, 1.1, 1.2, 2.0, 3.0tag v3.0.443.0.432023-05-171.0, 1.1, 1.2, 2.0, 3.0tag v3.0.433.0.422023-04-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.423.0.412023-02-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.413.0.402023-01-271.0, 1.1, 1.2, 2.0, 3.0tag v3.0.403.0.392023-01-251.0, 1.1, 1.2, 2.0, 3.0tag v3.0.393.0.382023-01-221.0, 1.1, 1.2, 2.0, 3.0tag v3.0.383.0.372023-01-191.0, 1.1, 1.2, 2.0, 3.0tag v3.0.373.0.362022-11-101.0, 1.1, 1.2, 2.0, 3.0tag v3.0.363.0.352022-08-151.0, 1.1, 1.2, 2.0, 3.0tag v3.0.353.0.342022-04-121.0, 1.1, 1.2, 2.0, 3.0tag v3.0.343.0.332022-02-071.0, 1.1, 1.2, 2.0, 3.0tag v3.0.333.0.322022-01-111.0, 1.1, 1.2, 2.0, 3.0tag v3.0.323.0.312021-12-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.313.0.302021-11-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.303.0.292021-10-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.293.0.282021-09-301.0, 1.1, 1.2, 2.0, 3.0tag v3.0.283.0.272021-06-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.273.0.262021-05-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.263.0.252021-03-041.0, 1.1, 1.2, 2.0, 3.0tag v3.0.253.0.242020-12-291.0, 1.1, 1.2, 2.0, 3.0tag v3.0.243.0.232020-11-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.233.0.222020-10-051.0, 1.1, 1.2, 2.0, 3.0tag v3.0.223.0.212020-07-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.213.0.202020-05-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.203.0.192020-04-021.0, 1.1, 1.2, 2.0, 3.0tag v3.0.193.0.182020-02-261.0, 1.1, 1.2, 2.0, 3.0tag v3.0.183.0.172020-02-231.0, 1.1, 1.2, 2.0, 3.0tag v3.0.173.0.172020-01-151.0, 1.1, 1.2, 2.0, 3.0tag v3.0.163.0.152020-01-031.0, 1.1, 1.2, 2.0, 3.0tag v3.0.153.0.142019-11-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.143.0.132019-10-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.133.0.122019-10-141.0, 1.1, 1.2, 2.0, 3.0tag v3.0.123.0.112019-08-241.0, 1.1, 1.2, 2.0, 3.0tag v3.0.113.0.102019-07-111.0, 1.1, 1.2, 2.0, 3.0tag v3.0.103.0.92019-06-281.0, 1.1, 1.2, 2.0, 3.0tag v3.0.93.0.82019-04-251.0, 1.1, 1.2, 2.0, 3.0tag v3.0.83.0.72019-03-261.0, 1.1, 1.2, 2.0, 3.0tag v3.0.73.0.52019-02-181.0, 1.1, 1.2, 2.0, 3.0tag v3.0.53.0.42019-01-161.0, 1.1, 1.2, 2.0, 3.0tag v3.0.43.0.32018-11-301.0, 1.1, 1.2, 2.0, 3.0tag v3.0.33.0.22018-10-191.0, 1.1, 1.2, 2.0, 3.0Minor release3.0.12018-10-051.0, 1.1, 1.2, 2.0, 3.0Major release with breaking changes3.0.02018-09-061.0, 1.1, 1.2, 2.0, 3.0Major release with breaking changes2.4.45-SNAPSHOT (current master, upcoming minor release) SNAPSHOTTBD1.0, 1.1, 1.2, 2.0Minor release2.4.44 (current stable)2024-12-181.0, 1.1, 1.2, 2.0tag v2.4.442.4.432024-08-091.0, 1.1, 1.2, 2.0tag v2.4.432.4.422024-07-291.0, 1.1, 1.2, 2.0tag v2.4.422.4.412024-04-221.0, 1.1, 1.2, 2.0tag v2.4.412.4.392024-01-021.0, 1.1, 1.2, 2.0tag v2.4.392.4.382023-12-291.0, 1.1, 1.2, 2.0tag v2.4.382.4.372023-11-211.0, 1.1, 1.2, 2.0tag v2.4.372.4.362023-10-261.0, 1.1, 1.2, 2.0tag v2.4.362.4.352023-10-261.0, 1.1, 1.2, 2.0tag v2.4.352.4.342023-10-191.0, 1.1, 1.2, 2.0tag v2.4.342.4.332023-10-021.0, 1.1, 1.2, 2.0tag v2.4.332.4.322023-05-171.0, 1.1, 1.2, 2.0tag v2.4.322.4.312023-04-021.0, 1.1, 1.2, 2.0tag v2.4.312.4.302023-02-161.0, 1.1, 1.2, 2.0tag v2.4.302.4.292022-11-101.0, 1.1, 1.2, 2.0tag v2.4.292.4.282022-08-151.0, 1.1, 1.2, 2.0tag v2.4.282.4.272022-04-121.0, 1.1, 1.2, 2.0tag v2.4.272.4.262022-02-071.0, 1.1, 1.2, 2.0tag v2.4.262.4.252021-12-281.0, 1.1, 1.2, 2.0tag v2.4.252.4.242021-11-181.0, 1.1, 1.2, 2.0tag v2.4.242.4.232021-10-081.0, 1.1, 1.2, 2.0tag v2.4.232.4.222021-09-301.0, 1.1, 1.2, 2.0tag v2.4.222.4.212021-06-281.0, 1.1, 1.2, 2.0tag v2.4.212.4.202021-05-281.0, 1.1, 1.2, 2.0tag v2.4.202.4.192021-03-041.0, 1.1, 1.2, 2.0tag v2.4.192.4.182020-12-291.0, 1.1, 1.2, 2.0tag v2.4.182.4.172020-11-021.0, 1.1, 1.2, 2.0tag v2.4.172.4.162020-10-051.0, 1.1, 1.2, 2.0tag v2.4.162.4.152020-07-281.0, 1.1, 1.2, 2.0tag v2.4.152.4.142020-05-181.0, 1.1, 1.2, 2.0tag v2.4.142.4.132020-04-021.0, 1.1, 1.2, 2.0tag v2.4.132.4.122020-01-151.0, 1.1, 1.2, 2.0tag v2.4.122.4.112020-01-031.0, 1.1, 1.2, 2.0tag v2.4.112.4.102019-11-161.0, 1.1, 1.2, 2.0tag v2.4.102.4.92019-10-141.0, 1.1, 1.2, 2.0tag v2.4.92.4.82019-08-241.0, 1.1, 1.2, 2.0tag v2.4.82.4.72019-07-111.0, 1.1, 1.2, 2.0tag v2.4.72.4.62019-06-281.0, 1.1, 1.2, 2.0tag v2.4.62.4.52019-04-251.0, 1.1, 1.2, 2.0tag v2.4.52.4.42019-03-261.0, 1.1, 1.2, 2.0tag v2.4.42.4.22019-02-181.0, 1.1, 1.2, 2.0tag v2.4.22.4.12019-01-161.0, 1.1, 1.2, 2.0tag v2.4.12.4.02018-11-301.0, 1.1, 1.2, 2.0tag v2.4.02.3.12018-01-171.0, 1.1, 1.2, 2.0tag v2.3.12.3.02017-12-211.0, 1.1, 1.2, 2.0tag v2.3.02.2.32017-07-151.0, 1.1, 1.2, 2.0tag v2.2.32.2.22017-03-011.0, 1.1, 1.2, 2.0tag v2.2.22.2.12016-08-071.0, 1.1, 1.2, 2.0tag v2.2.12.1.62016-04-061.0, 1.1, 1.2, 2.0tag v2.1.62.0.172014-08-221.1, 1.2tag v2.0.171.0.42012-04-121.0, 1.1tag v1.0.4     Edit page        Previous  Versioning       Next  Prerequisites\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Prerequisites        If you’re looking for the latest stable version, you can grab it directly from Maven.org (Java 8 runtime at a minimum):
Terminal window1# Download current stable 2.x.x branch (Swagger and OpenAPI version 2)2wget https://repo1.maven.org/maven2/io/swagger/swagger-codegen-cli/2.4.44/swagger-codegen-cli-2.4.44.jar -O swagger-codegen-cli.jar3
4java -jar swagger-codegen-cli.jar help5
6# Download current stable 3.x.x branch (OpenAPI version 3)7wget https://repo1.maven.org/maven2/io/swagger/codegen/v3/swagger-codegen-cli/3.0.65/swagger-codegen-cli-3.0.65.jar -O swagger-codegen-cli.jar8
9java -jar swagger-codegen-cli.jar --help
For Windows users, you will need to install wget or you can use Invoke-WebRequest in PowerShell (3.0+).
example:
Terminal window1Invoke-WebRequest -OutFile swagger-codegen-cli.jar https://repo1.maven.org/maven2/io/swagger/swagger-codegen-cli/2.4.44/swagger-codegen-cli-2.4.44.jar
On a mac, it’s even easier with brew:
Terminal window1brew install swagger-codegen
To build from source, you need the following installed and available in your $PATH:


Java 11+


Apache maven 3.6.2 or greater


OS X Users
Don’t forget to install Java 11+.
Export JAVA_HOME in order to use the supported Java version:
Terminal window1export JAVA_HOME=`/usr/libexec/java_home -v 11`2export PATH=${JAVA_HOME}/bin:$PATH     Edit page        Previous  Compatibility       Next  Building\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Building        After cloning the project, you can build it from source with this command:
Terminal window1mvn clean package
If you don’t have maven installed, you may directly use the included maven wrapper, and build with the command:
Terminal window1./mvnw clean package
Homebrew
To install, run brew install swagger-codegen
Here is an example usage:
Terminal window1swagger-codegen generate -i https://petstore.swagger.io/v2/swagger.json -l ruby -o /tmp/test/
To build a server stub
Please refer to https://github.com/swagger-api/swagger-codegen/wiki/Server-stub-generator-HOWTO for more information.
To build the codegen library
This will create the Swagger Codegen library from source.
Terminal window1mvn package
Note!  The templates are included in the library generated.  If you want to modify the templates, you’ll need to either repackage the library OR specify a path to your scripts.     Edit page        Previous  Prerequisites       Next  Using Docker\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Using Docker        Development in docker
You can use run-in-docker.sh to do all development. This script maps your local repository to /gen
in the docker container. It also maps ~/.m2/repository to the appropriate container location.
To execute mvn package:
Terminal window1git clone https://github.com/swagger-api/swagger-codegen2cd swagger-codegen3./run-in-docker.sh mvn package
Build artifacts are now accessible in your working directory.
Once built, run-in-docker.sh will act as an executable for swagger-codegen-cli. To generate code, you’ll need to output to a directory under /gen (e.g. /gen/out). For example:
Terminal window1./run-in-docker.sh help # Executes 'help' command for swagger-codegen-cli2./run-in-docker.sh langs # Executes 'langs' command for swagger-codegen-cli3./run-in-docker.sh /gen/bin/go-petstore.sh  # Builds the Go client4./run-in-docker.sh generate -i modules/swagger-codegen/src/test/resources/2_0/petstore.yaml \5    -l go -o /gen/out/go-petstore -DpackageName=petstore # generates go client, outputs locally to ./out/go-petstore
Standalone generator Development in docker
See standalone generator development
Run Docker in Vagrant
Prerequisite: install Vagrant and VirtualBox.
Terminal window1git clone http://github.com/swagger-api/swagger-codegen.git2cd swagger-codegen3vagrant up4vagrant ssh5cd /vagrant6./run-in-docker.sh mvn package
Public Pre-built Docker images

https://hub.docker.com/r/swaggerapi/swagger-generator/ (official web service)
https://hub.docker.com/r/swaggerapi/swagger-codegen-cli/ (official CLI)

Swagger Generator Docker Image
The Swagger Generator image can act as a self-hosted web application and API for generating code. This container can be  incorporated into a CI pipeline, and requires at least two HTTP requests and some docker orchestration to access generated code.
Example usage (note this assumes jq is installed for command line processing of JSON):
Terminal window1# Start container and save the container id2CID=$(docker run -d swaggerapi/swagger-generator)3# allow for startup4sleep 55# Get the IP of the running container6GEN_IP=$(docker inspect --format '{{.NetworkSettings.IPAddress}}'  $CID)7# Execute an HTTP request and store the download link8RESULT=$(curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' -d '{9  "swaggerUrl": "https://petstore.swagger.io/v2/swagger.json"10}' 'http://localhost:8188/api/gen/clients/javascript' | jq '.link' | tr -d '"')11# Download the generated zip and redirect to a file12curl $RESULT > result.zip13# Shutdown the swagger generator image14docker stop $CID && docker rm $CID
In the example above, result.zip will contain the generated client.
Swagger Codegen CLI Docker Image
The Swagger Codegen image acts as a standalone executable. It can be used as an alternative to installing via homebrew, or for developers who are unable to install Java or upgrade the installed version.
To generate code with this image, you’ll need to mount a local location as a volume.
Example:
Terminal window1docker run --rm -v ${PWD}:/local swaggerapi/swagger-codegen-cli generate \2    -i https://petstore.swagger.io/v2/swagger.json \3    -l go \4    -o /local/out/go
(On Windows replace ${PWD} with %CD%)
The generated code will be located under ./out/go in the current directory.     Edit page        Previous  Building       Next  Generators\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Generators        If the default generator configuration does not meet your needs, you have various options to modify or create new modules or templates.
Modifying the client library format
Don’t like the default swagger client syntax?  Want a different language supported?  No problem!  Swagger Codegen processes mustache templates with the jmustache engine.  You can modify our templates or make your own.
You can look at modules/swagger-codegen/src/main/resources/${your-language} for examples.  To make your own templates, create your own files and use the -t flag to specify your template folder.  It actually is that easy.
Making your own codegen modules
If you’re starting a project with a new language and don’t see what you need, Swagger Codegen can help you create a project to generate your own libraries:
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar meta \2  -o output/myLibrary -n myClientCodegen -p com.my.company.codegen
This will write, in the folder output/myLibrary, all the files you need to get started, including a README.md. Once modified and compiled, you can load your library with the codegen and generate clients with your own, custom-rolled logic.
You would then compile your library in the output/myLibrary folder with mvn package and execute the codegen like such:
Terminal window1java -cp output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar:modules/swagger-codegen-cli/target/swagger-codegen-cli.jar io.swagger.codegen.SwaggerCodegen
For Windows users, you will need to use ; instead of : in the classpath, e.g.:
Terminal window1java -cp output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar;modules/swagger-codegen-cli/target/swagger-codegen-cli.jar io.swagger.codegen.SwaggerCodegen
Note the myClientCodegen is an option now, and you can use the usual arguments for generating your library:
Terminal window1java -cp output/myLibrary/target/myClientCodegen-swagger-codegen-1.0.0.jar:modules/swagger-codegen-cli/target/swagger-codegen-cli.jar \2  io.swagger.codegen.SwaggerCodegen generate -l myClientCodegen\3  -i https://petstore.swagger.io/v2/swagger.json \4  -o myClient
See also standalone generator development.
Generating a client from local files
If you don’t want to call your server, you can save the OpenAPI Spec files into a directory and pass an argument
to the code generator like this:
Terminal window1-i ./modules/swagger-codegen/src/test/resources/2_0/petstore.json
Great for creating libraries on your ci server, from the Swagger Editor… or while coding on an airplane ✈️.
Ignore file format
Swagger Codegen supports a .swagger-codegen-ignore file, similar to .gitignore or .dockerignore you’re probably already familiar with.
The ignore file allows for better control over overwriting existing files than the --skip-overwrite flag. With the ignore file, you can specify individual files or directories can be ignored. This can be useful, for example if you only want a subset of the generated code.
Examples:
Terminal window1# Swagger Codegen Ignore2# Lines beginning with a # are comments3
4# This should match build.sh located anywhere.5build.sh6
7# Matches build.sh in the root8/build.sh9
10# Exclude all recursively11docs/**12
13# Explicitly allow files excluded by other rules14!docs/UserApi.md15
16# Recursively exclude directories named Api17# You can't negate files below this directory.18src/**/Api/19
20# When this file is nested under /Api (excluded above),21# this rule is ignored because parent directory is excluded by previous rule.22!src/**/PetApiTests.cs23
24# Exclude a single, nested file explicitly25src/IO.Swagger.Test/Model/AnimalFarmTests.cs
The .swagger-codegen-ignore file must exist in the root of the output directory.
Upon first code generation, you may also pass the CLI option --ignore-file-override=/path/to/ignore_file for greater control over generated outputs. Note that this is a complete override, and will override the .swagger-codegen-ignore file in an output directory when regenerating code.
Editor support for .swagger-codegen-ignore files is available in IntelliJ via the .ignore plugin.     Edit page        Previous  Using Docker       Next  Selective Generation\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Selective Generation        You may not want to generate all models in your project.  Likewise you may want just one or two apis to be written. If that’s the case, you can use system properties to control the output:
The default is generate everything supported by the specific library.  Once you enable a feature, it will restrict the contents generated:
Terminal window1# generate only models2java -Dmodels {opts}3
4# generate only apis5java -Dapis {opts}6
7# generate only supporting files8java -DsupportingFiles9
10# generate models and supporting files11java -Dmodels -DsupportingFiles
To control the specific files being generated, you can pass a CSV list of what you want:
Terminal window1# generate the User and Pet models only2-Dmodels=User,Pet3
4# generate the User model and the supportingFile `StringUtil.java`:5-Dmodels=User -DsupportingFiles=StringUtil.java
To control generation of docs and tests for api and models, pass false to the option. For api, these options are  -DapiTests=false and -DapiDocs=false. For models, -DmodelTests=false and -DmodelDocs=false.
These options default to true and don’t limit the generation of the feature options listed above (like -Dapi):
Terminal window1# generate only models (with tests and documentation)2java -Dmodels {opts}3
4# generate only models (with tests but no documentation)5java -Dmodels -DmodelDocs=false {opts}6
7# generate only User and Pet models (no tests and no documentation)8java -Dmodels=User,Pet -DmodelTests=false {opts}9
10# generate only apis (without tests)11java -Dapis -DapiTests=false {opts}12
13# generate only apis (modelTests option is ignored)14java -Dapis -DmodelTests=false {opts}
When using selective generation, only the templates needed for the specific generation will be used.     Edit page        Previous  Generators       Next  Advanced Generator Configuration\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Generators Configuration        There are different aspects of customizing the code generator beyond just creating or modifying templates.  Each language has a supporting configuration file to handle different type mappings, etc:
Terminal window1$ ls -1 modules/swagger-codegen/src/main/java/io/swagger/codegen/languages/2AbstractJavaJAXRSServerCodegen.java3AbstractTypeScriptClientCodegen.java4... (results omitted)5TypeScriptAngularClientCodegen.java6TypeScriptNodeClientCodegen.java
Each of these files creates reasonable defaults so you can get running quickly.  But if you want to configure package names, prefixes, model folders, etc. you can use a json config file to pass the values.
Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \2  -i https://petstore.swagger.io/v2/swagger.json \3  -l java \4  -o samples/client/petstore/java \5  -c path/to/config.json
and config.json contains the following as an example:
1{2  "apiPackage" : "petstore"3}
Supported config options can be different per language. Running config-help -l {lang} will show available options.
These options are applied via configuration file (e.g. config.json) or by passing them with java -jar swagger-codegen-cli.jar -D{optionName}={optionValue}.

If -D{optionName} does not work, please open a ticket and we’ll look into it.

Terminal window1java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar config-help -l java
Output
1CONFIG OPTIONS2modelPackage3    package for generated models4
5apiPackage6    package for generated api classes7...... (results omitted)8library9    library template (sub-template) to use:10    jersey1 - HTTP client: Jersey client 1.18. JSON processing: Jackson 2.4.211    jersey2 - HTTP client: Jersey client 2.612    feign - HTTP client: Netflix Feign 8.1.1.  JSON processing: Jackson 2.6.313    okhttp-gson (default) - HTTP client: OkHttp 2.4.0. JSON processing: Gson 2.3.114    retrofit - HTTP client: OkHttp 2.4.0. JSON processing: Gson 2.3.1 (Retrofit 1.9.0)15    retrofit2 - HTTP client: OkHttp 2.5.0. JSON processing: Gson 2.4 (Retrofit 2.0.0-beta2)16    google-api-client - HTTP client: google-api-client 1.23.0. JSON processing: Jackson 2.8.917    rest-assured - HTTP client: rest-assured : 3.1.0. JSON processing: Gson 2.6.1. Only for Java8
Your config file for Java can look like
1{2  "groupId": "com.my.company",3  "artifactId": "MyClient",4  "artifactVersion": "1.2.0",5  "library": "feign"6}
For all the unspecified options default values will be used.
Another way to override default options is to extend the config class for the specific language.
To change, for example, the prefix for the Objective-C generated files, simply subclass the ObjcClientCodegen.java:
1package com.mycompany.swagger.codegen;2
3import io.swagger.codegen.languages.*;4
5public class MyObjcCodegen extends ObjcClientCodegen {6    static {7        PREFIX = "HELO";8    }9}
and specify the classname when running the generator:
Terminal window1-l com.mycompany.swagger.codegen.MyObjcCodegen
Your subclass will now be loaded and overrides the PREFIX value in the superclass.
Bringing your own models
Sometimes you don’t want a model generated.  In this case, you can simply specify an import mapping to tell
the codegen what not to create.  When doing this, every location that references a specific model will
refer back to your classes.  Note, this may not apply to all languages…
To specify an import mapping, use the --import-mappings argument and specify the model-to-import logic as such:
Terminal window1--import-mappings Pet=my.models.MyPet
Or for multiple mappings:
Terminal window1--import-mappings Pet=my.models.MyPet,Order=my.models.MyOrder
or
Terminal window1--import-mappings Pet=my.models.MyPet --import-mappings Order=my.models.MyOrder     Edit page        Previous  Selective Generation       Next  Workflow Integration\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Workflow Integration        Maven Integration
You can use the swagger-codegen-maven-plugin for integrating with your workflow, and generating any codegen target.
Gradle Integration
Gradle Swagger Generator Plugin is available for generating source code and API document.
GitHub Integration
To push the auto-generated SDK to GitHub, we provide git_push.sh to streamline the process. For example:


Create a new repository in GitHub (Ref: https://help.github.com/articles/creating-a-new-repository/)


Generate the SDK


Terminal window1 java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \2 -i modules/swagger-codegen/src/test/resources/2_0/petstore.json -l perl \3 --git-user-id "swaggerapi" \4 --git-repo-id "petstore-perl" \5 --release-note "Github integration demo" \6 -o /var/tmp/perl/petstore

Push the SDK to GitHub

Terminal window1cd /var/tmp/perl/petstore2/bin/sh ./git_push.sh     Edit page        Previous  Advanced Generator Configuration       Next  Online Generators\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Codegen Online Generators        One can also generate API client or server using the online generators (https://generator.swagger.io)
For example, to generate Ruby API client, simply send the following HTTP request using curl:
Terminal window1curl -X POST -H "content-type:application/json" -d '{"swaggerUrl":"https://petstore.swagger.io/v2/swagger.json"}' https://generator.swagger.io/api/gen/clients/ruby
Then you will receive a JSON response with the URL to download the zipped code.
To customize the SDK, you can POST to https://generator.swagger.io/api/gen/clients/{language} with the following HTTP body:
1{2  "options":  {},3  "swaggerUrl": "https://petstore.swagger.io/v2/swagger.json"4}
in which the options for a language can be obtained by submitting a GET request to https://generator.swagger.io/api/gen/clients/{language}:
For example, curl https://generator.swagger.io/api/gen/clients/python returns
1{2  "packageName": {3    "opt": "packageName",4    "description": "python package name (convention: snake_case).",5    "type": "string",6    "default": "swagger_client"7  },8  "packageVersion": {9    "opt": "packageVersion",10    "description": "python package version.",11    "type": "string",12    "default": "1.0.0"13  },14  "sortParamsByRequiredFlag": {15    "opt": "sortParamsByRequiredFlag",16    "description": "Sort method arguments to place required parameters before optional parameters.",17    "type": "boolean",18    "default": "true"19  }20}
To set package name to pet_store, the HTTP body of the request is as follows:
1{2  "options": {3    "packageName": "pet_store"4  },5  "swaggerUrl": "https://petstore.swagger.io/v2/swagger.json"6}
and here is the curl command:
Terminal window1curl -H "Content-type: application/json" -X POST -d '{"options": {"packageName": "pet_store"},"swaggerUrl": "https://petstore.swagger.io/v2/swagger.json"}' https://generator.swagger.io/api/gen/clients/python
Instead of using swaggerUrl with an URL to the OpenAPI/Swagger spec, one can include the spec in the JSON payload with spec, e.g.
1{2  "options": {},3  "spec": {4    "swagger": "2.0",5    "info": {6      "version": "1.0.0",7      "title": "Test API"8    },9    ...10  }11}     Edit page        Previous  Workflow Integration       Next  What Is OpenAPI?\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nWhat Is OpenAPI?        OpenAPI Specification (formerly Swagger Specification) is an API description format for REST APIs. An OpenAPI file allows you to describe your entire API, including:

Available endpoints (/users) and operations on each endpoint (GET /users, POST /users)
Operation parameters Input and output for each operation
Authentication methods
Contact information, license, terms of use, and other information.

API specifications can be written in YAML or JSON. The format is easy to learn and readable to both humans and machines. The complete OpenAPI Specification can be found on GitHub: OpenAPI 3.0 Specification
What Is Swagger?
Swagger is a set of open-source tools built around the OpenAPI Specification that can help you design, build, document, and consume REST APIs. The major Swagger tools include:

Swagger Editor – browser-based editor where you can write OpenAPI definitions.
Swagger UI – renders OpenAPI definitions as interactive documentation.
Swagger Codegen – generates server stubs and client libraries from an OpenAPI definition.
Swagger Editor Next (beta) – browser-based editor where you can write and review OpenAPI and AsyncAPI definitions.
Swagger Core – Java-related libraries for creating, consuming, and working with OpenAPI definitions.
Swagger Parser – standalone library for parsing OpenAPI definitions.
Swagger APIDom – provides a single, unifying structure for describing APIs across various description languages and serialization formats.

Why Use OpenAPI?
The ability of APIs to describe their own structure is the root of all awesomeness in OpenAPI. Once written, an OpenAPI specification and Swagger tools can drive your API development further in various ways:

Design-first users: use Swagger Codegen to generate a server stub for your API. The only thing left is to implement the server logic – and your API is ready to go live!
Use Swagger Codegen to generate client libraries for your API in over 40 languages.
Use Swagger UI to generate interactive API documentation that lets your users try out the API calls directly in the browser.
Use the spec to connect API-related tools to your API. For example, import the spec to SoapUI to create automated tests for your API.
And more! Check out the open-source and commercial tools that integrate with Swagger.
     Edit page        Previous  Online Generators       Next  Basic Structure\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nBasic Structure        NoteOAS 3 This page is about OpenAPI 3.0. If you use OpenAPI 2.0, visit OpenAPI 2.0 pages.
You can write OpenAPI definitions in YAML or JSON. In this guide, we use only YAML examples but JSON works equally well. A sample OpenAPI 3.0 definition written in YAML looks like:
1openapi: 3.0.42info:3  title: Sample API4  description: Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML.5  version: 0.1.96
7servers:8  - url: http://api.example.com/v19    description: Optional server description, e.g. Main (production) server10  - url: http://staging-api.example.com11    description: Optional server description, e.g. Internal staging server for testing12
13paths:14  /users:15    get:16      summary: Returns a list of users.17      description: Optional extended description in CommonMark or HTML.18      responses:19        "200": # status code20          description: A JSON array of user names21          content:22            application/json:23              schema:24                type: array25                items:26                  type: string
All keyword names are case-sensitive.
Metadata
Every API definition must include the version of the OpenAPI Specification that this definition is based on:
1openapi: 3.0.4
The OpenAPI version defines the overall structure of an API definition – what you can document and how you document it. OpenAPI 3.0 uses semantic versioning with a three-part version number. The available versions are 3.0.0, 3.0.1, 3.0.2, 3.0.3, and 3.0.4; they are functionally the same.
The info section contains API information: title, description (optional), version:
1info:2  title: Sample API3  description: Optional multiline or single-line description in [CommonMark](http://commonmark.org/help/) or HTML.4  version: 0.1.9
title is your API name. description is extended information about your API. It can be multiline and supports the CommonMark dialect of Markdown for rich text representation. HTML is supported to the extent provided by CommonMark (see HTML Blocks in CommonMark 0.27 Specification). version is an arbitrary string that specifies the version of your API (do not confuse it with file revision or the openapi version). You can use semantic versioning like major.minor.patch, or an arbitrary string like 1.0-beta or 2017-07-25. info also supports other keywords for contact information, license, terms of service, and other details.
Reference: Info Object.
Servers
The servers section specifies the API server and base URL. You can define one or several servers, such as production and sandbox.
1servers:2  - url: http://api.example.com/v13    description: Optional server description, e.g. Main (production) server4  - url: http://staging-api.example.com5    description: Optional server description, e.g. Internal staging server for testing
All API paths are relative to the server URL. In the example above, /users means http://api.example.com/v1/users or http://staging-api.example.com/users, depending on the server used. For more information, see API Server and Base Path.
Paths
The paths section defines individual endpoints (paths) in your API, and the HTTP methods (operations) supported by these endpoints. For example, GET /users can be described as:
1paths:2  /users:3    get:4      summary: Returns a list of users.5      description: Optional extended description in CommonMark or HTML6      responses:7        "200":8          description: A JSON array of user names9          content:10            application/json:11              schema:12                type: array13                items:14                  type: string     Edit page        Previous  What Is OpenAPI?       Next  API Server and Base Path\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Server and Base Path        NoteOAS 3 This page is about OpenAPI 3.0. If you use OpenAPI 2.0, see the OpenAPI 2.0 guide.
All API endpoints are relative to the base URL. For example, assuming the base URL of https://api.example.com/v1, the /users endpoint refers to https://api.example.com/v1/users.
1https://api.example.com/v1/users?role=admin&status=active2\________________________/\____/ \______________________/3server URL       endpoint    query parameters4path
In OpenAPI 3.0, you use the servers array to specify one or more base URLs for your API. servers replaces the host, basePath and schemes keywords used in OpenAPI 2.0. Each server has an url and an optional Markdown-formatted description.
1servers:2  - url: https://api.example.com/v1    # The "url: " prefix is required
You can also have multiple servers, for example, production and sandbox:
1servers:2  - url: https://api.example.com/v13    description: Production server (uses live data)4  - url: https://sandbox-api.example.com:8443/v15    description: Sandbox server (uses test data)
Server URL Format
Server URL format follows RFC 3986 and usually looks like this:
1scheme://host[:port][/path]
The host can be a name or IP address (IPv4 or IPv6). WebSocket schemes ws:// and wss:// from OpenAPI 2.0 are also supported in OpenAPI 3.0. Examples of valid server URLs:
1https://api.example.com2https://api.example.com:8443/v1/reports3http://localhost:3025/v14http://10.0.81.36/v15ws://api.example.com/v16wss://api.example.com/v17/v1/reports8/9//api.example.com
If the server URL is relative, it is resolved against the server where the given OpenAPI definition file is hosted (more on that below). Note: Server URL must not include query string parameters. For example, this is invalid:
1https://api.example.com/v1?route=
If the servers array is not provided or is empty, the server URL defaults to /:
1servers:2  - url: /
Server Templating
Any part of the server URL – scheme, host name or its parts, port, subpath – can be parameterized using variables. Variables are indicated by {curly braces} in the server url, like so:
1servers:2  - url: https://{customerId}.saas-app.com:{port}/v23    variables:4      customerId:5        default: demo6        description: Customer ID assigned by the service provider7      port:8        enum:9          - '443'10          - '8443'11        default: '443'
Unlike path parameters, server variables do not use a schema. Instead, they are assumed to be strings. Variables can have arbitrary values, or may be restricted to an enum. In any case, a default value is required, which will be used if the client does not supply a value. Variable description is optional, but useful to have and supports Markdown (CommonMark) for rich text formatting. Common use cases for server templating:

Specifying multiple protocols (such as HTTP vs HTTPS).
SaaS (hosted) applications where each customer has their own subdomain.
Regional servers in different geographical regions (example: Amazon Web Services).
Single API definition for SaaS and on-premise APIs.

Examples
HTTPS and HTTP
1servers:2  - url: http://api.example.com3  - url: https://api.example.com
Or using templating:
1servers:2  - url: '{protocol}://api.example.com'3    variables:4      protocol:5        enum:6          - http7          - https8        default: https
Note: These two examples are semantically different. The second example explicitly sets the HTTPS server as default, whereas the first example does not have a default server.
Production, Development and Staging
1servers:2  - url: https://{environment}.example.com/v23    variables:4      environment:5        default: api    # Production server6        enum:7          - api         # Production server8          - api.dev     # Development server9          - api.staging # Staging server
SaaS and On-Premise
1servers:2  - url: "{server}/v1"3    variables:4      server:5        default: https://api.example.com # SaaS server
Regional Endpoints for Different Geographical Areas
1servers:2  - url: https://{region}.api.cognitive.microsoft.com3    variables:4      region:5        default: westus6        enum:7          - westus8          - eastus29          - westcentralus10          - westeurope11          - southeastasia
Overriding Servers
The global servers array can be overridden on the path level or operation level. This is handy if some endpoints use a different server or base path than the rest of the API. Common examples are:

Different base URL for file upload and download operations,
Deprecated but still functional endpoints.

1servers:2  - url: https://api.example.com/v13
4paths:5  /files:6    description: File upload and download operations7    servers:8      - url: https://files.example.com9        description: Override base path for all operations with the /files path10    ...11
12/ping:13    get:14      servers:15        - url: https://echo.example.com16          description: Override base path for the GET /ping operation
Relative URLs
The URLs in the servers array can be relative, such as /v2. In this case, the URL is resolved against the server that hosts the given OpenAPI definition. This is useful in on-premises installations hosted on your customer’s own servers. For example, if the definition hosted at http://localhost:3001/openapi.yaml specifies url: /v2, the url is resolved to http://localhost:3001/v2. Relative URL resolution rules follow RFC 3986. Moreover, almost all other URLs in an API definition, including OAuth 2 flow endpoints, termsOfService, external documentation URL and others, can be specified relative to the server URL.
1servers:2  - url: https://api.example.com3  - url: https://sandbox-api.example.com4
5# Relative URL to Terms of Service6info:7  version: 0.0.08  title: test9  termsOfService: /terms-of-use10
11# Relative URL to external documentation12externalDocs:13  url: /docs14  description: Find more info here15
16# Relative URLs to OAuth2 authorization and token URLs17components:18  securitySchemes:19    oauth2:20      type: oauth221      flows:22        authorizationCode:23          authorizationUrl: /oauth/dialog24          tokenUrl: /oauth/token
Note that if using multiple servers, the resources specified by relative URLs are expected to exist on all servers.
References
Server Object
Relative References in URLs
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Structure       Next  Media Types\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nMedia Types        NoteOAS 3 This page is about OpenAPI 3.0. If you use OpenAPI 2.0, see the OpenAPI 2.0 guide.
Media type is a format of a request or response body data. Web service operations can accept and return data in different formats, the most common being JSON, XML and images. You specify the media type in request and response definitions. Here is an example of a response definition:
1paths:2  /employees:3    get:4      summary: Returns a list of employees.5      responses:6        "200": # Response7          description: OK8          content: # Response body9            application/json: # Media type10              schema: # Must-have11                type: object # Data type12                properties:13                  id:14                    type: integer15                  name:16                    type: string17                  fullTime:18                    type: boolean19                example: # Sample data20                  id: 121                  name: Jessica Right22                  fullTime: true
Under responses we have definitions of individual responses. As you can see, each response is defined by its code ('200' in our example.). The keyword content below the code corresponds to the response body. One or multiple media types go as child keywords of this content keyword. Each media type includes a schema, defining the data type of the message body, and, optionally, one or several examples. For more information on defining body data, see Defining Request Body and Defining Responses.
Media Type Names
The media types listed below the content field should be compliant with RFC 6838. For example, you can use standard types or vendor-specific types (indicated by .vnd) –
1application/json2application/xml3application/x-www-form-urlencoded4multipart/form-data5text/plain; charset=utf-86text/html7application/pdf8image/png
1application/vnd.mycompany.myapp.v2+json2application/vnd.ms-excel3application/vnd.openstreetmap.data+xml4application/vnd.github-issue.text+json5application/vnd.github.v3.diff6image/vnd.djvu
Multiple Media Types
You may want to specify multiple media types:
1paths:2  /employees:3    get:4      summary: Returns a list of employees.5      responses:6        "200": # Response7          description: OK8          content: # Response body9            application/json: # One of media types10              schema:11                type: object12                properties:13                  id:14                    type: integer15                  name:16                    type: string17                  fullTime:18                    type: boolean19            application/xml: # Another media types20              schema:21                type: object22                properties:23                  id:24                    type: integer25                  name:26                    type: string27                  fullTime:28                    type: boolean
To use the same data format for several media types, define a custom object in the components section of your spec and then refer to this object in each media type:
1paths:2  /employees:3    get:4      responses:5        "200": # Response6          description: OK7          content: # Response body8            application/json: # Media type9              schema:10                $ref: "#/components/schemas/Employee" # Reference to object definition11            application/xml: # Media type12              schema:13                $ref: "#/components/schemas/Employee" # Reference to object definition14components:15  schemas:16    Employee: # Object definition17      type: object18      properties:19        id:20          type: integer21        name:22          type: string23        fullTime:24          type: boolean
To define the same format for multiple media types, you can also use placeholders like */*, application/*, image/* or others:
1paths:2  /info/logo:3    get:4      responses:5        "200": # Response6          description: OK7          content: # Response body8            image/*: # Media type9              schema:10                type: string11                format: binary
The value you use as media type – image/* in our example – is very similar to what you can see in the Accept or Content-Type headers of HTTP requests and responses. Do not confuse the placeholder and the actual value of the Accept or Content-Type headers. For example, the image/* placeholder for a response body means that the server will use the same data structure for all the responses that match the placeholder. It does not mean that the string image/* will be specified in the Content-Type header. The Content-Type header most likely will have image/png, image/jpeg, or some other similar value.
_Did not find what you were looking for? Ask the community
Found a mistake? Let us know_OAS 3 This page is about OpenAPI 3.0. If you use OpenAPI 2.0, see the OpenAPI 2.0 guide.
Media Types
Media type is a format of a request or response body data. Web service operations can accept and return data in different formats, the most common being JSON, XML and images. You specify the media type in request and response definitions. Here is an example of a response definition:
1paths:2  /employees:3    get:4      summary: Returns a list of employees.5      responses:6        "200": # Response7          description: OK8          content: # Response body9            application/json: # Media type10              schema: # Must-have11                type: object # Data type12                properties:13                  id:14                    type: integer15                  name:16                    type: string17                  fullTime:18                    type: boolean19                example: # Sample data20                  id: 121                  name: Jessica Right22                  fullTime: true
Under responses we have definitions of individual responses. As you can see, each response is defined by its code ('200' in our example.). The keyword content below the code corresponds to the response body. One or multiple media types go as child keywords of this content keyword. Each media type includes a schema, defining the data type of the message body, and, optionally, one or several examples. For more information on defining body data, see Defining Request Body and Defining Responses.
Media Type Names
The media types listed below the content field should be compliant with RFC 6838. For example, you can use standard types or vendor-specific types (indicated by .vnd) –
1application/json2application/xml3application/x-www-form-urlencoded4multipart/form-data5text/plain; charset=utf-86text/html7application/pdf8image/png
1application/vnd.mycompany.myapp.v2+json2application/vnd.ms-excel3application/vnd.openstreetmap.data+xml4application/vnd.github-issue.text+json5application/vnd.github.v3.diff6image/vnd.djvu
Multiple Media Types
You may want to specify multiple media types:
1paths:2  /employees:3    get:4      summary: Returns a list of employees.5      responses:6        "200": # Response7          description: OK8          content: # Response body9            application/json: # One of media types10              schema:11                type: object12                properties:13                  id:14                    type: integer15                  name:16                    type: string17                  fullTime:18                    type: boolean19            application/xml: # Another media types20              schema:21                type: object22                properties:23                  id:24                    type: integer25                  name:26                    type: string27                  fullTime:28                    type: boolean
To use the same data format for several media types, define a custom object in the components section of your spec and then refer to this object in each media type:
1paths:2  /employees:3    get:4      responses:5        "200": # Response6          description: OK7          content: # Response body8            application/json: # Media type9              schema:10                $ref: "#/components/schemas/Employee" # Reference to object definition11            application/xml: # Media type12              schema:13                $ref: "#/components/schemas/Employee" # Reference to object definition14components:15  schemas:16    Employee: # Object definition17      type: object18      properties:19        id:20          type: integer21        name:22          type: string23        fullTime:24          type: boolean
To define the same format for multiple media types, you can also use placeholders like */*, application/*, image/* or others:
1paths:2  /info/logo:3    get:4      responses:5        "200": # Response6          description: OK7          content: # Response body8            image/*: # Media type9              schema:10                type: string11                format: binary
The value you use as media type – image/* in our example – is very similar to what you can see in the Accept or Content-Type headers of HTTP requests and responses. Do not confuse the placeholder and the actual value of the Accept or Content-Type headers. For example, the image/* placeholder for a response body means that the server will use the same data structure for all the responses that match the placeholder. It does not mean that the string image/* will be specified in the Content-Type header. The Content-Type header most likely will have image/png, image/jpeg, or some other similar value.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  API Server and Base Path       Next  Paths and Operations\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nPaths and Operations        NoteOAS 3 This page is about OpenAPI 3.0. If you use OpenAPI 2.0, see the OpenAPI 2.0 guide.
In OpenAPI terms, paths are endpoints (resources), such as /users or /reports/summary/, that your API exposes, and operations are the HTTP methods used to manipulate these paths, such as GET, POST or DELETE.
Paths
API paths and operations are defined in the global paths section of the API specification.
1paths:2  /ping: ...3  /users: ...4  /users/{id}: ...
All paths are relative to the API server URL. The full request URL is constructed as <server-url>/path. Global servers can also be overridden on the path level or operation level (more on that below). Paths may have an optional short summary and a longer description for documentation purposes. This information is supposed to be relevant to all operations in this path. description can be multi-line and supports Markdown (CommonMark) for rich text representation.
1paths:2  /users/{id}:3    summary: Represents a user4    description: >5      This resource represents an individual user in the system.6      Each user is identified by a numeric `id`.7
8    get: ...9    patch: ...10    delete: ...
Path Templating
You can use curly braces {} to mark parts of an URL as path parameters:
1/users/{id}2/organizations/{orgId}/members/{memberId}3/report.{format}
The API client needs to provide appropriate parameter values when making an API call, such as /users/5 or /users/12.
Operations
For each path, you define operations (HTTP methods) that can be used to access that path. OpenAPI 3.0 supports get, post, put, patch, delete, head, options, and trace. A single path can support multiple operations, for example GET /users to get a list of users and POST /users to add a new user. OpenAPI defines a unique operation as a combination of a path and an HTTP method. This means that two GET or two POST methods for the same path are not allowed – even if they have different parameters (parameters have no effect on uniqueness). Below is a minimal example of an operation:
1paths:2  /ping:3    get:4      responses:5        "200":6          description: OK
Here is a more detailed example with parameters and response schema:
1paths:2  /users/{id}:3    get:4      tags:5        - Users6      summary: Gets a user by ID.7      description: >8        A detailed description of the operation.9        Use markdown for rich text representation,10        such as **bold**, *italic*, and [links](https://swagger.io).11      operationId: getUserById12      parameters:13        - name: id14          in: path15          description: User ID16          required: true17          schema:18            type: integer19            format: int6420      responses:21        "200":22          description: Successful operation23          content:24            application/json:25              schema:26                $ref: "#/components/schemas/User"27      externalDocs:28        description: Learn more about user operations provided by this API.29        url: http://api.example.com/docs/user-operations/30
31components:32  schemas:33    User:34      type: object35      properties:36        id:37          type: integer38          format: int6439        name:40          type: string41      required:42        - id43        - name
Operations also support some optional elements for documentation purposes:

A short summary and a longer description of what an operation does. description can be multi-line and supports Markdown (CommonMark) for rich text representation.
tags – used to group operations logically by resources or any other qualifier. See Grouping Operations With Tags.
externalDocs – used to reference an external resource that contains additional documentation.

Operation Parameters
OpenAPI 3.0 supports operation parameters passed via path, query string, headers, and cookies. You can also define the request body for operations that transmit data to the server, such as POST, PUT and PATCH. For details, see Describing Parameters and Describing Request Body.
Query String in Paths
Query string parameters must not be included in paths. They should be defined as query parameters instead.
Incorrect:
1paths:2  /users?role={role}:
Correct:
1paths:2  /users:3    get:4      parameters:5        - in: query6          name: role7          schema:8            type: string9            enum: [user, poweruser, admin]10          required: true
This also means that it is impossible to have multiple paths that differ only in query string, such as:
1GET /users?firstName=value&lastName=value2GET /users?role=value
This is because OpenAPI considers a unique operation as a combination of a path and the HTTP method, and additional parameters do not make the operation unique. Instead, you should use unique paths such as:
1GET /users/findByName?firstName=value&lastName=value2GET /users/findByRole?role=value
operationId
operationId is an optional unique string used to identify an operation. If provided, these IDs must be unique among all operations described in your API.
1/users:2  get:3    operationId: getUsers4    summary: Gets all users5    ...6  post:7    operationId: addUser8    summary: Adds a new user9    ...10/user/{id}:11  get:12    operationId: getUserById13    summary: Gets a user by user ID14    ...
Some common use cases for operationId are:

Some code generators use this value to name the corresponding methods in code.
Links can refer to the linked operations by operationId.

Deprecated Operations
You can mark specific operations as deprecated to indicate that they should be transitioned out of usage:
1/pet/findByTags:2  get:3    deprecated: true
Tools may handle deprecated operations in a specific way. For example, Swagger UI displays them with a different style:

Overriding Global Servers
The global servers array can be overridden on the path level or operation level. This is useful if some endpoints use a different server or base path than the rest of the API. Common examples are:


Different base URL for file upload and download operations.


Deprecated but still functional endpoints.
servers:

url: https://api.example.com/v1



1paths:2  /files:3    description: File upload and download operations4    servers:5      - url: https://files.example.com6        description: Override base path for all operations with the /files path7    ...8
9/ping:10    get:11      servers:12        - url: https://echo.example.com13          description: Override base path for the GET /ping operation
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Media Types       Next  Describing Parameters\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDescribing Parameters        NoteOAS 3 This page is about OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
In OpenAPI 3.0, parameters are defined in the parameters section of an operation or path. To describe a parameter, you specify its name, location (in), data type (defined by either schema or content) and other attributes, such as description or required. Here is an example:
1paths:2  /users/{userId}:3    get:4      summary: Get a user by ID5      parameters:6        - in: path7          name: userId8          schema:9            type: integer10          required: true11          description: Numeric ID of the user to get
Note that parameters is an array, so, in YAML, each parameter definition must be listed with a dash (-) in front of it.
Parameter Types
OpenAPI 3.0 distinguishes between the following parameter types based on the parameter location. The location is determined by the parameter’s in key, for example, in: query or in: path.

path parameters, such as /users/{id}
query parameters, such as /users?role=admin
header parameters, such as X-MyHeader: Value
cookie parameters, which are passed in the Cookie header, such as Cookie: debug=0; csrftoken=BUSe35dohU3O1MZvDCU

Path Parameters
Path parameters are variable parts of a URL path. They are typically used to point to a specific resource within a collection, such as a user identified by ID. A URL can have several path parameters, each denoted with curly braces { }.
1GET /users/{id}2GET /cars/{carId}/drivers/{driverId}3GET /report.{format}
Each path parameter must be substituted with an actual value when the client makes an API call. In OpenAPI, a path parameter is defined using in: path. The parameter name must be the same as specified in the path. Also remember to add required: true, because path parameters are always required. For example, the /users/{id} endpoint would be described as:
1paths:2  /users/{id}:3    get:4      parameters:5        - in: path6          name: id # Note the name is the same as in the path7          required: true8          schema:9            type: integer10            minimum: 111          description: The user ID
Path parameters containing arrays and objects can be serialized in different ways:

path-style expansion (matrix) – semicolon-prefixed, such as /map/point;x=50;y=20
label expansion – dot-prefixed, such as /color.R=100.G=200.B=150
simple-style – comma-delimited, such as /users/12,34,56

The serialization method is specified by the style and explode keywords. To learn more, see Parameter Serialization.
Query Parameters
Query parameters are the most common type of parameters. They appear at the end of the request URL after a question mark (?), with different name=value pairs separated by ampersands (&). Query parameters can be required and optional.
1GET /pets/findByStatus?status=available2GET /notes?offset=100&limit=50
Use in: query to denote query parameters:
1parameters:2  - in: query3    name: offset4    schema:5      type: integer6    description: The number of items to skip before starting to collect the result set7  - in: query8    name: limit9    schema:10      type: integer11    description: The numbers of items to return
Note: To describe API keys passed as query parameters, use securitySchemes and security instead. See API Keys.
Query parameters can be primitive values, arrays and objects. OpenAPI 3.0 provides several ways to serialize objects and arrays in the query string.
Arrays can be serialized as:

form – /products?color=blue,green,red or /products?color=blue&color=green, depending on the explode keyword
spaceDelimited (same as collectionFormat: ssv in OpenAPI 2.0) – /products?color=blue%20green%20red
pipeDelimited (same as collectionFormat: pipes in OpenAPI 2.0) – /products?color=blue|green|red

Objects can be serialized as:

form – /points?color=R,100,G,200,B,150 or /points?R=100&G=200&B=150, depending on the explode keyword
deepObject – /points?color[R]=100&color[G]=200&color[B]=150

The serialization method is specified by the style and explode keywords. To learn more, see Parameter Serialization.
Reserved Characters in Query Parameters
RFC 3986 defines a set of reserved characters :/?#[]@!$&'()*+,;= that are used as URI component delimiters. When these characters need to be used literally in a query parameter value, they are usually percent-encoded. For example, / is encoded as %2F (or %2f), so that the parameter value quotes/h2g2.txt would be sent as
1GET /file?path=quotes%2Fh2g2.txt
If you want a query parameter that is not percent-encoded, add allowReserved: true to the parameter definition:
1parameters:2  - in: query3    name: path4    required: true5    schema:6      type: string7    allowReserved: true # <-----
In this case, the parameter value would be sent like so:
1GET /file?path=quotes/h2g2.txt
Header Parameters
An API call may require that custom headers be sent with an HTTP request. OpenAPI lets you define custom request headers as in: header parameters. For example, suppose, a call to GET /ping requires the X-Request-ID header:
1    GET /ping HTTP/1.12    Host: example.com3    X-Request-ID: 77e1c83b-7bb0-437b-bc50-a7a58e5660ac
Using OpenAPI 3.0, you would define this operation as follows:
1paths:2  /ping:3    get:4      summary: Checks if the server is alive5      parameters:6        - in: header7          name: X-Request-ID8          schema:9            type: string10            format: uuid11          required: true
In a similar way, you can define custom response headers. Header parameter can be primitives, arrays and objects. Arrays and objects are serialized using the simple style. For more information, see Parameter Serialization.
Note: Header parameters named Accept, Content-Type and Authorization are not allowed. To describe these headers, use the corresponding OpenAPI keywords:

	
		
			Header
			OpenAPI keywords
			For more information, see...
		
	
	
		
			Content-Type
			Request content type: requestBody.content.<media-type>
			
			Response content type: responses.<code>.content.<media-type>
			Describing Request Body,
			Describing Responses,
			Media Types
		
		
			Accept
			responses.<code>.content.<media-type>
			Describing Responses,
			Media Types
		
		
			Authorization
			securitySchemes, security
			Authentication
		
	

Cookie Parameters
Operations can also pass parameters in the Cookie header, as Cookie: name=value. Multiple cookie parameters are sent in the same header, separated by a semicolon and space.
1GET /api/users2Host: example.com3Cookie: debug=0; csrftoken=BUSe35dohU3O1MZvDCUOJ
Use in: cookie to define cookie parameters:
1parameters:2  - in: cookie3    name: debug4    schema:5      type: integer6      enum: [0, 1]7      default: 08  - in: cookie9    name: csrftoken10    schema:11      type: string
Cookie parameters can be primitive values, arrays and objects. Arrays and objects are serialized using the form style. For more information, see Parameter Serialization.
Note: To define cookie authentication, use API keys instead.
Required and Optional Parameters
By default, OpenAPI treats all request parameters as optional. You can add required: true to mark a parameter as required. Note that path parameters must have required: true, because they are always required.
1parameters:2  - in: path3    name: userId4    schema:5      type: integer6    required: true # <----------7    description: Numeric ID of the user to get.
schema vs content
To describe the parameter contents, you can use either the schema or content keyword. They are mutually exclusive and used in different scenarios. In most cases, you would use schema. It lets you describe primitive values, as well as simple arrays and objects serialized into a string. The serialization method for array and object parameters is defined by the style and explode keywords used in that parameter.
1parameters:2  - in: query3    name: color4    schema:5      type: array6      items:7        type: string8
9    # Serialize as color=blue,black,brown (default)10    style: form11    explode: false
content is used in complex serialization scenarios that are not covered by style and explode. For example, if you need to send a JSON string in the query string like so:
1filter={"type":"t-shirt","color":"blue"}
In this case, you need to wrap the parameter schema into content/<media-type> as shown below. The schema defines the parameter data structure, and the media type (in this example – application/json) serves as a reference to an external specification that describes the serialization format.
1parameters:2  - in: query3    name: filter4
5    # Wrap 'schema' into 'content.<media-type>'6    content:7      application/json: # <---- media type indicates how to serialize / deserialize the parameter content8        schema:9          type: object10          properties:11            type:12              type: string13            color:14              type: string
Note for Swagger UI and Swagger Editor users: Parameters with content are supported in Swagger UI 3.23.7+ and Swagger Editor 3.6.34+.
Default Parameter Values
Use the default keyword in the parameter schema to specify the default value for an optional parameter. The default value is the one that the server uses if the client does not supply the parameter value in the request. The value type must be the same as the parameter’s data type. A typical example is paging parameters such as offset and limit:
1GET /users2GET /users?offset=30&limit=10
Assuming offset defaults to 0 and limit defaults to 20 and ranges from 0 to 100, you would define these parameters as:
1parameters:2  - in: query3    name: offset4    schema:5      type: integer6      minimum: 07      default: 08    required: false9    description: The number of items to skip before starting to collect the result set.10  - in: query11    name: limit12    schema:13      type: integer14      minimum: 115      maximum: 10016      default: 2017    required: false18    description: The number of items to return.
Common Mistakes
There are two common mistakes when using the default keyword:

Using default with required parameters or properties, for example, with path parameters. This does not make sense – if a value is required, the client must always send it, and the default value is never used.
Using default to specify a sample value. This is not intended use of default and can lead to unexpected behavior in some Swagger tools. Use the example or examples keyword for this purpose instead. See Adding Examples.

Enum Parameters
You can restrict a parameter to a fixed set of values by adding the enum to the parameter’s schema. The enum values must be of the same type as the parameter data type.
1parameters:2  - in: query3    name: status4    schema:5      type: string6      enum:7        - available8        - pending9        - sold
More info: Defining an Enum.
Constant Parameters
You can define a constant parameter as a required parameter with only one possible value:
1parameters:2  - in: query3    name: rel_date4    required: true5    schema:6      type: string7      enum:8        - now
The enum property specifies possible values. In this example, only one value can be used, and this will be the only value available in the Swagger UI for the user to choose from.
Note: A constant parameter is not the same as the default parameter value. A constant parameter is always sent by the client, whereas the default value is something that the server uses if the parameter is not sent by the client.
Empty-Valued and Nullable Parameters
Query string parameters may only have a name and no value, like so:
1GET /foo?metadata
Use allowEmptyValue to describe such parameters:
1parameters:2  - in: query3    name: metadata4    schema:5      type: boolean6    allowEmptyValue: true # <-----
OpenAPI 3.0 also supports nullable in schemas, allowing operation parameters to have the null value. For example, the following schema corresponds to int? in C# and java.lang.Integer in Java:
1schema:2  type: integer3  format: int324  nullable: true
Note: nullable is not the same as an optional parameter or an empty-valued parameter. nullable means the parameter value can be null. Specific implementations may choose to map an absent or empty-valued parameter to null, but strictly speaking these are not the same thing.
Parameter Examples
You can specify an example or multiple examples for a parameter. The example value should match the parameter schema. Single example:
1parameters:2  - in: query3    name: limit4    schema:5      type: integer6      minimum: 17    example: 20
Multiple named examples:
1parameters:2  - in: query3    name: ids4    description: One or more IDs5    required: true6    schema:7      type: array8      items:9        type: integer10    style: form11    explode: false12    examples:13      oneId:14        summary: Example of a single ID15        value: [5] # ?ids=516      multipleIds:17        summary: Example of multiple IDs18        value: [1, 5, 7] # ?ids=1,5,7
For details, see Adding Examples.
Deprecated Parameters
Use deprecated: true to mark a parameter as deprecated.
1- in: query2  name: format3  required: true4  schema:5    type: string6    enum: [json, xml, yaml]7  deprecated: true8  description: Deprecated, use the appropriate `Accept` header instead.
Common Parameters
Common Parameters for All Methods of a Path
Parameters shared by all operations of a path can be defined on the path level instead of the operation level. Path-level parameters are inherited by all operations of that path. A typical use case are the GET/PUT/PATCH/DELETE operations that manipulate a resource accessed via a path parameter.
1paths:2  /user/{id}:3    parameters:4      - in: path5        name: id6        schema:7          type: integer8        required: true9        description: The user ID10    get:11      summary: Gets a user by ID12      ...13    patch:14      summary: Updates an existing user with the specified ID15      ...16    delete:17      summary: Deletes the user with the specified ID18      ...
Any extra parameters defined at the operation level are used together with path-level parameters:
1paths:2  /users/{id}:3    parameters:4      - in: path5        name: id6        schema:7          type: integer8        required: true9        description: The user ID.10
11    # GET/users/{id}?metadata=true12    get:13      summary: Gets a user by ID14      # Note we only define the query parameter, because the {id} is defined at the path level.15      parameters:16        - in: query17          name: metadata18          schema:19            type: boolean20          required: false21          description: If true, the endpoint returns only the user metadata.22      responses:23        "200":24          description: OK
Specific path-level parameters can be overridden on the operation level, but cannot be removed.
1paths:2  /users/{id}:3    parameters:4      - in: path5        name: id6        schema:7          type: integer8        required: true9        description: The user ID.10
11    # DELETE /users/{id} - uses a single ID.12    # Reuses the {id} parameter definition from the path level.13    delete:14      summary: Deletes the user with the specified ID.15      responses:16        "204":17          description: User was deleted.18
19    # GET /users/id1,id2,id3 - uses one or more user IDs.20    # Overrides the path-level {id} parameter.21    get:22      summary: Gets one or more users by ID.23      parameters:24        - in: path25          name: id26          required: true27          description: A comma-separated list of user IDs.28          schema:29            type: array30            items:31              type: integer32            minItems: 133          explode: false34          style: simple35      responses:36        "200":37          description: OK
Common Parameters for Various Paths
Different API paths may have common parameters, such as pagination parameters. You can define common parameters under parameters in the global components section and reference them elsewhere via $ref.
1components:2  parameters:3    offsetParam: # <-- Arbitrary name for the definition that will be used to refer to it.4      # Not necessarily the same as the parameter name.5      in: query6      name: offset7      required: false8      schema:9        type: integer10        minimum: 011      description: The number of items to skip before starting to collect the result set.12    limitParam:13      in: query14      name: limit15      required: false16      schema:17        type: integer18        minimum: 119        maximum: 5020        default: 2021      description: The numbers of items to return.22
23paths:24  /users:25    get:26      summary: Gets a list of users.27      parameters:28        - $ref: "#/components/parameters/offsetParam"29        - $ref: "#/components/parameters/limitParam"30      responses:31        "200":32          description: OK33  /teams:34    get:35      summary: Gets a list of teams.36      parameters:37        - $ref: "#/components/parameters/offsetParam"38        - $ref: "#/components/parameters/limitParam"39      responses:40        "200":41          description: OK
Note that the parameters defined in components are not parameters applied to all operations — they are simply global definitions that can be easily re-used.
Parameter Dependencies
OpenAPI 3.0 does not support parameter dependencies and mutually exclusive parameters. There is an open feature request at https://github.com/OAI/OpenAPI-Specification/issues/256. What you can do is document the restrictions in the parameter description and define the logic in the 400 Bad Request response. For example, consider the /report endpoint that accepts either a relative date range (rdate) or an exact range (start_date+end_date):
1GET /report?rdate=Today2GET /report?start_date=2016-11-15&end_date=2016-11-20
You can describe this endpoint as follows:
1paths:2  /report:3    get:4      parameters:5        - name: rdate6          in: query7          schema:8            type: string9          description: >10            A relative date range for the report, such as `Today` or `LastWeek`.11            For an exact range, use `start_date` and `end_date` instead.12        - name: start_date13          in: query14          schema:15            type: string16            format: date17          description: >18            The start date for the report. Must be used together with `end_date`.19            This parameter is incompatible with `rdate`.20        - name: end_date21          in: query22          schema:23            type: string24            format: date25          description: >26            The end date for the report. Must be used together with `start_date`.27            This parameter is incompatible with `rdate`.28      responses:29        "400":30          description: Either `rdate` or `start_date`+`end_date` are required.
References
Parameter Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Paths and Operations       Next  Parameter Serialization\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nParameter Serialization        NoteOAS 3 This guide is for OpenAPI 3.0.
Serialization means translating data structures or object state into a format that can be transmitted and reconstructed later. OpenAPI 3.0 supports arrays and objects in operation parameters (path, query, header, and cookie) and lets you specify how these parameters should be serialized. The serialization method is defined by the style and explode keywords:

style defines how multiple values are delimited. Possible styles depend on the parameter location – path, query, header or cookie.
explode (true/false) specifies whether arrays and objects should generate separate parameters for each array item or object property.

OpenAPI serialization rules are based on a subset of URI template patterns defined by RFC 6570. Tool implementers can use existing URI template libraries to handle the serialization, as explained below.
Path Parameters
Path parameters support the following style values:

simple – (default) comma-separated values. Corresponds to the {param_name} URI template.
label – dot-prefixed values, also known as label expansion. Corresponds to the {.param_name} URI template.
matrix – semicolon-prefixed values, also known as path-style expansion. Corresponds to the {;param_name} URI template.

The default serialization method is style: simple and explode: false. Given the path /users/{id}, the path parameter id is serialized as follows:





























































styleexplodeURI templatePrimitive value id = 5Array id = [3, 4, 5]Object id = {“role”: “admin”, “firstName”: “Alex”}simple *false */users/{id}/users/5/users/3,4,5/users/role,admin,firstName,Alexsimpletrue/users/{id*}/users/5/users/3,4,5/users/role=admin,firstName=Alexlabelfalse/users/{.id}/users/.5/users/.3,4,5/users/.role,admin,firstName,Alexlabeltrue/users/{.id*}/users/.5/users/.3.4.5/users/.role=admin.firstName=Alexmatrixfalse/users/{;id}/users/;id=5/users/;id=3,4,5/users/;id=role,admin,firstName,Alexmatrixtrue/users/{;id*}/users/;id=5/users/;id=3;id=4;id=5/users/;role=admin;firstName=Alex

Default serialization method

The label and matrix styles are sometimes used with partial path parameters, such as /users{id}, because the parameter values get prefixed.
Query Parameters
Query parameters support the following style values:

form – (default) ampersand-separated values, also known as form-style query expansion. Corresponds to the {?param_name} URI template.
spaceDelimited – space-separated array values. Same as collectionFormat: ssv in OpenAPI 2.0. Has effect only for non-exploded arrays (explode: false), that is, the space separates the array values if the array is a single parameter, as in arr=a b c.
pipeDelimited – pipeline-separated array values. Same as collectionFormat: pipes in OpenAPI 2.0. Has effect only for non-exploded arrays (explode: false), that is, the pipe separates the array values if the array is a single parameter, as in arr=a|b|c.
deepObject – simple non-nested objects are serialized as paramName[prop1]=value1&paramName[prop2]=value2&.... The behavior for nested objects and arrays is undefined.

The default serialization method is style: form and explode: true. This corresponds to collectionFormat: multi from OpenAPI 2.0. Given the path /users with a query parameter id, the query string is serialized as follows:





































































styleexplodeURI templatePrimitive value id = 5Array id = [3, 4, 5]Object id = {“role”: “admin”, “firstName”: “Alex”}form *true */users{?id*}/users?id=5/users?id=3&id=4&id=5/users?role=admin&firstName=Alexformfalse/users{?id}/users?id=5/users?id=3,4,5/users?id=role,admin,firstName,AlexspaceDelimitedtrue/users{?id*}n/a/users?id=3&id=4&id=5n/aspaceDelimitedfalsen/an/a/users?id=3%204%205n/apipeDelimitedtrue/users{?id*}n/a/users?id=3&id=4&id=5n/apipeDelimitedfalsen/an/a/users?id=3|4|5n/adeepObjecttruen/an/an/a/users?id[role]=admin&id[firstName]=Alex
* Default serialization method
Additionally, the allowReserved keyword specifies whether the reserved characters :/?#[]@!$&'()*+,;= in parameter values are allowed to be sent as they are, or should be percent-encoded. By default, allowReserved is false, and reserved characters are percent-encoded. For example, / is encoded as %2F (or %2f), so that the parameter value quotes/h2g2.txt will be sent as quotes%2Fh2g2.txt.
Header Parameters
Header parameters always use the simple style, that is, comma-separated values. This corresponds to the {param_name} URI template. An optional explode keyword controls the object serialization. Given the request header named X-MyHeader, the header value is serialized as follows:





























styleexplodeURI templatePrimitive value X-MyHeader = 5Array X-MyHeader = [3, 4, 5]Object X-MyHeader = {“role”: “admin”, “firstName”: “Alex”}simple *false *{id}X-MyHeader: 5X-MyHeader: 3,4,5X-MyHeader: role,admin,firstName,Alexsimpletrue{id*}X-MyHeader: 5X-MyHeader: 3,4,5X-MyHeader: role=admin,firstName=Alex

Default serialization method

Cookie Parameters
Cookie parameters always use the form style. An optional explode keyword controls the array and object serialization. Given the cookie named id, the cookie value is serialized as follows:





























styleexplodeURI templatePrimitive value id = 5Array id = [3, 4, 5]Object id = {“role”: “admin”, “firstName”: “Alex”}form *true *Cookie: id=5formfalseid={id}Cookie: id=5Cookie: id=3,4,5Cookie: id=role,admin,firstName,Alex

Default serialization method

Serialization and RFC 6570
OpenAPI serialization rules are based on a subset of URI templates defined by RFC 6570. Tool implementers can use existing URI template libraries to handle the serialization. You will need to construct the URI template based on the path and parameter definitions. The following table shows how OpenAPI keywords are mapped to the URI Template modifiers.

















































KeywordURI Template Modifierstyle: simplenonestyle: label. prefixstyle: matrix; prefixstyle: form? or & prefix (depending on the parameter position in the query string)style: pipeDelimited? or & prefix (depending on the parameter position in the query string) – but using pipes                                               |instead of commas, to join the array valuesstyle: spaceDelimited? or & prefix (depending on the parameter position in the query string) – but using spaces instead of commas , to join the array valuesexplode: falsenoneexplode: true* suffixallowReserved: falsenoneallowReserved: true+ prefix
For example, consider the path /users{id} with a query parameter metadata, defined like so:
1paths:2  # /users;id=3;id=4?metadata=true3  /users{id}:4    get:5      parameters:6        - in: path7          name: id8          required: true9          schema:10            type: array11            items:12              type: integer13            minItems: 114          style: matrix15          explode: true16        - in: query17          name: metadata18          schema:19            type: boolean20          # Using the default serialization for query parameters:21          # style=form, explode=false, allowReserved=false22      responses:23        '200':24          description: A list of users
The path parameter id uses the matrix style with the explode modifier, which corresponds to the {;id*} template. The query parameter metadata uses the default form style, which corresponds to the {?metadata} template. The complete URI template would look like:
1/users{;id*}{?metadata}
A client application can then use an URI template library to generate the request URL based on this template and specific parameter values.
Other Serialization Methods
style and explode cover the most common serialization methods, but not all. For more complex scenarios (for example, a JSON-formatted object in the query string), you can use the content keyword and specify the media type that defines the serialization format. For more information, see schema vs content.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Describing Parameters       Next  Overview\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDescribing Request Body        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Request bodies are typically used with “create” and “update” operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. OpenAPI 3.0 provides the requestBody keyword to describe request bodies.
Differences From OpenAPI 2.0
If you used OpenAPI 2.0 before, here is a summary of changes to help you get started with OpenAPI 3.0:

Body and form parameters are replaced with requestBody.
Operations can now consume both form data and other media types such as JSON.
The consumes array is replaced with the requestBody.content map which maps the media types to their schemas.
Schemas can vary by media type.
anyOf and oneOf can be used to specify alternate schemas.
Form data can now contain objects, and you can specify the serialization strategy for objects and arrays.
GET, DELETE and HEAD are no longer allowed to have request body because it does not have defined semantics as per RFC 7231.

requestBody, content and Media Types
Unlike OpenAPI 2.0, where the request body was defined using body and formData parameters, OpenAPI 3.0 uses the requestBody keyword to distinguish the payload from parameters (such as query string). The requestBody is more flexible in that it lets you consume different media types, such as JSON, XML, form data, plain text, and others, and use different schemas for different media types. requestBody consists of the content object, an optional Markdown-formatted description, and an optional required flag (false by default). content lists the media types consumed by the operation (such as application/json) and specifies the schema for each media type. Request bodies are optional by default. To mark the body as required, use required: true.
1paths:2  /pets:3    post:4      summary: Add a new pet5
6      requestBody:7        description: Optional description in *Markdown*8        required: true9        content:10          application/json:11            schema:12              $ref: "#/components/schemas/Pet"13          application/xml:14            schema:15              $ref: "#/components/schemas/Pet"16          application/x-www-form-urlencoded:17            schema:18              $ref: "#/components/schemas/PetForm"19          text/plain:20            schema:21              type: string22
23      responses:24        "201":25          description: Created
content allows wildcard media types. For example, image/* represents all image types; */* represents all types and is functionally equivalent to application/octet-stream. Specific media types have preference over wildcard media types when interpreting the spec, for example, image/png > image/* > */*.
1paths:2  /avatar:3    put:4      summary: Upload an avatar5      requestBody:6        content:7          image/*: # Can be image/png, image/svg, image/gif, etc.8            schema:9              type: string10              format: binary
anyOf, oneOf
OpenAPI 3.0 supports anyOf and oneOf, so you can specify alternate schemas for the request body:
1requestBody:2  description: A JSON object containing pet information3  content:4    application/json:5      schema:6        oneOf:7          - $ref: "#/components/schemas/Cat"8          - $ref: "#/components/schemas/Dog"9          - $ref: "#/components/schemas/Hamster"
File Upload
To learn how to describe file upload, see File Upload and Multipart Requests.
Request Body Examples
The request body can have an example or multiple examples. example and examples are properties of the requestBody.content.<media-type> object. If provided, these examples override the examples provided by the schema. This is handy, for example, if the request and response use the same schema but you want to have different examples. example allows a single inline example:
1requestBody:2  content:3    application/json:4      schema:5        $ref: "#/components/schemas/Pet"6      example:7        name: Fluffy8        petType: dog
The examples (plural) are more flexible – you can have an inline example, a $ref reference, or point to an external URL containing the payload example. Each example can also have optional summary and description for documentation purposes.
1requestBody:2  content:3    application/json:4      schema:5        $ref: '#/components/schemas/Pet'6      examples:7
8        dog:  # <--- example name9          summary: An example of a dog10          value:11            # vv Actual payload goes here vv12            name: Fluffy13            petType: dog14
15        cat:  # <--- example name16          summary: An example of a cat17          externalValue: http://api.example.com/examples/cat.json   # cat.json contains {"name": "Tiger", "petType": "cat"}18
19        hamster:  # <--- example name20          $ref: '#/components/examples/hamster'21
22  components:23    examples:24      hamster:  # <--- example name25        summary: An example of a hamster26        value:27          # vv Actual payload goes here vv28          name: Ginger29          petType: hamster
See Adding Examples for more information.
Reusable Bodies
You can put the request body definitions in the global components.requestBodies section and $ref them elsewhere. This is handy if multiple operations have the same request body – this way you can reuse the same definition easily.
1paths:2  /pets:3    post:4      summary: Add a new pet5      requestBody:6        $ref: '#/components/requestBodies/PetBody'7
8  /pets/{petId}9    put:10      summary: Update a pet11      parameters: [ ... ]12      requestBody:13        $ref: '#/components/requestBodies/PetBody'14
15components:16  requestBodies:17    PetBody:18      description: A JSON object containing pet information19      required: true20      content:21        application/json:22          schema:23            $ref: '#/components/schemas/Pet'
Form Data
The term “form data” is used for the media types application/x-www-form-urlencoded and multipart/form-data, which are commonly used to submit HTML forms.

application/x-www-form-urlencoded is used to send simple ASCII text data as key=value pairs. The payload format is similar to query parameters.
multipart/form-data allows submitting binary data as well as multiple media types in a single message (for example, image and JSON). Each form field has its own section in the payload with internal HTTP headers. multipart requests are commonly used for file uploads.

To illustrate form data, consider an HTML POST form:
1<form action="http://example.com/survey" method="post">2  <input type="text" name="name" />3  <input type="number" name="fav_number" />4  <input type="submit" />5</form>
This form POSTs data to the form’s endpoint:
1POST /survey HTTP/1.12Host: example.com3Content-Type: application/x-www-form-urlencoded4Content-Length: 285
6name=Amy+Smith&fav_number=42
In OpenAPI 3.0, form data is modelled using a type: object schema where the object properties represent the form fields:
1paths:2  /survey:3    post:4      requestBody:5        required: true6        content:7          application/x-www-form-urlencoded:8            schema:9              type: object10              properties:11                name: # <!--- form field name12                  type: string13                fav_number: # <!--- form field name14                  type: integer15              required:16                - name17                - email
Form fields can contain primitives values, arrays and objects. By default, arrays are serialized as array_name=value1&array_name=value2 and objects as prop1=value1&prop=value2, but you can use other serialization strategies as defined by the OpenAPI 3.0 Specification. The serialization strategy is specified in the encoding section like so:
1requestBody:2  content:3    application/x-www-form-urlencoded:4      schema:5        type: object6        properties:7          color:8            type: array9            items:10              type: string11      encoding:12        color: # color=red,green,blue13          style: form14          explode: false
By default, reserved characters :/?#[]@!$&'()*+,;= in form field values within application/x-www-form-urlencoded bodies are percent-encoded when sent. To allow these characters to be sent as is, use the allowReserved keyword like so:
1requestBody:2  content:3    application/x-www-form-urlencoded:4      schema:5        type: object6        properties:7          foo:8            type: string9          bar:10            type: string11          baz:12            type: string13      encoding:14        # Don't percent-encode reserved characters in the values of "bar" and "baz" fields15        bar:16          allowReserved: true17        baz:18          allowReserved: true
Arbitrary key=value pairs can be modelled using a free-form schema:
1requestBody:2  content:3    application/x-www-form-urlencoded:4      schema:5        type: object6        additionalProperties: true # this line is optional
Complex Serialization in Form Data
The serialization rules provided by the style and explode keywords only have defined behavior for arrays of primitives and objects with primitive properties. For more complex scenarios, such as nested arrays or JSON in form data, you need to use the contentType keyword to specify the media type for encoding the value of a complex field. Consider Slack incoming webhooks for an example. A message can be sent directly as JSON, or the JSON data can be sent inside a form field named payload like so (before URL-encoding is applied):
1payload={"text":"Swagger is awesome"}
This can be described as:
1openapi: 3.0.42info:3  version: 1.0.04  title: Slack Incoming Webhook5externalDocs:6  url: https://api.slack.com/incoming-webhooks7
8servers:9  - url: https://hooks.slack.com10
11paths:12  /services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX:13    post:14      summary: Post a message to Slack15      requestBody:16        content:17          application/json:18            schema:19              $ref: "#/components/schemas/Message"20
21          application/x-www-form-urlencoded:22            schema:23              type: object24              properties:25                payload: # <--- form field that contains the JSON message26                  $ref: "#/components/schemas/Message"27            encoding:28              payload:29                contentType: application/json30
31      responses:32        "200":33          description: OK34
35components:36  schemas:37    Message:38      title: A Slack message39      type: object40      properties:41        text:42          type: string43          description: Message text44      required:45        - text
References
RequestBody Object
MediaType Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Parameter Serialization       Next  File Upload\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nFile Upload        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
In OpenAPI 3.0, you can describe files uploaded directly with the request content and files uploaded with multipart requests. Use the requestBody keyword to describe the request payload containing a file. Under content, specify the request media type (such as image/png or application/octet-stream). Files use a type: string schema with format: binary or format: base64, depending on how the file contents will be encoded. For example:
1requestBody:2  content:3    image/png:4      schema:5        type: string6        format: binary
This definition corresponds to an HTTP request that looks as follows:
1POST /upload2Host: example.com3Content-Length: 8084Content-Type: image/png5
6[file content goes there]
Upload via Multipart Requests
To describe a file sent with other data, use the multipart media type. For example:
1requestBody:2  content:3    multipart/form-data:4      schema:5        type: object6        properties:7          orderId:8            type: integer9          userId:10            type: integer11          fileName:12            type: string13            format: binary
The corresponding HTTP request payload will include multiple parts:
1POST /upload2Host: example.com3Content-Length: 27404Content-Type: multipart/form-data; boundary=abcde123455
6--abcde123457Content-Disposition: form-data; name="orderId"8
9119510--abcde1234511Content-Disposition: form-data; name="userId"12
1354514--abcde1234515Content-Disposition: form-data; name="fileName"; filename="attachment.txt"16Content-Type: text/plain17
18[file content goes there]19--abcde12345--
Multiple File Upload
Use the multipart media type to define uploading an arbitrary number of files (an array of files):
1requestBody:2  content:3    multipart/form-data:4      schema:5        type: object6        properties:7          filename:8            type: array9            items:10              type: string11              format: binary
The corresponding HTTP request will look as follows:
1POST /upload2Host: example.com3Content-Length: 27404Content-Type: multipart/form-data; boundary=abcde123455
6--abcde123457Content-Disposition: form-data; name="fileName"; filename="file1.txt"8Content-Type: text/plain9
10[file content goes there]11--abcde1234512Content-Disposition: form-data; name="fileName"; filename="file2.png"13Content-Type: image/png14
15[file content goes there]16--abcde1234517Content-Disposition: form-data; name="fileName"; filename="file3.jpg"18Content-Type: image/jpeg19
20[file content goes there]21--abcde12345--
References
For more information about file upload in OpenAPI, see the following sections of the OpenAPI 3.0 Specification:
Considerations for File Uploads
Special Considerations for multipart Content
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Overview       Next  Multipart Requests\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nMultipart Requests        NoteOAS 3 This guide is for OpenAPI 3.0.
Multipart requests combine one or more sets of data into a single body, separated by boundaries. You typically use these requests for file uploads and for transferring data of several types in a single request (for example, a file along with a JSON object). In OpenAPI 3, you describe a multipart request in the following way:
1requestBody:2  content:3    multipart/form-data: # Media type4      schema: # Request payload5        type: object6        properties: # Request parts7          id: # Part 1 (string value)8            type: string9            format: uuid10          address: # Part2 (object)11            type: object12            properties:13              street:14                type: string15              city:16                type: string17          profileImage: # Part 3 (an image)18            type: string19            format: binary
You start with the requestBody/content keyword. Then, you specify the media type of request data. File uploads typically use the _multipart/form-data_ media type, and mixed-data requests usually use _multipart/mixed_. Below the media type, put the schema keyword to indicate that you start describing the request payload. You describe individual parts of the request as properties of the schema object. As you can see, a multipart request can include various data: strings, objects in JSON format, and binary data. You can also specify one or several files for uploading. (To learn more, see File Upload.) The example above corresponds to the following request:
1POST /upload HTTP/1.12Content-Length: 4283Content-Type: multipart/form-data; boundary=abcde123454
5--abcde123456Content-Disposition: form-data; name="id"7Content-Type: text/plain8
9123e4567-e89b-12d3-a456-42665544000010--abcde1234511Content-Disposition: form-data; name="address"12Content-Type: application/json13
14{15  "street": "3, Garden St",16  "city": "Hillsbery, UT"17}18--abcde1234519Content-Disposition: form-data; name="profileImage "; filename="image1.png"20Content-Type: application/octet-stream21
22{…file content…}23--abcde12345--
Specifying Content-Type
By default, the Content-Type of individual request parts is set automatically according to the type of the schema properties that describe the request parts:
Schema Property Type
Content-Type
Primitive or array of primitives
text/plain
Complex value or array of complex values
application/json
String in the binary or base64 format
application/octet-stream
To set a specific Content-Type for a request part, use the encoding/_{property-name}_/contentType field. You add encoding as a child of the media type property, one the same level where schema is located. In the example below, we set the contentType for the profileImage part of a multipart request to image/png, image/jpg:
1requestBody:2  content:3    multipart/form-data:4      schema:5        type: object6        properties: # Request parts7          id:8            type: string9            format: uuid10          address:11            type: object12            properties:13              street:14                type: string15              city:16                type: string17          profileImage:18            type: string19            format: base6420      encoding: # The same level as schema21        profileImage: # Property name (see above)22          contentType: image/png, image/jpeg
Specifying Custom Headers
Parts of multipart requests usually do not use any headers, except for Content. In case you need to include custom headers, use the encoding/_{property-name}_/headers field to describe these headers (see below). For complete information on describing headers, see Describing Parameters. Below is an example of a custom header defined for a part of a multipart request:
1requestBody:2  content:3    multipart/form-data:4      schema:5        type: object6        properties:7          id:8            type: string9            format: uuid10          profileImage:11            type: string12            format: binary13      encoding:14        profileImage: # Property name15          contentType: image/png, image/jpeg16          headers: # Custom headers17            X-Custom-Header:18              description: This is a custom header19              schema:20                type: string
This declaration matches the following request:
1POST /upload HTTP/1.12Content-Length: 4283Content-Type: multipart/form-data; boundary=abcde123454
5--abcde123456Content-Disposition: form-data; name="id"7Content-Type: text/plain8
9123e4567-e89b-12d3-a456-42665544000010--abcde1234511Content-Disposition: form-data; name="profileImage"; filename="image1.png"12Content-Type: image/png13X-Custom-Header: x-header14
15{…file content…}16--abcde12345--
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  File Upload       Next  Describing Responses\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDescribing Responses        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
An API specification needs to specify the responses for all API operations. Each operation must have at least one response defined, usually a successful response. A response is defined by its HTTP status code and the data returned in the response body and/or headers. Here is a minimal example:
1paths:2  /ping:3    get:4      responses:5        "200":6          description: OK7          content:8            text/plain:9              schema:10                type: string11                example: pong
Response Media Types
An API can respond with various media types. JSON is the most common format for data exchange, but not the only one possible. To specify the response media types, use the content keyword at the operation level.
1paths:2  /users:3    get:4      summary: Get all users5      responses:6        "200":7          description: A list of users8          content:9            application/json:10              schema:11                $ref: "#/components/schemas/ArrayOfUsers"12            application/xml:13              schema:14                $ref: "#/components/schemas/ArrayOfUsers"15            text/plain:16              schema:17                type: string18
19  # This operation returns image20  /logo:21    get:22      summary: Get the logo image23      responses:24        "200":25          description: Logo image in PNG format26          content:27            image/png:28              schema:29                type: string30                format: binary
More info: Media Types.
HTTP Status Codes
Under responses, each response definition starts with a status code, such as 200 or 404. An operation typically returns one successful status code and one or more error statuses. To define a range of response codes, you may use the following range definitions: 1XX, 2XX, 3XX, 4XX, and 5XX. If a response range is defined using an explicit code, the explicit code definition takes precedence over the range definition for that code. Each response status requires a description. For example, you can describe the conditions for error responses. Markdown (CommonMark) can be used for rich text representation.
1responses:2  "200":3    description: OK4  "400":5    description: Bad request. User ID must be an integer and larger than 0.6  "401":7    description: Authorization information is missing or invalid.8  "404":9    description: A user with the specified ID was not found.10  "5XX":11    description: Unexpected error.
Note that an API specification does not necessarily need to cover all possible HTTP response codes, since they may not be known in advance. However, it is expected to cover successful responses and any known errors. By “known errors” we mean, for example, a 404 Not Found response for an operation that returns a resource by ID, or a 400 Bad Request response in case of invalid operation parameters.
Response Body
The schema keyword is used to describe the response body. A schema can define:

an object or an array — typically used with JSON and XML APIs,
a primitive data type such as a number or string – used for plain text responses,
a file – (see below).

Schema can be defined inline in the operation:
1responses:2  "200":3    description: A User object4    content:5      application/json:6        schema:7          type: object8          properties:9            id:10              type: integer11              description: The user ID.12            username:13              type: string14              description: The user name.
or defined in the global components.schemas section and referenced via $ref. This is useful if multiple media types use the same schema.
1responses:2  "200":3    description: A User object4    content:5      application/json:6        schema:7          $ref: "#/components/schemas/User"8    components:9      schemas:10        User:11          type: object12          properties:13            id:14              type: integer15              description: The user ID.16            username:17              type: string18              description: The user name.
Response That Returns a File
An API operation can return a file, such as an image or PDF. OpenAPI 3.0 defines file input/output content as type: string with format: binary or format: base64. This is in contrast with OpenAPI 2.0, which uses type: file to describe file input/output content. If the response returns the file alone, you would typically use a binary string schema and specify the appropriate media type for the response content:
1paths:2  /report:3    get:4      summary: Returns the report in the PDF format5      responses:6        "200":7          description: A PDF file8          content:9            application/pdf:10              schema:11                type: string12                format: binary
Files can also be embedded into, say, JSON or XML as a base64-encoded string. In this case, you would use something like:
1paths:2  /users/me:3    get:4      summary: Returns user information5      responses:6        "200":7          description: A JSON object containing user name and avatar8          content:9            application/json:10              schema:11                type: object12                properties:13                  username:14                    type: string15                  avatar: # <-- image embedded into JSON16                    type: string17                    format: byte18                    description: Base64-encoded contents of the avatar image
anyOf, oneOf
OpenAPI 3.0 also supports oneOf and anyOf, so you can specify alternate schemas for the response body.
1responses:2  "200":3    description: A JSON object containing pet information4    content:5      application/json:6        schema:7          oneOf:8            - $ref: "#/components/schemas/Cat"9            - $ref: "#/components/schemas/Dog"10            - $ref: "#/components/schemas/Hamster"
Empty Response Body
Some responses, such as 204 No Content, have no body. To indicate the response body is empty, do not specify a content for the response:
1responses:2  "204":3    description: The resource was deleted successfully.
Response Headers
Responses from an API can include custom headers to provide additional information on the result of an API call. For example, a rate-limited API may provide the rate limit status via response headers as follows:
1HTTP 1/1 200 OK2X-RateLimit-Limit: 1003X-RateLimit-Remaining: 994X-RateLimit-Reset: 2016-10-12T11:00:00Z5
6{ ... }
You can define custom headers for each response as follows:
1paths:2  /ping:3    get:4      summary: Checks if the server is alive.5      responses:6        "200":7          description: OK8          headers:9            X-RateLimit-Limit:10              schema:11                type: integer12              description: Request limit per hour.13            X-RateLimit-Remaining:14              schema:15                type: integer16              description: The number of requests left for the time window.17            X-RateLimit-Reset:18              schema:19                type: string20                format: date-time21              description: The UTC date/time at which the current rate limit window resets.
Note that, currently, OpenAPI Specification does not permit to define common response headers for different response codes or different API operations. You need to define the headers for each response individually.
Default Response
Sometimes, an operation can return multiple errors with different HTTP status codes, but all of them have the same response structure:
1responses:2  "200":3    description: Success4    content:5      application/json:6        schema:7          $ref: "#/components/schemas/User"8
9  # These two error responses have the same schema10  "400":11    description: Bad request12    content:13      application/json:14        schema:15          $ref: "#/components/schemas/Error"16  "404":17    description: Not found18    content:19      application/json:20        schema:21          $ref: "#/components/schemas/Error"
You can use the default response to describe these errors collectively, not individually. “Default” means this response is used for all HTTP codes that are not covered individually for this operation.
1responses:2  "200":3    description: Success4    content:5      application/json:6        schema:7          $ref: "#/components/schemas/User"8
9  # Definition of all error statuses10  default:11    description: Unexpected error12    content:13      application/json:14        schema:15          $ref: "#/components/schemas/Error"
Reusing Responses
If multiple operations return the same response (status code and data), you can define it in the responses section of the global components object and then reference that definition via $ref at the operation level. This is useful for error responses with the same status codes and response body.
1paths:2  /users:3    get:4      summary: Gets a list of users.5      response:6        "200":7          description: OK8          content:9            application/json:10              schema:11                $ref: "#/components/schemas/ArrayOfUsers"12        "401":13          $ref: "#/components/responses/Unauthorized" # <-----14  /users/{id}:15    get:16      summary: Gets a user by ID.17      response:18        "200":19          description: OK20          content:21            application/json:22              schema:23                $ref: "#/components/schemas/User"24        "401":25          $ref: "#/components/responses/Unauthorized" # <-----26        "404":27          $ref: "#/components/responses/NotFound" # <-----28
29# Descriptions of common components30components:31  responses:32    NotFound:33      description: The specified resource was not found34      content:35        application/json:36          schema:37            $ref: "#/components/schemas/Error"38    Unauthorized:39      description: Unauthorized40      content:41        application/json:42          schema:43            $ref: "#/components/schemas/Error"44
45  schemas:46    # Schema for error response body47    Error:48      type: object49      properties:50        code:51          type: string52        message:53          type: string54      required:55        - code56        - message
Note that responses defined in components.responses are not automatically applied to all operations. These are just definitions that can be referenced and reused by multiple operations.
Linking Response Values to Other Operations
Certain values in the response could be used as parameters to other operations. A typical example is the “create resource” operation that returns the ID of the created resource, and this ID can be used to get that resource, update or delete it. OpenAPI 3.0 provides the links keyword to describe such relationships between a response and other API calls. For more information, see Links.
FAQ
Can I have different responses based on a request parameter? Such as:
1GET /something -> {200, schema_1}2GET /something?foo=bar -> {200, schema_2}
In OpenAPI 3.0, you can use oneOf to specify alternate schemas for the response and document possible dependencies verbally in the response description. However, there is no way to link specific schemas to certain parameter combinations.
Reference
Response Object
MediaType Object
Components Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Multipart Requests       Next  Overview\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nData Models (Schemas)        NoteOAS 3 This guide is for OpenAPI 3.0.
OpenAPI 3.0 data types are based on an extended subset JSON Schema Specification Wright Draft 00 (aka Draft 5). The data types are described using a Schema object. To learn how to model various data types, see the following topics:

Data Types
Enums
Dictionaries, Hashmaps, Associative Arrays
oneOf, anyOf, allOf, not
Inheritance and Polymorphism
Representing XML
Supported JSON Schema Keywords

Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Describing Responses       Next  Data Types\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nData Types        NoteOAS 3 This guide is for OpenAPI 3.0.
The data type of a schema is defined by the type keyword, for example, type: string. OpenAPI defines the following basic types:

string (this includes dates and files)
number
integer
boolean
array
object

These types exist in most programming languages, though they may go by different names. Using these types, you can describe any data structures.
Note that there is no null type; instead, the nullable attribute is used as a modifier of the base type.
Additional type-specific keywords can be used to refine the data type, for example, limit the string length or specify an enum of possible values.
Mixed Types
type takes a single value. type as a list is not valid in OpenAPI (even though it is valid in JSON Schema):
1# Incorrect2type:3  - string4  - integer
Mixed types can be described using oneOf and anyOf, which specify a list of alternate types:
1# Correct2oneOf:3  - type: string4  - type: integer
See also Any Type.
Numbers
OpenAPI has two numeric types, number and integer, where number includes both integer and floating-point numbers. An optional format keyword serves as a hint for the tools to use a specific numeric type:

  
    
			type
			format
			Description
		
	
	
		
			number
			–
			Any numbers.
		
		
			number
			float
			Floating-point numbers.
		
		
			number
			double
			Floating-point numbers with double precision.
		
		
			integer
			–
			Integer numbers.
		
		
			integer
			int32
			Signed 32-bit integers (commonly used integer type).
		
		
			integer
			int64
			Signed 64-bit integers (long type).
		
	

Note that strings containing numbers, such as “17”, are considered strings and not numbers.
Minimum and Maximum
Use the minimum and maximum keywords to specify the range of possible values:
1type: integer2minimum: 13maximum: 20
By default, the minimum and maximum values are included in the range, that is:
1minimum ≤ value ≤ maximum
To exclude the boundary values, specify exclusiveMinimum: true and exclusiveMaximum: true. For example, you can define a floating-point number range as 0–50 and exclude the 0 value:
1type: number2minimum: 03exclusiveMinimum: true4maximum: 50
The word “exclusive” in exclusiveMinimum and exclusiveMaximum means the corresponding boundary is excluded:

	
		
			Keyword
			Description
		
	
	
		
			exclusiveMinimum: false or not included
			value ≥ minimum
		
		
			exclusiveMinimum: true
			value > minimum
		
		
			exclusiveMaximum: false or not included
			value ≤ maximum
		
		
			exclusiveMaximum: true
			value < maximum
		
	

Multiples
Use the multipleOf keyword to specify that a number must be the multiple of another number:
1type: integer2multipleOf: 10
The example above matches 10, 20, 30, 0, -10, -20, and so on. multipleOf may be used with floating-point numbers, but in practice this can be unreliable due to the limited precision or floating point math.
1type: number2multipleOf: 2.5
The value of multipleOf must be a positive number, that is, you cannot use multipleOf: -5.
Strings
A string of text is defined as:
1type: string
String length can be restricted using minLength and maxLength:
1type: string2minLength: 33maxLength: 20
Note that an empty string "" is a valid string unless minLength or pattern is specified.
String Formats
An optional format modifier serves as a hint at the contents and format of the string. OpenAPI defines the following built-in string formats:

date – full-date notation as defined by RFC 3339, section 5.6, for example, 2017-07-21
date-time – the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z
password – a hint to UIs to mask the input
byte – base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==
binary – binary data, used to describe files (see Files below)

However, format is an open value, so you can use any formats, even not those defined by the OpenAPI Specification, such as:

email
uuid
uri
hostname
ipv4
ipv6
and others

Tools can use the format to validate the input or to map the value to a specific type in the chosen programming language. Tools that do not support a specific format may default back to the type alone, as if the format is not specified.
pattern
The pattern keyword lets you define a regular expression template for the string value. Only the values that match this template will be accepted. The regular expression syntax used is from JavaScript (more specifically, ECMA 262). Regular expressions are case-sensitive, that is, [a-z] and [A-Z] are different expressions. For example, the following pattern matches a Social Security Number (SSN) in the 123-45-6789 format:
1ssn:2  type: string3  pattern: '^\d{3}-\d{2}-\d{4}$'
Note that the regular expression is enclosed in the ^…$ tokens, where ^ means the beginning of the string, and $ means the end of the string. Without ^…$, pattern works as a partial match, that is, matches any string that contains the specified regular expression. For example, pattern: pet matches pet, petstore and carpet. The ^…$ token forces an exact match.
Boolean
type: boolean represents two values: true and false. Note that truthy and falsy values such as “true”, "", 0 or null are not considered boolean values.
Null
OpenAPI 3.0 does not have an explicit null type as in JSON Schema, but you can use nullable: true to specify that the value may be null. Note that null is different from an empty string "".
1# Correct2type: integer3nullable: true4
5# Incorrect6type: null7
8# Incorrect as well9type:10  - integer11  - null
The example above may be mapped to the nullable types int? in C# and java.lang.Integer in Java. In objects, a nullable property is not the same as an optional property, but some tools may choose to map an optional property to the null value.
Arrays
Arrays are defined as:
1type: array2items:3  type: string
Unlike JSON Schema, the items keyword is required in arrays. The value of items is a schema that describes the type and format of array items. Arrays can be nested:
1# [ [1, 2], [3, 4] ]2type: array3items:4  type: array5  items:6    type: integer
and contain objects:
1# [ {"id": 5}, {"id": 8} ]2type: array3items:4  type: object5  properties:6    id:7      type: integer
Item schema can be specified inline (as in the previous examples), or referenced via $ref:
1# Array of Pets2type: array3items:4  $ref: "#/components/schemas/Pet"
Mixed-Type Arrays
Mixed-type arrays can be defined using oneOf:
1# ["foo", 5, -2, "bar"]2type: array3items:4  oneOf:5    - type: string6    - type: integer
oneOf allows both inline subschemas (as in the example above) and references:
1# Array of Cats and Dogs2type: array3items:4  oneOf:5    - $ref: "#/components/schemas/Cat"6    - $ref: "#/components/schemas/Dog"
An array of arbitrary types can be defined as:
1type: array2items: {}
1# [ "hello", -2, true, [5.7], {"id": 5} ]
Here, {} is the “any-type” schema (see below). Note that the following syntax for items is not valid:
1# Incorrect2items:3  - type: string4  - type: integer5
6# Incorrect as well7items:8  type:9    - string10    - integer
Array Length
You can define the minimum and maximum length of an array like so:
1type: array2items:3  type: integer4minItems: 15maxItems: 10
Without minItems, an empty array is considered valid.
uniqueItems
You can use uniqueItems: true to specify that all items in the array must be unique:
1type: array2items:3  type: integer4uniqueItems: true5# [1, 2, 3] – valid6# [1, 1, 3] – not valid7# [ ] – valid
Objects
An object is a collection of property/value pairs. The properties keyword is used to define the object properties – you need to list the property names and specify a schema for each property.
1type: object2properties:3  id:4    type: integer5  name:6    type: string
Tip: In OpenAPI, objects are usually defined in the global components/schemas section rather than inline in the request and response definitions.
Required Properties
By default, all object properties are optional. You can specify the required properties in the required list:
1type: object2properties:3  id:4    type: integer5  username:6    type: string7  name:8    type: string9required:10  - id11  - username
Note that required is an object-level attribute, not a property attribute:
1type: object2properties:3  id:4    type: integer5    required: true # Wrong!6
7required: # Correct8  - id
An empty list required: [] is not valid. If all properties are optional, do not specify the required keyword.
Read-Only and Write-Only Properties
You can use the readOnly and writeOnly keywords to mark specific properties as read-only or write-only. This is useful, for example, when GET returns more properties than used in POST – you can use the same schema in both GET and POST and mark the extra properties as readOnly. readOnly properties are included in responses but not in requests, and writeOnly properties may be sent in requests but not in responses.
1type: object2properties:3  id:4    # Returned by GET, not used in POST/PUT/PATCH5    type: integer6    readOnly: true7  username:8    type: string9  password:10    # Used in POST/PUT/PATCH, not returned by GET11    type: string12    writeOnly: true
If a readOnly or writeOnly property is included in the required list, required affects just the relevant scope – responses only or requests only. That is, read-only required properties apply to responses only, and write-only required properties – to requests only.
Nested Objects
An object can include nested objects:
1components:2  schemas:3    User:4      type: object5      properties:6        id:7          type: integer8        name:9          type: string10        contact_info:11          # The value of this property is an object12          type: object13          properties:14            email:15              type: string16              format: email17            phone:18              type: string
You may want to split nested objects into multiple schemas and use $ref to reference the nested schemas:
1components:2  schemas:3    User:4      type: object5      properties:6        id:7          type: integer8        name:9          type: string10        contact_info:11          $ref: "#/components/schemas/ContactInfo"12
13    ContactInfo:14      type: object15      properties:16        email:17          type: string18          format: email19        phone:20          type: string
Free-Form Object
A free-form object (arbitrary property/value pairs) is defined as:
1type: object
This is equivalent to
1type: object2additionalProperties: true
and
1type: object2additionalProperties: {}
Number of Properties
The minProperties and maxProperties keywords let you restrict the number of properties allowed in an object. This can be useful when using additionalProperties or free-form objects.
1type: object2minProperties: 23maxProperties: 10
In this example, {"id": 5, "username": "trillian"} matches the schema, but {"id": 5} does not.
Files
Unlike OpenAPI 2.0, Open API 3.0 does not have the file type. Files are defined as strings:
1type: string2format: binary # binary file contents
or
1type: string2format: byte # base64-encoded file contents
depending on the desired file transfer method. For more information, see File Upload, Multipart Requests and Response That Returns a File.
Any Type
A schema without a type matches any data type – numbers, strings, objects, and so on. {} is shorthand syntax for an arbitrary-type schema:
1components:2  schemas:3    AnyValue: {}
If you want to provide a description:
1components:2  schemas:3    AnyValue:4      description: Can be any value - string, number, boolean, array or object.
The above is equivalent to:
1components:2  schemas:3    AnyValue:4      anyOf:5        - type: string6        - type: number7        - type: integer8        - type: boolean9        - type: array10          items: {}11        - type: object
If the null value needs to be allowed, add nullable: true:
1components:2  schemas:3    AnyValue:4      nullable: true5      description: Can be any value, including `null`.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Overview       Next  Enums\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nEnums        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
You can use the enum keyword to specify possible values of a request parameter or a model property. For example, the sort parameter in GET /items?sort=[asc|desc] can be described as:
1paths:2  /items:3    get:4      parameters:5        - in: query6          name: sort7          description: Sort order8          schema:9            type: string10            enum: [asc, desc]
In YAML, you can also specify one enum value per line:
1enum:2  - asc3  - desc
All values in an enum must adhere to the specified type. If you need to specify descriptions for enum items, you can do this in the description of the parameter or property:
1parameters:2  - in: query3    name: sort4    schema:5      type: string6      enum: [asc, desc]7    description: >8      Sort order:9       * `asc` - Ascending, from A to Z10       * `desc` - Descending, from Z to A
Nullable enums
A nullable enum can be defined as follows:
1type: string2nullable: true  # <---3enum:4  - asc5  - desc6  - null        # <--- without quotes, i.e. null not "null"
Note that null must be explicitly included in the list of enum values. Using nullable: true alone is not enough here.
Reusable enums
In OpenAPI 3.0, both operation parameters and data models use a schema, making it easy to reuse the data types. You can define reusable enums in the global components section and reference them via $ref elsewhere.
1paths:2  /products:3    get:4      parameters:5        - in: query6          name: color7          required: true8          schema:9            $ref: "#/components/schemas/Color"10      responses:11        "200":12          description: OK13components:14  schemas:15    Color:16      type: string17      enum:18        - black19        - white20        - red21        - green22        - blue
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Data Types       Next  Dictionaries, Hashmaps, Associative Arrays\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDictionaries, HashMaps and Associative Arrays        NoteOAS 3 This guide is for OpenAPI 3.0.
A dictionary (also known as a map, hashmap or associative array) is a set of key/value pairs. OpenAPI lets you define dictionaries where the keys are strings. To define a dictionary, use type: object and use the additionalProperties keyword to specify the type of values in key/value pairs. For example, a string-to-string dictionary like this:
1{ "en": "English", "fr": "French" }
is defined using the following schema:
1type: object2additionalProperties:3  type: string
Value Type
The additionalProperties keyword specifies the type of values in the dictionary. Values can be primitives (strings, numbers or boolean values), arrays or objects. For example, a string-to-object dictionary can be defined as follows:
1type: object2additionalProperties:3  type: object4  properties:5    code:6      type: integer7    text:8      type: string
Instead of using an inline schema, additionalProperties can $ref another schema:
1components:2  schemas:3    Messages: # <---- dictionary4      type: object5      additionalProperties:6        $ref: "#/components/schemas/Message"7
8    Message:9      type: object10      properties:11        code:12          type: integer13        text:14          type: string
Free-Form Objects
If the dictionary values can be of any type (aka free-form object), use additionalProperties: true:
1type: object2additionalProperties: true
This is equivalent to:
1type: object2additionalProperties: {}
Fixed Keys
If a dictionary has some fixed keys, you can define them explicitly as object properties and mark them as required:
1type: object2properties:3  default:4    type: string5required:6  - default7additionalProperties:8  type: string
Examples of Dictionary Contents
You can use the example keyword to specify sample dictionary contents:
1type: object2additionalProperties:3  type: string4example:5  en: Hello!6  fr: Bonjour!
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Enums       Next  oneOf, anyOf, allOf, not\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\noneOf, anyOf, allOf, not        NoteOAS 3 This guide is for OpenAPI 3.0.
OpenAPI 3.0 provides several keywords which you can use to combine schemas. You can use these keywords to create a complex schema, or validate a value against multiple criteria.

oneOf – validates the value against exactly one of the subschemas
allOf – validates the value against all the subschemas
anyOf – validates the value against any (one or more) of the subschemas

Besides these, there is a not keyword which you can use to make sure the value is not valid against the specified schema.
oneOf
Use the oneOf keyword to ensure the given data is valid against one of the specified schemas.
1paths:2  /pets:3    patch:4      requestBody:5        content:6          application/json:7            schema:8              oneOf:9                - $ref: "#/components/schemas/Cat"10                - $ref: "#/components/schemas/Dog"11      responses:12        "200":13          description: Updated14
15components:16  schemas:17    Dog:18      type: object19      properties:20        bark:21          type: boolean22        breed:23          type: string24          enum: [Dingo, Husky, Retriever, Shepherd]25    Cat:26      type: object27      properties:28        hunts:29          type: boolean30        age:31          type: integer
The example above shows how to validate the request body in the “update” operation (PATCH). You can use it to validate the request body contains all the necessary information about the object to be updated, depending on the object type. Note the inline or referenced schema must be a schema object, not a standard JSON Schema. Now, to validation. The following JSON object is valid against one of the schemas, so the request body is correct:
1{ "bark": true, "breed": "Dingo" }
The following JSON object is not valid against both schemas, so the request body is incorrect:
1{ "bark": true, "hunts": true }
The following JSON object is valid against both schemas, so the request body is incorrect – it should be valid against only one of the schemas, since we are using the oneOf keyword.
1{ "bark": true, "hunts": true, "breed": "Husky", "age": 3 }
allOf
OpenAPI lets you combine and extend model definitions using the allOf keyword. allOf takes an array of object definitions that are used for independent validation but together compose a single object. Still, it does not imply a hierarchy between the models. For that purpose, you should include the discriminator. To be valid against allOf, the data provided by the client must be valid against all of the given subschemas. In the following example, allOf acts as a tool for combining schemas used in specific cases with the general one. For more clearness, oneOf is also used with a discriminator.
1paths:2  /pets:3    patch:4      requestBody:5        content:6          application/json:7            schema:8              oneOf:9                - $ref: "#/components/schemas/Cat"10                - $ref: "#/components/schemas/Dog"11              discriminator:12                propertyName: pet_type13      responses:14        "200":15          description: Updated16
17components:18  schemas:19    Pet:20      type: object21      required:22        - pet_type23      properties:24        pet_type:25          type: string26      discriminator:27        propertyName: pet_type28
29    Dog: # "Dog" is a value for the pet_type property (the discriminator value)30      allOf: # Combines the main `Pet` schema with `Dog`-specific properties31        - $ref: "#/components/schemas/Pet"32        - type: object33          # all other properties specific to a `Dog`34          properties:35            bark:36              type: boolean37            breed:38              type: string39              enum: [Dingo, Husky, Retriever, Shepherd]40
41    Cat: # "Cat" is a value for the pet_type property (the discriminator value)42      allOf: # Combines the main `Pet` schema with `Cat`-specific properties43        - $ref: "#/components/schemas/Pet"44        - type: object45          # all other properties specific to a `Cat`46          properties:47            hunts:48              type: boolean49            age:50              type: integer
As you can see, this example validates the request body content to make sure it includes all the information needed to update a pet item with the PUT operation. It requires user to specify which type of the item should be updated, and validates against the specified schema according to their choice. Note the inline or referenced schema must be a schema object, not a standard JSON schema. For that example, all of the following request bodies are valid:
1{2  "pet_type": "Cat",3  "age": 34}5
6{7  "pet_type": "Dog",8  "bark": true9}10
11{12  "pet_type": "Dog",13  "bark": false,14  "breed": "Dingo"15}
The following request bodies are not valid:
1{2  "age": 3        # Does not include the pet_type property3}4
5{6  "pet_type": "Cat",7  "bark": true    # The `Cat` schema does not have the `bark` property8}
anyOf
Use the anyOf keyword to validate the data against any amount of the given subschemas. That is, the data may be valid against one or more subschemas at the same time.
1paths:2  /pets:3    patch:4      requestBody:5        content:6          application/json:7            schema:8              anyOf:9                - $ref: "#/components/schemas/PetByAge"10                - $ref: "#/components/schemas/PetByType"11      responses:12        "200":13          description: Updated14
15components:16  schemas:17    PetByAge:18      type: object19      properties:20        age:21          type: integer22        nickname:23          type: string24      required:25        - age26
27    PetByType:28      type: object29      properties:30        pet_type:31          type: string32          enum: [Cat, Dog]33        hunts:34          type: boolean35      required:36        - pet_type
Note the inline or referenced schema must be a schema object, not a standard JSON schema. With this example, the following JSON request bodies are valid:
1{2  "age": 13}4
5{6  "pet_type": "Cat",7  "hunts": true8}9
10{11  "nickname": "Fido",12  "pet_type": "Dog",13  "age": 414}
The following example is not valid, because it does not contain any of the required properties for both of the schemas:
1{ "nickname": "Mr. Paws", "hunts": false }
Difference Between anyOf and oneOf
oneOf matches exactly one subschema, and anyOf can match one or more subschemas. To better understand the difference, use the example above but replace anyOf with oneOf. When using oneOf, the following request body is not valid because it matches both schemas and not just one:
1{ "nickname": "Fido", "pet_type": "Dog", "age": 4 }
not
The not keyword does not exactly combine schemas, but as all of the keywords mentioned above it helps you to modify your schemas and make them more specific.
1paths:2  /pets:3    patch:4      requestBody:5        content:6          application/json:7            schema:8              $ref: "#/components/schemas/PetByType"9      responses:10        "200":11          description: Updated12
13components:14  schemas:15    PetByType:16      type: object17      properties:18        pet_type:19          not:20            type: integer21      required:22        - pet_type
In this example, user should specify the pet_type value of any type except integer (that is, it should be an array, boolean, number, object, or string). The following request body is valid:
1{ "pet_type": "Cat" }
And the following is not valid:
1{ "pet_type": 11 }
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Dictionaries, Hashmaps, Associative Arrays       Next  Inheritance and Polymorphism\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nInheritance and Polymorphism        NoteOAS 3 This guide is for OpenAPI 3.0.
Model Composition
In your API, you may have model schemas that share common properties. Instead of describing these properties for each schema repeatedly, you can describe the schemas as a composition of the common property set and schema-specific properties. In OpenAPI version 3, you do this with the allOf keyword:
1components:2  schemas:3    BasicErrorModel:4      type: object5      required:6        - message7        - code8      properties:9        message:10          type: string11        code:12          type: integer13          minimum: 10014          maximum: 60015    ExtendedErrorModel:16      allOf: # Combines the BasicErrorModel and the inline model17        - $ref: "#/components/schemas/BasicErrorModel"18        - type: object19          required:20            - rootCause21          properties:22            rootCause:23              type: string
In the example above, the ExtendedErrorModel schema includes its own properties and properties inherited from BasicErrorModel. Note: When validating the data, servers and clients will validate the combined model against each model it consists of. It is recommended to avoid using conflicting properties (like properties that have the same names, but different data types).
Polymorphism
In your API, you can have request and responses that can be described by several alternative schemas. In OpenAPI 3.0, to describe such a model, you can use the oneOf or anyOf keywords:
1components:2  responses:3    sampleObjectResponse:4      content:5        application/json:6          schema:7            oneOf:8              - $ref: '#/components/schemas/simpleObject'9              - $ref: '#/components/schemas/complexObject'10  …11components:12  schemas:13    simpleObject:14      …15    complexObject:16      …
In this example, the response payload can contain either simpleObject, or complexObject.
Discriminator
To help API consumers detect the object type, you can add the discriminator/propertyName keyword to model definitions. This keyword points to the property that specifies the data type name:
1components:2  responses:3    sampleObjectResponse:4      content:5        application/json:6          schema:7            oneOf:8              - $ref: '#/components/schemas/simpleObject'9              - $ref: '#/components/schemas/complexObject'10            discriminator:11              propertyName: objectType12  …13  schemas:14    simpleObject:15      type: object16      required:17        - objectType18      properties:19        objectType:20          type: string21      …22    complexObject:23      type: object24      required:25        - objectType26      properties:27        objectType:28          type: string29      …
In our example, the discriminator points to the objectType property that contains the data type name. The discriminator is used with anyOf or oneOf keywords only. It is important that all the models mentioned below anyOf or oneOf contain the property that the discriminator specifies. This means, for example, that in our code above, both simpleObject and complexObject must have the objectType property. This property is required in these schemas:
1schemas:2    simpleObject:3      type: object4      required:5        - objectType6      properties:7        objectType:8          type: string9      …10    complexObject:11      type: object12      required:13        - objectType14      properties:15        objectType:16          type: string17      …
The discriminator keyword can be used by various API consumers. One possible example are code generation tools: they can use discriminator to generate program statements that typecast request data to appropriate object type based on the discriminator property value.
Mapping Type Names
It is implied, that the property to which discriminator refers, contains the name of the target schema. In the example above, the objectType property should contain either simpleObject, or complexObject string. If the property values do not match the schema names, you can map the values to the names. To do this, use the discriminator/mapping keyword:
1components:2  responses:3    sampleObjectResponse:4      content:5        application/json:6          schema:7            oneOf:8              - $ref: '#/components/schemas/Object1'9              - $ref: '#/components/schemas/Object2'10              - $ref: 'sysObject.json#/sysObject'11            discriminator:12              propertyName: objectType13              mapping:14                obj1: '#/components/schemas/Object1'15                obj2: '#/components/schemas/Object2'16                system: 'sysObject.json#/sysObject'17  …18  schemas:19    Object1:20      type: object21      required:22        - objectType23      properties:24        objectType:25          type: string26      …27    Object2:28      type: object29      required:30        - objectType31      properties:32        objectType:33          type: string34      …
In this example, the obj1 value is mapped to the Object1 model that is defined in the same spec, obj2 – to Object2, and the value system matches the sysObject model that is located in an external file. All these objects must have the objectType property with the value "obj1", "obj2" or "system", respectively.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  oneOf, anyOf, allOf, not       Next  Representing XML\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nRepresenting XML        NoteOAS 3 This guide is for OpenAPI 3.0.
In your API specification, you can describe data in both XML and JSON formats as they are easily interchangeable. For example, the following declaration —
1components:2  schemas:3    book:4      type: object5      properties:6        id:7          type: integer8        title:9          type: string10        author:11          type: string
— is represented in the following way in JSON and XML:
JSON
1{ "id": 0, "title": "string", "author": "string" }
XML
1<book>2  <id>0</id>3  <title>string</title>4  <author>string</author>5</book>
As you can see, in XML representation, the object name serves as a parent element and properties are translated to child elements. The OpenAPI 3 format offers a special xml object to help you fine-tune representation of XML data. You can use this object to transform some properties to attributes rather than elements, to change element names, to add namespaces and to control transformations of array items.
Change Element Names
By default, XML elements get the same names that fields in the API declaration have. To change the default behavior, add the xml/name field to your spec:
Element name
Specification
1components:2  schemas:3    book:4      type: object5      properties:6        id:7          type: integer8        title:9          type: string10        author:11          type: string12      xml:13        name: "xml-book"
XML
1<xml-book>2  <id>0</id>3  <title>string</title>4  <author>string</author>5</xml-book>
Attribute name
Specification
1components:2  schemas:3    book:4      type: object5      properties:6        id:7          type: integer8        title:9          type: string10          xml:11            name: "xml-title"12        author:13          type: string
XML
1<book>2  <id>0</id>3  <xml-title>string</xml-title>4  <author>string</author>5</book>
For arrays, the xml/name property works only if another property – xml/wrapped – is set to true. See below.
Convert Property to an Attribute
As we said above, by default, properties are transformed to child elements of the parent “object” element. To make some property an attribute in the resulting XML data, use the xml/attribute:
Specification
1book:2  type: object3  properties:4    id:5      type: integer6      xml:7        attribute: true8    title:9      type: string10    author:11      type: string
XML
1<book id="0">2  <title>string</title>3  <author>string</author>4</book>
This works only for properties. Using xml/attribute for objects is meaningless.
Prefixes and Namespaces
To avoid element name conflicts, you can specify namespace and prefix for elements. The namespace value must be an absolute URI:
1xml:2  prefix: "smp"3  namespace: "http://example.com/schema"
Namespace prefixes will be ignored for JSON:
1{ "author": "Mark Twain" }
The example below shows how you can add namespaces and prefixes:
Specification
1book:2  type: object3  properties:4    id:5      type: integer6    title:7      type: string8    author:9      type: string10  xml:11    prefix: "smp"12    namespace: "http://example.com/schema"
XML
1<smp:book xmlns:smp="http://example.com/schema">2  <id>0</id>3  <title>string</title>4  <author>string</author>5</smp:book>
If needed, you can specify only prefix (This works in case the namespace is defined in some parent element). You can also specify prefixes for attributes.
Wrapping Arrays
Arrays are translated as a sequence of elements of the same name:
Specification
1books:2  type: array3  items:4    type: string5  example:6    - "one"7    - "two"8    - "three"
XML
1<books>one</books>2<books>two</books>3<books>three</books>
If needed, you can add a wrapping element by using the xml/wrapped property:
Specification
1books:2  type: array3  items:4    type: string5  xml:6    wrapped: true7  example:8    - "one"9    - "two"10    - "three"
XML
1<books>2  <books>one</books>3  <books>two</books>4  <books>three</books>5</books>
As you can see, by default, the wrapping element has the same name as item elements. Use xml/name to give different names to the wrapping element and array items (this will help you resolve possible naming issues):
Specification
1books:2  type: array3  items:4    type: string5    xml:6      name: "item"7  xml:8    wrapped: true9    name: books-array10  example:11    - "one"12    - "two"13    - "three"
XML
1<books-array>2  <item>one</item>3  <item>two</item>4  <item>three</item>5</books-array>
Note that the xml.name property of the wrapping element (books in our example) has effect only if wrapped is true. If wrapped is false, xml.name of the wrapping element is ignored.
Reference
XML Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Inheritance and Polymorphism       Next  Supported JSON Schema Keywords\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSupported JSON Schema Keywords        NoteOAS 3 This guide is for OpenAPI 3.0.
OpenAPI 3.0 uses an extended subset of JSON Schema Specification Wright Draft 00 (aka Draft 5) to describe the data formats. “Extended subset” means that some keywords are supported and some are not, some keywords have slightly different usage than in JSON Schema, and additional keywords are introduced.
Supported Keywords
These keywords have the same meaning as in JSON Schema:

title
pattern
required
enum
minimum
maximum
exclusiveMinimum
exclusiveMaximum
multipleOf
minLength
maxLength
minItems
maxItems
uniqueItems
minProperties
maxProperties

These keywords are supported with minor differences:

type – the value must be a single type and not an array of types. null is not supported as a type, use the nullable: true keyword instead.
format – OpenAPI has its own predefined formats and also allows custom formats.
description – supports CommonMark syntax for rich text representation.
items – must be present if type is array. The item schema must be an OpenAPI schema and not a standard JSON Schema.
properties – individual property definitions must follow OpenAPI schema rules and not standard JSON Schema.
additionalProperties – the value can be a boolean (true or false) or an OpenAPI schema.
default – the default value must conform to the specified schema.
allOf – the subschemas must be OpenAPI schemas and not standard JSON Schemas.
oneOf – the subschemas must be OpenAPI schemas and not standard JSON Schemas.
anyOf – the subschemas must be OpenAPI schemas and not standard JSON Schemas.
not – the subschema must be an OpenAPI schema and not a standard JSON Schema.

Unsupported Keywords

$schema
additionalItems
const
contains
dependencies
id,
$id
patternProperties
propertyNames

Additional Keywords
OpenAPI schemas can also use the following keywords that are not part of JSON Schema:

deprecated
discriminator
example
externalDocs
nullable
readOnly
writeOnly
xml

References
OpenAPI 3.0 – Schema Object
JSON Schema Validation – JSON Schema keyword reference
JSON Schema Draft Wright 00 – Core JSON Schema Specification
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Representing XML       Next  Adding Examples\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAdding Examples        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
You can add examples to parameters, properties and objects to make OpenAPI specification of your web service clearer. Examples can be read by tools and libraries that process your API in some way. For example, an API mocking tool can use sample values to generate mock requests. You can specify examples for objects, individual properties and operation parameters. To specify an example, you use the example or examples keys. See below for details.
Note for Swagger UI users: Support for multiple examples is available since Swagger UI 3.23.0 and Swagger Editor 3.6.31.
Note: Do not confuse example values with default values. An example illustrates what the value is supposed to be. A default value is what the server uses if the client does not provide the value.
Parameter Examples
Here is an example of a parameter value:
1parameters:2  - in: query3    name: status4    schema:5      type: string6      enum: [approved, pending, closed, new]7      example: approved # Example of a parameter value
Multiple examples for a parameter:
1parameters:2  - in: query3    name: limit4    schema:5      type: integer6      maximum: 507    examples: # Multiple examples8      zero: # Distinct name9        value: 0 # Example value10        summary: A sample limit value # Optional description11      max: # Distinct name12        value: 50 # Example value13        summary: A sample limit value # Optional description
As you can see, each example has a distinct key name. Also, in the code above, we used an optional summary keys with description. Note: the sample values you specify should match the parameter data type.
Request and Response Body Examples
Here is an example of the example keyword in a request body:
1paths:2  /users:3    post:4      summary: Adds a new user5      requestBody:6        content:7          application/json:8            schema: # Request body contents9              type: object10              properties:11                id:12                  type: integer13                name:14                  type: string15              example: # Sample object16                id: 1017                name: Jessica Smith18      responses:19        "200":20          description: OK
Note that in the code above, example is a child of schema. If schema refers to some object defined in the components section, then you should make example a child of the media type keyword:
1paths:2  /users:3    post:4      summary: Adds a new user5      requestBody:6        content:7          application/json: # Media type8            schema: # Request body contents9              $ref: "#/components/schemas/User" # Reference to an object10            example: # Child of media type because we use $ref above11              # Properties of a referenced object12              id: 1013              name: Jessica Smith14      responses:15        "200":16          description: OK
This is needed because $ref overwrites all the siblings alongside it. If needed, you can use multiple examples:
1paths:2  /users:3    post:4      summary: Adds a new user5      requestBody:6        content:7          application/json: # Media type8            schema: # Request body contents9              $ref: "#/components/schemas/User" # Reference to an object10            examples: # Child of media type11              Jessica: # Example 112                value:13                  id: 1014                  name: Jessica Smith15              Ron: # Example 216                value:17                  id: 1118                  name: Ron Stewart19      responses:20        "200":21          description: OK
Here is an example of the example in response bodies:
1responses:2  "200":3    description: A user object.4    content:5      application/json:6        schema:7          $ref: "#/components/schemas/User" # Reference to an object8        example:9          # Properties of the referenced object10          id: 1011          name: Jessica Smith
Multiple examples in response bodies:
1responses:2  "200":3    description: A user object.4    content:5      application/json:6        schema:7          $ref: "#/components/schemas/User" # Reference to an object8        examples:9          Jessica:10            value:11              id: 1012              name: Jessica Smith13          Ron:14            value:15              id: 2016              name: Ron Stewart
Note: The examples in response and request bodies are free-form, but are expected to be compatible with the body schema.
Object and Property Examples
You can also specify examples for objects and individual properties in the components section.

Property-level example:

1components:2  schemas:3    User: # Schema name4      type: object5      properties:6        id:7          type: integer8          format: int649          example: 1 # Property example10        name:11          type: string12          example: New order # Property example

Object-level example:

1components:2  schemas:3    User: # Schema name4      type: object5      properties:6        id:7          type: integer8        name:9          type: string10      example: # Object-level example11        id: 112        name: Jessica Smith
Note that schemas and properties support single example but not multiple examples.
Array Example
You can add an example of an individual array item:
1components:2  schemas:3    ArrayOfInt:4      type: array5      items:6        type: integer7        format: int648        example: 1
or an array-level example containing multiple items:
1components:2  schemas:3    ArrayOfInt:4      type: array5      items:6        type: integer7        format: int648      example: [1, 2, 3]
If the array contains objects, you can specify a multi-item example as follows:
1components:2  schemas:3    ArrayOfUsers:4      type: array5      items:6        type: object7        properties:8          id:9            type: integer10          name:11            type: string12      example:13        - id: 1014          name: Jessica Smith15        - id: 2016          name: Ron Stewart
Note that arrays and array items support single example but not multiple examples.
Examples for XML and HTML Data
To describe an example value that cannot be presented in JSON or YAML format, specify it as a string:
1content:2  application/xml:3    schema:4      $ref: "#/components/schemas/xml"5    examples:6      xml:7        summary: A sample XML response8        value: "<objects><object><id>1</id><name>new</name></object><object><id>2</id></object></objects>"9  text/html:10    schema:11      type: string12    examples:13      html:14        summary: A list containing two items15        value: "<html><body><ul><li>item 1</li><li>item 2</li></ul></body></html>"
You can find information on writing multiline string in YAML in this Stack Overflow post: https://stackoverflow.com/questions/3790454/in-yaml-how-do-i-break-a-string-over-multiple-lines.
External Examples
If a sample value cannot be inserted into your specification for some reason, for instance, it is neither YAML-, nor JSON-conformant, you can use the externalValue keyword to specify the URL of the example value. The URL should point to the resource that contains the literal example contents (an object, file or image, for example):
1content:2  application/json:3    schema:4      $ref: "#/components/schemas/MyObject"5    examples:6      jsonObject:7        summary: A sample object8        externalValue: "http://example.com/examples/object-example.json"9  application/pdf:10    schema:11      type: string12      format: binary13    examples:14      sampleFile:15        summary: A sample file16        externalValue: "http://example.com/examples/example.pdf"
Reusing Examples
You can define common examples in the components/examples section of your specification and then re-use them in various parameter descriptions, request and response body descriptions, objects and properties:
1    content:2      application/json:3        schema:4          $ref: '#/components/schemas/MyObject'5        examples:6          objectExample:7            $ref: '#/components/examples/objectExample'8    ...9    components:10      examples:11        objectExample:12          value:13            id: 114            name: new object15          summary: A sample object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Supported JSON Schema Keywords       Next  Overview\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAuthentication        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
OpenAPI uses the term security scheme for authentication and authorization schemes. OpenAPI 3.0 lets you describe APIs protected using the following security schemes:

HTTP authentication schemes (they use the Authorization header):

Basic
Bearer
other HTTP schemes as defined by RFC 7235 and HTTP Authentication Scheme Registry


API keys in headers, query string or cookies

Cookie authentication


OAuth 2
OpenID Connect Discovery

Follow the links above for the guides on specific security types, or continue reading to learn how to describe security in general.
Changes from OpenAPI 2.0
If you used OpenAPI 2.0 before, here is a summary of changes to help you get started with OpenAPI 3.0:

securityDefinitions were renamed to securitySchemes and moved inside components.
type: basic was replaced with type: http and scheme: basic.
The new type: http is an umbrella type for all HTTP security schemes, including Basic, Bearer and other, and the scheme keyword indicates the scheme type.
API keys can now be sent in: cookie.
Added support for OpenID Connect Discovery (type: openIdConnect).
OAuth 2 security schemes can now define multiple flows.
OAuth 2 flows were renamed to match the OAuth 2 Specification: accessCode is now authorizationCode, and application is now clientCredentials.

Describing Security
Security is described using the securitySchemes and security keywords. You use securitySchemes to define all security schemes your API supports, then use security to apply specific schemes to the whole API or individual operations.
Step 1. Defining securitySchemes
All security schemes used by the API must be defined in the global components/securitySchemes section. This section contains a list of named security schemes, where each scheme can be of type:

http – for Basic, Bearer and other HTTP authentications schemes
apiKey – for API keys and cookie authentication
oauth2 – for OAuth 2
openIdConnect – for OpenID Connect Discovery

Other required properties for security schemes depend on the type. The following example shows how various security schemes are defined. The BasicAuth, BearerAuth names and others are arbitrary names that will be used to refer to these definitions from other places in the spec.
1components:2  securitySchemes:3    BasicAuth:4      type: http5      scheme: basic6
7    BearerAuth:8      type: http9      scheme: bearer10
11    ApiKeyAuth:12      type: apiKey13      in: header14      name: X-API-Key15
16    OpenID:17      type: openIdConnect18      openIdConnectUrl: https://example.com/.well-known/openid-configuration19
20    OAuth2:21      type: oauth222      flows:23        authorizationCode:24          authorizationUrl: https://example.com/oauth/authorize25          tokenUrl: https://example.com/oauth/token26          scopes:27            read: Grants read access28            write: Grants write access29            admin: Grants access to admin operations
Step 2. Applying security
After you have defined the security schemes in the securitySchemes section, you can apply them to the whole API or individual operations by adding the security section on the root level or operation level, respectively. When used on the root level, security applies the specified security schemes globally to all API operations, unless overridden on the operation level. In the following example, the API calls can be authenticated using either an API key or OAuth 2. The ApiKeyAuth and OAuth2 names refer to the schemes previously defined in securitySchemes.
1security:2  - ApiKeyAuth: []3  - OAuth2:4      - read5      - write6# The syntax is:7# - scheme name:8#     - scope 19#     - scope 2
For each scheme, you specify a list of security scopes required for API calls (see below). Scopes are used only for OAuth 2 and OpenID Connect Discovery; other security schemes use an empty array [] instead. Global security can be overridden in individual operations to use a different authentication type, different OAuth/OpenID scopes, or no authentication at all:
1paths:2  /billing_info:3    get:4      summary: Gets the account billing info5      security:6        - OAuth2: [admin] # Use OAuth with a different scope7      responses:8        "200":9          description: OK10        "401":11          description: Not authenticated12        "403":13          description: Access token does not have the required scope14
15  /ping:16    get:17      summary: Checks if the server is running18      security: [] # No security19      responses:20        "200":21          description: Server is up and running22        default:23          description: Something is wrong
Scopes
OAuth 2 and OpenID Connect use scopes to control permissions to various user resources. For example, the scopes for a pet store may include read_pets, write_pets, read_orders, write_orders, admin. When applying security, the entries corresponding to OAuth 2 and OpenID Connect need to specify a list of scopes required for a specific operation (if security is used on the operation level) or all API calls (if security is used on the root level).
1security:2  - OAuth2:3      - scope14      - scope25  - OpenId:6      - scopeA7      - scopeB8  - BasicAuth: []

In case of OAuth 2, the scopes used in security must be previously defined in securitySchemes.
In case of OpenID Connect Discovery, possible scopes are listed in the discovery endpoint specified by openIdConnectUrl.
Other schemes (Basic, Bearer, API keys and others) do not use scopes, so their security entries specify an empty array [] instead.

Different operations typically require different scopes, such as read vs write vs admin. In this case, you should apply scoped security to specific operations instead of doing it globally.
1# Instead of this:2# security:3#   - OAuth2:4#       - read5#       - write6
7# Do this:8paths:9  /users:10    get:11      summary: Get a list of users12      security:13        - OAuth2: [read]     # <------14      ...15
16    post:17      summary: Add a user18      security:19        - OAuth2: [write]    # <------20      ...
Using Multiple Authentication Types
Some REST APIs support several authentication types. The security section lets you combine the security requirements using logical OR and AND to achieve the desired result. security uses the following logic:
1security: # A OR B2  - A3  - B
1security: # A AND B2  - A3    B
1security: # (A AND B) OR (C AND D)2  - A3    B4  - C5    D
That is, security is an array of hashmaps, where each hashmap contains one or more named security schemes. Items in a hashmap are combined using logical AND, and array items are combined using logical OR. Security schemes combined via OR are alternatives – any one can be used in the given context. Security schemes combined via AND must be used simultaneously in the same request. Here, we can use either Basic authentication or an API key:
1security:2  - basicAuth: []3  - apiKey: []
Here, the API requires a pair of API keys to be included in requests:
1security:2  - apiKey1: []3    apiKey2: []
Here, we can use either OAuth 2 or a pair of API keys:
1security:2  - oauth2: [scope1, scope2]3  - apiKey1: []4    apiKey2: []
Reference
Security Scheme Object
Security Requirement Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Adding Examples       Next  Basic Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nBasic Authentication        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Basic authentication is a simple authentication scheme built into the HTTP protocol. The client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password. For example, to authorize as demo / p@55w0rd the client would send
1Authorization: Basic ZGVtbzpwQDU1dzByZA==
Note: Because base64 is easily decoded, Basic authentication should only be used together with other security mechanisms such as HTTPS/SSL.
Describing Basic Authentication
Using OpenAPI 3.0, you can describe Basic authentication as follows:
1openapi: 3.0.42---3components:4  securitySchemes:5    basicAuth: # <-- arbitrary name for the security scheme6      type: http7      scheme: basic8
9security:10  - basicAuth: [] # <-- use the same name here
The first section, securitySchemes, defines a security scheme named basicAuth (an arbitrary name). This scheme must have type: http and scheme: basic. The security section then applies Basic authentication to the entire API. The square brackets [] denote the security scopes used; the list is empty because Basic authentication does not use scopes. security can be set globally (as in the example above) or on the operation level. The latter is useful if only a subset of operations require Basic authentication:
1paths:2  /something:3    get:4      security:5        - basicAuth: []
Basic authentication can also be combined with other authentication methods as explained in Using Multiple Authentication Types.
401 Response
You can also define the 401 “Unauthorized” response returned for requests with missing or incorrect credentials. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: '#/components/responses/UnauthorizedError'9    post:10      ...11      responses:12        ...13        '401':14          $ref: '#/components/responses/UnauthorizedError'15...16components:17  responses:18    UnauthorizedError:19      description: Authentication information is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about the responses syntax, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Overview       Next  API Keys\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nBearer Authentication        NoteOAS 3 This guide is for OpenAPI 3.0.
Bearer authentication (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens. The name “Bearer authentication” can be understood as “give access to the bearer of this token.” The bearer token is a cryptic string, usually generated by the server in response to a login request. The client must send this token in the Authorization header when making requests to protected resources:
1Authorization: Bearer <token>
The Bearer authentication scheme was originally created as part of OAuth 2.0 in RFC 6750, but is sometimes also used on its own. Similarly to Basic authentication, Bearer authentication should only be used over HTTPS (SSL).
Describing Bearer Authentication
In OpenAPI 3.0, Bearer authentication is a security scheme with type: http and scheme: bearer. You first need to define the security scheme under components/securitySchemes, then use the security keyword to apply this scheme to the desired scope – global (as in the example below) or specific operations:
1openapi: 3.0.42---3# 1) Define the security scheme type (HTTP bearer)4components:5  securitySchemes:6    bearerAuth: # arbitrary name for the security scheme7      type: http8      scheme: bearer9      bearerFormat: JWT # optional, arbitrary value for documentation purposes10
11# 2) Apply the security globally to all operations12security:13  - bearerAuth: [] # use the same name as above
Optional bearerFormat is an arbitrary string that specifies how the bearer token is formatted. Since bearer tokens are usually generated by the server, bearerFormat is used mainly for documentation purposes, as a hint to the clients. In the example above, it is “JWT”, meaning JSON Web Token. The square brackets [] in bearerAuth: [] contain a list of security scopes required for API calls. The list is empty because scopes are only used with OAuth 2 and OpenID Connect. In the example above, Bearer authentication is applied globally to the whole API. If you need to apply it to just a few operations, add security on the operation level instead of doing this globally:
1paths:2  /something:3    get:4      security:5        - bearerAuth: []
Bearer authentication can also be combined with other authentication methods as explained in Using Multiple Authentication Types.
401 Response
You can also define the 401 “Unauthorized” response returned for requests that do not contain a proper bearer token. Since the 401 response will be used by multiple operations, you can define it in the global components/responses section and reference elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        '401':7          $ref: '#/components/responses/UnauthorizedError'8        ...9    post:10      ...11      responses:12        '401':13          $ref: '#/components/responses/UnauthorizedError'14        ...15
16components:17  responses:18    UnauthorizedError:19      description: Access token is missing or invalid
To learn more about responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  API Keys       Next  OAuth 2.0\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nOAuth 2.0        NoteOAS 3 This guide is for OpenAPI 3.0.
OAuth 2.0 is an authorization protocol that gives an API client limited access to user data on a web server. GitHub, Google, and Facebook APIs notably use it. OAuth relies on authentication scenarios called flows, which allow the resource owner (user) to share the protected content from the resource server without sharing their credentials. For that purpose, an OAuth 2.0 server issues access tokens that the client applications can use to access protected resources on behalf of the resource owner. For more information about OAuth 2.0, see oauth.net and RFC 6749.
Flows
The flows (also called grant types) are scenarios an API client performs to get an access token from the authorization server. OAuth 2.0 provides several flows suitable for different types of API clients:

Authorization code – The most common flow, mostly used for server-side and mobile web applications. This flow is similar to how users sign up into a web application using their Facebook or Google account.
Implicit – This flow requires the client to retrieve an access token directly. It is useful in cases when the user’s credentials cannot be stored in the client code because they can be easily accessed by the third party. It is suitable for web, desktop, and mobile applications that do not include any server component.
Resource owner password credentials (or just password) – Requires logging in with a username and password. Since in that case the credentials will be a part of the request, this flow is suitable only for trusted clients (for example, official applications released by the API provider).
Client Credentials – Intended for the server-to-server authentication, this flow describes an approach when the client application acts on its own behalf rather than on behalf of any individual user. In most scenarios, this flow provides the means to allow users specify their credentials in the client application, so it can access the resources under the client’s control.

Describing OAuth 2.0 Using OpenAPI
To describe an API protected using OAuth 2.0, first, add a security scheme with type: oauth2 to the global components/securitySchemes section. Then add the security key to apply security globally or to individual operations:
1# Step 1 - define the security scheme2components:3  securitySchemes:4    oAuthSample:    # <---- arbitrary name5      type: oauth26      description: This API uses OAuth 2 with the implicit grant flow. [More info](https://api.example.com/docs/auth)7      flows:8        implicit:   # <---- OAuth flow(authorizationCode, implicit, password or clientCredentials)9          authorizationUrl: https://api.example.com/oauth2/authorize10          scopes:11            read_pets: read your pets12            write_pets: modify pets in your account13
14# Step 2 - apply security globally...15security:16  - oAuthSample:17    - write_pets18    - read_pets19
20# ... or to individual operations21paths:22  /pets:23    patch:24      summary: Add a new pet25      security:26        - oAuthSample:27          - write_pets28          - read_pets29      ...
The flows keyword specifies one or more named flows supported by this OAuth 2.0 scheme. The flow names are:

authorizationCode – Authorization Code flow (previously called accessCode in OpenAPI 2.0)
implicit – Implicit flow
password – Resource Owner Password flow
clientCredentials – Client Credentials flow (previously called application in OpenAPI 2.0)

The flows object can specify multiple flows, but only one of each type. Each flow contains the following information:

	
		
			Field Name
			Description
			Applies to flows
		
		
			authorizationCode
			implicit
			password
			clientCredentials
		
	
	
		
			authorizationUrl
			The authorization URL to use for this flow. Can be relative to the API server URL.
			+
			+
			-
			-
		
		
			tokenUrl
			The token URL to use for this flow. Can be relative to the API server URL.
			+
			-
			+
			+
		
		
			refreshUrl
			Optional. The URL to be used for obtaining refresh tokens. Can be relative to the API server URL.
			+
			+
			+
			+
		
		
			scopes
			The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.
			+
			+
			+
			+
		
	

About Scopes
With OpenAPI 3.0, a user can grant scoped access to their account, which can vary depending on the operation the client application wants to perform. Each OAuth access token can be tagged with multiple scopes. Scopes are access rights that control whether the credentials a user provides allow to perform the needed call to the resource server. They do not grant any additional permissions to the client except for those it already has. Note: In the authorization code and implicit flows, the requested scopes are listed on the authorization form displayed to the user. To apply the scopes, you need to perform two steps:

Define all supported scopes in your OAuth security definition in the components/securitySchemes section:

1components:2  securitySchemes:3    oAuthSample:4      type: oauth25      flows:6        implicit:7          authorizationUrl: https://api.example.com/oauth2/authorize8          scopes:9            read_pets: read pets in your account10            write_pets: modify pets in your account

List the scopes required by each operation in the security section of that operation:

1paths:2  /pets/{petId}:3    patch:4      summary: Updates a pet in the store5      security:6        - oAuthSample: [write_pets]7      ...
If all API operations require the same scopes, you can add security on the root level of the API definition instead:
1security:2  - oAuthSample: [write_pets]
No Scopes
Scopes are optional, and your API may not use any. In this case, specify an empty object {} in the scopes definition, and an empty list of scopes [] in the security section:
1components:2  securitySchemes:3    oAuthNoScopes:4      type: oauth25      flows:6        implicit:7          authorizationUrl: https://api.example.com/oauth2/authorize8          scopes: {} # <-----9
10security:11  - oAuthNoScopes: [] # <-----
Relative Endpoint URLs
In OpenAPI 3.0, authorizationUrl, tokenUrl and refreshUrl can be specified relative to the API server URL. This is handy if these endpoints are on same server as the rest of the API operations.
1servers:2  - url: https://api.example.com/v23
4components:5  securitySchemes:6    oauth2sample:7      type: oauth28      flows:9        authorizationCode:10          authorizationUrl: /oauth/authorize # <-----11          tokenUrl: /oauth/token # <-----12          scopes: ...
Relative URLs are resolved according to RFC 3986. In the example above, the endpoints will be resolved to:
authorizationUrl: https://api.example.com/oauth/authorize
tokenUrl: https://api.example.com/oauth/token
Security Scheme Examples
Authorization Code Flow
The authorization flow uses authorizationUrl, tokenUrl and optional refreshUrl. Here is an example for Slack API:
1components:2  securitySchemes:3    oAuth2AuthCode:4      type: oauth25      description: For more information, see https://api.slack.com/docs/oauth6      flows:7        authorizationCode:8          authorizationUrl: https://slack.com/oauth/authorize9          tokenUrl: https://slack.com/api/oauth.access10          scopes:11            users:read: Read user information12            users:write: Modify user information13            im:read: Read messages14            im:write: Write messages15            im:history: Access the message archive16            search:read: Search messages, files, and so on17            # etc.
Implicit Flow
implicit flow defines authorizationUrl that is used to obtain the access token from the authorization server. Here is an example:
1components:2  securitySchemes:3    oAuth2Implicit:4      type: oauth25      description: For more information, see https://developers.getbase.com/docs/rest/articles/oauth2/requests6      flows:7        implicit:8          authorizationUrl: https://api.getbase.com/oauth2/authorize9          scopes:10            read: Grant read-only access to all your data except for the account and user info11            write: Grant write-only access to all your data except for the account and user info12            profile: Grant read-only access to the account and user info only
Resource Owner Password Flow
The password flow uses tokenUrl and optional refreshUrl. Here is an example:
1components:2  securitySchemes:3    oAuth2Password:4      type: oauth25      description: See https://developers.getbase.com/docs/rest/articles/oauth2/requests6      flows:7        password:8          tokenUrl: https://api.getbase.com/oauth2/token9          scopes:10            read: Grant read-only access to all your data except for the account and user info11            write: Grant write-only access to all your data except for the account and user info12            profile: Grant read-only access to the account and user info only
Client Credentials Flow
The clientCredentials flow uses tokenUrl and optional refreshUrl. Here is an example for Getty Images API:
1components:2  securitySchemes:3    oAuth2ClientCredentials:4      type: oauth25      description: See http://developers.gettyimages.com/api/docs/v3/oauth2.html6      flows:7        clientCredentials:8          tokenUrl: https://api.gettyimages.com/oauth2/token/9          scopes: {} # Getty Images does not use scopes
Multiple Flows
Below is an example of the OAuth 2.0 security definition that supports multiple flows. The clients can use any of these flows.
1components:2  securitySchemes:3    oAuth2:4      type: oauth25      description: For more information, see https://developers.getbase.com/docs/rest/articles/oauth2/requests6      flows:7        implicit:8          authorizationUrl: https://api.getbase.com/oauth2/authorize9          scopes:10            read: Grant read-only access to all your data except for the account and user info11            write: Grant write-only access to all your data except for the account and user info12            profile: Grant read-only access to the account and user info only13        password:14          tokenUrl: https://api.getbase.com/oauth2/token15          scopes:16            read: Grant read-only access to all your data except for the account and user info17            write: Grant write-only access to all your data except for the account and user info18            profile: Grant read-only access to the account and user info only
Frequently Asked Questions
Should I additionally define authorizationUrl and tokenUrl as API operations?
authorizationUrl is not an API endpoint but a special web page that requires user input. So, it cannot be described using OpenAPI. Still, you can describe tokenUrl if you need it.
Should authorizationUrl and tokenUrl include query string parameters, such as grant_type, client_id and others?
The OpenAPI Specification does not state this, so it is up to you and the tools you use.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Bearer Authentication       Next  OpenID Connect Discovery\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nOpenID Connect Discovery        NoteOAS 3 This guide is for OpenAPI 3.0.
OpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 protocol and supported by some OAuth 2.0 providers, such as Google and Azure Active Directory. It defines a sign-in flow that enables a client application to authenticate a user, and to obtain information (or “claims”) about that user, such as the user name, email, and so on. User identity information is encoded in a secure JSON Web Token (JWT), called ID token. OpenID Connect defines a discovery mechanism, called OpenID Connect Discovery, where an OpenID server publishes its metadata at a well-known URL, typically
https://server.com/.well-known/openid-configuration
This URL returns a JSON listing of the OpenID/OAuth endpoints, supported scopes and claims, public keys used to sign the tokens, and other details. The clients can use this information to construct a request to the OpenID server. The field names and values are defined in the OpenID Connect Discovery Specification. Here is an example of data returned:
1{2  "issuer": "https://example.com/",3  "authorization_endpoint": "https://example.com/authorize",4  "token_endpoint": "https://example.com/token",5  "userinfo_endpoint": "https://example.com/userinfo",6  "jwks_uri": "https://example.com/.well-known/jwks.json",7  "scopes_supported": ["pets_read", "pets_write", "admin"],8  "response_types_supported": ["code", "id_token", "token id_token"],9  "token_endpoint_auth_methods_supported": ["client_secret_basic"],10  ...,11}
Describing OpenID Connect Discovery
OpenAPI 3.0 lets you describe OpenID Connect Discovery as follows:
1openapi: 3.0.42---3# 1) Define the security scheme type and attributes4components:5  securitySchemes:6    openId: # <--- Arbitrary name for the security scheme. Used to refer to it from elsewhere.7      type: openIdConnect8      openIdConnectUrl: https://example.com/.well-known/openid-configuration9
10# 2) Apply security globally to all operations11security:12  - openId: # <--- Use the same name as specified in securitySchemes13      - pets_read14      - pets_write15      - admin
The first section, components/securitySchemes, defines the security scheme type (openIdConnect) and the URL of the discovery endpoint (openIdConnectUrl). Unlike OAuth 2.0, you do not need to list the available scopes in securitySchemes – the clients are supposed to read them from the discovery endpoint instead. The security section then applies the chosen security scheme to your API. The actual scopes required for API calls need to be listed here. These may be a subset of the scopes returned by the discovery endpoint. If different API operations require different scopes, you can apply security on the operation level instead of globally. This way you can list the relevant scopes for each operation:
1paths:2  /pets/{petId}:3    get:4      summary: Get a pet by ID5      security:6        - openId:7          - pets_read8      ...9
10    delete:11      summary: Delete a pet by ID12      security:13        - openId:14          - pets_write15      ...
Relative Discovery URL
openIdConnectUrl can be specified relative to the server URL, like so:
1servers:2  - url: https://api.example.com/v2
1components:2  securitySchemes:3    openId:4      type: openIdConnect5      openIdConnectUrl: /.well-known/openid-configuration
Relative URLs are resolved according to RFC 3986. In the example above, it will be resolved to https://api.example.com/.well-known/openid-configuration.
Swagger UI support
Support for OpenID Connect Discovery was added in Swagger UI v. 3.38.0 and Swagger Editor 3.14.8.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  OAuth 2.0       Next  Cookie Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nCookie Authentication        NoteOAS 3 This guide is for OpenAPI 3.0.
Cookie authentication uses HTTP cookies to authenticate client requests and maintain session information. It works as follows:

The client sends a login request to the server.
On the successful login, the server response includes the Set-Cookie header that contains the cookie name, value, expiry time and some other info. Here is an example that sets the cookie named JSESSIONID:

1Set-Cookie: JSESSIONID=abcde12345; Path=/; HttpOnly

The client needs to send this cookie in the Cookie header in all subsequent requests to the server.

1Cookie: JSESSIONID=abcde12345

On the logout operation, the server sends back the Set-Cookie header that causes the cookie to expire.

Note: Cookie authentication is vulnerable to Cross-Site Request Forgeries (CSRF) attacks, so it should be used together with other security measures, such as CSRF tokens.
Note for Swagger UI and Swagger Editor users: Cookie authentication is currently not supported for “try it out” requests due to browser security restrictions. See this issue for more information. SwaggerHub does not have this limitation.
Describing Cookie Authentication
In OpenAPI 3.0 terms, cookie authentication is an API key that is sent in: cookie. For example, authentication via a cookie named JSESSIONID is defined as follows:
1openapi: 3.0.42---3# 1) Define the cookie name4components:5  securitySchemes:6    cookieAuth: # arbitrary name for the security scheme; will be used in the "security" key later7      type: apiKey8      in: cookie9      name: JSESSIONID # cookie name10
11# 2) Apply cookie auth globally to all operations12security:13  - cookieAuth: []
In this example, cookie authentication is applied globally to the whole API using the security key at the root level of the specification. If cookies are required for just a subset of operations, apply security on the operation level instead of doing it globally:
1paths:2  /users:3    get:4      security:5        - cookieAuth: []6      description: Returns a list of users.7      responses:8        "200":9          description: OK
Cookie authentication can be combined with other authentication methods as explained in Using Multiple Authentication Types.
Describing the Set-Cookie Header
You may also want to document that your login operation returns the cookie in the Set-Cookie header. You can include this information in the description, and also define the Set-Cookie header in the response headers, like so:
1paths:2  /login:3    post:4      summary: Logs in and returns the authentication  cookie5      requestBody:6        required: true7        description: A JSON object containing the login and password.8        content:9          application/json:10            schema:11              $ref: "#/components/schemas/LoginRequest"12      security: [] # no authentication13      responses:14        "200":15          description: >16            Successfully authenticated.17            The session ID is returned in a cookie named `JSESSIONID`. You need to include this cookie in subsequent requests.18          headers:19            Set-Cookie:20              schema:21                type: string22                example: JSESSIONID=abcde12345; Path=/; HttpOnly
Note that the Set-Cookie header and securitySchemes are not connected in any way, and the Set-Header definition is for documentation purposes only.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  OpenID Connect Discovery       Next  Links\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nLinks        NoteOAS 3 This guide is for OpenAPI 3.0.
Links are one of the new features of OpenAPI 3.0. Using links, you can describe how various values returned by one operation can be used as input for other operations. This way, links provide a known relationship and traversal mechanism between the operations. The concept of links is somewhat similar to hypermedia, but OpenAPI links do not require the link information present in the actual responses.
When to Use Links?
Consider the “create user” operation:
1POST /users HTTP/1.12Host: example.com3Content-Type: application/json4
5{6  "name": "Alex",7  "age": 278}9
10which returns the ID of the created user:11
12HTTP/1.1 201 Created13Content-Type: application/json14
15{16  "id": 30517}
This user ID can then be used to read, update or delete the user: GET /users/305, PATCH /users/305 and DELETE /users/305. Using links, you can specify that the id value returned by “create user” can be used as a parameter to “get user”, “update user” and “delete user”. Another example is pagination via cursors, where the response includes a cursor to retrieve the next data set:
1GET /items?limit=1002
3  ⇩4
5{6  "metadata": {7    "previous": null,8    "next": "Q1MjAwNz",9    "count": 1010  },11  ...12}13
14  ⇩15
16GET /items?cursor=Q1MjAwNz&limit=100
However, linking relationships are not necessarily within the same resource, or even the same API specification.
Defining Links
Links are defined in the links section of each response:
1responses:2  "200":3    description: Created4    content: ...5    links: # <----6      ...7  "400":8    description: Bad request9    content: ...10    links: # <----11      ...
To better understand this, let’s look at a complete example. This API defines the “create user” and “get user” operations, and the result of “create user” is used as an input to “get user”.
1openapi: 3.0.42info:3  version: 0.0.04  title: Links example5
6paths:7  /users:8    post:9      summary: Creates a user and returns the user ID10      operationId: createUser11      requestBody:12        required: true13        description: A JSON object that contains the user name and age.14        content:15          application/json:16            schema:17              $ref: "#/components/schemas/User"18      responses:19        "201":20          description: Created21          content:22            application/json:23              schema:24                type: object25                properties:26                  id:27                    type: integer28                    format: int6429                    description: ID of the created user.30          # -----------------------------------------------------31          # Links32          # -----------------------------------------------------33          links:34            GetUserByUserId: # <---- arbitrary name for the link35              operationId: getUser36              # or37              # operationRef: '#/paths/~1users~1{userId}/get'38              parameters:39                userId: "$response.body#/id"40
41              description: >42                The `id` value returned in the response can be used as43                the `userId` parameter in `GET /users/{userId}`.44          # -----------------------------------------------------45
46  /users/{userId}:47    get:48      summary: Gets a user by ID49      operationId: getUser50      parameters:51        - in: path52          name: userId53          required: true54          schema:55            type: integer56            format: int6457      responses:58        "200":59          description: A User object60          content:61            application/json:62              schema:63                $ref: "#/components/schemas/User"64
65components:66  schemas:67    User:68      type: object69      properties:70        id:71          type: integer72          format: int6473          readOnly: true74        name:75          type: string
The links section contains named link definitions, in this example – just one link named GetUserByUserId. The link names can only contain the following characters:
1A..Z a..z 0..9 . _ -
Each link contains the following information:

operationId or operationRef that specifies the target operation. It can be the same operation or a different operation in the current or external API specification. operationId is used for local links only, and operationRef can link to both local and external operations.
parameters and/or requestBody sections that specify the values to pass to the target operation. Runtime expression syntax is used to extract these values from the parent operation.
(Optional) The server that the target operation should use, if it is different from the default servers.
(Optional) A description of this link. CommonMark syntax can be used for rich text representation.

The rest of this page goes into more detail about these keywords.

operationId
If the target operation has operationId specified, the link can point to this ID – as in the image above. This approach can be used for local links only, because the operationId values are resolved in the scope of the current API specification.
operationRef
operationRef can be used when operationId is not available. operationRef is a reference to the target operation using the JSON Reference syntax – same as used by the $ref keyword. References can be local (within the current API specification):
1operationRef: "#/paths/~1users~1{userId}/get"
or external:
1operationRef: 'https://anotherapi.com/openapi.yaml#/paths/~1users~1{userId}/get'2operationRef: './operations/getUser.yaml'
Here, the string #/paths/~1users~1{userId}/get actually means #/paths//users/{userId}/get, but the inner slashes / in the path name need to be escaped as ~1 because they are special characters.
1#/paths/~1users~1{userId}/get2    │       │               │3    │       │               │4paths:     │               │5  /users/{userId}:         │6    get:  ─────────────────┘7      ...
This syntax can be difficult to read, so we recommend using it for external links only. In case of local links, it is easier to assign operationId to all operations and link to these IDs instead.
parameters and requestBody
The most important part of a link is computing the input for the target operation based on the values from the original operation. This is what the parameters and requestBody keywords are for.
1links:2  # GET /users/{userId}3  GetUserByUserId:4    operationId: getUser5    parameters:6      userId: "$response.body#/id"7
8  # POST /users/{userId}/manager with the manager ID in the request body9  SetManagerId:10    operationId: setUserManager11    requestBody: "$response.body#/id"
The syntax is _parameter_name: value_ or requestBody: value. The parameter names and request body are those of the target operation. There is no need to list all the parameters, just those required to follow the link. Similarly, requestBody is only used if the target operation has a body and the link purpose is to define the body contents. If two or more parameters have the same name, prefix the names with the parameter location – path, query, header, or cookie, like so:
1parameters:2  path.id: ...3  query.id: ...
The values for parameters and requestBody can be defined in the following ways:

runtime expressions, such as $response.body#/id, that refer to the values in the request or response of the original operation,
strings containing embedded runtime expressions, such as ID_{$response.body#/id},
hard-coded values – strings, numbers, arrays, and so on, such as mystring or true.

You would typically use constant values if you need to pass a specific combination of evaluated and hard-coded parameters for the target operation.
1paths:2  /date_ranges:3    get:4      summary: Get relative date ranges for the report.5      responses:6        '200':7          description: OK8          content:9            application/json:10              example: [Today, Yesterday, LastWeek, ThisMonth]11          links:12            ReportRelDate:13              operationId: getReport14              # Call "getReport" with the `rdate` parameter and with empty `start_date` and `end_date`15              parameters:16                rdate: '$response.body#/1'17                start_date: ''18                end_date: ''19
20  # GET /report?rdate=...21  # GET /report?start_date=...&end_date=...22  /report:23    get:24      operationId: getReport25      ...
Runtime Expression Syntax
OpenAPI runtime expressions are syntax for extracting various values from an operation’s request and response. Links use runtime expressions to specify the parameter values to be passed to the linked operation. The expressions are called “runtime” because the values are extracted from the actual request and response of the API call and not, say, the example values provided in the API specification. The following table describes the runtime expression syntax. All expressions refer to the current operation where the links are defined.
Expression
Description
$url
The full request URL, including the query string.
$method
Request HTTP method, such as GET or POST.
$request.query._param_name_
The value of the specified query parameter. The parameter must be defined in the operation’s parameters section, otherwise, it cannot be evaluated. Parameter names are case-sensitive.
$request.path._param_name_
The value of the specified path parameter. The parameter must be defined in the operation’s parameters section, otherwise, it cannot be evaluated. Parameter names are case-sensitive.
$request.header._header_name_
The value of the specified request header. This header must be defined in the operation’s parameters section, otherwise, it cannot be evaluated. Header names are case-insensitive.
$request.body
The entire request body.
$request.body_#/foo/bar_
A portion of the request body specified by a JSON Pointer.
$statusCode
HTTP status code of the response. For example, 200 or 404.
$response.header._header_name_
The complete value of the specified response header, as a string. Header names are case-insensitive. The header does not need to be defined in the response’s headers section.
$response.body
The entire response body.
$response.body_#/foo/bar_
A portion of the request body specified by a JSON Pointer.
foo{$request.path.id}bar
Enclose an expression into {} curly braces to embed it into a string.
Notes:

The evaluated expression has the same type as the referenced value, unless noted otherwise.
If a runtime expression cannot be evaluated, no parameter value is passed to the target operation.

Examples
Consider the following request and response:
1GET /users?limit=2&total=true2Host: api.example.com3Accept: application/json
1HTTP/1.1 200 OK2Content-Type: application/json3X-Total-Count: 374
5{6  "prev_offset": 0,7  "next_offset": 2,8  "users": [9    {"id": 1, "name": "Alice"},10    {"id": 2, "name": "Bob"}11  ]12}
Below are some examples of runtime expressions and the values they evaluate to:




























































ExpressionResultComments$urlhttp://api.example.com/users?limit=2&total=true$methodGET$request.query.totaltruetotal must be defined as a query parameter.$statusCode200$response.header.x-total-count37Assuming X-Total-Count is defined as a response header. Header names are case-insensitive.$response.body#/next_offset2$response.body#/users/0{"id": 1, "name": "Alice"}JSON Pointer (the #/... part) uses 0-based indexes to access array elements. There is no wildcard syntax though, so $response.body#/users/*/id is not valid.$response.body#/users/1{"id": 2, "name": "Bob"}$response.body#/users/1/nameBobID_{$response.body#/users/1/id}ID_2
server
By default, the target operation is called against its default servers – either global servers, or operation-specific servers. However, the server can be overridden by the link using the server keyword. server has the same fields as global servers, but it is a single server and not an array.
1servers:2  - url: https://api.example.com3---4links:5  GetUserByUserId:6    operationId: getUser7    parameters:8      userId: "$response.body#/id"9    server:10      url: https://new-api.example.com/v2
Reusing Links
Links can be defined inline (as in the previous examples), or placed in the global components/links section and referenced from an operation’s links section via $ref. This can be useful if multiple operations link to another operation in the same way – referencing helps reduce code duplication. In the following example, both the “create user” and “update user” operations return the user ID in the response body, and this ID is used in the “get user” operation. The source operations reuse the same link definition from components/links.
1paths:2  /users:3    post:4      summary: Create a user5      operationId: createUser6      ...7      responses:8        '201':9          description: Created10          content:11            application/json:12              schema:13                type: object14                properties:15                  id:16                    type: integer17                    format: int6418                    description: ID of the created user.19          links:20            GetUserByUserId:21              $ref: '#/components/links/GetUserByUserId'    # <-------22
23  /user/{userId}:24    patch:25      summary: Update user26      operationId: updateUser27      ...28      responses:29        '200':30          description: The updated user object31          content:32            application/json:33              schema:34                $ref: '#/components/schemas/User'35          links:36            GetUserByUserId:37              $ref: '#/components/links/GetUserByUserId'    # <-------38
39    get:40      summary: Get a user by ID41      operationId: getUser42      ...43
44components:45  links:46    GetUserByUserId:   # <----- The $ref's above point here47      description: >48        The `id` value returned in the response can be used as49        the `userId` parameter in `GET /users/{userId}`.50      operationId: getUser51      parameters:52        userId: '$response.body#/id'
References
Link Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Cookie Authentication       Next  Callbacks\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nCallbacks        NoteOAS 3 This guide is for OpenAPI 3.0.
In OpenAPI 3 specs, you can define callbacks – asynchronous, out-of-band requests that your service will send to some other service in response to certain events. This helps you improve the workflow your API offers to clients. A typical example of a callback is subscription functionality – users subscribe to certain events of your service and receive a notification when this or that event occurs. For example, an e-shop can send a notification to the manager on each purchase. These notifications will be “out-of-band”, that is, they will go through a connection other than the connection through which a visitor works, and they will be asynchronous, as they will be out of the regular request-response flow. In OpenAPI 3, you can define the format of the “subscription” operation as well as the format of callback messages and expected responses to these messages. This description will simplify communication between different servers and will help you standardize the use of webhooks in your API.
Callback Example
Let’s create a callback definition – a simple webhook notification. Suppose, your API provides a POST /subscribe operation that expects a callback URL in the request body:
1POST /subscribe2Host: my.example.com3Content-Type: application/json4
5{6  "callbackUrl": "https://myserver.com/send/callback/here"7}
The API acknowledges the subscription —
1HTTP/1.1 201 Created
— and later sends notifications on certain events:
1POST /send/callback/here2Host: myserver.com3Content-Type: application/json4
5{6  "message": "Something happened"7}
Let’s now define the /subscribe operation:
1openapi: 3.0.42info:3  version: 0.0.04  title: test5
6paths:7  /subscribe:8    post:9      summary: Subscribe to a webhook10      requestBody:11        required: true12        content:13          application/json:14            schema:15              type: object16              properties:17                callbackUrl: # Callback URL18                  type: string19                  format: uri20                  example: https://myserver.com/send/callback/here21              required:22                - callbackUrl23      responses:24        "201":25          description: Webhook created
Now let’s add the callbacks keyword to this operation to define a callback:
1paths:2  /subscribe:3    post:4      summary: Subscribe to a webhook5      requestBody: …6      callbacks: # Callback definition7        myEvent: # Event name8          "{$request.body#/callbackUrl}": # The callback URL,9            # Refers to the passed URL10            post:11              requestBody: # Contents of the callback message12                required: true13                content:14                  application/json:15                    schema:16                      type: object17                      properties:18                        message:19                          type: string20                          example: Some event happened21                      required:22                        - message23              responses: # Expected responses to the callback message24                "200":25                  description: Your server returns this code if it accepts the callback
Let’s walk through this definition line by line:

callbacks are defined inside the related operation - post, put, and so on (not under the path itself). In this example, under the post method of the /subscribe path:

1paths:2  /subscribe:3    post:4      …5      callbacks:6        …
This does not mean that the API will send callbacks only when this operation is working. Your API will send callback requests when the business logic of your service requires. The hierarchy of keywords simply lets you use parameters of the /subscribe operation to configure the callback requests (see below).

Inside callbacks, we define one or more callback messages. In our example, we have one message only. You can find an example with multiple callbacks below. The definition of each callback starts with the event name (_myEvent_ in our example):

1callbacks:2  myEvent: # Event name

Under the event name, we define the URL your service will send callback messages to. In our example, the URL is specified by using the {$request.body#/callbackUrl} expression:

1callbacks:2  myEvent:3    "{$request.body#/callbackUrl}": # The callback URL, refers to the URL passed in the request body
This expression tells that the callback URL will be based on the parameters of the /subscribe operation. We will tell more about these expressions a bit later.

Below the URL, we specify the method of the callback message, and define the message format and the expected responses. These definitions are similar to regular request and response definitions:

1callbacks:2  myEvent:3    "{$request.body#/callbackUrl}":4      post: # Method5        requestBody: # Contents of the callback message6          …7        responses: # Expected responses8          …
Please note that when you define a callback, you define a specification of your API. The actual implementation of the callback functionality is done in the server code.
Use Runtime Expressions to Refer to Request Fields
As you can see, we use the {$request.body#/callbackUrl} expression in our example. It is a runtime expression that sets which data of the POST /subscribe request will be used in callbacks. Runtime means that unlike API endpoints, this URL is not known beforehand and is evaluated at run time based on the data supplied by API clients. This value varies from one client to another. For example, the POST /subscribe request can look as follows:
1POST /subscribe?p1=query-param-value HTTP/1.12Host: my.example.com3Content-Type: application/json4Content-Length: 1875
6{7  "callbackUrl" : "http://my.client.com/callback"8}9
10201 Created11Location: http://my.example.com?id=123
You can use the following expressions to refer to its data:













































ExpressionExampleDescription{$url}/subscribeThe parent operation URL.{$method}POSTThe method of the callback request.{$request.path.eventType}myEventThe event name.{$request.query.param-name}query-param-value (the p1 query parameter)The value of the specified query parameter.{$request.header.header-name}application/json (the Content-Type header)The specified header of the “subscription” request.{$request.body#/field-name}callbackUrlA field in the request body. If the field is an array, use the syntax like {$request.body#/arrayField/2}.{$response.header.header-name}http://my.example.com?id=123 (the Location header)The value of the specified response header (the response to the “subscription” request).
You can combine a runtime expression with static data in callback definitions. For instance, you can define the callback URL in the following way:
1{$request.body#callbackUrl}/data:2– or –3{$request.body#/callbackUrl}/{$request.query.eventType}:
You can use expressions to specify query parameters:
1{$request.body#/callbackUrl}/data?p1={$request.query.eventType}
If the string includes both runtime expressions and static text, you should enclose the runtime expressions in curly braces. If the whole string is a runtime expression, you can skip the curly braces.
Multiple Callbacks
As we have said above, you can use one “subscription” operation to define multiple callbacks:
1/subscribe:2  post:3    requestBody:4      content:5        application/json:6          schema:7            type: object8            properties:9              inProgressUrl:10                type: string11              failedUrl:12                type: string13              successUrl:14                type: string15    responses:16      "200":17        description: OK18    callbacks:19      inProgress:20        "{$request.body#/inProgressUrl}":21          post:22            requestBody:23              $ref: "#/components/requestBodies/callbackMessage1"24            responses:25              "200":26                description: OK27        "{$request.body#/failedUrl}":28          post:29            requestBody:30              $ref: "#/components/requestBodies/callbackMessage2"31            responses:32              "200":33                description: OK34        "{$request.body#/successUrl}":35          post:36            requestBody:37              $ref: "#/components/requestBodies/callbackMessage3"38            responses:39              "200":40                description: OK
Unsubscribing From Callbacks
The way you implement the unsubscription mechanism is up to you. For example, the receiving server can return specific code in response to the callback message to indicate that it is no longer interested in callbacks. In this case, clients can unsubscribe only in response to a callback request. To allow clients to unsubscribe at any time, your API can provide a special “unsubscribe” operation. This is a rather common approach. In this case, your service can generate an ID or token for each subscriber and return this ID or token in a response to the “subscription” request. To unsubscribe, a client can pass this ID to the “unsubscribe” operation to specify the subscriber to be removed. The following example demonstrates how you can define this behavior in your spec:
1paths:2/subscribe:3  description: Add a subscriber4  post:5    parameters:6      - name: callbackUrl7        in: query8        required: true9        schema:10          type: string11          format: uri12      - name: event13        in: query14        required: true15        schema:16          type: string17    responses:18      '201':19        description: Added20        content:21          application/json:22            type: object23            properties:24              subscriberId:25                type: string26                example: AAA-123-BBB-45627    links:  # Link the returned id with the unsubscribe operation28      unsubscribeOp:29        operationId: unsubscribeOperation30            parameters:31              Id: $response.body#/subscriberId32    callbacks:33      myEvent:34        '{$request.query.callbackUrl}?event={$request.query.event}':35          post:36            requestBody:37              content:38                application/json:39                  example:40                    message: Some event41            responses:42              '200':43                description: OK44
45/unsubscribe:46  post:47    operationId: unsubscribeOperation48    parameters:49      - name: Id50        in: query51        required: true52        schema:53          type: string
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Links       Next  Components Section\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nComponents Section        NoteOAS 3 This guide is for OpenAPI 3.0.
Often, multiple API operations have some common parameters or return the same response structure. To avoid code duplication, you can place the common definitions in the global components section and reference them using $ref. In the example below, duplicate definitions of a User object are replaced with a single component and references to that component. Before:
1paths:2  /users/{userId}:3    get:4      summary: Get a user by ID5      parameters: ...6      responses:7        "200":8          description: A single user.9          content:10            application/json:11              schema:12                type: object13                properties:14                  id:15                    type: integer16                  name:17                    type: string18  /users:19    get:20      summary: Get all users21      responses:22        "200":23          description: A list of users.24          content:25            application/json:26              schema:27                type: array28                items:29                  type: object30                  properties:31                    id:32                      type: integer33                    name:34                      type: string
After:
1paths:2  /users/{userId}:3    get:4      summary: Get a user by ID5      parameters: ...6      responses:7        "200":8          description: A single user.9          content:10            application/json:11              schema:12                $ref: "#/components/schemas/User"13  /users:14    get:15      summary: Get all users16      responses:17        "200":18          description: A list of users.19          content:20            application/json:21              schema:22                type: array23                items:24                  $ref: "#/components/schemas/User"25
26components:27  schemas:28    User:29      type: object30      properties:31        id:32          type: integer33        name:34          type: string
Components Structure
components serve as a container for various reusable definitions – schemas (data models), parameters, responses, examples, and others. The definitions in components have no direct effect on the API unless you explicitly reference them from somewhere outside the components. That is, components are not parameters and responses that apply to all operations; they are just pieces of information to be referenced elsewhere. Under components, the definitions are grouped by type – schemas, parameters and so on. The following example lists the available subsections. All subsections are optional.
1components:2  # Reusable schemas (data models)3  schemas: ...4
5  # Reusable path, query, header and cookie parameters6  parameters: ...7
8  # Security scheme definitions (see Authentication)9  securitySchemes: ...10
11  # Reusable request bodies12  requestBodies: ...13
14  # Reusable responses, such as 401 Unauthorized or 400 Bad Request15  responses: ...16
17  # Reusable response headers18  headers: ...19
20  # Reusable examples21  examples: ...22
23  # Reusable links24  links: ...25
26  # Reusable callbacks27  callbacks: ...
Each subsection contains one or more named components (definitions):
1components:2  schemas:3    User:4      type: object5      ...6    Pet:7      type: object8      ...
The component names can consist of the following characters only:
1A..Z a..z 0..9 . _ -
Examples of valid names:
1User2New_User3org.example.User4401-Unauthorized
The component names are used to reference the components via $ref from other parts of the API specification:
1$ref: "#/components/<type>/<name>"
For example:
1$ref: "#/components/schemas/User"
An exception are definitions in securitySchemes which are referenced directly by name (see Authentication).
Components Example
Below is an example of components that contains reusable data schemas, parameters and responses. Other component types (links, examples, and others) are defined similarly.
1components:2  #-------------------------------3  # Reusable schemas (data models)4  #-------------------------------5  schemas:6    User: # Can be referenced as '#/components/schemas/User'7      type: object8      properties:9        id:10          type: integer11          format: int6412        name:13          type: string14
15    Error: # Can be referenced as '#/components/schemas/Error'16      type: object17      properties:18        code:19          type: integer20        message:21          type: string22
23  #-------------------------------24  # Reusable operation parameters25  #-------------------------------26  parameters:27    offsetParam: # Can be referenced via '#/components/parameters/offsetParam'28      name: offset29      in: query30      description: Number of items to skip before returning the results.31      required: false32      schema:33        type: integer34        format: int3235        minimum: 036        default: 037
38    limitParam: # Can be referenced as '#/components/parameters/limitParam'39      name: limit40      in: query41      description: Maximum number of items to return.42      required: false43      schema:44        type: integer45        format: int3246        minimum: 147        maximum: 10048        default: 2049
50  #-------------------------------51  # Reusable responses52  #-------------------------------53  responses:54    404NotFound: # Can be referenced as '#/components/responses/404NotFound'55      description: The specified resource was not found.56
57    ImageResponse: # Can be referenced as '#/components/responses/ImageResponse'58      description: An image.59      content:60        image/*:61          schema:62            type: string63            format: binary64
65    GenericError: # Can be referenced as '#/components/responses/GenericError'66      description: An error occurred.67      content:68        application/json:69          schema:70            $ref: "#/components/schemas/Error"
Externally Defined Components
Individual definitions in components can be specified either inline (as in the previous example) or using a $ref reference to an external definition:
1components:2  schemas:3    Pet:4      $ref: "../models/pet.yaml"5      # Can now use use '#/components/schemas/Pet' instead6    User:7      $ref: "https://api.example.com/v2/openapi.yaml#/components/schemas/User"8      # Can now use '#/components/schemas/User' instead9
10  responses:11    GenericError:12      $ref: "../template-api.yaml#/components/responses/GenericError"13      # Can now use '#/components/responses/GenericError' instead
This way you can define local “aliases” for external definitions that you can use instead of repeating the external file paths in all references. If the location of the referenced file changes, you only need to change it in one place (in components) instead of in all references.
Differences From OpenAPI 2.0
OpenAPI 2.0 had separate sections for reusable components – definitions, parameters, responses and securityDefinitions. In OpenAPI 3.0, they all were moved inside components. Also, definitions were renamed to schemas and securityDefinitions were renamed to securitySchemes (note the different spelling: schem_A_s vs securitySchem_E_s). The references are changed accordingly to reflect the new structure:
1OpenAPI 2.0                    OpenAPI 3.02'#/definitions/User'         → '#/components/schemas/User'3'#/parameters/offsetParam'   → '#/components/parameters/offsetParam'4'#/responses/ErrorResponse'  → '#/components/responses/ErrorResponse'
References
Components Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Callbacks       Next  Using $ref\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nUsing $ref        NoteOAS 3 This guide is for OpenAPI 3.0.
When you document an API, it is common to have some features which you use across several of API resources. In that case, you can create a snippet for such elements in order to use them multiple times when you need it. With OpenAPI 3.0, you can reference a definition hosted on any location. It can be the same server, or another one – for example, GitHub, SwaggerHub, and so on. To reference a definition, use the $ref keyword:
1$ref: "reference to definition"
For example, suppose you have the following schema object, which you want to use inside your response:
JSON Example1"components":2  {3    "schemas":4      {5        "user":6          {7            "properties":8              { "id": { "type": "integer" }, "name": { "type": "string" } },9          },10      },11  }
YAML Example1components:2  schemas:3    User:4      properties:5        id:6          type: integer7        name:8          type: string
To refer that object, you need to add $ref with the corresponding path to your response:
JSON Example1"responses":2  {3    "200":4      {5        "description": "The response",6        "schema": { "$ref": "#/components/schemas/user" },7      },8  }
YAML Example1responses:2  "200":3    description: The response4    schema:5      $ref: "#/components/schemas/User"
The value of $ref uses the JSON Reference notation, and the portion starting with # uses the JSON Pointer notation. This notation lets you specify the target file or a specific part of a file you want to reference. In the previous example, #/components/schemas/User means the resolving starts from the root of the current document, and then finds the values of components, schemas, and User one after another.
$ref Syntax
According to RFC3986, the $ref string value (JSON Reference) should contain a URI, which identifies the location of the JSON value you are referencing to. If the string value does not conform URI syntax rules, it causes an error during the resolving. Any members other than $ref in a JSON Reference object are ignored. Check this list for example values of a JSON reference in specific cases:

Local Reference – $ref: '#/definitions/myElement' # means go to the root of the current document and then find elements definitions and myElement one after one.
Remote Reference – $ref: 'document.json' Uses the whole document located on the same server and in the same location.

The element of the document located in the same folder – $ref: 'document.json#/myElement'
The element of the document located in the parent folder – $ref: '../document.json#/myElement'
The element of the document located in another folder – $ref: '../another-folder/document.json#/myElement'


URL Reference – $ref: 'http://path/to/your/resource' Uses the whole document located on the different server.

The specific element of the document stored on the different server – $ref: 'http://path/to/your/resource.json#/myElement'
The document on the different server, which uses the same protocol (for example, HTTP or HTTPS) – $ref: '//anotherserver.com/files/example.json'



Note: When using local references such as #/components/schemas/User in YAML, enclose the value in quotes: '#/components/schemas/User'. Otherwise it will be treated as a comment.
Escape Characters
/ and ~ are special characters in JSON Pointers, and need to be escaped when used literally (for example, in path names).

















CharacterEscape With~~0/~1
For example, to refer to the path /blogs/{blog_id}/new~posts, you would use:
1$ref: "#/paths/~1blogs~1{blog_id}~1new~0posts"
Considerations
Places Where $ref Can Be Used
A common misconception is that $ref is allowed anywhere in an OpenAPI specification file. Actually $ref is only allowed in places where the OpenAPI 3.0 Specification explicitly states that the value may be a reference. For example, $ref cannot be used in the info section and directly under paths:
1openapi: 3.0.42
3# Incorrect!4info:5  $ref: info.yaml6paths:7  $ref: paths.yaml
However, you can $ref individual paths, like so:
1paths:2  /users:3    $ref: "../resources/users.yaml"4  /users/{userId}:5    $ref: "../resources/users-by-id.yaml"
$ref and Sibling Elements
Any sibling elements of a $ref are ignored. This is because $ref works by replacing itself and everything on its level with the definition it is pointing at. Consider this example:
1components:2  schemas:3    Date:4      type: string5      format: date6
7    DateWithExample:8      $ref: "#/components/schemas/Date"9      description: Date schema extended with a `default` value... Or not?10      default: 2000-01-01
In the second schema, the description and default properties are ignored, so this schema ends up exactly the same as the referenced Date schema.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Components Section       Next  API General Info\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI General Info        NoteOAS 3 This guide is OpenAPI 3.0.
It is considered to be a good practice to include general information about your API into the specification: version number, license notes, contact data, links to documentation, and more. We particularly recommend doing this for publicly available APIs; as this will can increase user confidence in the services, your company provides. To specify the API metadata, you use properties of the top-level info object:
1openapi: 3.0.42info:3  # You application title. Required.4  title: Sample Pet Store App5
6  # API version. You can use semantic versioning like 1.0.0,7  # or an arbitrary string like 0.99-beta. Required.8  version: 1.0.09
10  # API description. Arbitrary text in CommonMark or HTML.11  description: This is a sample server for a pet store.12
13  # Link to the page that describes the terms of service.14  # Must be in the URL format.15  termsOfService: http://example.com/terms/16
17  # Contact information: name, email, URL.18  contact:19    name: API Support20    email: support@example.com21    url: http://example.com/support22
23  # Name of the license and a URL to the license description.24  license:25    name: Apache 2.026    url: http://www.apache.org/licenses/LICENSE-2.0.html27
28# Link to the external documentation (if any).29# Code or documentation generation tools can use description as the text of the link.30externalDocs:31  description: Find out more32  url: http://example.com
The title and version properties are required, others are optional.
Reference
Info Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Using $ref       Next  Grouping Operations With Tags\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nGrouping Operations With Tags        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
You can assign a list of tags to each API operation. Tagged operations may be handled differently by tools and libraries. For example, Swagger UI uses tags to group the displayed operations.
1paths:2  /pet/findByStatus:3    get:4      summary: Finds pets by Status5      tags:6        - pets7      ...8  /pet:9    post:10      summary: Adds a new pet to the store11      tags:12        - pets13      ...14  /store/inventory:15    get:16      summary: Returns pet inventories17      tags:18        - store19      ...

Optionally, you can specify description and externalDocs for each tag by using the global tags section on the root level. The tag names here should match those used in operations.
1tags:2  - name: pets3    description: Everything about your Pets4    externalDocs:5      url: http://docs.my-api.com/pet-operations.htm6  - name: store7    description: Access to Petstore orders8    externalDocs:9      url: http://docs.my-api.com/store-orders.htm
The tag order in the global tags section also controls the default sorting in Swagger UI. Note that it is possible to use a tag in an operation even if it is not defined on the root level.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  API General Info       Next  OpenAPI Extensions\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nOpenAPI Extensions        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Extensions (also referred to as specification extensions or vendor extensions) are custom properties that start with x-, such as x-logo. These are used to add extra information or functionality that the OpenAPI standard doesn’t include by default. For example, many tools including Amazon API Gateway, ReDoc, APIMatic, and Fern use extensions to include details specific to their products.
Adding Extensions
Extensions are supported on the root level of the API spec and in the following places:

info section
paths section, individual paths and operations
operation parameters
responses
tags
security schemes

The extension value can be a primitive, an array, an object or null. If the value is an object or array of objects, the object’s property names do not need to start with x-.
Example
An API that uses Amazon API Gateway custom authorizer might include extensions similar to this:
1components:2  securitySchemes:3    APIGatewayAuthorizer:4      type: apiKey5      name: Authorization6      in: header7      x-amazon-apigateway-authtype: oauth28      x-amazon-apigateway-authorizer:9        type: token10        authorizerUri: arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:account-id:function:function-name/invocations11        authorizerCredentials: arn:aws:iam::account-id:role12        identityValidationExpression: "^x-[a-z]+"13        authorizerResultTtlInSeconds: 60
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Grouping Operations With Tags       Next  What is Swagger\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nWhat is Swagger        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger).
To learn about the latest version, visit OpenAPI 3 pages.
Swagger allows you to describe the structure of your APIs so that machines can read them. The ability of APIs to describe their own structure is the root of all awesomeness in Swagger. Why is it so great? Well, by reading your API’s structure, we can automatically build beautiful and interactive API documentation. We can also automatically generate client libraries for your API in many languages and explore other possibilities like automated testing. Swagger does this by asking your API to return a YAML or JSON that contains a detailed description of your entire API. This file is essentially a resource listing of your API which adheres to OpenAPI Specification. The specification asks you to include information like:

What are all the operations that your API supports?
What are your API’s parameters and what does it return?
Does your API need some authorization?
And even fun things like terms, contact information and license to use the API.

You can write a Swagger spec for your API manually, or have it generated automatically from annotations in your source code. Check swagger.io/open-source-integrations for a list of tools that let you generate Swagger from code.
So, I’ve got a Swagger spec for my API. Now what?
There are a few ways in which Swagger can help drive your API development further:

Design-first users: use Swagger Codegen to generate a server stub for your API. The only thing left is to implement the server logic – and your API is ready to go live!
Use Swagger Codegen to generate client libraries for your API in over 40 languages.
Use Swagger UI to generate interactive API documentation that lets your users try out the API calls directly in the browser.
Use the spec to connect API-related tools to your API. For example, import the spec to SoapUI to create automated tests for your API.
And more! Check out the open-source and commercial tools that integrate with Swagger.
     Edit page        Previous  OpenAPI Extensions       Next  Basic Structure\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nBasic Structure        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
Swagger definitions can be written in JSON or YAML. In this guide, we only use YAML examples, but JSON works equally well. A sample Swagger specification written in YAML looks like:
1swagger: "2.0"2info:3  title: Sample API4  description: API description in Markdown.5  version: 1.0.06
7host: api.example.com8basePath: /v19schemes:10  - https11
12paths:13  /users:14    get:15      summary: Returns a list of users.16      description: Optional extended description in Markdown.17      produces:18        - application/json19      responses:20        200:21          description: OK
Metadata
Every Swagger specification starts with the Swagger version, 2.0 being the latest version. A Swagger version defines the overall structure of an API specification – what you can document and how you document it.
1swagger: "2.0"
Then, you need to specify the API info – title, description (optional), version (API version, not file revision or Swagger version).
1info:2  title: Sample API3  description: API description in Markdown.4  version: 1.0.0
version can be a random string. You can use major.minor.patch (as in semantic versioning), or an arbitrary format like 1.0-beta or 2016.11.15. description can be multiline and supports GitHub Flavored Markdown for rich text representation. info also supports other fields for contact information, license and other details. Reference: Info Object.
Base URL
The base URL for all API calls is defined using schemes, host and basePath:
1host: api.example.com2basePath: /v13schemes:4  - https
All API paths are relative to the base URL. For example, /users actually means https://api.example.com/v1/users. More info: API Host and Base URL.
Consumes, Produces
The consumes and produces sections define the MIME types supported by the API. The root-level definition can be overridden in individual operations.
1consumes:2  - application/json3  - application/xml4produces:5  - application/json6  - application/xml
More info: MIME Types.
Paths
The paths section defines individual endpoints (paths) in your API, and the HTTP methods (operations) supported by these endpoints. For example, GET /users can be described as:
1paths:2  /users:3    get:4      summary: Returns a list of users.5      description: Optional extended description in Markdown.6      produces:7        - application/json8      responses:9        200:10          description: OK
More info: Paths and Operations.
Parameters
Operations can have parameters that can be passed via URL path (/users/{userId}), query string (/users?role=admin), headers (X-CustomHeader: Value) and request body. You can define the parameter types, format, whether they are required or optional, and other details:
1paths:2  /users/{userId}:3    get:4      summary: Returns a user by ID.5      parameters:6        - in: path7          name: userId8          required: true9          type: integer10          minimum: 111          description: Parameter description in Markdown.12      responses:13        200:14          description: OK
More info: Describing Parameters.
Responses
For each operation, you can define possible status codes, such as 200 OK or 404 Not Found, and schema of the response body. Schemas can be defined inline or referenced from an external definition via $ref. You can also provide example responses for different content types.
1paths:2  /users/{userId}:3    get:4      summary: Returns a user by ID.5      parameters:6        - in: path7          name: userId8          required: true9          type: integer10          minimum: 111          description: The ID of the user to return.12      responses:13        200:14          description: A User object.15          schema:16            type: object17            properties:18              id:19                type: integer20                example: 421              name:22                type: string23                example: Arthur Dent24        400:25          description: The specified user ID is invalid (e.g. not a number).26        404:27          description: A user with the specified ID was not found.28        default:29          description: Unexpected error
More info: Describing Responses.
Input and Output Models
The global definitions section lets you define common data structures used in your API. They can be referenced via $refwhenever a schema is required – both for request body and response body. For example, this JSON object:
1{2  "id": 4,3  "name": "Arthur Dent"4}
can be represented as:
1definitions:2  User:3    properties:4      id:5        type: integer6      name:7        type: string8    # Both properties are required9    required:10      - id11      - name
and then referenced in the request body schema and response body schema as follows:
1paths:2  /users/{userId}:3    get:4      summary: Returns a user by ID.5      parameters:6        - in: path7          name: userId8          required: true9          type: integer10      responses:11        200:12          description: OK13          schema:14            $ref: "#/definitions/User"15  /users:16    post:17      summary: Creates a new user.18      parameters:19        - in: body20          name: user21          schema:22            $ref: "#/definitions/User"23      responses:24        200:25          description: OK
Authentication
The securityDefinitions and security keywords are used to describe the authentication methods used in your API.
1securityDefinitions:2  BasicAuth:3    type: basic4
5security:6  - BasicAuth: []
Supported authentication methods are:

Basic authentication
API key (as a header or query parameter)
OAuth 2 common flows (implicit, password, application and access code)

More info: Authentication.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  What is Swagger       Next  API Host and Base Path\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Host and Base Path        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
REST APIs have a base URL to which the endpoint paths are appended. The base URL is defined by schemes, host and basePath on the root level of the API specification.
1host: petstore.swagger.io2basePath: /v23schemes:4    - https
All API paths are relative to this base URL, for example, /users actually means <scheme>://<host>/<basePath>/users.

schemes
schemes are the transfer protocols used by the API. Swagger supports the http, https, and WebSocket schemes – ws and wss. As with any lists in YAML, schemes can be specified using the list syntax:
1schemes:2    - http3    - https
or the array literal syntax:
1schemes: [http, https]
If schemes are not specified, the scheme used to serve the API specification will be used for API calls.
host
host is the domain name or IP address (IPv4) of the host that serves the API. It may include the port number if different from the scheme’s default port (80 for HTTP and 443 for HTTPS). Note that this must be the host only, without http(s):// or sub-paths. Valid hosts:
Terminal window1api.example.com2example.com:8089393.184.216.34493.184.216.34:8089
Incorrect:
Terminal window1http://api.example.com2example.com/api/v1
If host is not specified, it is assumed to be the same host where the API documentation is being served.
basePath
basePath is the URL prefix for all API paths, relative to the host root. It must start with a leading slash /. If basePath is not specified, it defaults to /, that is, all paths start at the host root. Valid base paths:
Terminal window1/v22/api/v23/
Incorrect:
Terminal window1v2
Omitting host and scheme
host and schemes can be omitted for a more dynamic association. In this case, the host and scheme used to serve the API documentation will be used for API calls. For example, if Swagger UI-based documentation is hosted at https://api.example.com/apidocs/index.html, “try it out” API calls will be directed to https://api.example.com.
FAQ
Can I specify multiple hosts, e.g. development, test and production?
Multiple hosts are supported in OpenAPI 3.0. 2.0 supports only one host per API specification (or two if you count HTTP and HTTPS as different hosts). A possible way to target multiple hosts is to omit the host and schemes from your specification and serve it from each host. In this case, each copy of the specification will target the corresponding host.
Do host and basePath support templating? Such as:
Terminal window1https://{customer_id}.saas-app.com/api/v12https://api.saas-app.com/v1/{customer_id}/apis
This is supported in OpenAPI 3.0, but not in 2.0. For a workaround for host templating, see the previous question.
Can I specify different ports for HTTP and HTTPS? Such as:
Terminal window1http://example.com:80802https://example.com:8443
This is supported in OpenAPI 3.0, but not in 2.0. In 2.0, you can omit the host and schemes and serve the specification from both hosts. This way, each copy of the specification will target the host and port used to access that specification.
Reference
host, basePath and schemes fields
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Structure       Next  MIME Types\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nMIME Types        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
An API can accept and return data in different formats, the most common being JSON and XML. You can use the consumes and produces keywords to specify the MIME types understood by your API. The value of consumes and produces is an array of MIME types. Global MIME types can be defined on the root level of an API specification and are inherited by all API operations. Here the API uses JSON and XML:
1consumes:2  - application/json3  - application/xml4produces:5  - application/json6  - application/xml
Note that consumes only affects operations with a request body, such as POST, PUT and PATCH. It is ignored for bodiless operations like GET. When used on the operation level, consumes and produces override (not extend) the global definitions. In the following example, the GET /logo operation redefines the produces array to return an image:
1paths:2  /logo:3    get:4      summary: Returns the logo image5      produces:6        - image/png7        - image/gif8        - image/jpeg9      responses:10        200:11          description: OK12          schema:13            type: file
MIME types listed in consumes and produces should be compliant with RFC 6838. For example, you can use standard MIME types such as:
1application/json2application/xml3application/x-www-form-urlencoded4multipart/form-data5text/plain; charset=utf-86text/html7application/pdf8image/png
as well as vendor-specific MIME types (indicated by vnd.):
1application/vnd.mycompany.myapp.v2+json2application/vnd.ms-excel3application/vnd.openstreetmap.data+xml4application/vnd.github-issue.text+json5application/vnd.github.v3.diff6image/vnd.djvu
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  API Host and Base Path       Next  Paths and Operations\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nPaths and Operations        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
In Swagger terms, paths are endpoints (resources) that your API exposes, such as /users or /reports/summary, and operations are the HTTP methods used to manipulate these paths, such as GET, POST or DELETE.
Paths
API paths and operations are defined in the global paths section of the API specification.
1paths:2  /ping: ...3  /users: ...4  /users/{id}: ...
All paths are relative to basePath (see API Host and Base URL). The full request URL is constructed as scheme://host/basePath/path.
Path Templating
Swagger supports path templating, meaning you can use curly braces {} to mark parts of a URL as path parameters:
1/users/{id}2/organizations/{orgId}/members/{memberId}3/report.{format}
The API client needs to provide appropriate parameter values when making an API call, such as /users/5 or /users/12.
Operations
For each path, you define operations (HTTP methods) that can be used to access that path. Swagger 2.0 supports get, post, put, patch, delete, head, and options. A single path can support multiple operations, for example, GET /users to get a list of users and POST /users to add a new user. Swagger defines a unique operation as a combination of a path and an HTTP method. This means that two GET or two POST methods for the same path are not allowed – even if they have different parameters (parameters have no effect on uniqueness). Minimal example of an operation:
1paths:2  /ping:3    get:4      responses:5        200:6          description: OK
More detailed example with parameters and response schema:
1paths:2  /users/{id}:3    get:4      summary: Gets a user by ID.5      description: >6        A detailed description of the operation.7        GitHub Flavored Markdown can be used for rich text representation,8        such as **bold**, *italic* and [links](https://swagger.io).9      operationId: getUsers10      tags:11        - users12      produces:13        - application/json14        - application/xml15      parameters:16        - name: id17          in: path18          description: User ID19          type: integer20          required: true21      responses:22        200:23          description: OK24          schema:25            $ref: "#/definitions/User"26      externalDocs:27        url: http://api.example.com/docs/user-operations/28        description: Learn more about User operations provided by this API.29definitions:30  User:31    type: object32    properties:33      id:34        type: integer35      name:36        type: string37    required:38      - id39      - name
Operations support some optional elements for documentation purposes:

A short summary and a longer description of what the operation does. description can be multi-line and supports GitHub Flavored Markdown for rich text representation.
tags are used to group operations in Swagger UI.
externalDocs allows referencing an external resource that contains additional documentation.

Operation Parameters
Swagger supports operation parameters passed via path, query string, headers and request body. For details, see Describing Parameters.
operationId
Each operation may specify a unique operationId. Some code generators use this value to name the corresponding methods in code.
1/users:2    get:3      operationId: getUsers4      summary: Gets all users.5      ...6    post:7      operationId: addUser8      summary: Adds a new user.9      ...10  /user/{id}:11    get:12      operationId: getUserById13      summary: Gets a user by user ID.14      ...
Query String in Paths
Query string parameters must not be included in paths. They should be defined as query parameters instead. Incorrect:
1paths:2  /users?role={role}:
Correct:
1paths:2  /users:3    get:4      parameters:5        - in: query6          name: role7          type: string8          enum: [user, poweruser, admin]9          required: false
This also means that it is impossible to have multiple paths that differ only in query string, such as:
1GET /users?firstName=value&lastName=value2GET /users?role=value
This is because Swagger considers a unique operation as a combination of a path and the HTTP method, and additional parameters do not make the operation unique. Instead, you should use unique paths such as:
1GET /users/findByName?firstName=value&lastName=value2GET /users/findByRole?role=value
Marking as Deprecated
You can mark specific operations as deprecated to indicate that they should be transitioned out of usage:
1/pet/findByTags:2  get:3    deprecated: true
Tools may handle deprecated operations in a specific way. For example, Swagger UI displays them with a different style:

Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  MIME Types       Next  Describing Parameters\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDescribing Parameters        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
In Swagger, API operation parameters are defined under the parameters section in the operation definition. Each parameter has name, value type (for primitive value parameters) or schema (for request body), and optional description. Here is an example:
1paths:2  /users/{userId}:3    get:4      summary: Gets a user by ID.5      parameters:6        - in: path7          name: userId8          type: integer9          required: true10          description: Numeric ID of the user to get.
Note that parameters is an array, so, in YAML, each parameter definition must be listed with a dash (-) in front of it.
Parameter Types
Swagger distinguishes between the following parameter types based on the parameter location. The location is determined by the parameter’s in key, for example, in: query or in: path.

query parameters, such as /users?role=admin
path parameters, such as /users/{id}
header parameters, such as X-MyHeader: Value
body parameters that describe the body of POST, PUT and PATCH requests (see Describing Request Body)
form parameters – a variety of body parameters used to describe the payload of requests with Content-Type of application/x-www-form-urlencoded and multipart/form-data (the latter is typically used for file uploads)

Query Parameters
Query parameters are the most common type of parameters. They appear at the end of the request URL after a question mark (?), with different name=value pairs separated by ampersands (&). Query parameters can be required and optional.
Terminal window1GET /pets/findByStatus?status=available2GET /notes?offset=100&limit=50
Use in: query to denote query parameters:
1parameters:2  - in: query3    name: offset4    type: integer5    description: The number of items to skip before starting to collect the result set.6  - in: query7    name: limit8    type: integer9    description: The numbers of items to return.
Query parameters only support primitive types. You can have an array, but the items must be a primitive value type. Objects are not supported.
Note: To describe API keys passed as query parameters, use a security definition instead. See API Keys.
Path Parameters
Path parameters are components of a URL path that can vary. They are typically used to point to a specific resource within a collection, such as a user identified by ID. A URL can have several path parameters, each denoted with curly braces { }.
Terminal window1GET /users/{id}2GET /cars/{carId}/drivers/{driverId}
Each path parameter must be substituted with an actual value when the client makes an API call. In Swagger, a path parameter is defined using in: path and other attributes as necessary. The parameter name must be the same as specified in the path. Also, remember to add required: true, because path parameters are always required. Here is an example for GET /users/{id}:
1paths:2  /users/{id}:3    get:4      parameters:5        - in: path6          name: id   # Note the name is the same as in the path7          required: true8          type: integer9          minimum: 110          description: The user ID.11        responses:12          200:13            description: OK
Path parameters can be multi-valued, such as GET /users/12,34,56. This is achieved by specifying the parameter type as array. See Array and Multi-Value Parameters below.
Header Parameters
An API call may require that custom headers be sent with an HTTP request. Swagger lets you define custom request headers as in: header parameters. For example, suppose, a call to GET /ping requires the X-Request-ID header:
Terminal window1GET /ping HTTP/1.12Host: example.com3X-Request-ID: 77e1c83b-7bb0-437b-bc50-a7a58e5660ac
In Swagger, you would define this operation as follows:
1paths:2  /ping:3    get:4      summary: Checks if the server is alive.5      parameters:6        - in: header7          name: X-Request-ID8          type: string9          required: true
In a similar way, you can define custom response headers.
Note: Swagger specification has special keywords for some headers:

	
		
			Header
			Swagger Keywords
			For more information, see...
		
	
	
		
			Content-Type
			consumes (request content type)
			produces (response content type)
			MIME Types
		
		
			Accept
			produces
			MIME Types
		
		
			Authorization
			securityDefinitions, security
			Authentication
		
	

Form Parameters
Form parameters are used to describe the payload of requests with Content-Type of:

application/x-www-form-urlencoded (used to POST primitive values and arrays of primitive values).
multipart/form-data (used to upload files or a combination of files and primitive data).

That is, the operation’s consumes property must specify one of these content types. Form parameters are defined as in: formData. They can only be primitives (strings, numbers, booleans) or arrays of primitives (meaning you cannot use a $ref as the items value). Also, form parameters cannot coexist with the in: bodyparameter, because formData is a specific way of describing the body. To illustrate form parameters, consider an HTML POST form:
1<form action="http://example.com/survey" method="post">2  <input type="text" name="name" />3  <input type="number" name="fav_number" />4  <input type="submit" />5</form>
This form POSTs data to the form’s endpoint:
Terminal window1POST /survey HTTP/1.12Host: example.com3Content-Type: application/x-www-form-urlencoded4Content-Length: 295
6name=Amy+Smith&fav_number=321
In Swagger, you can describe the endpoint as follows:
1paths:2  /survey:3    post:4      summary: A sample survey.5      consumes:6        - application/x-www-form-urlencoded7      parameters:8        - in: formData9          name: name10          type: string11          description: A person's name.12        - in: formData13          name: fav_number14          type: number15          description: A person's favorite number.16      responses:17        200:18          description: OK
To learn how to define form parameters for file uploads, see File Upload.
Required and Optional Parameters
By default, Swagger treats all request parameters as optional. You can add required: true to mark a parameter as required. Note that path parameters must have required: true, because they are always required.
1parameters:2  - in: path3    name: userId4    type: integer5    required: true # <----------6    description: Numeric ID of the user to get.
Default Parameter Values
You can use the default key to specify the default value for an optional parameter. The default value is the one that the server uses if the client does not supply the parameter value in the request. The value type must be the same as the parameter’s data type. A typical example is paging parameters such as offset and limit:
Terminal window1GET /users2GET /users?offset=30&limit=10
Assuming offset defaults to 0 and limit defaults to 20 and ranges from 0 to 100, you would define these parameters as:
1parameters:2  - in: query3    name: offset4    type: integer5    required: false6    default: 07    minimum: 08    description: The number of items to skip before starting to collect the result set.9  - in: query10    name: limit11    type: integer12    required: false13    default: 2014    minimum: 115    maximum: 10016    description: The numbers of items to return.
Common Mistakes
There are two common mistakes when using the default keyword:

Using default with required parameters or properties, for example, with path parameters. This does not make sense – if a value is required, the client must always send it, and the default value is never used.
Using default to specify a sample value. This is not intended use of default and can lead to unexpected behavior in some Swagger tools. Some elements of the specification support the example or examples keyword for this purpose.

Enum Parameters
The enum keyword allows you to restrict a parameter value to a fixed set of values. The enum values must be of the same type as the parameter type.
1- in: query2  name: status3  type: string4  enum: [available, pending, sold]
More info: Defining an Enum.
Array and Multi-Value Parameters
Path, query, header and form parameters can accept a list of values, for example:
Terminal window1GET /users/12,34,56,782GET /resource?param=value1,value2,value33GET /resource?param=value1&param=value2&param=value34
5POST /resource6param=value1&param=value2
A multi-value parameter must be defined with type: array and the appropriate collectionFormat.
1# color=red,black,white2parameters:3  - in: query4    name: color5    type: array6    collectionFormat: csv7    items:8      type: string
collectionFormat specifies the array format (a single parameter with multiple parameter or multiple parameters with the same name) and the separator for array items.

	
		
			collectionFormat
			Description
			Example
		
	
	
		
			csv (default)
			Comma-separated values.
			foo,bar,baz
		
		
			ssv
			Space-separated values.
			foo bar baz
		
		
			tsv
			Tab-separated values.
			"foo\tbar\tbaz"
		
		
			pipes
			Pipe-separated values.
			foo|bar|baz
		
		
			multi
			Multiple parameter instances rather than multiple values. This is only supported for the in: query and in: formData parameters.
			foo=value&foo=another_value
		
	

Additionally, you can:

use minItems and maxItems to control the size of the array,
enforce uniqueItems,
restrict the array items to a fixed set of enum values.

For example:
1- in: query2  name: color3  required: false4  type: array5  minItems: 16  maxItems: 57  uniqueItems: true8  items:9    type: string10    enum:11      [12        black,13        white,14        gray,15        red,16        pink,17        orange,18        yellow,19        green,20        blue,21        purple,22        brown,23      ]
You can also specify the default array that the server will use if this parameter is omitted:
1- in: query2  name: sort3  required: false4  type: array5  items:6    type: string7  default: ["-modified", "+id"]
Constant Parameters
You can define a constant parameter as a required parameter with only one possible value:
1- required: true2  enum: [value]
The enum property specifies possible values. In this example, only one value can be used, and this will be the only value available in the Swagger UI for the user to choose from.
Note: A constant parameter is not the same as the default parameter value. A constant parameter is always sent by the client, whereas the default value is something that the server uses if the parameter is not sent by the client.
Parameters Without a Value
Query string and form data parameters may only have a name and no value:
Terminal window1GET /foo?metadata2
3POST /something4foo&bar&baz
Use allowEmptyValue to describe such parameters:
1- in: query2  name: metadata3  required: true4  type: boolean5  allowEmptyValue: true # <-----
Common Parameters
Common Parameters for All Methods of a Path
Parameters can be defined under a path itself, in this case, the parameters exist in all operations described under this path. A typical example is the GET/PUT/PATCH/DELETE operations that manipulate the same resource accessed via a path parameter.
1paths:2  /user/{id}:3    parameters:4      - in: path5        name: id6        type: integer7        required: true8        description: The user ID.9
10    get:11      summary: Gets a user by ID.12      ...13    patch:14      summary: Updates an existing user with the specified ID.15      ...16    delete:17      summary: Deletes the user with the specified ID.18      ...
Any extra parameters defined at the operation level are used together with path-level parameters:
1paths:2  /users/{id}:3    parameters:4      - in: path5        name: id6        type: integer7        required: true8        description: The user ID.9
10    # GET/users/{id}?metadata=true11    get:12      summary: Gets a user by ID.13      # Note we only define the query parameter, because the {id} is defined at the path level.14      parameters:15        - in: query16          name: metadata17          type: boolean18          required: false19          description: If true, the endpoint returns only the user metadata.20      responses:21        200:22          description: OK
Specific path-level parameters can be overridden on the operation level, but cannot be removed.
1paths:2  /users/{id}:3    parameters:4      - in: path5        name: id6        type: integer7        required: true8        description: The user ID.9
10    # DELETE /users/{id} - uses a single ID.11    # Reuses the {id} parameter definition from the path level.12    delete:13      summary: Deletes the user with the specified ID.14      responses:15        204:16          description: User was deleted.17
18    # GET /users/id1,id2,id3 - uses one or more user IDs.19    # Overrides the path-level {id} parameter.20    get:21      summary: Gets one or more users by ID.22      parameters:23        - in: path24          name: id25          required: true26          description: A comma-separated list of user IDs.27          type: array28          items:29            type: integer30          collectionFormat: csv31          minItems: 132      responses:33        200:34          description: OK
Common Parameters in Different Paths
Different API paths may have some common parameters, such as pagination parameters. You can define common parameters in the global parameters section and reference them in individual operations via $ref.
1parameters:2  offsetParam: # <-- Arbitrary name for the definition that will be used to refer to it.3    # Not necessarily the same as the parameter name.4    in: query5    name: offset6    required: false7    type: integer8    minimum: 09    description: The number of items to skip before starting to collect the result set.10  limitParam:11    in: query12    name: limit13    required: false14    type: integer15    minimum: 116    maximum: 5017    default: 2018    description: The numbers of items to return.19paths:20  /users:21    get:22      summary: Gets a list of users.23      parameters:24        - $ref: "#/parameters/offsetParam"25        - $ref: "#/parameters/limitParam"26      responses:27        200:28          description: OK29  /teams:30    get:31      summary: Gets a list of teams.32      parameters:33        - $ref: "#/parameters/offsetParam"34        - $ref: "#/parameters/limitParam"35      responses:36        200:37          description: OK
Note that the global parameters are not parameters applied to all operations — they are simply global definitions that can be easily re-used.
Parameter Dependencies
Swagger does not support parameter dependencies and mutually exclusive parameters. There is an open feature request at https://github.com/OAI/OpenAPI-Specification/issues/256. What you can do is document the restrictions in the parameter description and define the logic in the 400 Bad Request response. For example, consider the /report endpoint that accepts either a relative date range (rdate) or an exact range (start_date+ end_date):
Terminal window1GET /report?rdate=Today2GET /report?start_date=2016-11-15&end_date=2016-11-20
You can describe this endpoint as follows:
1paths:2  /report:3    get:4      parameters:5        - name: rdate6          in: query7          type: string8          description: >9            A relative date range for the report, such as `Today` or `LastWeek`.10            For an exact range, use `start_date` and `end_date` instead.11        - name: start_date12          in: query13          type: string14          format: date15          description: >16            The start date for the report. Must be used together with `end_date`.17            This parameter is incompatible with `rdate`.18        - name: end_date19          in: query20          type: string21          format: date22          description: >23            The end date for the report. Must be used together with `start_date`.24            This parameter is incompatible with `rdate`.25      responses:26        400:27          description: Either `rdate` or `start_date`+`end_date` are required.
FAQ
When should I use “type” vs “schema”?
schema is only used with in: body parameters. Any other parameters expect a primitive type, such as type: string, or an array of primitives.
Can I have an object as a query parameter?
This is possible in OpenAPI 3.0, but not in 2.0.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Paths and Operations       Next  Describing Request Body\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDescribing Request Body        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
The POST, PUT and PATCH requests can have the request body (payload), such as JSON or XML data. In Swagger terms, the request body is called a body parameter. There can be only one body parameter, although the operation may have other parameters (path, query, header).
Note: The payload of the application/x-www-form-urlencoded and multipart/form-data requests is described by using form parameters, not body parameters.
The body parameter is defined in the operation’s parameters section and includes the following:

in: body
schema that describes the body data type and structure. The data type is usually an object, but can also be a primitive (such as a string or number) or an array.
Optional description.
The payload name. It is required but ignored (it is used for documentation purposes only).

Object Payload (JSON, etc.)
Many APIs transmit data as an object, such as JSON. schema for an object should specify type: object and properties for that object. For example, the POST /users operation with this JSON body:
1{2  "userName": "Trillian",3  "firstName": "Tricia",4  "lastName": "McMillan"5}
can be described as:
1paths:2  /users:3    post:4      summary: Creates a new user.5      consumes:6        - application/json7      parameters:8        - in: body9          name: user10          description: The user to create.11          schema:12            type: object13            required:14              - userName15            properties:16              userName:17                type: string18              firstName:19                type: string20              lastName:21                type: string22      responses:23        201:24          description: Created
Note: The name of the body parameter is ignored. It is used for documentation purposes only. For a more modular style, you can move the schema definitions to the global definitions section and refer to them by using $ref:
1paths:2  /users:3    post:4      summary: Creates a new user.5      consumes:6        - application/json7      parameters:8        - in: body9          name: user10          description: The user to create.11          schema:12            $ref: "#/definitions/User" # <----------13      responses:14        200:15          description: OK16definitions:17  User: # <----------18    type: object19    required:20      - userName21    properties:22      userName:23        type: string24      firstName:25        type: string26      lastName:27        type: string
Primitive Body
Want to POST/PUT just a single value? No problem, you can define the body schema type as a primitive, such as a string or number. Raw request:
1POST /status HTTP/1.12Host: api.example.com3Content-Type: text/plain4Content-Length: 425
6Time is an illusion. Lunchtime doubly so.
Swagger definition:
1paths:2  /status:3    post:4      summary: Updates the status message.5      consumes:6        - text/plain # <----------7      parameters:8        - in: body9          name: status10          required: true11          schema:12            type: string # <----------13      responses:14        200:15          description: Success!
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Describing Parameters       Next  File Upload\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nFile Upload        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
Swagger 2.0 supports file uploads sent with Content-Type: multipart/form-data. That is, your API server must consume multipart/form-data for this operation:
1consumes:2  - multipart/form-data
The operation payload is defined using formData parameters (not body parameters). The file parameter must have type: file:
1paths:2  /upload:3    post:4      summary: Uploads a file.5      consumes:6        - multipart/form-data7      parameters:8        - in: formData9          name: upfile10          type: file11          description: The file to upload.
This definition corresponds to the following HTTP request:
1POST /upload2Host: example.com3Content-Type: multipart/form-data; boundary=abcde123454Content-Length: 2045
6--abcde123457Content-Disposition: form-data; name="upfile"; filename="example.txt"8Content-Type: text/plain9
10File contents go here.11--abcde12345--
Swagger UI displays file parameters using a file input control, allowing the users to browse for a local file to upload. 
Upload a File + Other Data
File parameters can be sent along with other form data:
1parameters:2  - in: formData3    name: upfile4    type: file5    required: true6    description: The file to upload.7  - in: formData8    name: note9    type: string10    required: false11    description: Description of file contents.
The corresponding HTTP request payload will include multiple parts:
1POST /upload2Host: example.com3Content-Type: multipart/form-data; boundary=abcde123454Content-Length: 3325
6--abcde123457Content-Disposition: form-data; name="upfile"; filename="example.txt"8Content-Type: text/plain9
10File contents go here.11--abcde1234512Content-Disposition: form-data; name="note"13
14Uploading a file named "example.txt"15--abcde12345--
Multiple Upload
You can have several named file parameters, each defined individually:
1parameters:2  - in: formData3    name: upfile14    type: file5    required: true6  - in: formData7    name: upfile28    type: file9    required: false10  - in: formData11    name: upfile312    type: file13    required: false
However, uploading an arbitrary number of files (an array of files) is not supported. There is an open feature request at https://github.com/OAI/OpenAPI-Specification/issues/254. For now, you can use a binary string array as a workaround for uploading an arbitrary number of files:
1type: array2items:3  type: string4  format: binary
Note that this will not produce the file upload interface in Swagger UI.
FAQ
Can I upload files via PUT?
Swagger 2.0 supports file upload requests with Content-Type: multipart/form-data, but does not care about the HTTP method. You can use POST, PUT or any other method, provided that the operation consumes multipart/form-data. Uploads where the payload is just the raw file contents are not supported in Swagger 2.0, because they are not multipart/form-data. That is, Swagger 2.0 does NOT support something like:
1curl --upload-file archive.zip http://example.com/upload
Note also that file uploading in Swagger UI only works for POST requests, because HTML forms in browsers support GET and POST methods only.
Can I define the Content-Type for uploaded files?
This is supported in OpenAPI 3.0, but not in OpenAPI/Swagger 2.0. In 2.0, you can say that an operation accepts a file, but you cannot say that this file is of a specific type or structure.
As a workaround, vendor extensions may be used to extend this functionality, for example:
1- in: formData2  name: zipfile3  type: file4  description: Contents of the ZIP file.5  x-mimetype: application/zip
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Describing Request Body       Next  Describing Responses\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nDescribing Responses        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
An API specification needs to specify the responses for all API operations. Each operation must have at least one response defined, usually a successful response. A response is defined by its HTTP status code and the data returned in the response body and/or headers. Here is a minimal example:
1paths:2  /ping:3    get:4      produces:5        - application/json6      responses:7        200:8          description: OK
Response Media Types
An API can respond with various media types. JSON is the most common format for data exchange, but not the only one possible. To specify the response media types, use the produces keyword on the root level or operation level. The global list can be overridden on the operation level.
1produces:2  - application/json3
4paths:5  # This operation returns JSON - as defined globally above6  /users:7    get:8      summary: Gets a list of users.9      responses:10        200:11          description: OK12  # Here, we override the "produces" array to specify other media types13  /logo:14    get:15      summary: Gets the logo image.16      produces:17        - image/png18        - image/gif19        - image/jpeg20      responses:21        200:22          description: OK
More info: MIME Types.
HTTP Status Codes
Under responses, each response definition starts with a status code, such as 200 or 404. An operation typically returns one successful status code and one or more error statuses. Each response status requires a description. For example, you can describe the conditions for error responses. GitHub Flavored Markdown can be used for rich text representation.
1responses:2  200:3    description: OK4  400:5    description: Bad request. User ID must be an integer and bigger than 0.6  401:7    description: Authorization information is missing or invalid.8  404:9    description: A user with the specified ID was not found.
Note that an API specification does not necessarily need to cover all possible HTTP response codes, since they may not be known in advance. However, it is expected to cover successful responses and any known errors. By “known errors” we mean, for example, a 404 Not Found response for an operation that returns a resource by ID, or a 400 Bad Request response in case of invalid operation parameters.
Response Body
The schema keyword is used to describe the response body. A schema can define:

object or array – typically used with JSON and XML APIs,
a primitive such as a number or string – used for plain text responses,
file (see below).

Schema can be defined inline in the operation:
1responses:2  200:3    description: A User object4    schema:5      type: object6      properties:7        id:8          type: integer9          description: The user ID.10        username:11          type: string12          description: The user name.
or defined at the root level and referenced via $ref. This is useful if multiple responses use the same schema.
1      responses:2        200:3          description: A User object4          schema:5            $ref: '#/definitions/User'6definitions:7  User:8    type: object9    properties:10      id:11        type: integer12        description: The user ID.13      username:14        type: string15        description: The user name.
Response That Returns a File
An API operation can return a file, such as an image or PDF. In this case, define the response schema with type: file and specify the appropriate MIME types in the produces section.
1paths:2  /report:3    get:4      summary: Returns the report in the PDF format.5      produces:6        - application/pdf7      responses:8        200:9          description: A PDF file.10          schema:11            type: file
Empty Response Body
Some responses, such as 204 No Content, have no body. To indicate the response body is empty, do not specify a schema for the response. Swagger treats no schema as a response without a body.
1responses:2  204:3    description: The resource was deleted successfully.
Response Headers
Responses from an API can include custom headers to provide additional information on the result of an API call. For example, a rate-limited API may provide the rate limit status via response headers as follows:
1HTTP 1/1 200 OK2X-RateLimit-Limit: 1003X-RateLimit-Remaining: 994X-RateLimit-Reset: 2016-10-12T11:00:00Z5
6{ ... }
You can define custom headers for each response as follows:
1paths:2  /ping:3    get:4      summary: Checks if the server is alive.5      responses:6        200:7          description: OK8          headers:9            X-RateLimit-Limit:10              type: integer11              description: Request limit per hour.12            X-RateLimit-Remaining:13              type: integer14              description: The number of requests left for the time window.15            X-RateLimit-Reset:16              type: string17              format: date-time18              description: The UTC date/time at which the current rate limit window resets.
Note that, currently, there is no way in Swagger to define common response headers for different response codes or different API operations. You need to define the headers for each response individually.
Default Response
Sometimes, an operation can return multiple errors with different HTTP status codes, but all of them have the same response structure:
1responses:2  200:3    description: Success4    schema:5      $ref: "#/definitions/User"6  400:7    description: Bad request8    schema:9      $ref: "#/definitions/Error" # <-----10  404:11    description: Not found12    schema:13      $ref: "#/definitions/Error" # <-----
You can use the default response to describe these errors collectively, not individually. “Default” means this response is used for all HTTP codes that are not covered individually for this operation.
1responses:2  200:3    description: Success4    schema:5      $ref: "#/definitions/User"6  # Definition of all error statuses7  default:8    description: Unexpected error9    schema:10      $ref: "#/definitions/Error"
Reusing Responses
If multiple operations return the same response (status code and data), you can define it in the global responses section and reference that definition via $ref at the operation level. This is useful for error responses with the same status codes and response body.
1paths:2  /users:3    get:4      summary: Gets a list of users.5      response:6        200:7          description: OK8          schema:9            $ref: "#/definitions/ArrayOfUsers"10        401:11          $ref: "#/responses/Unauthorized" # <-----12  /users/{id}:13    get:14      summary: Gets a user by ID.15      response:16        200:17          description: OK18          schema:19            $ref: "#/definitions/User"20        401:21          $ref: "#/responses/Unauthorized" # <-----22        404:23          $ref: "#/responses/NotFound" # <-----24# Descriptions of common responses25responses:26  NotFound:27    description: The specified resource was not found28    schema:29      $ref: "#/definitions/Error"30  Unauthorized:31    description: Unauthorized32    schema:33      $ref: "#/definitions/Error"34definitions:35  # Schema for error response body36  Error:37    type: object38    properties:39      code:40        type: string41      message:42        type: string43    required:44      - code45      - message
Note that responses defined at the root level are not automatically applied to all operations. These are just definitions that can be referenced and reused by multiple operations.
FAQ
Can I have different responses based on a request parameter? Such as:
1GET /something -> {200, schema_1}2GET /something?foo=bar -> {200, schema_2}
No, this is not supported.
Reference
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#responsesDefinitionsObject
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#responsesObject
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#responseObject
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  File Upload       Next  Overview\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAuthentication        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
Swagger 2.0 lets you define the following authentication types for an API:

Basic authentication
API key (as a header or a query string parameter)
OAuth 2 common flows (authorization code, implicit, resource owner password credentials, client credentials)

Follow the links above for examples specific to these authentication types, or continue reading to learn how to describe authentication in general.
Authentication is described by using the securityDefinitions and security keywords. You use securityDefinitions to define all authentication types supported by the API, then use security to apply specific authentication types to the whole API or individual operations.
The securityDefinitions section is used to define all security schemes (authentication types) supported by the API. It is a name->definition map that maps arbitrary names to the security scheme definitions. Here, the API supports three security schemes named BasicAuth, ApiKeyAuth and OAuth2, and these names will be used to refer to these security schemes from elsewhere:
1securityDefinitions:2  BasicAuth:3    type: basic4  ApiKeyAuth:5    type: apiKey6    in: header7    name: X-API-Key8  OAuth2:9    type: oauth210    flow: accessCode11    authorizationUrl: https://example.com/oauth/authorize12    tokenUrl: https://example.com/oauth/token13    scopes:14      read: Grants read access15      write: Grants write access16      admin: Grants read and write access to administrative information
Each security scheme can be of type:

basic for Basic authentication
apiKey for an API key
oauth2 for OAuth 2

Other required properties depend on the security type. For details, check the Swagger Specification or our examples for Basic auth and API keys.
After you have defined the security schemes in securityDefinitions, you can apply them to the whole API or individual operations by adding the security section on the root level or operation level, respectively. When used on the root level, security applies the specified security schemes globally to all API operations, unless overridden on the operation level.
In the following example, the API calls can be authenticated using either an API key or OAuth 2. The ApiKeyAuth and OAuth2 names refer to the security schemes previously defined in securityDefinitions.
1security:2  - ApiKeyAuth: []3  - OAuth2: [read, write]
Global security can be overridden in individual operations to use a different authentication type, different OAuth 2 scopes, or no authentication at all:
1paths:2/billing_info:3  get:4    summary: Gets the account billing info5    security:6      - OAuth2: [admin]   # Use OAuth with a different scope7    responses:8      200:9        description: OK10      401:11        description: Not authenticated12      403:13        description: Access token does not have the required scope14
15/ping:16  get:17    summary: Checks if the server is running18    security: []   # No security19    responses:20      200:21        description: Server is up and running22      default:23        description: Something is wrong
Using Multiple Authentication Types
Some REST APIs support several authentication types. The security section lets you combine the security requirements using logical OR and AND to achieve the desired result. security uses the following logic:
1security:    # A OR B2  - A3  - B4
5security:    # A AND B6  - A7    B8
9security:    # (A AND B) OR (C AND D)10  - A11    B12  - C13    D
That is, security is an array of hashmaps, where each hashmap contains one or more named security schemes. Items in a hashmap are combined using logical AND, and array items are combined using logical OR. Security schemes combined via OR are alternatives – any one can be used in the given context. Security schemes combined via AND must be used simultaneously in the same request. Here, we can use either Basic authentication or an API key:
1security:2  - basicAuth: []3  - apiKey: []
Here, the API requires a pair of API keys to be included in requests:
1security:2  - apiKey1: []3    apiKey2: []
Here, we can use either OAuth 2 or a pair of API keys:
1security:2  - oauth2: [scope1, scope2]3  - apiKey1: []4    apiKey2: []
FAQ
What does [ ] mean in “securitySchemeName: [ ]”?
[] is a YAML/JSON syntax for an empty array. The Swagger Specification requires that items in the security array specify a list of required scopes, as in:
1security:2  - securityA: [scopeA1, scopeA2]3  - securityB: [scopeB1, scopeB2]
Scopes are only used with OAuth 2, so the Basic and API key security items use an empty array instead.
1security:2  - oauth2: [scope1, scope2]3  - BasicAuth: []4  - ApiKeyAuth: []
Reference
securityDefinitions
security
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Describing Responses       Next  API Keys\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Keys        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
Some APIs use API keys for authorization. An API key is a special token that the client needs to provide when making API calls. The key is usually sent as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a query parameter:
1GET /something?api_key=abcdef12345
API keys are supposed to be a secret that only the client and server know. But, as well as Basic authentication, API key-based authentication is not considered secure unless used together with other security mechanisms such as HTTPS/SSL.
To define API key-based security:

Add an entry with type: apiKey in the global securityDefinitions section. The entry name can be arbitrary (such as APIKeyHeader in the example below) and is used to refer to this security definition from other parts of the spec.
Specify whether the API key will be passed in: header or in: query.
Specify a name for that parameter or header.

1securityDefinitions:2  # X-API-Key: abcdef123453  APIKeyHeader:4    type: apiKey5    in: header6    name: X-API-Key7  # /path?api_key=abcdef123458  APIKeyQueryParam:9    type: apiKey10    in: query11    name: api_key
Then, use the security section on the root level or operation level to apply API keys to the whole API or specific operations.
1# Global security (applies to all operations):2security:3  - APIKeyHeader: []4paths:5  /something:6    get:7      # Operation-specific security:8      security:9        - APIKeyQueryParam: []10      responses:11        200:12          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Pair of API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1securityDefinitions:2  apiKey:3    type: apiKey4    in: header5    name: X-API-KEY6  appId:7    type: apiKey8    in: header9    name: X-APP-ID10security:11  - apiKey: []12    appId: []
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can also define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global responses section and referenced from multiple operations.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        401:8            $ref: '#/responses/UnauthorizedError'9    post:10      ...11      responses:12        ...13        401:14          $ref: '#/responses/UnauthorizedError'15responses:16  UnauthorizedError:17    description: API key is missing or invalid18    headers:19      WWW_Authenticate:20        type: string
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Overview       Next  Basic Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nBasic Authentication        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger).
To learn about the latest version, visit OpenAPI 3 pages.
Basic authentication is a very simple authentication scheme that is built into the HTTP protocol. The client sends HTTP requests with the Authorization header that contains the Basic word followed by a space and a base64-encoded username:password string. For example, a header containing the demo / p@55w0rd credentials would be encoded as:
1Authorization: Basic ZGVtbzpwQDU1dzByZA==
Note: Because base64 is easily decoded, Basic authentication should only be used together with other security mechanisms such as HTTPS/SSL.
Basic authentication is easy to define. In the global securityDefinitions section, add an entry with type: basic and an arbitrary name (in this example - basicAuth). Then, apply security to the whole API or specific operations by using the security section.
1securityDefinitions:2  basicAuth:3    type: basic4
5# To apply Basic auth to the whole API:6security:7  - basicAuth: []8
9paths:10  /something:11    get:12      # To apply Basic auth to an individual operation:13      security:14        - basicAuth: []15      responses:16        200:17          description: OK (successfully authenticated)
401 Response
You can also define the 401 “Unauthorized” response returned for requests with missing or incorrect credentials. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global responses section and referenced from multiple operations.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        401:8            $ref: '#/responses/UnauthorizedError'9    post:10      ...11      responses:12        ...13        401:14          $ref: '#/responses/UnauthorizedError'15responses:16  UnauthorizedError:17    description: Authentication information is missing or invalid18    headers:19      WWW_Authenticate:20        type: string
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  API Keys       Next  Adding Examples\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAdding Examples        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger).
To learn about the latest version, visit OpenAPI 3 pages.
An API specification can include examples for:

response MIME types,
schemas (data models),
individual properties in schemas.

Examples can be used by tools and libraries, for instance, Swagger UI auto-populates request bodies based on input schema examples, and some API mocking tools use examples to generate mock responses.
Note: Do not confuse example values with the default values. An example is used to illustrate what the value is supposed to be like. A default value is something that the server uses if the value is not provided in the request.
Schema Examples
The example key is used to provide a schema example. Examples can be given for individual properties, objects and the whole schema.
Property Examples
Property examples can be specified inline. The example value must conform to the property type.
1definitions:2  CatalogItem:3    type: object4    properties:5      id:6        type: integer7        example: 388      title:9        type: string10        example: T-shirt11    required:12      - id13      - title
Note that multiple example values per property or schema are not supported, that is, you cannot have:
1title:2  type: string3  example: T-shirt4  example: Phone
Object Examples
Properties of a type object can have complex inline examples that include that object’s properties. The example should comply with the object schema.
1definitions:2  CatalogItem:3    type: object4    properties:5      id:6        type: integer7        example: 388      title:9        type: string10        example: T-shirt11      image:12        type: object13        properties:14          url:15            type: string16          width:17            type: integer18          height:19            type: integer20        required:21          - url22        example:   # <-----23          url: images/38.png24          width: 10025          height: 10026    required:27      - id28      - title
Array Examples
An example for an array of primitives:
1definitions:2  ArrayOfStrings:3    type: array4    items:5      type: string6    example:7      - foo8      - bar9      - baz
Similarly, an array of objects would be specified as:
1definitions:2  ArrayOfCatalogItems:3    type: array4    items:5      $ref: '#/definitions/CatalogItem'6    example:7      - id: 388        title: T-shirt9      - id: 11410        title: Phone
Whole Schema Examples
An example can be specified for the entire schema (including all nested schema), provided that the example conforms to the schema.
1definition:2  CatalogItem:3    type: object4    properties:5      id:6        type: integer7      name:8        type: string9      image:10        type: object11        properties:12          url:13            type: string14          width:15            type: integer16          height:17            type: integer18    required:19      - id20      - name21    example:   # <----------22      id: 3823      name: T-shirt24      image:25        url: images/38.png26        width: 10027        height: 100
Response Examples
Swagger allows examples on the response level, each example corresponding to a specific MIME type returned by the operation. Such as one example for application/json, another one for text/csv and so on. Each MIME type must be one of the operation’s produces values — either explicit or inherited from the global scope.
1produces:2  - application/json3  - text/csv4responses:5  200:6    description: OK7    examples:8      application/json: { "id": 38, "title": "T-shirt" }9      text/csv: >10        id,title11        38,T-shirt
All examples are free-form, meaning their interpretation is up to tools and libraries.
JSON and YAML Examples
Since JSON and YAML are interchangeable (YAML is a superset of JSON), both can be specified either using the JSON syntax:
1examples:2  application/json:3    {4      "id": 38,5      "title": "T-shirt"6    }
or the YAML syntax:
1examples:2  application/json:3    id: 384    title: T-shirt5    image:6      url: images/38.png
XML Examples
There is no specific syntax for XML response examples. But, since the response examples are free-form, you can use any format that you wish or that is supported by your tool.
1examples:2  application/xml: '<users><user>Alice</user><user>Bob</user></users>'3
4examples:5  application/xml:6    users:7      user:8        - Alice9        - Bob10
11examples:12  application/xml:13    url: http://myapi.com/examples/users.xml
Alternatively, you can specify the example values in the response schema, as explained above.
Text Examples
Since all response examples are free-form, you can use any format supported by your tool or library. For instance, something like:
1examples:2  text/html: '<html><body><p>Hello, world!</p></body></html>'3  text/plain: Hello, world!
See also this post on Stack Overflow for tips on how to write multi-line strings in YAML.
Example Precedence
If there are multiple examples on different levels (property, schema, response), the higher-level example is used by the tool that is processing the spec. That is, the order of precedence is:

Response example
Schema example
Object and array property examples
Atomic property examples and array item examples

Examples and $ref
OpenAPI 2.0 example and examples keywords require inline examples and do not support $ref. The example values are displayed as is, so $ref would be displayed as an object property named $ref.
Referencing examples is supported in OpenAPI 3.0.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Enums\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nEnums        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
You can use the enum keyword to specify possible values of a request parameter or a model property. For example, the sort parameter in:
1GET /items?sort=[asc|desc]
can be described as:
1paths:2  /items:3    get:4      parameters:5        - in: query6          name: sort7          description: Sort order8          type: string9          enum: [asc, desc]
In YAML, you can also specify one enum value per line:
1enum:2  - asc3  - desc
All values in an enum must adhere to the specified type. If you need to specify descriptions for enum items, you can do this in the description of the parameter or property:
1type: string2enum:3  - asc4  - desc5description: >6  Sort order:7   * asc - Ascending, from A to Z.8   * desc - Descending, from Z to A.
Reusable Enums
Reusable enum definitions are supported in OpenAPI 3.0.
While Swagger 2.0 does not have built-in support for reusable enums, it is possible to define them in YAML using YAML anchors – provided that your tool supports them. Anchors are a handy feature of YAML where you can mark a key with &anchor-name and then further down use *anchor-name to reference that key’s value. This lets you easily duplicate the content across a YAML file.
Note: An anchor (&) must be defined before it is used.
1definitions:2  Colors:3    type: string4    enum: &COLORS5      - black6      - white7      - red8      - green9      - blue10    # OR:11    # enum: &COLORS [black, white, red, green, blue]12
13paths:14  /products:15    get:16      parameters:17        - in: query18          name: color19          required: true20          type: string21          enum: *COLORS22      responses:23        200:24          description: OK
If your tool’s YAML parser supports YAML merge keys (<<), you can use this trick to reference both the type and the enum values.
1definitions:2  Colors: &COLORS3    type: string4    enum: [black, white, red, green, blue]5paths:6  /products:7    get:8      parameters:9        - in: query10          name: color11          required: true12          <<: *COLORS13      responses:14        200:15          description: OK
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Adding Examples       Next  Grouping Operations With Tags\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nGrouping Operations With Tags        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger). To learn about the latest version, visit OpenAPI 3 pages.
You can assign a list of tags to each API operation. Tagged operations may be handled differently by tools and libraries. For example, Swagger UI uses tags to group the displayed operations.
1paths:2  /pet/findByStatus:3    get:4      summary: Finds pets by Status5      tags:6        - pets7      ...8  /pet:9    post:10      summary: Adds a new pet to the store11      tags:12        - pets13      ...14  /store/inventory:15    get:16      summary: Returns pet inventories17      tags:18        - store19      ...
 Optionally, you can specify description and externalDocs for each tag by using the global tags section on the root level. The tag names here should match those used in operations.
1tags:2  - name: pets3    description: Everything about your Pets4    externalDocs:5      url: http://docs.my-api.com/pet-operations.htm6  - name: store7    description: Access to Petstore orders8    externalDocs:9      url: http://docs.my-api.com/store-orders.htm
The tag order in the global tags section also controls the default sorting in Swagger UI. Note that it is possible to use a tag in an operation even if it is not defined on the root level.

Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Enums       Next  Swagger Extensions\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nSwagger Extensions        NoteOAS 2 This page applies to OpenAPI Specification ver. 2 (fka Swagger).
To learn about the latest version, visit OpenAPI 3 pages.
Extensions, or vendor extensions, are custom properties that start with x-, such as x-logo. They can be used to describe extra functionality that is not covered by the standard Swagger specification. Many API-related products that support Swagger make use of extensions to document their own attributes, such as Amazon API Gateway, ReDoc, APIMatic and others. Extensions are supported on the root level of the API spec and in the following places:

info section
paths section, individual paths and operations
operation parameters
responses
tags
security schemes

The extension value can be a primitive, an array, an object or null. If the value is an object or array of objects, the object’s property names do not need to start with x-.
Example
An API that uses Amazon API Gateway custom authorizer would include extensions similar to this:
1securityDefinitions:2  APIGatewayAuthorizer:3    type: apiKey4    name: Authorization5    in: header6    x-amazon-apigateway-authtype: oauth27    x-amazon-apigateway-authorizer:8      type: token9      authorizerUri: arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:account-id:function:function-name/invocations10      authorizerCredentials: arn:aws:iam::account-id:role11      identityValidationExpression: "^x-[a-z]+"12      authorizerResultTtlInSeconds: 60
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Grouping Operations With Tags\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAPI Keys        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Some APIs use API keys for authorization. An API key is a token that a client provides when making API calls. The key can be sent in the query string:
1GET /something?api_key=abcdef12345
or as a request header:
1GET /something HTTP/1.12X-API-Key: abcdef12345
or as a cookie:
1GET /something HTTP/1.12Cookie: X-API-KEY=abcdef12345
API keys are supposed to be a secret that only the client and server know. Like Basic authentication, API key-based authentication is only considered secure if used together with other security mechanisms such as HTTPS/SSL.
Describing API Keys
In OpenAPI 3.0, API keys are described as follows:
1openapi: 3.0.42---3# 1) Define the key name and location4components:5  securitySchemes:6    ApiKeyAuth: # arbitrary name for the security scheme7      type: apiKey8      in: header # can be "header", "query" or "cookie"9      name: X-API-KEY # name of the header, query parameter or cookie10
11# 2) Apply the API key globally to all operations12security:13  - ApiKeyAuth: [] # use the same name as under securitySchemes
This example defines an API key named X-API-Key sent as a request header X-API-Key: <key>. The key name ApiKeyAuth is an arbitrary name for the security scheme (not to be confused with the API key name, which is specified by the name key). The name ApiKeyAuth is used again in the security section to apply this security scheme to the API. Note: The securitySchemes section alone is not enough; you must also use security for the API key to have effect. security can also be set on the operation level instead of globally. This is useful if just a subset of the operations need the API key:
1paths:2  /something:3    get:4      # Operation-specific security:5      security:6        - ApiKeyAuth: []7      responses:8        "200":9          description: OK (successfully authenticated)
Note that it is possible to support multiple authorization types in an API. See Using Multiple Authentication Types.
Multiple API Keys
Some APIs use a pair of security keys, say, API Key and App ID. To specify that the keys are used together (as in logical AND), list them in the same array item in the security array:
1components:2  securitySchemes:3    apiKey:4      type: apiKey5      in: header6      name: X-API-KEY7    appId:8      type: apiKey9      in: header10      name: X-APP-ID11
12security:13  - apiKey: []14    appId: [] # <-- no leading dash (-)
Note the difference from:
1security:2  - apiKey: []3  - appId: []
which means either key can be used (as in logical OR). For more examples, see Using Multiple Authentication Types.
401 Response
You can define the 401 “Unauthorized” response returned for requests with missing or invalid API key. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: "#/components/responses/UnauthorizedError"9    post:10      ...11      responses:12        ...13        '401':14          $ref: "#/components/responses/UnauthorizedError"15
16components:17  responses:18    UnauthorizedError:19      description: API key is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about describing responses, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Basic Authentication       Next  Bearer Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nCookie Authentication        NoteOAS 3 This guide is for OpenAPI 3.0.
Cookie authentication uses HTTP cookies to authenticate client requests and maintain session information. It works as follows:

The client sends a login request to the server.
On the successful login, the server response includes the Set-Cookie header that contains the cookie name, value, expiry time and some other info. Here is an example that sets the cookie named JSESSIONID:

1Set-Cookie: JSESSIONID=abcde12345; Path=/; HttpOnly

The client needs to send this cookie in the Cookie header in all subsequent requests to the server.

1Cookie: JSESSIONID=abcde12345

On the logout operation, the server sends back the Set-Cookie header that causes the cookie to expire.

Note: Cookie authentication is vulnerable to Cross-Site Request Forgeries (CSRF) attacks, so it should be used together with other security measures, such as CSRF tokens.
Note for Swagger UI and Swagger Editor users: Cookie authentication is currently not supported for “try it out” requests due to browser security restrictions. See this issue for more information. SwaggerHub does not have this limitation.
Describing Cookie Authentication
In OpenAPI 3.0 terms, cookie authentication is an API key that is sent in: cookie. For example, authentication via a cookie named JSESSIONID is defined as follows:
1openapi: 3.0.42---3# 1) Define the cookie name4components:5  securitySchemes:6    cookieAuth: # arbitrary name for the security scheme; will be used in the "security" key later7      type: apiKey8      in: cookie9      name: JSESSIONID # cookie name10
11# 2) Apply cookie auth globally to all operations12security:13  - cookieAuth: []
In this example, cookie authentication is applied globally to the whole API using the security key at the root level of the specification. If cookies are required for just a subset of operations, apply security on the operation level instead of doing it globally:
1paths:2  /users:3    get:4      security:5        - cookieAuth: []6      description: Returns a list of users.7      responses:8        "200":9          description: OK
Cookie authentication can be combined with other authentication methods as explained in Using Multiple Authentication Types.
Describing the Set-Cookie Header
You may also want to document that your login operation returns the cookie in the Set-Cookie header. You can include this information in the description, and also define the Set-Cookie header in the response headers, like so:
1paths:2  /login:3    post:4      summary: Logs in and returns the authentication  cookie5      requestBody:6        required: true7        description: A JSON object containing the login and password.8        content:9          application/json:10            schema:11              $ref: "#/components/schemas/LoginRequest"12      security: [] # no authentication13      responses:14        "200":15          description: >16            Successfully authenticated.17            The session ID is returned in a cookie named `JSESSIONID`. You need to include this cookie in subsequent requests.18          headers:19            Set-Cookie:20              schema:21                type: string22                example: JSESSIONID=abcde12345; Path=/; HttpOnly
Note that the Set-Cookie header and securitySchemes are not connected in any way, and the Set-Header definition is for documentation purposes only.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  OpenID Connect Discovery       Next  Links\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nBasic Authentication        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
Basic authentication is a simple authentication scheme built into the HTTP protocol. The client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password. For example, to authorize as demo / p@55w0rd the client would send
1Authorization: Basic ZGVtbzpwQDU1dzByZA==
Note: Because base64 is easily decoded, Basic authentication should only be used together with other security mechanisms such as HTTPS/SSL.
Describing Basic Authentication
Using OpenAPI 3.0, you can describe Basic authentication as follows:
1openapi: 3.0.42---3components:4  securitySchemes:5    basicAuth: # <-- arbitrary name for the security scheme6      type: http7      scheme: basic8
9security:10  - basicAuth: [] # <-- use the same name here
The first section, securitySchemes, defines a security scheme named basicAuth (an arbitrary name). This scheme must have type: http and scheme: basic. The security section then applies Basic authentication to the entire API. The square brackets [] denote the security scopes used; the list is empty because Basic authentication does not use scopes. security can be set globally (as in the example above) or on the operation level. The latter is useful if only a subset of operations require Basic authentication:
1paths:2  /something:3    get:4      security:5        - basicAuth: []
Basic authentication can also be combined with other authentication methods as explained in Using Multiple Authentication Types.
401 Response
You can also define the 401 “Unauthorized” response returned for requests with missing or incorrect credentials. This response includes the WWW-Authenticate header, which you may want to mention. As with other common responses, the 401 response can be defined in the global components/responses section and referenced elsewhere via $ref.
1paths:2  /something:3    get:4      ...5      responses:6        ...7        '401':8            $ref: '#/components/responses/UnauthorizedError'9    post:10      ...11      responses:12        ...13        '401':14          $ref: '#/components/responses/UnauthorizedError'15...16components:17  responses:18    UnauthorizedError:19      description: Authentication information is missing or invalid20      headers:21        WWW_Authenticate:22          schema:23            type: string
To learn more about the responses syntax, see Describing Responses.
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Overview       Next  API Keys\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\nAuthentication        NoteOAS 3 This guide is for OpenAPI 3.0. If you use OpenAPI 2.0, see our OpenAPI 2.0 guide.
OpenAPI uses the term security scheme for authentication and authorization schemes. OpenAPI 3.0 lets you describe APIs protected using the following security schemes:

HTTP authentication schemes (they use the Authorization header):

Basic
Bearer
other HTTP schemes as defined by RFC 7235 and HTTP Authentication Scheme Registry


API keys in headers, query string or cookies

Cookie authentication


OAuth 2
OpenID Connect Discovery

Follow the links above for the guides on specific security types, or continue reading to learn how to describe security in general.
Changes from OpenAPI 2.0
If you used OpenAPI 2.0 before, here is a summary of changes to help you get started with OpenAPI 3.0:

securityDefinitions were renamed to securitySchemes and moved inside components.
type: basic was replaced with type: http and scheme: basic.
The new type: http is an umbrella type for all HTTP security schemes, including Basic, Bearer and other, and the scheme keyword indicates the scheme type.
API keys can now be sent in: cookie.
Added support for OpenID Connect Discovery (type: openIdConnect).
OAuth 2 security schemes can now define multiple flows.
OAuth 2 flows were renamed to match the OAuth 2 Specification: accessCode is now authorizationCode, and application is now clientCredentials.

Describing Security
Security is described using the securitySchemes and security keywords. You use securitySchemes to define all security schemes your API supports, then use security to apply specific schemes to the whole API or individual operations.
Step 1. Defining securitySchemes
All security schemes used by the API must be defined in the global components/securitySchemes section. This section contains a list of named security schemes, where each scheme can be of type:

http – for Basic, Bearer and other HTTP authentications schemes
apiKey – for API keys and cookie authentication
oauth2 – for OAuth 2
openIdConnect – for OpenID Connect Discovery

Other required properties for security schemes depend on the type. The following example shows how various security schemes are defined. The BasicAuth, BearerAuth names and others are arbitrary names that will be used to refer to these definitions from other places in the spec.
1components:2  securitySchemes:3    BasicAuth:4      type: http5      scheme: basic6
7    BearerAuth:8      type: http9      scheme: bearer10
11    ApiKeyAuth:12      type: apiKey13      in: header14      name: X-API-Key15
16    OpenID:17      type: openIdConnect18      openIdConnectUrl: https://example.com/.well-known/openid-configuration19
20    OAuth2:21      type: oauth222      flows:23        authorizationCode:24          authorizationUrl: https://example.com/oauth/authorize25          tokenUrl: https://example.com/oauth/token26          scopes:27            read: Grants read access28            write: Grants write access29            admin: Grants access to admin operations
Step 2. Applying security
After you have defined the security schemes in the securitySchemes section, you can apply them to the whole API or individual operations by adding the security section on the root level or operation level, respectively. When used on the root level, security applies the specified security schemes globally to all API operations, unless overridden on the operation level. In the following example, the API calls can be authenticated using either an API key or OAuth 2. The ApiKeyAuth and OAuth2 names refer to the schemes previously defined in securitySchemes.
1security:2  - ApiKeyAuth: []3  - OAuth2:4      - read5      - write6# The syntax is:7# - scheme name:8#     - scope 19#     - scope 2
For each scheme, you specify a list of security scopes required for API calls (see below). Scopes are used only for OAuth 2 and OpenID Connect Discovery; other security schemes use an empty array [] instead. Global security can be overridden in individual operations to use a different authentication type, different OAuth/OpenID scopes, or no authentication at all:
1paths:2  /billing_info:3    get:4      summary: Gets the account billing info5      security:6        - OAuth2: [admin] # Use OAuth with a different scope7      responses:8        "200":9          description: OK10        "401":11          description: Not authenticated12        "403":13          description: Access token does not have the required scope14
15  /ping:16    get:17      summary: Checks if the server is running18      security: [] # No security19      responses:20        "200":21          description: Server is up and running22        default:23          description: Something is wrong
Scopes
OAuth 2 and OpenID Connect use scopes to control permissions to various user resources. For example, the scopes for a pet store may include read_pets, write_pets, read_orders, write_orders, admin. When applying security, the entries corresponding to OAuth 2 and OpenID Connect need to specify a list of scopes required for a specific operation (if security is used on the operation level) or all API calls (if security is used on the root level).
1security:2  - OAuth2:3      - scope14      - scope25  - OpenId:6      - scopeA7      - scopeB8  - BasicAuth: []

In case of OAuth 2, the scopes used in security must be previously defined in securitySchemes.
In case of OpenID Connect Discovery, possible scopes are listed in the discovery endpoint specified by openIdConnectUrl.
Other schemes (Basic, Bearer, API keys and others) do not use scopes, so their security entries specify an empty array [] instead.

Different operations typically require different scopes, such as read vs write vs admin. In this case, you should apply scoped security to specific operations instead of doing it globally.
1# Instead of this:2# security:3#   - OAuth2:4#       - read5#       - write6
7# Do this:8paths:9  /users:10    get:11      summary: Get a list of users12      security:13        - OAuth2: [read]     # <------14      ...15
16    post:17      summary: Add a user18      security:19        - OAuth2: [write]    # <------20      ...
Using Multiple Authentication Types
Some REST APIs support several authentication types. The security section lets you combine the security requirements using logical OR and AND to achieve the desired result. security uses the following logic:
1security: # A OR B2  - A3  - B
1security: # A AND B2  - A3    B
1security: # (A AND B) OR (C AND D)2  - A3    B4  - C5    D
That is, security is an array of hashmaps, where each hashmap contains one or more named security schemes. Items in a hashmap are combined using logical AND, and array items are combined using logical OR. Security schemes combined via OR are alternatives – any one can be used in the given context. Security schemes combined via AND must be used simultaneously in the same request. Here, we can use either Basic authentication or an API key:
1security:2  - basicAuth: []3  - apiKey: []
Here, the API requires a pair of API keys to be included in requests:
1security:2  - apiKey1: []3    apiKey2: []
Here, we can use either OAuth 2 or a pair of API keys:
1security:2  - oauth2: [scope1, scope2]3  - apiKey1: []4    apiKey2: []
Reference
Security Scheme Object
Security Requirement Object
Did not find what you were looking for? Ask the community
Found a mistake? Let us know     Edit page        Previous  Adding Examples       Next  Basic Authentication\n\nAccelerate API development with
                                    quality and consistency across
                                    OpenAPI and AsyncAPI.
Standardize your APIs with projects,
                                    style checks, and reusable domains.
 Ideal for individuals and small teams to design, build,
                                        and document APIs.\n\n\n\n