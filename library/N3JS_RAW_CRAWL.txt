Lightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\n\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
            ¬†
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
            ¬†
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
            ¬†
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\n\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\n\n\nSign UpUsername *Email addressYour email address will be added to the metadata of packages that you publish, so it may be seen publicly.PasswordShowMinimum of 10 characters and must meet our  password guidelinesI agree to the End User License Agreement and the Privacy Policy. *Create an AccountAlready have an account?Sign In\n\nSign UpUsername *Email addressYour email address will be added to the metadata of packages that you publish, so it may be seen publicly.PasswordShowMinimum of 10 characters and must meet our  password guidelinesI agree to the End User License Agreement and the Privacy Policy. *Create an AccountAlready have an account?Sign In\n\n\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\n\n\nInstallation

npm install --save @types/n3

Summary
This package contains type definitions for n3 (https://github.com/rdfjs/n3.js).
Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/n3.
Additional Details

Last updated: Mon, 24 Mar 2025 10:37:00 GMT
Dependencies: @rdfjs/types, @types/node


Credits
These definitions were written by Fred Eisele, Ruben Taelman, Laurens Rietveld, Joachim Van Herwegen, Alexey Morozov, and Jesse Wright.\n\n@types/n31.24.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published a month ago ReadmeCode Beta2 Dependencies64 Dependents42 VersionsInstallation

npm install --save @types/n3

Summary
This package contains type definitions for n3 (https://github.com/rdfjs/n3.js).
Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/n3.
Additional Details

Last updated: Mon, 24 Mar 2025 10:37:00 GMT
Dependencies: @rdfjs/types, @types/node


Credits
These definitions were written by Fred Eisele, Ruben Taelman, Laurens Rietveld, Joachim Van Herwegen, Alexey Morozov, and Jesse Wright.
ReadmeKeywordsnonePackage SidebarInstallnpm i @types/n3Repositorygithub.com/DefinitelyTyped/DefinitelyTypedHomepagegithub.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/n3Weekly Downloads25,813Version1.24.2LicenseMITUnpacked Size18.1 kBTotal Files5Last publisha month agoCollaboratorsTry on RunKitReport malware\n\n@types/n31.24.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published a month ago ReadmeCode Beta2 Dependencies64 Dependents42 VersionsInstallation

npm install --save @types/n3

Summary
This package contains type definitions for n3 (https://github.com/rdfjs/n3.js).
Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/n3.
Additional Details

Last updated: Mon, 24 Mar 2025 10:37:00 GMT
Dependencies: @rdfjs/types, @types/node


Credits
These definitions were written by Fred Eisele, Ruben Taelman, Laurens Rietveld, Joachim Van Herwegen, Alexey Morozov, and Jesse Wright.
ReadmeKeywordsnonePackage SidebarInstallnpm i @types/n3Repositorygithub.com/DefinitelyTyped/DefinitelyTypedHomepagegithub.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/n3Weekly Downloads25,813Version1.24.2LicenseMITUnpacked Size18.1 kBTotal Files5Last publisha month agoCollaboratorsTry on RunKitReport malware\n\n\n\nLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
ReadmeKeywordsturtlerdfn3streamingasynchronousPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
/n3//n3/Package SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
/n3//n3/Package SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
Dependencies (2)bufferreadable-streamDev Dependencies (18)@babel/cli@babel/core@babel/preset-env@babel/register@rdfjs/data-modelarrayify-streambrowserifydeep-taxonomy-benchmarkdoccoeslinteslint-plugin-importeslint-plugin-jestjestpre-commitrdf-isomorphicrdf-test-suitestreamify-stringuglify-jsPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
Dependencies (2)bufferreadable-streamDev Dependencies (18)@babel/cli@babel/core@babel/preset-env@babel/register@rdfjs/data-modelarrayify-streambrowserifydeep-taxonomy-benchmarkdoccoeslinteslint-plugin-importeslint-plugin-jestjestpre-commitrdf-isomorphicrdf-test-suitestreamify-stringuglify-jsPackage SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
Dependents‚ÄÇ(447)@potherca/inrupt-solid-client@janeirodigital/interop-application@janeirodigital/interop-utils@rmlio/matey@inhauth/solid@treecg/actor-rdf-filter-objects-with-quadstore@p2m2/discoveryshacl-form-reactarche-api@docknetwork/sdk@treecg/actor-init-ldes-client@consolidate/survey-ontology-tsshacl-test-as-object@dexagod/tree-metadata-extraction@dexagod/ldn-agentjson-rql-sparql@solid/identity-token-verifierschemarama@sral/yasrts-dpop@solid/community-server@shaviz-wc/shaviz-transformation@itme/solid-client@inrupt/solid-clientamf-shacl-node@tvachon/lit-pod@solid/lit-podlit-solidrdf2hk@ldf/feature-webid@ldf/feature-qpf@ldf/core@ldf/datasource-hdtontouml-js@techieinme/solid-auth-clirdf-playtripledoc@inrupt/solid-sdk-formstimeseries-clientgatsby-theme-rdfsite@ezs/lodexrdf-test-suite-ldf@dbrnz/flatmap-viewergraphdbrocketrml@rmlio/rmlmapper-java-wrappertestlib10101@shexjs/webapporg-rdf-cslsemantic-dependenciesand more...Package SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\nn31.25.2¬†‚Ä¢¬†Public¬†‚Ä¢¬†Published 8 days ago ReadmeCode Beta2 Dependencies447 Dependents132 VersionsLightning fast, asynchronous, streaming RDF for JavaScript




The N3.js library is an implementation of the RDF.js low-level specification that lets you handle RDF in JavaScript easily.
It offers:


Parsing triples/quads from
Turtle,
TriG,
N-Triples,
N-Quads,
RDF-star
and Notation3 (N3)


Writing triples/quads to
Turtle,
TriG,
N-Triples,
N-Quads
and RDF-star


Storage of triples/quads in memory

Parsing and writing is:

üéõ asynchronous ‚Äì triples arrive as soon as possible
üö∞ streaming ‚Äì streams are parsed as data comes in, so you can parse files larger than memory
‚ö°Ô∏è fast ‚Äì triples are flying out at high speeds

Installation
For Node.js, N3.js comes as an npm package.
$ npm install n3
const N3 = require('n3');
N3.js seamlessly works in browsers via webpack
or browserify.
If you're unfamiliar with these tools,
you can read
webpack: Creating a Bundle ‚Äì getting started
or
Introduction to browserify.
You will need to create a "UMD bundle" and supply a name (e.g. with the -s N3 option in browserify).
You can also load it via CDN:
<script src="https://unpkg.com/n3/browser/n3.min.js"></script>
Creating triples/quads
N3.js follows the RDF.js low-level specification.
N3.DataFactory will give you the factory functions to create triples and quads:
const { DataFactory } = N3;
const { namedNode, literal, defaultGraph, quad } = DataFactory;
const myQuad = quad(
  namedNode('https://ruben.verborgh.org/profile/#me'), // Subject
  namedNode('http://xmlns.com/foaf/0.1/givenName'),    // Predicate
  literal('Ruben', 'en'),                              // Object
  defaultGraph(),                                      // Graph
);
console.log(myQuad.termType);              // Quad
console.log(myQuad.value);                 // ''
console.log(myQuad.subject.value);         // https://ruben.verborgh.org/profile/#me
console.log(myQuad.object.value);          // Ruben
console.log(myQuad.object.datatype.value); // http://www.w3.org/1999/02/22-rdf-syntax-ns#langString
console.log(myQuad.object.language);       // en
In the rest of this document, we will treat ‚Äútriples‚Äù and ‚Äúquads‚Äù equally:
we assume that a¬†quad is simply a¬†triple in a¬†named or default graph.
Parsing
From an RDF document to quads
N3.Parser transforms Turtle, TriG, N-Triples, or N-Quads document into quads through a¬†callback:
const tomAndJerry = `PREFIX c: <http://example.org/cartoons#>
  # Tom is a cat
  c:Tom a c:Cat.
  c:Jerry a c:Mouse;
    c:smarterThan c:Tom.`

const parser = new N3.Parser();

parser.parse(tomAndJerry,
  (error, quad, prefixes) => {
    if (quad)
      console.log(quad);
    else
      console.log("# That's all, folks!", prefixes);
  });
The callback's first argument is an optional error value, the second is a quad.
If there are no more quads,
the callback is invoked one last time with null for quad
and a hash of prefixes as third argument.

Alternatively, an object can be supplied, where onQuad, onPrefix and onComment are used to listen for quads, prefixes and comments as follows:
const parser = new N3.Parser();

parser.parse(tomAndJerry, {
  // onQuad (required) accepts a listener of type (quad: RDF.Quad) => void
  onQuad: (err, quad) => { console.log(quad); },
  // onPrefix (optional) accepts a listener of type (prefix: string, iri: NamedNode) => void
  onPrefix: (prefix, iri) => { console.log(prefix, 'expands to', iri.value); },
  // onComment (optional) accepts a listener of type (comment: string) => void
  onComment: (comment) => { console.log('#', comment); },
});
If no callbacks are provided, parsing happens synchronously returning an array of quads:
const parser = new N3.Parser();

// An array of resultant Quads
const quadArray = parser.parse(tomAndJerry);
By default, N3.Parser parses a¬†permissive superset of Turtle, TriG, N-Triples, and N-Quads.

For strict compatibility with any of those languages, pass a¬†format argument upon creation:
const parser1 = new N3.Parser({ format: 'N-Triples' });
const parser2 = new N3.Parser({ format: 'application/trig' });
Notation3 (N3) is supported only through the format argument:
const parser3 = new N3.Parser({ format: 'N3' });
const parser4 = new N3.Parser({ format: 'Notation3' });
const parser5 = new N3.Parser({ format: 'text/n3' });
It is possible to provide the base IRI of the document that you want to parse.
This is done by passing a baseIRI argument upon creation:
const parser = new N3.Parser({ baseIRI: 'http://example.org/' });
By default, N3.Parser will prefix blank node labels with a b{digit}_ prefix.
This is done to prevent collisions of unrelated blank nodes having identical
labels. The blankNodePrefix constructor argument can be used to modify the
prefix or, if set to an empty string, completely disable prefixing:
const parser = new N3.Parser({ blankNodePrefix: '' });
The parser can output a backwards chaining rule such as _:q <= _:p. in two ways:

as _:p log:implies _:q. (default)
as _:q log:isImpliedBy _:p. (when the isImpliedBy flag is set to true)

const parser = new N3.Parser({ isImpliedBy: true });
From an RDF stream to quads
N3.Parser can parse Node.js streams as they grow,
returning quads as soon as they're ready.
const parser = new N3.Parser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
parser.parse(rdfStream, console.log);
N3.StreamParser is a Node.js stream and RDF.js Sink implementation.
This solution is ideal if your consumer is slower,
since source data is only read when the consumer is ready.
const streamParser = new N3.StreamParser(),
      rdfStream = fs.createReadStream('cartoons.ttl');
rdfStream.pipe(streamParser);
streamParser.pipe(new SlowConsumer());

function SlowConsumer() {
  const writer = new require('stream').Writable({ objectMode: true });
  writer._write = (quad, encoding, done) => {
    console.log(quad);
    setTimeout(done, 1000);
  };
  return writer;
}
A dedicated prefix event signals every prefix with prefix and term arguments.
A dedicated comment event can be enabled by setting comments: true in the N3.StreamParser constructor.
Writing
From quads to a string
N3.Writer serializes quads as an RDF document.
Write quads through addQuad.
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#' } }); // Create a writer which uses `c` as a prefix for the namespace `http://example.org/cartoons#`
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),   // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                  // Object
));
writer.end((error, result) => console.log(result));
By default, N3.Writer writes Turtle (or TriG if some quads are in a named graph).

To write N-Triples (or N-Quads) instead, pass a¬†format argument upon creation:
const writer1 = new N3.Writer({ format: 'N-Triples' });
const writer2 = new N3.Writer({ format: 'application/trig' });
From quads to an RDF stream
N3.Writer can also write quads to a Node.js stream through addQuad.
const writer = new N3.Writer(process.stdout, { end: false, prefixes: { c: 'http://example.org/cartoons#' } });
writer.addQuad(
  namedNode('http://example.org/cartoons#Tom'),                   // Subject
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),   // Predicate
  namedNode('http://example.org/cartoons#Cat')                    // Object
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Tom'),     // Subject
  namedNode('http://example.org/cartoons#name'),  // Predicate
  literal('Tom')                                    // Object
));
writer.end();
From a quad stream to an RDF stream
N3.StreamWriter is a Node.js stream and RDF.js Sink implementation.
const streamParser = new N3.StreamParser(),
      inputStream = fs.createReadStream('cartoons.ttl'),
      streamWriter = new N3.StreamWriter({ prefixes: { c: 'http://example.org/cartoons#' } });
inputStream.pipe(streamParser);
streamParser.pipe(streamWriter);
streamWriter.pipe(process.stdout);
Blank nodes and lists
You might want to use the [‚Ä¶] and list (‚Ä¶) notations of Turtle and TriG.
However, a streaming writer cannot create these automatically:
the shorthand notations are only possible if blank nodes or list heads are not used later on,
which can only be determined conclusively at the end of the stream.
The blank and list functions allow you to create them manually instead:
const writer = new N3.Writer({ prefixes: { c: 'http://example.org/cartoons#',
                                       foaf: 'http://xmlns.com/foaf/0.1/' } });
writer.addQuad(
  writer.blank(
    namedNode('http://xmlns.com/foaf/0.1/givenName'),
    literal('Tom', 'en')),
  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
  namedNode('http://example.org/cartoons#Cat')
);
writer.addQuad(quad(
  namedNode('http://example.org/cartoons#Jerry'),
  namedNode('http://xmlns.com/foaf/0.1/knows'),
  writer.blank([{
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object:    namedNode('http://example.org/cartoons#Cat'),
  },{
    predicate: namedNode('http://xmlns.com/foaf/0.1/givenName'),
    object:    literal('Tom', 'en'),
  }])
));
writer.addQuad(
  namedNode('http://example.org/cartoons#Mammy'),
  namedNode('http://example.org/cartoons#hasPets'),
  writer.list([
    namedNode('http://example.org/cartoons#Tom'),
    namedNode('http://example.org/cartoons#Jerry'),
  ])
);
writer.end((error, result) => console.log(result));
Storing
N3.Store allows you to store triples in memory and find them fast.
In this example, we create a new store and add the triples :Pluto a :Dog. and :Mickey a :Mouse.

Then, we find triples with :Mickey as subject.
const store = new N3.Store();
store.add(
  quad(
    namedNode('http://ex.org/Pluto'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Dog')
  )
);
store.add(
  quad(
    namedNode('http://ex.org/Mickey'),
    namedNode('http://ex.org/type'),
    namedNode('http://ex.org/Mouse')
  )
);

// Retrieve all quads
for (const quad of store)
  console.log(quad);
// Retrieve Mickey's quads
for (const quad of store.match(namedNode('http://ex.org/Mickey'), null, null))
  console.log(quad);
If you are using multiple stores, you can reduce memory consumption by allowing them to share an entity index:
const entityIndex = new N3.EntityIndex();
const store1 = new N3.Store([], { entityIndex });
const store2 = new N3.Store([], { entityIndex });
Dataset Interface
This store adheres to the Dataset interface which exposes the following properties
Attributes:


size ‚Äî A non-negative integer that specifies the number of quads in the set.

Methods:


add ‚Äî Adds the specified quad to the dataset. Existing quads, as defined in Quad.equals, will be ignored.

delete ‚Äî Removes the specified quad from the dataset.

has ‚Äî Determines whether a dataset includes a certain quad.

match ‚Äî Returns a new dataset that is comprised of all quads in the current instance matching the given arguments.

[Symbol.iterator] ‚Äî Implements the iterator protocol to allow iteration over all quads in the dataset as in the example above.

Addition and deletion of quads
The store implements the following manipulation methods in addition to the standard Dataset Interface
(documentation):


addQuad to insert one quad

addQuads to insert an array of quads

removeQuad to remove one quad

removeQuads to remove an array of quads

remove to remove a stream of quads

removeMatches to remove all quads matching the given pattern

deleteGraph to remove all quads with the given graph

createBlankNode returns an unused blank node identifier

Searching quads or entities
The store provides the following search methods
(documentation):


match returns a stream and generator of quads matching the given pattern

getQuads returns an array of quads matching the given pattern

countQuads counts the number of quads matching the given pattern

forEach executes a callback on all matching quads

every returns whether a callback on matching quads always returns true

some  returns whether a callback on matching quads returns true at least once

getSubjects returns an array of unique subjects occurring in matching quads

forSubjects executes a callback on unique subjects occurring in matching quads

getPredicates returns an array of unique predicates occurring in matching quad

forPredicates executes a callback on unique predicates occurring in matching quads

getObjects returns an array of unique objects occurring in matching quad

forObjects executes a callback on unique objects occurring in matching quads

getGraphs returns an array of unique graphs occurring in matching quad

forGraphs executes a callback on unique graphs occurring in matching quads

Reasoning
N3.js supports reasoning as follows:
import { Reasoner, Store, Parser } from 'n3';

const parser = new Parser({ format: 'text/n3' });
const rules = `
{
  ?s a ?o .
  ?o <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?o2 .
} => {
  ?s a ?o2 .
} .
`

const rulesDataset = new Store(parser.parse(rules));
const dataset = new Store(/* Dataset */)

// Applies the rules to the store; mutating it
const reasoner = new Reasoner(store);
reasoner.reason(rules);
Note: N3.js currently only supports rules with Basic Graph Patterns in the premise and conclusion. Built-ins and backward-chaining are not supported. For an RDF/JS reasoner that supports all Notation3 reasoning features, see eye-js.
Compatibility
Format specifications
The N3.js parser and writer is fully compatible with the following W3C specifications:


RDF¬†1.1 Turtle
‚Äì EARL report


RDF¬†1.1 TriG
‚Äì EARL report


RDF¬†1.1 N-Triples
‚Äì EARL report


RDF¬†1.1 N-Quads
‚Äì EARL report


In addition, the N3.js parser also supports Notation3 (N3) (no official specification yet).
The N3.js parser and writer are also fully compatible with the RDF-star variants
of the W3C specifications.
The default mode is permissive
and allows a mixture of different syntaxes, including RDF-star.
Pass a¬†format option to the constructor with the name or MIME type of a¬†format
for strict, fault-intolerant behavior.
If a format string contains star or *
(e.g., turtlestar or TriG*),
RDF-star support for that format will be enabled.
Interface specifications
The N3.js submodules are compatible with the following RDF.js interfaces:


N3.DataFactory implements
DataFactory

the terms it creates implement Term
and one of
NamedNode,
BlankNode,
Literal,
Variable,
DefaultGraph

the triples/quads it creates implement
Term,
Triple
and
Quad




N3.StreamParser implements
Stream
and
Sink


N3.StreamWriter implements
Stream
and
Sink


N3.Store implements
Store
Source
Sink
DatasetCore


License and contributions
The N3.js library is copyrighted by Ruben Verborgh
and released under the MIT License.
Contributions are welcome, and bug reports or pull requests are always helpful.
If you plan to implement a¬†larger feature, it's best to contact me first.
Dependents‚ÄÇ(447)@potherca/inrupt-solid-client@janeirodigital/interop-application@janeirodigital/interop-utils@rmlio/matey@inhauth/solid@treecg/actor-rdf-filter-objects-with-quadstore@p2m2/discoveryshacl-form-reactarche-api@docknetwork/sdk@treecg/actor-init-ldes-client@consolidate/survey-ontology-tsshacl-test-as-object@dexagod/tree-metadata-extraction@dexagod/ldn-agentjson-rql-sparql@solid/identity-token-verifierschemarama@sral/yasrts-dpop@solid/community-server@shaviz-wc/shaviz-transformation@itme/solid-client@inrupt/solid-clientamf-shacl-node@tvachon/lit-pod@solid/lit-podlit-solidrdf2hk@ldf/feature-webid@ldf/feature-qpf@ldf/core@ldf/datasource-hdtontouml-js@techieinme/solid-auth-clirdf-playtripledoc@inrupt/solid-sdk-formstimeseries-clientgatsby-theme-rdfsite@ezs/lodexrdf-test-suite-ldf@dbrnz/flatmap-viewergraphdbrocketrml@rmlio/rmlmapper-java-wrappertestlib10101@shexjs/webapporg-rdf-cslsemantic-dependenciesand more...Package SidebarInstallnpm i n3Repositorygithub.com/rdfjs/N3.jsHomepagegithub.com/rdfjs/N3.js#readmeWeekly Downloads71,133Version1.25.2LicenseMITUnpacked Size610 kBTotal Files33Last publish8 days agoCollaboratorsTry on RunKitReport malware\n\n\n\nSearch results161 packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedn3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.turtlerdfn3streamingasynchronousjeswr‚Ä¢ 1.25.2 ‚Ä¢ 8 days ago ‚Ä¢  447 dependents ‚Ä¢  MITpublished version 1.25.2, 8 days ago447 dependents licensed under $MIT278,285@rdfjs/parser-n3N3 parser that implements the RDF/JS Sink interfacerdfrdfjsparsern3ntriplesturtlebergos‚Ä¢ 2.1.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  MITpublished version 2.1.0, a month ago28 dependents licensed under $MIT128,177@inrupt/solid-clientMake your web apps work with Solid Pods.rdfsolidlinked dataturtleinrupt_ci‚Ä¢ 2.1.2 ‚Ä¢ 6 months ago ‚Ä¢  49 dependents ‚Ä¢  MITpublished version 2.1.2, 6 months ago49 dependents licensed under $MIT44,810@frogcat/ttl2jsonldTurtle to JSON-LD converter for node.js and browser, no library dependenciesrdfturtlejson-ldjavascriptfrogcat‚Ä¢ 0.0.10 ‚Ä¢ 3 months ago ‚Ä¢  6 dependents ‚Ä¢  MITpublished version 0.0.10, 3 months ago6 dependents licensed under $MIT17,810@graphy/content.ttl.writeRDF Turtle content writer for dynamic and stylized outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  7 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago7 dependents licensed under $ISC14,165@graphy/core.iso.streamProvides isomorphic stream interface for node.js / browser and adds `.until`, a promisified version of the `.on` event listenerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  8 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago8 dependents licensed under $ISC14,726rdfliban RDF library for node.js. Suitable for client and server side.linkeddatalinked datardfrdfaturtlesemanticwebread-write webtimbl‚Ä¢ 2.2.37 ‚Ä¢ 2 months ago ‚Ä¢  105 dependents ‚Ä¢  MITpublished version 2.2.37, 2 months ago105 dependents licensed under $MIT20,496@graphy/core.class.writableSerialize RDF conveniently and with stylerdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  10 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago10 dependents licensed under $ISC14,255@graphy/core.class.scribableSerialize RDF fastrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  2 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago2 dependents licensed under $ISC14,189@graphy/content.xml.scribeRDF/XML content scriber for fast and simple outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC12,659@graphy/content.trig.readSingle-threaded RDF TriG content readerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC13,706rdf-string-ttlConvenience functions for creating and serializing RDF terms and quads following Turtle/SPARQL syntaxrdfrdfjstermquadtripleturtlesparqln3rubensworks‚Ä¢ 2.0.1 ‚Ä¢ 4 months ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.0.1, 4 months ago10 dependents licensed under $MIT17,650@graphy/core.data.factoryCreate instances of Terms and Triples/Quads. Implements @RDFJS DataFactoryrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  27 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago27 dependents licensed under $ISC15,642@graphy/content.nq.readSingle-threaded RDF N-Quads content readerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC13,720@graphy/content.trig.writeRDF TriG content writer for dynamic and stylized outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC12,711@inrupt/solid-client-vcA library to act as a client to a server implementing the W3C VC HTTP APIs.rdfsolidlinked dataturtleinrupt_ci‚Ä¢ 1.2.0 ‚Ä¢ 4 months ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 1.2.0, 4 months ago2 dependents licensed under $MIT3,211@graphy/content.nq.scanMulti-threaded RDF N-Quads content readerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  1 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago1 dependents licensed under $ISC2,283@graphy/util.dataset.treeThis package is now an alias for where it has been moved to: '@graphy/memory.dataset.fast'rdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  1 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago1 dependents licensed under $ISC2,359@graphy/content.nq.writeRDF N-Quads content writer for dynamic and stylized outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  1 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago1 dependents licensed under $ISC2,360@graphy/memory.dataset.fastCreate a dataset of quads in memory for comparison and set operations such as union, intersection, difference, etc.rdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  7 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago7 dependents licensed under $ISC3,326123‚Ä¶9¬ª\n\nSearch results161 packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedn3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.turtlerdfn3streamingasynchronousjeswr‚Ä¢ 1.25.2 ‚Ä¢ 8 days ago ‚Ä¢  447 dependents ‚Ä¢  MITpublished version 1.25.2, 8 days ago447 dependents licensed under $MIT278,285@rdfjs/parser-n3N3 parser that implements the RDF/JS Sink interfacerdfrdfjsparsern3ntriplesturtlebergos‚Ä¢ 2.1.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  MITpublished version 2.1.0, a month ago28 dependents licensed under $MIT128,177@inrupt/solid-clientMake your web apps work with Solid Pods.rdfsolidlinked dataturtleinrupt_ci‚Ä¢ 2.1.2 ‚Ä¢ 6 months ago ‚Ä¢  49 dependents ‚Ä¢  MITpublished version 2.1.2, 6 months ago49 dependents licensed under $MIT44,810@frogcat/ttl2jsonldTurtle to JSON-LD converter for node.js and browser, no library dependenciesrdfturtlejson-ldjavascriptfrogcat‚Ä¢ 0.0.10 ‚Ä¢ 3 months ago ‚Ä¢  6 dependents ‚Ä¢  MITpublished version 0.0.10, 3 months ago6 dependents licensed under $MIT17,810@graphy/content.ttl.writeRDF Turtle content writer for dynamic and stylized outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  7 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago7 dependents licensed under $ISC14,165@graphy/core.iso.streamProvides isomorphic stream interface for node.js / browser and adds `.until`, a promisified version of the `.on` event listenerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  8 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago8 dependents licensed under $ISC14,726rdfliban RDF library for node.js. Suitable for client and server side.linkeddatalinked datardfrdfaturtlesemanticwebread-write webtimbl‚Ä¢ 2.2.37 ‚Ä¢ 2 months ago ‚Ä¢  105 dependents ‚Ä¢  MITpublished version 2.2.37, 2 months ago105 dependents licensed under $MIT20,496@graphy/core.class.writableSerialize RDF conveniently and with stylerdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  10 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago10 dependents licensed under $ISC14,255@graphy/core.class.scribableSerialize RDF fastrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  2 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago2 dependents licensed under $ISC14,189@graphy/content.xml.scribeRDF/XML content scriber for fast and simple outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC12,659@graphy/content.trig.readSingle-threaded RDF TriG content readerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC13,706rdf-string-ttlConvenience functions for creating and serializing RDF terms and quads following Turtle/SPARQL syntaxrdfrdfjstermquadtripleturtlesparqln3rubensworks‚Ä¢ 2.0.1 ‚Ä¢ 4 months ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.0.1, 4 months ago10 dependents licensed under $MIT17,650@graphy/core.data.factoryCreate instances of Terms and Triples/Quads. Implements @RDFJS DataFactoryrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  27 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago27 dependents licensed under $ISC15,642@graphy/content.nq.readSingle-threaded RDF N-Quads content readerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC13,720@graphy/content.trig.writeRDF TriG content writer for dynamic and stylized outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  3 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago3 dependents licensed under $ISC12,711@inrupt/solid-client-vcA library to act as a client to a server implementing the W3C VC HTTP APIs.rdfsolidlinked dataturtleinrupt_ci‚Ä¢ 1.2.0 ‚Ä¢ 4 months ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 1.2.0, 4 months ago2 dependents licensed under $MIT3,211@graphy/content.nq.scanMulti-threaded RDF N-Quads content readerrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  1 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago1 dependents licensed under $ISC2,283@graphy/util.dataset.treeThis package is now an alias for where it has been moved to: '@graphy/memory.dataset.fast'rdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  1 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago1 dependents licensed under $ISC2,359@graphy/content.nq.writeRDF N-Quads content writer for dynamic and stylized outputrdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  1 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago1 dependents licensed under $ISC2,360@graphy/memory.dataset.fastCreate a dataset of quads in memory for comparison and set operations such as union, intersection, difference, etc.rdfrdfjslinked-datasemantic-webturtlettltrign-triplesntn-quadsnqblake.regalia‚Ä¢ 4.3.7 ‚Ä¢ 2 years ago ‚Ä¢  7 dependents ‚Ä¢  ISCpublished version 4.3.7, 2 years ago7 dependents licensed under $ISC3,326123‚Ä¶9¬ª\n\n\n\nSearch results614 packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently published@rdfjs/typesAuthoritative TypeScript typings for all RDF/JS specificationsrdfrdf/jsrdfjstypescriptrdfjsbot‚Ä¢ 2.0.1 ‚Ä¢ 3 months ago ‚Ä¢  364 dependents ‚Ä¢  MITpublished version 2.0.1, 3 months ago364 dependents licensed under $MIT276,358@rdfjs/to-ntriplesConverts RDF/JS Terms, Quads and Datasets to N-Triple stringsrdfrdfjsntriplesstringbergos‚Ä¢ 3.0.1 ‚Ä¢ a year ago ‚Ä¢  32 dependents ‚Ä¢  MITpublished version 3.0.1, a year ago32 dependents licensed under $MIT236,195n3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.turtlerdfn3streamingasynchronousjeswr‚Ä¢ 1.25.2 ‚Ä¢ 8 days ago ‚Ä¢  447 dependents ‚Ä¢  MITpublished version 1.25.2, 8 days ago447 dependents licensed under $MIT278,285rdf-data-factoryA TypeScript/JavaScript implementation of the RDF/JS data factory.rdfrdfjsdata factoryfactorydata modelrdf termsrubensworks‚Ä¢ 2.0.2 ‚Ä¢ 4 months ago ‚Ä¢  159 dependents ‚Ä¢  MITpublished version 2.0.2, 4 months ago159 dependents licensed under $MIT202,513@rdfjs/data-modelA basic implementation of the RDF/JS Data Modeldata-modelrdfrdfjsbergos‚Ä¢ 2.1.0 ‚Ä¢ 3 months ago ‚Ä¢  166 dependents ‚Ä¢  MITpublished version 2.1.0, 3 months ago166 dependents licensed under $MIT287,580jsonld-streaming-parserA fast and lightweight streaming JSON-LD parserjsonlinked datasemantic webjson-ldjsonldrdfrdfjsstreamingasynchronousrubensworks‚Ä¢ 5.0.0 ‚Ä¢ 4 months ago ‚Ä¢  26 dependents ‚Ä¢  MITpublished version 5.0.0, 4 months ago26 dependents licensed under $MIT171,385jsonld-context-parserParses JSON-LD contextsjsonlinked datasemantic webjson-ldjsonldrdfrubensworks‚Ä¢ 3.0.0 ‚Ä¢ 10 months ago ‚Ä¢  24 dependents ‚Ä¢  MITpublished version 3.0.0, 10 months ago24 dependents licensed under $MIT162,135rdfxml-streaming-parserStreaming RDF/XML parserrdf/xmlstreamingparserxmlrdfjsrdflinked datarubensworks‚Ä¢ 3.0.1 ‚Ä¢ 4 months ago ‚Ä¢  29 dependents ‚Ä¢  MITpublished version 3.0.1, 4 months ago29 dependents licensed under $MIT181,467@rdfjs/datasetAn indexed implementation of the RDF/JS Datasetdatasetrdfrdfjsbergos‚Ä¢ 2.0.2 ‚Ä¢ a year ago ‚Ä¢  63 dependents ‚Ä¢  MITpublished version 2.0.2, a year ago63 dependents licensed under $MIT165,635@rdfjs/parser-n3N3 parser that implements the RDF/JS Sink interfacerdfrdfjsparsern3ntriplesturtlebergos‚Ä¢ 2.1.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  MITpublished version 2.1.0, a month ago28 dependents licensed under $MIT128,177@rdfjs/sink-mapMap for RDF/JS Sinks including shortcut methodsmaprdfrdfjssinkbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  5 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago5 dependents licensed under $MIT105,348@rdfjs/serializer-ntriplesN-Triples serializer that implements the RDF/JS Sink interfacerdfrdfjsserializerntriplesbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  8 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago8 dependents licensed under $MIT107,010@rdfjs/serializer-jsonldJSON-LD serializer that implements the RDF/JS Sink interfacerdfrdfjsserializerjson-ldbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago10 dependents licensed under $MIT106,975@rdfjs/namespaceNamed Node buildernamednodenamespacerdfrdfjsbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  84 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago84 dependents licensed under $MIT148,428@rdfjs/sinkAbstract RDF/JS Sink Interface implementationrdfrdfjssinkbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  13 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago13 dependents licensed under $MIT140,664rdf-extRDF-Ext is a developer-friendly extension for RDF/JSrdfrdfjsrdf-extbergos‚Ä¢ 2.5.2 ‚Ä¢ 10 months ago ‚Ä¢  116 dependents ‚Ä¢  MITpublished version 2.5.2, 10 months ago116 dependents licensed under $MIT103,363@rdfjs/term-mapMap for RDF/JS Terms keysmaprdfrdfjstermbergos‚Ä¢ 2.0.2 ‚Ä¢ a year ago ‚Ä¢  32 dependents ‚Ä¢  MITpublished version 2.0.2, a year ago32 dependents licensed under $MIT96,463clownfaceSimple but powerful graph traversing libraryrdfgraphtraversingzazuko-bot‚Ä¢ 2.0.3 ‚Ä¢ 5 months ago ‚Ä¢  45 dependents ‚Ä¢  MITpublished version 2.0.3, 5 months ago45 dependents licensed under $MIT58,147@rdfjs/term-setSet for RDF/JS Termsrdfrdfjssettermbergos‚Ä¢ 2.0.3 ‚Ä¢ a year ago ‚Ä¢  43 dependents ‚Ä¢  MITpublished version 2.0.3, a year ago43 dependents licensed under $MIT99,133@rdfjs/fetch-liteWrapper for fetch to simplify sending and receiving RDF datafetchlightliterdfrdfjsbergos‚Ä¢ 3.3.0 ‚Ä¢ 6 months ago ‚Ä¢  11 dependents ‚Ä¢  MITpublished version 3.3.0, 6 months ago11 dependents licensed under $MIT77,347123‚Ä¶31¬ª\n\nSearch results614 packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently published@rdfjs/typesAuthoritative TypeScript typings for all RDF/JS specificationsrdfrdf/jsrdfjstypescriptrdfjsbot‚Ä¢ 2.0.1 ‚Ä¢ 3 months ago ‚Ä¢  364 dependents ‚Ä¢  MITpublished version 2.0.1, 3 months ago364 dependents licensed under $MIT276,358@rdfjs/to-ntriplesConverts RDF/JS Terms, Quads and Datasets to N-Triple stringsrdfrdfjsntriplesstringbergos‚Ä¢ 3.0.1 ‚Ä¢ a year ago ‚Ä¢  32 dependents ‚Ä¢  MITpublished version 3.0.1, a year ago32 dependents licensed under $MIT236,195n3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.turtlerdfn3streamingasynchronousjeswr‚Ä¢ 1.25.2 ‚Ä¢ 8 days ago ‚Ä¢  447 dependents ‚Ä¢  MITpublished version 1.25.2, 8 days ago447 dependents licensed under $MIT278,285rdf-data-factoryA TypeScript/JavaScript implementation of the RDF/JS data factory.rdfrdfjsdata factoryfactorydata modelrdf termsrubensworks‚Ä¢ 2.0.2 ‚Ä¢ 4 months ago ‚Ä¢  159 dependents ‚Ä¢  MITpublished version 2.0.2, 4 months ago159 dependents licensed under $MIT202,513@rdfjs/data-modelA basic implementation of the RDF/JS Data Modeldata-modelrdfrdfjsbergos‚Ä¢ 2.1.0 ‚Ä¢ 3 months ago ‚Ä¢  166 dependents ‚Ä¢  MITpublished version 2.1.0, 3 months ago166 dependents licensed under $MIT287,580jsonld-streaming-parserA fast and lightweight streaming JSON-LD parserjsonlinked datasemantic webjson-ldjsonldrdfrdfjsstreamingasynchronousrubensworks‚Ä¢ 5.0.0 ‚Ä¢ 4 months ago ‚Ä¢  26 dependents ‚Ä¢  MITpublished version 5.0.0, 4 months ago26 dependents licensed under $MIT171,385jsonld-context-parserParses JSON-LD contextsjsonlinked datasemantic webjson-ldjsonldrdfrubensworks‚Ä¢ 3.0.0 ‚Ä¢ 10 months ago ‚Ä¢  24 dependents ‚Ä¢  MITpublished version 3.0.0, 10 months ago24 dependents licensed under $MIT162,135rdfxml-streaming-parserStreaming RDF/XML parserrdf/xmlstreamingparserxmlrdfjsrdflinked datarubensworks‚Ä¢ 3.0.1 ‚Ä¢ 4 months ago ‚Ä¢  29 dependents ‚Ä¢  MITpublished version 3.0.1, 4 months ago29 dependents licensed under $MIT181,467@rdfjs/datasetAn indexed implementation of the RDF/JS Datasetdatasetrdfrdfjsbergos‚Ä¢ 2.0.2 ‚Ä¢ a year ago ‚Ä¢  63 dependents ‚Ä¢  MITpublished version 2.0.2, a year ago63 dependents licensed under $MIT165,635@rdfjs/parser-n3N3 parser that implements the RDF/JS Sink interfacerdfrdfjsparsern3ntriplesturtlebergos‚Ä¢ 2.1.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  MITpublished version 2.1.0, a month ago28 dependents licensed under $MIT128,177@rdfjs/sink-mapMap for RDF/JS Sinks including shortcut methodsmaprdfrdfjssinkbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  5 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago5 dependents licensed under $MIT105,348@rdfjs/serializer-ntriplesN-Triples serializer that implements the RDF/JS Sink interfacerdfrdfjsserializerntriplesbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  8 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago8 dependents licensed under $MIT107,010@rdfjs/serializer-jsonldJSON-LD serializer that implements the RDF/JS Sink interfacerdfrdfjsserializerjson-ldbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago10 dependents licensed under $MIT106,975@rdfjs/namespaceNamed Node buildernamednodenamespacerdfrdfjsbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  84 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago84 dependents licensed under $MIT148,428@rdfjs/sinkAbstract RDF/JS Sink Interface implementationrdfrdfjssinkbergos‚Ä¢ 2.0.1 ‚Ä¢ a year ago ‚Ä¢  13 dependents ‚Ä¢  MITpublished version 2.0.1, a year ago13 dependents licensed under $MIT140,664rdf-extRDF-Ext is a developer-friendly extension for RDF/JSrdfrdfjsrdf-extbergos‚Ä¢ 2.5.2 ‚Ä¢ 10 months ago ‚Ä¢  116 dependents ‚Ä¢  MITpublished version 2.5.2, 10 months ago116 dependents licensed under $MIT103,363@rdfjs/term-mapMap for RDF/JS Terms keysmaprdfrdfjstermbergos‚Ä¢ 2.0.2 ‚Ä¢ a year ago ‚Ä¢  32 dependents ‚Ä¢  MITpublished version 2.0.2, a year ago32 dependents licensed under $MIT96,463clownfaceSimple but powerful graph traversing libraryrdfgraphtraversingzazuko-bot‚Ä¢ 2.0.3 ‚Ä¢ 5 months ago ‚Ä¢  45 dependents ‚Ä¢  MITpublished version 2.0.3, 5 months ago45 dependents licensed under $MIT58,147@rdfjs/term-setSet for RDF/JS Termsrdfrdfjssettermbergos‚Ä¢ 2.0.3 ‚Ä¢ a year ago ‚Ä¢  43 dependents ‚Ä¢  MITpublished version 2.0.3, a year ago43 dependents licensed under $MIT99,133@rdfjs/fetch-liteWrapper for fetch to simplify sending and receiving RDF datafetchlightliterdfrdfjsbergos‚Ä¢ 3.3.0 ‚Ä¢ 6 months ago ‚Ä¢  11 dependents ‚Ä¢  MITpublished version 3.3.0, 6 months ago11 dependents licensed under $MIT77,347123‚Ä¶31¬ª\n\n\n\nSearch results30 packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedn3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.turtlerdfn3streamingasynchronousjeswr‚Ä¢ 1.25.2 ‚Ä¢ 8 days ago ‚Ä¢  447 dependents ‚Ä¢  MITpublished version 1.25.2, 8 days ago447 dependents licensed under $MIT278,285@rdfjs/parser-n3N3 parser that implements the RDF/JS Sink interfacerdfrdfjsparsern3ntriplesturtlebergos‚Ä¢ 2.1.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  MITpublished version 2.1.0, a month ago28 dependents licensed under $MIT128,177rdf-quadA convenience constructor for RDF quadsrdfrdfjstermquadtriplen3rubensworks‚Ä¢ 2.0.0 ‚Ä¢ 4 months ago ‚Ä¢  3 dependents ‚Ä¢  MITpublished version 2.0.0, 4 months ago3 dependents licensed under $MIT30,899rdf-string-ttlConvenience functions for creating and serializing RDF terms and quads following Turtle/SPARQL syntaxrdfrdfjstermquadtripleturtlesparqln3rubensworks‚Ä¢ 2.0.1 ‚Ä¢ 4 months ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.0.1, 4 months ago10 dependents licensed under $MIT17,650@comunica/actor-rdf-serialize-n3A n3 rdf-serialize actorcomunicaactorrdf-serializen3rubensworks‚Ä¢ 4.1.0 ‚Ä¢ 2 months ago ‚Ä¢  12 dependents ‚Ä¢  MITpublished version 4.1.0, 2 months ago12 dependents licensed under $MIT18,088@jeswr/pretty-turtleA pretty serializer for turtle RDF syntaxturtlen3rdfwriteserializejeswr‚Ä¢ 1.5.1 ‚Ä¢ 9 days ago ‚Ä¢  3 dependents ‚Ä¢  MITpublished version 1.5.1, 9 days ago3 dependents licensed under $MIT1,647@n3/eslint-configN3 ESLint config, following our styleguideeslinteslintconfigconfign3vtaits‚Ä¢ 0.14.0 ‚Ä¢ 2 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 0.14.0, 2 years ago0 dependents licensed under $MIT591rdf-transformEasily transform between RDF syntaxesRDFtransformparseserializationturtlen3jsonldcontent-typecontentnegotiationjeswr‚Ä¢ 1.2.2 ‚Ä¢ a month ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 1.2.2, a month ago2 dependents licensed under $MIT330N3-componentsN3 built with Vue.jsvuen3vue-componentx-cold‚Ä¢ 2.4.5 ‚Ä¢ 7 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 2.4.5, 7 years ago0 dependents licensed under $MIT229h-eyeH-Eye Dataspaceseyereasonern3blackboardscristianvasquez‚Ä¢ 1.3.9 ‚Ä¢ 7 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.3.9, 7 years ago0 dependents licensed under $MIT148@r3e/neo-n3-mcpMCP server for Neo N3 blockchain integrationneoblockchainmcpn3modelcontextprotocoljinghuiliao‚Ä¢ 1.2.0 ‚Ä¢ 2 days ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.2.0, 2 days ago0 dependents licensed under $MIT128levelgraph-n3LevelGraph plugin that add the ability to load and store n3/turtle files.levelgraphgraphrdfturtlelinkeddatalinked datan3matteo.collina‚Ä¢ 2.1.0 ‚Ä¢ 8 years ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 2.1.0, 8 years ago2 dependents licensed under $MIT95eye-mockEYE mock solving your n3 reasoning on a server instead of client side Prolog executioneyemockn3notation3reasoningsmessie‚Ä¢ 3.0.0 ‚Ä¢ 9 months ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 3.0.0, 9 months ago0 dependents licensed under $MIT71n3-transform[![npm version](https://badge.fury.io/js/n3-transform.svg)](https://www.npmjs.com/package/n3-transform)rdfstreamturtlen3rubensworks‚Ä¢ 1.1.0 ‚Ä¢ 6 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.0, 6 years ago0 dependents licensed under $MIT62inilloN3 parser that implements the RDF/JS Sink interfacerdfcorporisparsern3accusantiummolestiaeroxanepurdy‚Ä¢ 1.6.0 ‚Ä¢ a year ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.6.0, a year ago0 dependents licensed under $MIT49@mseep/neo-n3-mcpMCP server for Neo N3 blockchain integrationneoblockchainmcpn3modelcontextprotocolmseepmcp-serverskydeckai‚Ä¢ 1.1.0 ‚Ä¢ 10 days ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.0, 10 days ago0 dependents licensed under $MIT57eyeserverEYE reasoner servereyereasonern3rubenverborgh‚Ä¢ 1.1.2 ‚Ä¢ 6 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.2, 6 years ago0 dependents licensed under $MIT45@comunica/actor-rule-parse-n3A n3 rule-parse actorcomunicaactorrule-parsen3jeswr‚Ä¢ 0.2.0 ‚Ä¢ 3 years ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 0.2.0, 3 years ago2 dependents licensed under $MIT50modidoloremqueN3 parser that implements the RDFJS Sink interfaceodioliberosolutan3cupiditateturtleadeleweimann‚Ä¢ 1.1.4 ‚Ä¢ a year ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.4, a year ago0 dependents licensed under $MIT33rdf-builderConveniently construct RDF triplesrdfn3triplesgraphptgolden‚Ä¢ 2.0.0 ‚Ä¢ 8 years ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 2.0.0, 8 years ago2 dependents licensed under $MIT3312\n\nSearch results30 packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedn3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.turtlerdfn3streamingasynchronousjeswr‚Ä¢ 1.25.2 ‚Ä¢ 8 days ago ‚Ä¢  447 dependents ‚Ä¢  MITpublished version 1.25.2, 8 days ago447 dependents licensed under $MIT278,285@rdfjs/parser-n3N3 parser that implements the RDF/JS Sink interfacerdfrdfjsparsern3ntriplesturtlebergos‚Ä¢ 2.1.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  MITpublished version 2.1.0, a month ago28 dependents licensed under $MIT128,177rdf-quadA convenience constructor for RDF quadsrdfrdfjstermquadtriplen3rubensworks‚Ä¢ 2.0.0 ‚Ä¢ 4 months ago ‚Ä¢  3 dependents ‚Ä¢  MITpublished version 2.0.0, 4 months ago3 dependents licensed under $MIT30,899rdf-string-ttlConvenience functions for creating and serializing RDF terms and quads following Turtle/SPARQL syntaxrdfrdfjstermquadtripleturtlesparqln3rubensworks‚Ä¢ 2.0.1 ‚Ä¢ 4 months ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.0.1, 4 months ago10 dependents licensed under $MIT17,650@comunica/actor-rdf-serialize-n3A n3 rdf-serialize actorcomunicaactorrdf-serializen3rubensworks‚Ä¢ 4.1.0 ‚Ä¢ 2 months ago ‚Ä¢  12 dependents ‚Ä¢  MITpublished version 4.1.0, 2 months ago12 dependents licensed under $MIT18,088@jeswr/pretty-turtleA pretty serializer for turtle RDF syntaxturtlen3rdfwriteserializejeswr‚Ä¢ 1.5.1 ‚Ä¢ 9 days ago ‚Ä¢  3 dependents ‚Ä¢  MITpublished version 1.5.1, 9 days ago3 dependents licensed under $MIT1,647@n3/eslint-configN3 ESLint config, following our styleguideeslinteslintconfigconfign3vtaits‚Ä¢ 0.14.0 ‚Ä¢ 2 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 0.14.0, 2 years ago0 dependents licensed under $MIT591rdf-transformEasily transform between RDF syntaxesRDFtransformparseserializationturtlen3jsonldcontent-typecontentnegotiationjeswr‚Ä¢ 1.2.2 ‚Ä¢ a month ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 1.2.2, a month ago2 dependents licensed under $MIT330N3-componentsN3 built with Vue.jsvuen3vue-componentx-cold‚Ä¢ 2.4.5 ‚Ä¢ 7 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 2.4.5, 7 years ago0 dependents licensed under $MIT229h-eyeH-Eye Dataspaceseyereasonern3blackboardscristianvasquez‚Ä¢ 1.3.9 ‚Ä¢ 7 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.3.9, 7 years ago0 dependents licensed under $MIT148@r3e/neo-n3-mcpMCP server for Neo N3 blockchain integrationneoblockchainmcpn3modelcontextprotocoljinghuiliao‚Ä¢ 1.2.0 ‚Ä¢ 2 days ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.2.0, 2 days ago0 dependents licensed under $MIT128levelgraph-n3LevelGraph plugin that add the ability to load and store n3/turtle files.levelgraphgraphrdfturtlelinkeddatalinked datan3matteo.collina‚Ä¢ 2.1.0 ‚Ä¢ 8 years ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 2.1.0, 8 years ago2 dependents licensed under $MIT95eye-mockEYE mock solving your n3 reasoning on a server instead of client side Prolog executioneyemockn3notation3reasoningsmessie‚Ä¢ 3.0.0 ‚Ä¢ 9 months ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 3.0.0, 9 months ago0 dependents licensed under $MIT71n3-transform[![npm version](https://badge.fury.io/js/n3-transform.svg)](https://www.npmjs.com/package/n3-transform)rdfstreamturtlen3rubensworks‚Ä¢ 1.1.0 ‚Ä¢ 6 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.0, 6 years ago0 dependents licensed under $MIT62inilloN3 parser that implements the RDF/JS Sink interfacerdfcorporisparsern3accusantiummolestiaeroxanepurdy‚Ä¢ 1.6.0 ‚Ä¢ a year ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.6.0, a year ago0 dependents licensed under $MIT49@mseep/neo-n3-mcpMCP server for Neo N3 blockchain integrationneoblockchainmcpn3modelcontextprotocolmseepmcp-serverskydeckai‚Ä¢ 1.1.0 ‚Ä¢ 10 days ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.0, 10 days ago0 dependents licensed under $MIT57eyeserverEYE reasoner servereyereasonern3rubenverborgh‚Ä¢ 1.1.2 ‚Ä¢ 6 years ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.2, 6 years ago0 dependents licensed under $MIT45@comunica/actor-rule-parse-n3A n3 rule-parse actorcomunicaactorrule-parsen3jeswr‚Ä¢ 0.2.0 ‚Ä¢ 3 years ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 0.2.0, 3 years ago2 dependents licensed under $MIT50modidoloremqueN3 parser that implements the RDFJS Sink interfaceodioliberosolutan3cupiditateturtleadeleweimann‚Ä¢ 1.1.4 ‚Ä¢ a year ago ‚Ä¢  0 dependents ‚Ä¢  MITpublished version 1.1.4, a year ago0 dependents licensed under $MIT33rdf-builderConveniently construct RDF triplesrdfn3triplesgraphptgolden‚Ä¢ 2.0.0 ‚Ä¢ 8 years ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 2.0.0, 8 years ago2 dependents licensed under $MIT3312\n\n\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedJSONStreamrawStream.pipe(JSONStream.parse()).pipe(streamOfObjects)jsonstreamstreamingparserasyncparsingdominictarr‚Ä¢ 1.3.5 ‚Ä¢ 7 years ago ‚Ä¢  1,960 dependents ‚Ä¢  (MIT OR Apache-2.0)published version 1.3.5, 7 years ago1960 dependents licensed under $(MIT OR Apache-2.0)40,640,415unbzip2-streamstreaming unbzip2 implementation in pure javascript for node and browsersbzipbzip2bz2streamstreamingdecompressthroughregular‚Ä¢ 1.4.3 ‚Ä¢ 5 years ago ‚Ä¢  119 dependents ‚Ä¢  MITpublished version 1.4.3, 5 years ago119 dependents licensed under $MIT35,014,691stream-httpStreaming http in the browserhttpstreamstreamingxhrhttp-browserifyjhiesey‚Ä¢ 3.2.0 ‚Ä¢ 4 years ago ‚Ä¢  894 dependents ‚Ä¢  MITpublished version 3.2.0, 4 years ago894 dependents licensed under $MIT38,790,301strtok3A promise based streaming tokenizertokenizerreadertokenasyncpromiseparserdecoderbinaryendianuintstreamstreamingborewit‚Ä¢ 10.2.2 ‚Ä¢ 2 months ago ‚Ä¢  51 dependents ‚Ä¢  MITpublished version 10.2.2, 2 months ago51 dependents licensed under $MIT28,165,694parse5-sax-parserStreaming SAX-style HTML parser.parse5parserstreamstreamingSAXfeedic‚Ä¢ 7.0.0 ‚Ä¢ 3 years ago ‚Ä¢  26 dependents ‚Ä¢  MITpublished version 7.0.0, 3 years ago26 dependents licensed under $MIT12,189,550parse5-html-rewriting-streamStreaming HTML rewriter.parse5parserstreamstreamingrewritterrewriteHTML43081j‚Ä¢ 7.1.0 ‚Ä¢ 4 days ago ‚Ä¢  34 dependents ‚Ä¢  MITpublished version 7.1.0, 4 days ago34 dependents licensed under $MIT12,135,837parse5-parser-streamStreaming HTML parser with scripting support.parse5parserstreamstreamingfeedic‚Ä¢ 7.1.2 ‚Ä¢ 2 years ago ‚Ä¢  17 dependents ‚Ä¢  MITpublished version 7.1.2, 2 years ago17 dependents licensed under $MIT13,815,806stream-jsonstream-json is the micro-library of Node.js stream components for creating custom JSON processing pipelines with a minimal memory footprint. It can parse JSON files far exceeding available memory streaming individual primitives using a SAX-inspired API. Iscannerlexertokenizerparserdjangostreamstreamingjsonelazutkin‚Ä¢ 1.9.1 ‚Ä¢ 5 months ago ‚Ä¢  330 dependents ‚Ä¢  BSD-3-Clausepublished version 1.9.1, 5 months ago330 dependents licensed under $BSD-3-Clause8,442,527dicerA very fast streaming multipart parser for node.jsparserparseparsingmultipartform-datastreamingmscdex‚Ä¢ 0.3.1 ‚Ä¢ 3 years ago ‚Ä¢  39 dependentspublished version 0.3.1, 3 years ago39 dependents 7,898,211gulpThe streaming build system.buildstreamsystemmaketoolassetpipelineseriesparallelstreamingphated‚Ä¢ 5.0.0 ‚Ä¢ a year ago ‚Ä¢  9,480 dependents ‚Ä¢  MITpublished version 5.0.0, a year ago9480 dependents licensed under $MIT6,600,823unique-streamnode.js through stream that emits a unique stream of objects based on criteriauniquestreamunique-streamstreamingstreamseugeneware‚Ä¢ 2.3.1 ‚Ä¢ 6 years ago ‚Ä¢  65 dependents ‚Ä¢  MITpublished version 2.3.1, 6 years ago65 dependents licensed under $MIT7,187,090remove-bom-streamRemove a UTF8 BOM at the start of the stream.bomremoveutf8streamingstreamphated‚Ä¢ 2.0.0 ‚Ä¢ 3 years ago ‚Ä¢  27 dependents ‚Ä¢  MITpublished version 2.0.0, 3 years ago27 dependents licensed under $MIT5,417,833launchdarkly-eventsourceFork of eventsource package - W3C compliant EventSource client for Node.js and browser (polyfill)eventsourcehttpstreamingssepolyfilllaunchdarkly‚Ä¢ 2.2.0 ‚Ä¢ a day ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.2.0, a day ago10 dependents licensed under $MIT6,714,068replacestreamA node.js through stream that does basic streaming text search and replace and is chunk boundary friendlyreplacetextregexstreamstreamsstreamingsearchshinnn‚Ä¢ 4.0.3 ‚Ä¢ 8 years ago ‚Ä¢  272 dependents ‚Ä¢  BSD-3-Clausepublished version 4.0.3, 8 years ago272 dependents licensed under $BSD-3-Clause2,265,221progress-streamRead the progress of a streamstreamprogresspercentagepercentdownloaduploadfilestreamingrequesthttpfreeall‚Ä¢ 2.0.0 ‚Ä¢ 8 years ago ‚Ä¢  292 dependents ‚Ä¢  BSD-2-Clausepublished version 2.0.0, 8 years ago292 dependents licensed under $BSD-2-Clause2,494,922jsonrepairRepair broken JSON documentssimplejsonrepairfixinvalidstreamstreamingjosdejong‚Ä¢ 3.12.0 ‚Ä¢ 3 months ago ‚Ä¢  161 dependents ‚Ä¢  ISCpublished version 3.12.0, 3 months ago161 dependents licensed under $ISC1,707,416base64-streamContains new Node.js v0.10 style stream classes for encoding / decoding Base64 dataBase64streamstreamingpipingnodenode.jsencodedecoderossj‚Ä¢ 1.0.0 ‚Ä¢ 7 years ago ‚Ä¢  198 dependents ‚Ä¢  MITpublished version 1.0.0, 7 years ago198 dependents licensed under $MIT2,387,088bufferstreamsAbstract streams to deal with the whole buffered contents.bufferstreamingstreamasyncabstractnfroidure‚Ä¢ 4.0.0 ‚Ä¢ 9 months ago ‚Ä¢  89 dependents ‚Ä¢  MITpublished version 4.0.0, 9 months ago89 dependents licensed under $MIT1,739,551css-tokenizeTransform stream that tokenizes CSScsstokenizeparsestreamstreaminganandthakker‚Ä¢ 1.0.1 ‚Ä¢ 10 years ago ‚Ä¢  6 dependents ‚Ä¢  MITpublished version 1.0.1, 10 years ago6 dependents licensed under $MIT1,537,218vega-dataflowReactive dataflow processing.vegadataflowreactivestreamingdatalhermann‚Ä¢ 6.0.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  BSD-3-Clausepublished version 6.0.0, a month ago28 dependents licensed under $BSD-3-Clause828,355123‚Ä¶50¬ª\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedJSONStreamrawStream.pipe(JSONStream.parse()).pipe(streamOfObjects)jsonstreamstreamingparserasyncparsingdominictarr‚Ä¢ 1.3.5 ‚Ä¢ 7 years ago ‚Ä¢  1,960 dependents ‚Ä¢  (MIT OR Apache-2.0)published version 1.3.5, 7 years ago1960 dependents licensed under $(MIT OR Apache-2.0)40,640,415unbzip2-streamstreaming unbzip2 implementation in pure javascript for node and browsersbzipbzip2bz2streamstreamingdecompressthroughregular‚Ä¢ 1.4.3 ‚Ä¢ 5 years ago ‚Ä¢  119 dependents ‚Ä¢  MITpublished version 1.4.3, 5 years ago119 dependents licensed under $MIT35,014,691stream-httpStreaming http in the browserhttpstreamstreamingxhrhttp-browserifyjhiesey‚Ä¢ 3.2.0 ‚Ä¢ 4 years ago ‚Ä¢  894 dependents ‚Ä¢  MITpublished version 3.2.0, 4 years ago894 dependents licensed under $MIT38,790,301strtok3A promise based streaming tokenizertokenizerreadertokenasyncpromiseparserdecoderbinaryendianuintstreamstreamingborewit‚Ä¢ 10.2.2 ‚Ä¢ 2 months ago ‚Ä¢  51 dependents ‚Ä¢  MITpublished version 10.2.2, 2 months ago51 dependents licensed under $MIT28,165,694parse5-sax-parserStreaming SAX-style HTML parser.parse5parserstreamstreamingSAXfeedic‚Ä¢ 7.0.0 ‚Ä¢ 3 years ago ‚Ä¢  26 dependents ‚Ä¢  MITpublished version 7.0.0, 3 years ago26 dependents licensed under $MIT12,189,550parse5-html-rewriting-streamStreaming HTML rewriter.parse5parserstreamstreamingrewritterrewriteHTML43081j‚Ä¢ 7.1.0 ‚Ä¢ 4 days ago ‚Ä¢  34 dependents ‚Ä¢  MITpublished version 7.1.0, 4 days ago34 dependents licensed under $MIT12,135,837parse5-parser-streamStreaming HTML parser with scripting support.parse5parserstreamstreamingfeedic‚Ä¢ 7.1.2 ‚Ä¢ 2 years ago ‚Ä¢  17 dependents ‚Ä¢  MITpublished version 7.1.2, 2 years ago17 dependents licensed under $MIT13,815,806stream-jsonstream-json is the micro-library of Node.js stream components for creating custom JSON processing pipelines with a minimal memory footprint. It can parse JSON files far exceeding available memory streaming individual primitives using a SAX-inspired API. Iscannerlexertokenizerparserdjangostreamstreamingjsonelazutkin‚Ä¢ 1.9.1 ‚Ä¢ 5 months ago ‚Ä¢  330 dependents ‚Ä¢  BSD-3-Clausepublished version 1.9.1, 5 months ago330 dependents licensed under $BSD-3-Clause8,442,527dicerA very fast streaming multipart parser for node.jsparserparseparsingmultipartform-datastreamingmscdex‚Ä¢ 0.3.1 ‚Ä¢ 3 years ago ‚Ä¢  39 dependentspublished version 0.3.1, 3 years ago39 dependents 7,898,211gulpThe streaming build system.buildstreamsystemmaketoolassetpipelineseriesparallelstreamingphated‚Ä¢ 5.0.0 ‚Ä¢ a year ago ‚Ä¢  9,480 dependents ‚Ä¢  MITpublished version 5.0.0, a year ago9480 dependents licensed under $MIT6,600,823unique-streamnode.js through stream that emits a unique stream of objects based on criteriauniquestreamunique-streamstreamingstreamseugeneware‚Ä¢ 2.3.1 ‚Ä¢ 6 years ago ‚Ä¢  65 dependents ‚Ä¢  MITpublished version 2.3.1, 6 years ago65 dependents licensed under $MIT7,187,090remove-bom-streamRemove a UTF8 BOM at the start of the stream.bomremoveutf8streamingstreamphated‚Ä¢ 2.0.0 ‚Ä¢ 3 years ago ‚Ä¢  27 dependents ‚Ä¢  MITpublished version 2.0.0, 3 years ago27 dependents licensed under $MIT5,417,833launchdarkly-eventsourceFork of eventsource package - W3C compliant EventSource client for Node.js and browser (polyfill)eventsourcehttpstreamingssepolyfilllaunchdarkly‚Ä¢ 2.2.0 ‚Ä¢ a day ago ‚Ä¢  10 dependents ‚Ä¢  MITpublished version 2.2.0, a day ago10 dependents licensed under $MIT6,714,068replacestreamA node.js through stream that does basic streaming text search and replace and is chunk boundary friendlyreplacetextregexstreamstreamsstreamingsearchshinnn‚Ä¢ 4.0.3 ‚Ä¢ 8 years ago ‚Ä¢  272 dependents ‚Ä¢  BSD-3-Clausepublished version 4.0.3, 8 years ago272 dependents licensed under $BSD-3-Clause2,265,221progress-streamRead the progress of a streamstreamprogresspercentagepercentdownloaduploadfilestreamingrequesthttpfreeall‚Ä¢ 2.0.0 ‚Ä¢ 8 years ago ‚Ä¢  292 dependents ‚Ä¢  BSD-2-Clausepublished version 2.0.0, 8 years ago292 dependents licensed under $BSD-2-Clause2,494,922jsonrepairRepair broken JSON documentssimplejsonrepairfixinvalidstreamstreamingjosdejong‚Ä¢ 3.12.0 ‚Ä¢ 3 months ago ‚Ä¢  161 dependents ‚Ä¢  ISCpublished version 3.12.0, 3 months ago161 dependents licensed under $ISC1,707,416base64-streamContains new Node.js v0.10 style stream classes for encoding / decoding Base64 dataBase64streamstreamingpipingnodenode.jsencodedecoderossj‚Ä¢ 1.0.0 ‚Ä¢ 7 years ago ‚Ä¢  198 dependents ‚Ä¢  MITpublished version 1.0.0, 7 years ago198 dependents licensed under $MIT2,387,088bufferstreamsAbstract streams to deal with the whole buffered contents.bufferstreamingstreamasyncabstractnfroidure‚Ä¢ 4.0.0 ‚Ä¢ 9 months ago ‚Ä¢  89 dependents ‚Ä¢  MITpublished version 4.0.0, 9 months ago89 dependents licensed under $MIT1,739,551css-tokenizeTransform stream that tokenizes CSScsstokenizeparsestreamstreaminganandthakker‚Ä¢ 1.0.1 ‚Ä¢ 10 years ago ‚Ä¢  6 dependents ‚Ä¢  MITpublished version 1.0.1, 10 years ago6 dependents licensed under $MIT1,537,218vega-dataflowReactive dataflow processing.vegadataflowreactivestreamingdatalhermann‚Ä¢ 6.0.0 ‚Ä¢ a month ago ‚Ä¢  28 dependents ‚Ä¢  BSD-3-Clausepublished version 6.0.0, a month ago28 dependents licensed under $BSD-3-Clause828,355123‚Ä¶50¬ª\n\n\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedrun-parallelRun an array of functions in parallelparallelasyncfunctioncallbackasynchronousrunarrayrun parallelfeross‚Ä¢ 1.2.0 ‚Ä¢ 4 years ago ‚Ä¢  1,828 dependents ‚Ä¢  MITpublished version 1.2.0, 4 years ago1828 dependents licensed under $MIT213,470,282async-limiterasynchronous function queue with adjustable concurrencythrottleasynclimiterasynchronousjobtaskconcurrencyconcurrentstrml‚Ä¢ 2.0.0 ‚Ä¢ 5 years ago ‚Ä¢  615 dependents ‚Ä¢  MITpublished version 2.0.0, 5 years ago615 dependents licensed under $MIT36,615,846async-eachNo-bullshit, ultra-simple, 35-lines-of-code async parallel forEach / map function for JavaScript.asyncforEacheachmapasynchronousiterationiterateloopparallelconcurrentarrayflowcontrol flowpaulmillr‚Ä¢ 1.0.6 ‚Ä¢ 2 years ago ‚Ä¢  500 dependents ‚Ä¢  MITpublished version 1.0.6, 2 years ago500 dependents licensed under $MIT29,300,562queueasynchronous function queue with adjustable concurrencyqueueasyncasynchronoussynchronousjobtaskconcurrencyconcurrentjessetane‚Ä¢ 7.0.0 ‚Ä¢ 2 years ago ‚Ä¢  611 dependents ‚Ä¢  MITpublished version 7.0.0, 2 years ago611 dependents licensed under $MIT25,271,866node-dirasynchronous file and directory operations for Node.jsnode-dirdirectorydirsubdirfileasynchronousNode.jsfsfshost‚Ä¢ 0.1.17 ‚Ä¢ 8 years ago ‚Ä¢  991 dependents ‚Ä¢  MITpublished version 0.1.17, 8 years ago991 dependents licensed under $MIT26,474,492@sec-ant/readable-streamA tiny, zero-dependency yet spec-compliant asynchronous iterator polyfill/ponyfill for ReadableStreams.streamweb-streamsreadablestreamasyncasynchronousiteratoriterationasync-iteratorpolyfillesmfrom-iterablesec-ant‚Ä¢ 0.6.0 ‚Ä¢ 7 months ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 0.6.0, 7 months ago2 dependents licensed under $MIT14,670,438bfjBig-friendly JSON. Asynchronous streaming functions for large JSON data sets.jsonstreamifystringifywalkparseparserserialiseserializereadwriteasyncasynchronousphilbooth‚Ä¢ 9.1.2 ‚Ä¢ 3 months ago ‚Ä¢  2,155 dependents ‚Ä¢  MITpublished version 9.1.2, 3 months ago2155 dependents licensed under $MIT17,372,454exit-hookRun some code when the process exitsexitquitprocesshookgracefulhandlershutdownsigtermsigintterminatekillstopeventsignalView moresindresorhus‚Ä¢ 4.0.0 ‚Ä¢ 2 years ago ‚Ä¢  340 dependents ‚Ä¢  MITpublished version 4.0.0, 2 years ago340 dependents licensed under $MIT13,106,085run-seriesRun an array of functions in seriesseriesasyncfunctioncallbackasynchronousrunarrayrun seriesfeross‚Ä¢ 1.1.9 ‚Ä¢ 4 years ago ‚Ä¢  167 dependents ‚Ä¢  MITpublished version 1.1.9, 4 years ago167 dependents licensed under $MIT5,600,677run-parallel-limitRun an array of functions in parallel, but limit the number of tasks executing at the same timeparallelasyncfunctioncallbackasynchronousrunarrayrun parallellimitmaxqueuerun parallel limitmax taskstasksfeross‚Ä¢ 1.1.0 ‚Ä¢ 4 years ago ‚Ä¢  65 dependents ‚Ä¢  MITpublished version 1.1.0, 4 years ago65 dependents licensed under $MIT5,206,181stenoSpecialized fast async file writerfsfilewritewriterasynchronousfastraceconditionatomicwritingsafetypicode‚Ä¢ 4.0.2 ‚Ä¢ a year ago ‚Ä¢  62 dependents ‚Ä¢  MITpublished version 4.0.2, a year ago62 dependents licensed under $MIT4,133,102scrypt-jsThe scrypt password-based key derivation function with sync and cancellable async.scryptpbkdfpasswordasyncasynchronousstepwisericmoo‚Ä¢ 3.0.1 ‚Ä¢ 5 years ago ‚Ä¢  405 dependents ‚Ä¢  MITpublished version 3.0.1, 5 years ago405 dependents licensed under $MIT4,859,917deferredModular and fast Promises implementationasyncasynchronousdeferredflowfuturefuturespromisepromisescontinuationsmedikoo‚Ä¢ 0.7.11 ‚Ä¢ 6 years ago ‚Ä¢  187 dependents ‚Ä¢  ISCpublished version 0.7.11, 6 years ago187 dependents licensed under $ISC3,849,219whenA lightweight Promises/A+ and when() implementation, plus other async goodies.cujoPromises/A+promises-apluspromisepromisesdeferreddeferredswhenasyncasynchronousendercujojs‚Ä¢ 3.7.8 ‚Ä¢ 8 years ago ‚Ä¢  1,436 dependents ‚Ä¢  MITpublished version 3.7.8, 8 years ago1436 dependents licensed under $MIT5,024,171react-async-scriptA composition mixin for loading scripts asynchronously for Reactreactasynchronousscript-loaderdozoisch‚Ä¢ 1.2.0 ‚Ä¢ 5 years ago ‚Ä¢  67 dependents ‚Ä¢  MITpublished version 1.2.0, 5 years ago67 dependents licensed under $MIT3,298,868@nevware21/ts-asyncsupport for asynchronous development with a Promise based task Scheduler, several different Promise implementations (synchronous, idle, asynchronous and native runtime wrappers), await helpers, and aliases all built and tested using TypeScript.typescriptjavascriptes5promisees6.promiseasyncasynchronousasync promiseasynchronous promisesyncsynchronoussync promisesynchronous promiseidleView morenevware21bot‚Ä¢ 0.5.4 ‚Ä¢ 4 months ago ‚Ä¢  15 dependents ‚Ä¢  MITpublished version 0.5.4, 4 months ago15 dependents licensed under $MIT1,807,310p-iterationMake array iteration easy when using async/await and Promisesasync/awaitasyncawaitasynchronousawaitableasync functionarrayiterationforEachmapeverysomefilterreduceantonvs‚Ä¢ 1.1.8 ‚Ä¢ 6 years ago ‚Ä¢  150 dependents ‚Ä¢  MITpublished version 1.1.8, 6 years ago150 dependents licensed under $MIT2,081,597@stdlib/utils-next-tickAdd a callback to the next tick queue.stdlibstdutilsstdutilutilsutilutilitiesutilityprocessnextticknextticksettimeoutsetimmediateasyncView morestdlib-bot‚Ä¢ 0.2.2 ‚Ä¢ 9 months ago ‚Ä¢  73 dependents ‚Ä¢  Apache-2.0published version 0.2.2, 9 months ago73 dependents licensed under $Apache-2.01,562,301d3-queueEvaluate asynchronous tasks with configurable concurrency.d3d3-moduleasynchronousasyncqueuembostock‚Ä¢ 3.0.7 ‚Ä¢ 8 years ago ‚Ä¢  195 dependents ‚Ä¢  BSD-3-Clausepublished version 3.0.7, 8 years ago195 dependents licensed under $BSD-3-Clause1,220,380set-interval-asyncModern version of setInterval for promises and async functions available in Node.js and browsers.setIntervalsetTimeoutclearIntervalclearTimeoutintervaltimeoutmillisecondssecondspromisepromisesasyncasynchronousawaitrecurrentView moreealmansi‚Ä¢ 3.0.3 ‚Ä¢ 2 years ago ‚Ä¢  74 dependents ‚Ä¢  MITpublished version 3.0.3, 2 years ago74 dependents licensed under $MIT941,210123‚Ä¶50¬ª\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedrun-parallelRun an array of functions in parallelparallelasyncfunctioncallbackasynchronousrunarrayrun parallelfeross‚Ä¢ 1.2.0 ‚Ä¢ 4 years ago ‚Ä¢  1,828 dependents ‚Ä¢  MITpublished version 1.2.0, 4 years ago1828 dependents licensed under $MIT213,470,282async-limiterasynchronous function queue with adjustable concurrencythrottleasynclimiterasynchronousjobtaskconcurrencyconcurrentstrml‚Ä¢ 2.0.0 ‚Ä¢ 5 years ago ‚Ä¢  615 dependents ‚Ä¢  MITpublished version 2.0.0, 5 years ago615 dependents licensed under $MIT36,615,846async-eachNo-bullshit, ultra-simple, 35-lines-of-code async parallel forEach / map function for JavaScript.asyncforEacheachmapasynchronousiterationiterateloopparallelconcurrentarrayflowcontrol flowpaulmillr‚Ä¢ 1.0.6 ‚Ä¢ 2 years ago ‚Ä¢  500 dependents ‚Ä¢  MITpublished version 1.0.6, 2 years ago500 dependents licensed under $MIT29,300,562queueasynchronous function queue with adjustable concurrencyqueueasyncasynchronoussynchronousjobtaskconcurrencyconcurrentjessetane‚Ä¢ 7.0.0 ‚Ä¢ 2 years ago ‚Ä¢  611 dependents ‚Ä¢  MITpublished version 7.0.0, 2 years ago611 dependents licensed under $MIT25,271,866node-dirasynchronous file and directory operations for Node.jsnode-dirdirectorydirsubdirfileasynchronousNode.jsfsfshost‚Ä¢ 0.1.17 ‚Ä¢ 8 years ago ‚Ä¢  991 dependents ‚Ä¢  MITpublished version 0.1.17, 8 years ago991 dependents licensed under $MIT26,474,492@sec-ant/readable-streamA tiny, zero-dependency yet spec-compliant asynchronous iterator polyfill/ponyfill for ReadableStreams.streamweb-streamsreadablestreamasyncasynchronousiteratoriterationasync-iteratorpolyfillesmfrom-iterablesec-ant‚Ä¢ 0.6.0 ‚Ä¢ 7 months ago ‚Ä¢  2 dependents ‚Ä¢  MITpublished version 0.6.0, 7 months ago2 dependents licensed under $MIT14,670,438bfjBig-friendly JSON. Asynchronous streaming functions for large JSON data sets.jsonstreamifystringifywalkparseparserserialiseserializereadwriteasyncasynchronousphilbooth‚Ä¢ 9.1.2 ‚Ä¢ 3 months ago ‚Ä¢  2,155 dependents ‚Ä¢  MITpublished version 9.1.2, 3 months ago2155 dependents licensed under $MIT17,372,454exit-hookRun some code when the process exitsexitquitprocesshookgracefulhandlershutdownsigtermsigintterminatekillstopeventsignalView moresindresorhus‚Ä¢ 4.0.0 ‚Ä¢ 2 years ago ‚Ä¢  340 dependents ‚Ä¢  MITpublished version 4.0.0, 2 years ago340 dependents licensed under $MIT13,106,085run-seriesRun an array of functions in seriesseriesasyncfunctioncallbackasynchronousrunarrayrun seriesfeross‚Ä¢ 1.1.9 ‚Ä¢ 4 years ago ‚Ä¢  167 dependents ‚Ä¢  MITpublished version 1.1.9, 4 years ago167 dependents licensed under $MIT5,600,677run-parallel-limitRun an array of functions in parallel, but limit the number of tasks executing at the same timeparallelasyncfunctioncallbackasynchronousrunarrayrun parallellimitmaxqueuerun parallel limitmax taskstasksfeross‚Ä¢ 1.1.0 ‚Ä¢ 4 years ago ‚Ä¢  65 dependents ‚Ä¢  MITpublished version 1.1.0, 4 years ago65 dependents licensed under $MIT5,206,181stenoSpecialized fast async file writerfsfilewritewriterasynchronousfastraceconditionatomicwritingsafetypicode‚Ä¢ 4.0.2 ‚Ä¢ a year ago ‚Ä¢  62 dependents ‚Ä¢  MITpublished version 4.0.2, a year ago62 dependents licensed under $MIT4,133,102scrypt-jsThe scrypt password-based key derivation function with sync and cancellable async.scryptpbkdfpasswordasyncasynchronousstepwisericmoo‚Ä¢ 3.0.1 ‚Ä¢ 5 years ago ‚Ä¢  405 dependents ‚Ä¢  MITpublished version 3.0.1, 5 years ago405 dependents licensed under $MIT4,859,917deferredModular and fast Promises implementationasyncasynchronousdeferredflowfuturefuturespromisepromisescontinuationsmedikoo‚Ä¢ 0.7.11 ‚Ä¢ 6 years ago ‚Ä¢  187 dependents ‚Ä¢  ISCpublished version 0.7.11, 6 years ago187 dependents licensed under $ISC3,849,219whenA lightweight Promises/A+ and when() implementation, plus other async goodies.cujoPromises/A+promises-apluspromisepromisesdeferreddeferredswhenasyncasynchronousendercujojs‚Ä¢ 3.7.8 ‚Ä¢ 8 years ago ‚Ä¢  1,436 dependents ‚Ä¢  MITpublished version 3.7.8, 8 years ago1436 dependents licensed under $MIT5,024,171react-async-scriptA composition mixin for loading scripts asynchronously for Reactreactasynchronousscript-loaderdozoisch‚Ä¢ 1.2.0 ‚Ä¢ 5 years ago ‚Ä¢  67 dependents ‚Ä¢  MITpublished version 1.2.0, 5 years ago67 dependents licensed under $MIT3,298,868@nevware21/ts-asyncsupport for asynchronous development with a Promise based task Scheduler, several different Promise implementations (synchronous, idle, asynchronous and native runtime wrappers), await helpers, and aliases all built and tested using TypeScript.typescriptjavascriptes5promisees6.promiseasyncasynchronousasync promiseasynchronous promisesyncsynchronoussync promisesynchronous promiseidleView morenevware21bot‚Ä¢ 0.5.4 ‚Ä¢ 4 months ago ‚Ä¢  15 dependents ‚Ä¢  MITpublished version 0.5.4, 4 months ago15 dependents licensed under $MIT1,807,310p-iterationMake array iteration easy when using async/await and Promisesasync/awaitasyncawaitasynchronousawaitableasync functionarrayiterationforEachmapeverysomefilterreduceantonvs‚Ä¢ 1.1.8 ‚Ä¢ 6 years ago ‚Ä¢  150 dependents ‚Ä¢  MITpublished version 1.1.8, 6 years ago150 dependents licensed under $MIT2,081,597@stdlib/utils-next-tickAdd a callback to the next tick queue.stdlibstdutilsstdutilutilsutilutilitiesutilityprocessnextticknextticksettimeoutsetimmediateasyncView morestdlib-bot‚Ä¢ 0.2.2 ‚Ä¢ 9 months ago ‚Ä¢  73 dependents ‚Ä¢  Apache-2.0published version 0.2.2, 9 months ago73 dependents licensed under $Apache-2.01,562,301d3-queueEvaluate asynchronous tasks with configurable concurrency.d3d3-moduleasynchronousasyncqueuembostock‚Ä¢ 3.0.7 ‚Ä¢ 8 years ago ‚Ä¢  195 dependents ‚Ä¢  BSD-3-Clausepublished version 3.0.7, 8 years ago195 dependents licensed under $BSD-3-Clause1,220,380set-interval-asyncModern version of setInterval for promises and async functions available in Node.js and browsers.setIntervalsetTimeoutclearIntervalclearTimeoutintervaltimeoutmillisecondssecondspromisepromisesasyncasynchronousawaitrecurrentView moreealmansi‚Ä¢ 3.0.3 ‚Ä¢ 2 years ago ‚Ä¢  74 dependents ‚Ä¢  MITpublished version 3.0.3, 2 years ago74 dependents licensed under $MIT941,210123‚Ä¶50¬ª\n\n\n\nrubenverborghRuben Verborgh@RubenVerborgh@RubenVerborgh707 Packages0 OrganizationsPackages 707alzheimerAdvanced memoization with promise and stream supportrubenverborghpublished 0.1.2 ‚Ä¢ 12 years agopublished version 0.1.2, 12 years agoeyeserverEYE reasoner serverrubenverborghpublished 1.1.2 ‚Ä¢ 6 years agopublished version 1.1.2, 6 years agoresourcecacheCaches resources from a string or URL in local files.rubenverborghpublished 0.1.2 ‚Ä¢ 12 years agopublished version 0.1.2, 12 years agochai-thingsChai Things adds support to [Chai](http://chaijs.com/) for assertions on array elements.rubenverborghpublished 0.2.0 ‚Ä¢ 12 years agopublished version 0.2.0, 12 years agopromiscuousA minimal and fast promise implementationrubenverborghpublished 0.7.2 ‚Ä¢ 7 years agopublished version 0.7.2, 7 years agosparql-parserSPARQL parser using rdfstore-js code, outputting an N3.js-compatible formatrubenverborghpublished 0.1.4 ‚Ä¢ 11 years agopublished version 0.1.4, 11 years agoldfLinked Data Fragmentsrubenverborghpublished 0.0.1 ‚Ä¢ 11 years agopublished version 0.0.1, 11 years agogit2provUnleash the potential of Git in the new W3C standard for provenance.rubenverborghpublished 0.1.2 ‚Ä¢ 11 years agopublished version 0.1.2, 11 years agonegotiateA JavaScript implementation of proper HTTP content negotiation.rubenverborghpublished 1.0.1 ‚Ä¢ 11 years agopublished version 1.0.1, 11 years agofollow-redirectsHTTP and HTTPS modules that follow redirects.rubenverborghpublished 1.15.9 ‚Ä¢ 8 months agopublished version 1.15.9, 8 months agoldf-clientLinked Data Fragments Clientrubenverborghpublished 2.0.5 ‚Ä¢ 8 years agopublished version 2.0.5, 8 years agotsv-to-jsonTSV to JSON convertorrubenverborghpublished 0.2.0 ‚Ä¢ 10 years agopublished version 0.2.0, 10 years agoldf-serverLinked Data Fragments Serverrubenverborghpublished 2.2.5 ‚Ä¢ 6 years agopublished version 2.2.5, 6 years agon3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.jeswrpublished 1.25.2 ‚Ä¢ 8 days agopublished version 1.25.2, 8 days agosparqljsA parser for the SPARQL query languagerubenverborghpublished 3.7.3 ‚Ä¢ 8 months agopublished version 3.7.3, 8 months agordfliban RDF library for node.js. Suitable for client and server side.timblpublished 2.2.37 ‚Ä¢ 2 months agopublished version 2.2.37, 2 months agohdtNative bindings to access HDT compressed triple files.rubensworkspublished 3.2.2 ‚Ä¢ 2 months agopublished version 3.2.2, 2 months agosolid-serverSolid server on top of the file-systembourgeoapublished 5.8.5 ‚Ä¢ 2 months agopublished version 5.8.5, 2 months agosolid-uiUI library for writing Solid read-write-web applicationsrubenverborghpublished 2.5.1 ‚Ä¢ 3 months agopublished version 2.5.1, 3 months agomashlibData mashup libraryrubenverborghpublished 1.10.4 ‚Ä¢ 2 months agopublished version 1.10.4, 2 months agoasynciteratorAn asynchronous iterator library for advanced object pipelines.rubenverborghpublished 3.9.0 ‚Ä¢ a year agopublished version 3.9.0, a year agosolid-permissionsWeb Access Control based permissions librarykjetilkpublished 0.6.0 ‚Ä¢ 7 years agopublished version 0.6.0, 7 years agooidc-auth-managerAn OpenID Connect (OIDC) authentication manager (OP, RP and RS) for decentralized peer-to-peer authenticationcodenamedmitripublished 0.16.1 ‚Ä¢ 7 years agopublished version 0.16.1, 7 years agosolid-auth-clientOpaquely authenticates solid clientsbourgeoapublished 2.5.6 ‚Ä¢ 4 years agopublished version 2.5.6, 4 years agowac-allowParser of the WAC-Allow HTTP header.rubenverborghpublished 1.0.0 ‚Ä¢ 8 years agopublished version 1.0.0, 8 years agoshow more packages\n\nrubenverborghRuben Verborgh@RubenVerborgh@RubenVerborgh707 Packages0 OrganizationsPackages 707alzheimerAdvanced memoization with promise and stream supportrubenverborghpublished 0.1.2 ‚Ä¢ 12 years agopublished version 0.1.2, 12 years agoeyeserverEYE reasoner serverrubenverborghpublished 1.1.2 ‚Ä¢ 6 years agopublished version 1.1.2, 6 years agoresourcecacheCaches resources from a string or URL in local files.rubenverborghpublished 0.1.2 ‚Ä¢ 12 years agopublished version 0.1.2, 12 years agochai-thingsChai Things adds support to [Chai](http://chaijs.com/) for assertions on array elements.rubenverborghpublished 0.2.0 ‚Ä¢ 12 years agopublished version 0.2.0, 12 years agopromiscuousA minimal and fast promise implementationrubenverborghpublished 0.7.2 ‚Ä¢ 7 years agopublished version 0.7.2, 7 years agosparql-parserSPARQL parser using rdfstore-js code, outputting an N3.js-compatible formatrubenverborghpublished 0.1.4 ‚Ä¢ 11 years agopublished version 0.1.4, 11 years agoldfLinked Data Fragmentsrubenverborghpublished 0.0.1 ‚Ä¢ 11 years agopublished version 0.0.1, 11 years agogit2provUnleash the potential of Git in the new W3C standard for provenance.rubenverborghpublished 0.1.2 ‚Ä¢ 11 years agopublished version 0.1.2, 11 years agonegotiateA JavaScript implementation of proper HTTP content negotiation.rubenverborghpublished 1.0.1 ‚Ä¢ 11 years agopublished version 1.0.1, 11 years agofollow-redirectsHTTP and HTTPS modules that follow redirects.rubenverborghpublished 1.15.9 ‚Ä¢ 8 months agopublished version 1.15.9, 8 months agoldf-clientLinked Data Fragments Clientrubenverborghpublished 2.0.5 ‚Ä¢ 8 years agopublished version 2.0.5, 8 years agotsv-to-jsonTSV to JSON convertorrubenverborghpublished 0.2.0 ‚Ä¢ 10 years agopublished version 0.2.0, 10 years agoldf-serverLinked Data Fragments Serverrubenverborghpublished 2.2.5 ‚Ä¢ 6 years agopublished version 2.2.5, 6 years agon3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.jeswrpublished 1.25.2 ‚Ä¢ 8 days agopublished version 1.25.2, 8 days agosparqljsA parser for the SPARQL query languagerubenverborghpublished 3.7.3 ‚Ä¢ 8 months agopublished version 3.7.3, 8 months agordfliban RDF library for node.js. Suitable for client and server side.timblpublished 2.2.37 ‚Ä¢ 2 months agopublished version 2.2.37, 2 months agohdtNative bindings to access HDT compressed triple files.rubensworkspublished 3.2.2 ‚Ä¢ 2 months agopublished version 3.2.2, 2 months agosolid-serverSolid server on top of the file-systembourgeoapublished 5.8.5 ‚Ä¢ 2 months agopublished version 5.8.5, 2 months agosolid-uiUI library for writing Solid read-write-web applicationsrubenverborghpublished 2.5.1 ‚Ä¢ 3 months agopublished version 2.5.1, 3 months agomashlibData mashup libraryrubenverborghpublished 1.10.4 ‚Ä¢ 2 months agopublished version 1.10.4, 2 months agoasynciteratorAn asynchronous iterator library for advanced object pipelines.rubenverborghpublished 3.9.0 ‚Ä¢ a year agopublished version 3.9.0, a year agosolid-permissionsWeb Access Control based permissions librarykjetilkpublished 0.6.0 ‚Ä¢ 7 years agopublished version 0.6.0, 7 years agooidc-auth-managerAn OpenID Connect (OIDC) authentication manager (OP, RP and RS) for decentralized peer-to-peer authenticationcodenamedmitripublished 0.16.1 ‚Ä¢ 7 years agopublished version 0.16.1, 7 years agosolid-auth-clientOpaquely authenticates solid clientsbourgeoapublished 2.5.6 ‚Ä¢ 4 years agopublished version 2.5.6, 4 years agowac-allowParser of the WAC-Allow HTTP header.rubenverborghpublished 1.0.0 ‚Ä¢ 8 years agopublished version 1.0.0, 8 years agoshow more packages\n\n\n\njeswrJesse Wright@jeswr562 Packages0 OrganizationsPackages 562n3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.jeswrpublished 1.25.2 ‚Ä¢ 8 days agopublished version 1.25.2, 8 days agorabelLinked Data command line utilityjeswrpublished 1.1.1 ‚Ä¢ a month agopublished version 1.1.1, a month ago@comunica/actor-query-operation-askA ask query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-abstract-mediatypedAn abstract actor for handling mediatypesrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-http-nativeA native http actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-http-node-fetchA node-fetch http actorrubensworkspublished 1.22.3 ‚Ä¢ 4 years agopublished version 1.22.3, 4 years ago@comunica/actor-query-operation-bgp-emptyA bgp-empty query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-bgp-left-deep-smallest-sortA bgp-left-deep-smallest-sort query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-bgp-singleA bgp-single query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-bgp-left-deep-smallestA bgp-left-deep-smallest query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-distinct-hashA distinct-hash query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-constructA construct query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-from-quadA from query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-filter-directA filter-direct query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-joinA join query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-leftjoin-nestedloopA leftjoin nestedloop query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-orderby-directA orderby-direct query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-projectA project query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-quadpatternA quadpattern query-operation actorrubensworkspublished 2.10.1 ‚Ä¢ a year agopublished version 2.10.1, a year ago@comunica/actor-query-operation-sliceA slice query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-unionA union query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-valuesA values query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-rdf-dereference-http-parseA node-fetch http actorrubensworkspublished 1.22.3 ‚Ä¢ 4 years agopublished version 1.22.3, 4 years ago@comunica/actor-rdf-dereference-paged-nextA hydra rdf-dereference-paged actorrubensworkspublished 1.22.2 ‚Ä¢ 4 years agopublished version 1.22.2, 4 years ago@comunica/actor-rdf-join-hashA hash rdf-join actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years agoshow more packages\n\njeswrJesse Wright@jeswr562 Packages0 OrganizationsPackages 562n3Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.jeswrpublished 1.25.2 ‚Ä¢ 8 days agopublished version 1.25.2, 8 days agorabelLinked Data command line utilityjeswrpublished 1.1.1 ‚Ä¢ a month agopublished version 1.1.1, a month ago@comunica/actor-query-operation-askA ask query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-abstract-mediatypedAn abstract actor for handling mediatypesrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-http-nativeA native http actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-http-node-fetchA node-fetch http actorrubensworkspublished 1.22.3 ‚Ä¢ 4 years agopublished version 1.22.3, 4 years ago@comunica/actor-query-operation-bgp-emptyA bgp-empty query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-bgp-left-deep-smallest-sortA bgp-left-deep-smallest-sort query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-bgp-singleA bgp-single query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-bgp-left-deep-smallestA bgp-left-deep-smallest query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-distinct-hashA distinct-hash query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-constructA construct query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-from-quadA from query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-filter-directA filter-direct query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-joinA join query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-leftjoin-nestedloopA leftjoin nestedloop query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-orderby-directA orderby-direct query-operation actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years ago@comunica/actor-query-operation-projectA project query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-quadpatternA quadpattern query-operation actorrubensworkspublished 2.10.1 ‚Ä¢ a year agopublished version 2.10.1, a year ago@comunica/actor-query-operation-sliceA slice query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-unionA union query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-query-operation-valuesA values query-operation actorrubensworkspublished 4.1.0 ‚Ä¢ 2 months agopublished version 4.1.0, 2 months ago@comunica/actor-rdf-dereference-http-parseA node-fetch http actorrubensworkspublished 1.22.3 ‚Ä¢ 4 years agopublished version 1.22.3, 4 years ago@comunica/actor-rdf-dereference-paged-nextA hydra rdf-dereference-paged actorrubensworkspublished 1.22.2 ‚Ä¢ 4 years agopublished version 1.22.2, 4 years ago@comunica/actor-rdf-join-hashA hash rdf-join actorrubensworkspublished 1.22.0 ‚Ä¢ 4 years agopublished version 1.22.0, 4 years agoshow more packages\n\n\n\nContact UsGet help with the npm registry or your npm account.Please contact us if you need help with the npm registry or with your npm account, if you are reporting security concerns in an npm product, or if you need to report malicious or abusive behavior in a package in the registry.How can we help?I'm reporting spam, abuse or a security issueMy Security IssueI am reporting malware in a package on npmjs.comAsterisk (*) Indicates Required Field Name *Email *Subject *Package *Version *How can we help? *Verify you are a humanSubmitnpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you‚Äôre working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to ¬†press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\nContact UsGet help with the npm registry or your npm account.Please contact us if you need help with the npm registry or with your npm account, if you are reporting security concerns in an npm product, or if you need to report malicious or abusive behavior in a package in the registry.How can we help?I'm reporting spam, abuse or a security issueMy Security IssueI am reporting malware in a package on npmjs.comAsterisk (*) Indicates Required Field Name *Email *Subject *Package *Version *How can we help? *Verify you are a humanSubmitnpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you‚Äôre working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to ¬†press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\n\n\nContact UsYou need to be signed in to get help with npm.Sign in for assistanceCan't sign in, or don't have an account?Choose one of these categories to continue.Account or billing issuesCopyright or trademark data removalDispute a package, org, or usernameReport a security issue or abusenpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you‚Äôre working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to ¬†press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\nContact UsYou need to be signed in to get help with npm.Sign in for assistanceCan't sign in, or don't have an account?Choose one of these categories to continue.Account or billing issuesCopyright or trademark data removalDispute a package, org, or usernameReport a security issue or abusenpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you‚Äôre working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to ¬†press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\n\n\nAbout npm
      
        npm, Inc. is a company founded in 2014, and was acquired by GitHub in 2020. npm is a critical part of the
        JavaScript community and helps support one of the largest developer ecosystems in the world.
      
      npm is lots of things.
      
        
          
            npm is the package manager for Node.js. It was created in
            2009 as an open source project  to help JavaScript
            developers easily share packaged modules of code.
          
        
        
          
            The npm Registry is a public collection of packages of open-source code for Node.js, front-end web apps,
            mobile apps, robots, routers, and countless other needs of the JavaScript community.
          
        
        
          
            npm is the command line client that allows developers to install and publish those packages.\n\nAbout npm
      
        npm, Inc. is a company founded in 2014, and was acquired by GitHub in 2020. npm is a critical part of the
        JavaScript community and helps support one of the largest developer ecosystems in the world.
      
      npm is lots of things.
      
        
          
            npm is the package manager for Node.js. It was created in
            2009 as an open source project  to help JavaScript
            developers easily share packaged modules of code.
          
        
        
          
            The npm Registry is a public collection of packages of open-source code for Node.js, front-end web apps,
            mobile apps, robots, routers, and countless other needs of the JavaScript community.
          
        
        
          
            npm is the command line client that allows developers to install and publish those packages.\n\n\n\nAbout
      Press
  



    
    
    
    

    Press

    


  
    
  
    

    
        Founded in February, 2008
    
  

  
    

    
      HQ in San Francisco
    
  

  
    

    
      Product updates
    
  

  
    

    
      GitHub glossary
    
  

  
    

    
      Media resources
    
  

  
    

    
       press@github.com
     
  


  

  
      
  
    
      ZDNet Korea
      [ÌòÑÏû•] ÍπÉÌóàÎ∏å "ÏΩîÌååÏùºÎüø, Í∞úÎ∞ú Ìå®Îü¨Îã§ÏûÑ Î∞îÍøî‚Ä¶ROI Îã¨ÏÑ± Í∞ÄÎä•"
    
    Mar 26, 2025


      
  
    
      Practical AI Podcast
      AI-assisted coding with GitHub's COO
    
    Mar 21, 2025


      
  
    
      No Priors 
      Episode 106: GitHub CEO Thomas Dohmke
    
    Mar 13, 2025


      
  
    
      The Guardian
      How ‚ÄòAI agents‚Äô will change the internet 
    
    Mar 9, 2025


      
  
    
      WirtschaftsWoche
      Ein B√ºro? Gibt‚Äôs bei uns nicht
    
    Mar 4, 2025


      
  
    
      Wall Street Journal
      How AI Tools Are Reshaping the Coding Workforce
    
    Mar 4, 2025


      
  
    
      TI Inside
      Exposi√ß√£o total: uma abordagem pr√°tica para lidar com vazamentos de dados sens√≠veis
    
    Mar 3, 2025


      
  
    
      The New York Times 
      A.I. is Prompting an Evolution, Not Extinction, for Coders 
    
    Feb 20, 2025


      
  
    
      itforum
      Botic√°rio inova com uso do GitHub Copilot, gera menos tarefas repetitivas e foca em valor ao neg√≥cio
    
    Feb 19, 2025


      
  
    
      IT Forum
      Botic√°rio inova com uso do GitHub Copilot, gera menos tarefas repetitivas e foca em valor ao neg√≥cio
    
    Feb 19, 2025


      
  
    
      Infosecurity Magazine
      Full Exposure: A Practical Approach to Handling Sensitive Data Leaks
    
    Feb 7, 2025


      
  
    
      TechCrunch
      GitHub Copilot brings mockups to life by generating code from images
    
    Feb 6, 2025


      
  
    
      Forbes
      GitHub code now has ‚Äòdata residency‚Äô in Australia
    
    Feb 5, 2025


      
  
    
      Accessibility and GenAI 
      Ep 5 - Ed Summers - Head of Accessibility, GitHub
    
    Feb 4, 2025


      
  
    
      FAZ
      DLD: Technologien und Talente pr√§gen den Arbeitsmarkt im KI-Zeitalter
    
    Jan 22, 2025


      
  
    
      Financial Express
      ‚ÄòWhere developers reside, innovation blooms‚Äô
    
    Jan 20, 2025


      
  
    
      Inforchannel
      GitHub anuncia tr√™s tend√™ncias de desenvolvimento de software para 2025
    
    Jan 17, 2025


      
  
    
      Help Net Security 
      GitHub CISO on security strategy and collaborating with the open source community
    
    Jan 13, 2025


  

    
      
        Previous 1 2 3 4 5 ‚Ä¶ 58 59 Next\n\n\n\n