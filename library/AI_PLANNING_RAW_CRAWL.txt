Report an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Guide  Contributors: The guide here provides an introduction designed for developers, undergraduates and post-graduates with no prior experience in the world of planning & scheduling and/or optimisation research. It is not a substitute for a thorough academic course, or the copious amounts of academic literature written on planning but does provide a solid basis from which to understand and use planning. The guide is constantly being developed and improved, so if you have any criticisms or feedback we really do truly value it. Especially if you’re not a planning expert, as you’re the target of this guide!  Table of contents   What is AI Planning?   What is PDDL?   What is a planner?\n\n\n\nReport an issue with this page         Guide What is AI Planning?      What is AI Planning?  Contributors: Adam Green,   Introduction  AI Planning is a field of Artificial Intelligence which explores the process of using autonomous techniques to solve planning and scheduling problems. A planning problem is one in which we have some initial starting state, which we wish to transform into a desired goal state through the application of a set of actions. In a simple example, imagine we wish to build a house. On our building site we can assume all the materials are ready to be used and we essentially now have to decide which order to perform construction in. Each step of construction in this situation could be modelled as an action (for example laying foundations, building the walls, installing the plumbing and electricals etc.). Certain actions cannot happen before others - we cannot build a wall before we have a foundation - so through the use of predicate logic we can express this problem by saying “if there is no foundation, we cannot build a wall”. AI planning can leverage this form of expression in order to solve this problem and others. Of course in reality planning the construction of a house is not particularly difficult, but imagine instead we were planning the construction of an Olympic stadium. The same problem can be broken down into similar simple tasks which are dependent on prior conditions being met.   Domain Independent Planning  The core philosophy built into PDDL (Ghallab et al., 1998), and as a result many planners, is that the techniques applied to solving a problem should know nothing about the problem they are solving. That is to say the techniques which we apply to solve for example a logistics problem, we could also apply to a manufacturing problem. This is interesting because unlike other fields of Artificial Intelligence, such as Machine Learning, we are not dependent on there being pre-existing information on the problem, or an example path to a solution. All we need is the starting state, the actions we can apply and the desired end state. Often these three pieces of information are readily available, purely from the nature inherent to the problems a planner is trying to solve. Simply put, you don’t start planning until you know what you’re trying to achieve. For example if we are planning the construction of large stadium, we know what needs to be completed in order for the stadium to be finished, we know that there is currently no stadium built and we know the different actions that can be performed to change the state closer to the position we desire it to be in (build frames, install pipework, raise flags etc.). We need no knowledge of how previous stadiums were built, or what orderings were used (for example building foundations then frames etc.). This lack of need for knowledge means we can apply planning to problems which have not been previously solved. Also, if we assume that previous solutions to a planning problem are sub-optimal (i.e. they’re not as good as they could be), applying a technique like learning would essentially train to solve problems sub-optimally. Therefore we need an appraoch which is methodical, objective and avoids learning from prior approaches which are sub-optimal (read as domain independent).   State Space Search  Although there is a lot more to solving a plan than a state space search, the general (but not universal) unifying factor of different planners is that they perform some kind of “state space” search. If we imagine that from the initial state, we can access various new states, by applying actions, the result is we form a tree of possible states, with the initial state being the root. From that root we perform a search, attempting to find a state as close as possible to the root, which has all of the facts we need in order to satisfy the goal. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is a planner?      What is a planner?  Contributors: Adam Green,   Introduction  An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances. This guide again will focus primarily on the best general purpose planners, in order to complement the focus on general purpose syntax.   Using AI Planners  Almost all AI planners are built with linux based compilation in mind. Some planners have been successfully ported to Windows and Mac and in some cases, the way in which their source code is written makes them easy to port (such as the Java based planner JavaFF). Planners aren’t often distributed in binary form and so often have to be compiled. This guide does not provide approaches for compiling planners. Any guidance on how to compile a planner is provided as guidance only and the planner’s creator should be contacted directly if help is needed with compilation. Once you have a compiled binary for a planner, most planners are designed to be run on the command line. Most planners follow one of two syntaxes for inputting a domain and problem file     ./<planner> <domain> <problem>
     ./<planner> -o <domain> -f <problem>
 The variance largely comes from the fact that the domain file at one point was considered to contain “operators” and the problem file contains “facts” hence the use of command line arguments “o” and “f”. As research tools, planners don’t tend to just pass out a plan onto the output, but rather provide feedback on the problem decomposition and search process it’s conducting. Eviscerator, the planner testing tool, uses a regex argument to automatically detect the plans in the output of the planner. This allows it to handle different planners which use different outputs.   Planner Support  For the benefit of users, this guide has - where possible - provided support tables for planners. These support tables allow you to identify what features a planner does and does not support and make decisions about what planner to apply to the problem you’re writing.\n\n\n\nReport an issue with this page          Reference  Contributors: Adam Green, The reference here is provided to help support developers, researchers and other end users of planning and PDDL with getting quick and easy information to hand whenever and wherever they need it. Our reference offers succinct, clear guidance on a variety of levels of the language and a growing set of docs on the planners you can use to run the language itself  Table of contents   PDDL   PDDL 2.1   PDDL 2.2   PDDL 3   PDDL+   Planners\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.1 has to be extended in order to complement the syntax of the domain file. One interesting extension to the syntax in PDDL 2.1 is the addition of a metric. A metric, which behaves like an optimisation function, defines a cost value for a plan. We then express whether we want this metric to be maximised (like in football) or minimised (like in golf). (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
   Contents   Numeric Fluents Metric Length    Numeric Fluents  back to contents Support: High Usage: High     (= (<fluent_name> <argument>) <value>)
 An equals prefix notation is used to assign a value to a numeric fluent. Some planners will require all possible numeric values for numeric fluents should be declared before it will attempt to plan.     (= (battery-amount r1) 10)
   Metric  back to contents Support: Medium Usage: High     (:metric minimize (<numeric_operation>))
     (:metric maximize (<numeric_operation>))
 A metric can be defined using some numeric operation on fluents, including using just a single fluent. The most common method for declaring a metric, is to declare a numeric fluent with no arguments and increase it within the effect of each action by the cost of that action. We can choose to either minimize or maximize the value of the metric function. Note, a metric function is NOT a replacement for a goal.   Length  back to contents Support: Deprecated Usage: Rare/None The length argument is deprecated. Few planners will support it (if any).\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.2      PDDL 2.2  Contributors: Adam Green,   Introduction  PDDL 2.2 {$ cite pddl222004 %} introduces a key new feature not previously considered in PDDL, Timed Initial Literals. In previous versions, we assumed that a predicate was either true or false at the start. This is not a realistic way of modelling because it fails to consider facts which may become true later. For example, in dynamic planning, where we are planning and re-planning as the world changes, we may wish to represent resources or states which are in the course of changing which we have no control over. Imagine for instance, we are planning a rail schedule. We’ve generated some schedule from a plan, which the trains at this point in time are currently running to. Something goes wrong, for example a train breaks down. We now have less resources, but what we also have is a state that is currently in motion. So for example we may have another dozen trains currently in use that won’t become available until some later stage than the point we’re currently planning at. We can’t represent these realistically with actions because actions are optional, instead we need some mechanism to represent the uncontrollable change of state at a later point in time. This is what timed initial literals allow us to do, by indicating at what point in time a fact which was previously false, becomes true. Now we could arguably jury rig this behaviour with cleverly created durative actions and predicates, that are forced to run at a certain point and then subsequently release the resource after the time has elapsed, but these approaches will almost certainly have a significant overhead to them, because creating a durative action which the planners has to figure out it has to run in order to do everything else, will increase the state space necessary to explore. Bottom line, Timed Initial Literals add a simple yet powerful new aspect to planning. PDDL 2.2 also reintroduces Axioms as derived predicates, with a different simpler syntax to them. To be clear, these features are the same but consist of different syntax, typically planners support the newer syntax. *This is speculative.   Table of contents   PDDL 2.2 Domain   PDDL 2.2 Problem   PDDL 2.2 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Domain      Domain  Contributors: Adam Green, Benjamin Jacob Reji, Jan Dolejsi, The domain syntax for PDDL2.2 adds very minimal changes to the domain. As with any update to PDDL it introduces new requirements, however, other than that the only new syntax is Derived Predicates, which are defined in a similar way to how actions are defined, and are defined in the same section of the domain file. (define
    (domain railways)
    (:requirements :derived-predicates :timed-initial-literals)
    (:types
        train station - object
    )
    (:predicates
        (train-not-in-use ?t - train)
        (train-has-guard ?t - train)
        (train-has-driver ?t - train)
        (train-usable ?t - train)
    )
    (:functions
        ... - omitted
    )
    (:durative-action MOVE-TRAIN
        ... - omitted
    )
    (:derived (train-usable ?t - train)
        (and
            (train-has-guard ?t)
            (train-has-driver ?t)
        )
    )
    (:derived
        ... - omitted
    )
)
   Contents   Requirements Derived Predicates    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL2.2 to the language of PDDL.  :derived-predicates :timed-initial-literals    Derived Predicates  back to contents Support: Medium Usage: Low     (:derived <predicate_name> <logical_expression>)
 A derived predicate is declared by naming the predicate who’s result is being derived, and a logical expression which is evaluated to work out the value. Note, that a derived predicate is declared similarly to actions, in that we use the :derived keyword for each declaration of a derived predicate. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
 The example above specifies that a train is only usable if it has a guard and a driver.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.2 is expanded very lightly in order to support Timed Initial Literals. The choice of keyword is an interesting one because at is a commonly used predicate name used to indicate that some locatable is in some location i.e. (at Adam Bush-House). The way in which this keyword is used to define timed initial literals means however that it should not conflict with domains that make use of at as a predicate name. However, this is entirely dependent on how the planner parses a plan. (define
    (problem trainplanning1)
    (:domain railways)
    (:objects
        Pompey Guildford London - station
        train1 train2 - train
    )
    (:init
        (train-not-in-use train1)
        (at 20 (train-not-in-use train2))
    )

    ... goal omitted
)
   Contents   Timed Initial Literals    Timed Initial Literals  back to contents Support: Medium Usage: Medium     (at <time_value> <predicate>)
 A timed initial literal is defined using the time keyword, followed by the value for the point in time which the predicate becomes true, followed by the predicate itself. In planning, time is treated as just a number, and no assumptions are made about the scale it represents, therefore writing something such as at 10 could express 10 seconds, minutes or indeed hours. Ultimately it is the responsibility of the modelling user to determine what scale they wish to map their model to, and therefore the “resolution” they get for the accuracy of time.     (at 20 (train-not-in-use train2))
 The statement above expresses that at some time 20, the train train2 will no longer be in use.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Requirements      Requirements (PDDL 2.2)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 2.2.   Derived Predicates  Support: Medium Usage: Low     (:requirements :derived-predicates)
 Allows the usage of derived predicates in domains. e.g. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
   Timed Initial Literals  Support: Medium Usage: Medium     (:requirements :timed-initial-literals)
 Allows the use of Timed Initial Literals when defining problems. e.g.     (at 10 (train-not-in-use t1))\n\n\n\nReport an issue with this page         Reference PDDL 3      PDDL 3.0  Contributors: Adam Green,   Introduction  PDDL 3.0 (Gerevini & Long, 2005) introduced soft goals to planning. As planning has grown to handle larger more complex problem, the way we express goals has had to change. In previous editions a goal was unavoidable. It had to be met in order for a a plan to be considered valid. With the introduction of preferences (soft goals), we are now able to express a desireable, but inconsequential goal. A goal which we would like to be satisfied but if it is not, then that is acceptable. For each soft goal we express, we include a cost for not meeting it. This cost essentially indicates how the plan quality is affected when such goal is not met. PDDL 3.0 also introduced constraints, a form of strong goal, which essentially can use the same keywords as used for preferences, but instead must be met for the plan to be considered valid. This allows us to express things such as facts that must become true after another, or facts which must always be true. See the keywords included in the Constraints and Preferences sections below. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.  Table of contents   PDDL 3 Domain   PDDL 3 Problem   PDDL 3 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Requirements      Requirements (PDDL 3.0)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 3.0.   Preferences  Support: Medium Usage: Medium     (:requirements :preferences)
 Allows for the usage of preferences within problem definitions (soft goals).   Constraints  Support: Medium Usage: Low     (:requirements :constraints)
 Allows for the use of constraints within domain definitions (goals which must be satisfied in every state). e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
    )
)\n\n\n\nReport an issue with this page         Reference PDDL+      PDDL+  Contributors: Adam Green, PDDL+ (missing reference) introduced processes and events, to the domain of PDDL. Where previous updates to PDDL had introduced intractable rules such as Derived Predicates and Constraints, PDDL+ is the first to consider essentially actions which must be applied when their preconditions are met. Processes directly correspond to a durative action and last for as long as their pre-condition is met. A process is something like gravity’s effect on a ball, increases the velocity of the ball until it either reaches terminal velocity or indeed, it hits the ground. Events directly correspond to instantaneous actions, and happen the instant their preconditions are met, usually with the effect of transforming their state such that their precondition is no longer met. Events are uncontrollable, and in our ball example, we might consider an event to be the ball hitting the ground. In that instance, the velocity of the ball is negated, and multiplied by some bounce coefficient. Processes and events are still very much a challenge for some planners, and support is somewhat patch, with certain planners losing support for earlier features in PDDL in order to support this new feature. Most notably, Processes can (and usually do) have a continuous effect in a state, and therefore cause problems if we define a preference such as preference (always (< (velocity ball) 10)).   Table of contents   PDDL+ Domain\n\n\n\nReport an issue with this page         Reference PDDL+ PDDL+ Domain      Domain  Contributors: Adam Green, Jan Dolejsi, PDDL+ (missing reference) introduces two new constructs to domains in PDDL, the first is Processes and the second is Events, both can essentially be thought of as uncontrollable durative actions, and uncontrollable instantaneous actions respectively. (define
    (domain ballphysics)
    (:requirements :time :typing)
    (:types
        ball - object
    )
    (:predicates
        (held ?b - ball)
    )
    (:functions
        (velocity ?b - ball)
        (distance-to-floor ?b - ball)
    )
    (:process FALLING
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (< (velocity ?b) 100)
        )
        :effect (and
            (increase (velocity ?b) (* #t 9.8))
            (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
        )
    )
    (:event HIT-GROUND
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (<= (distance-to-floor ?b) 0)
            (> (velocity ?b) 0)
        )
        :effect (
            (assign (velocity ?b) (* -0.8 (velocity ?b)))
        )
    )

    ; Actions omitted
)
   Contents   Requirements Processes Events    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
 Only one additional requirement is necessary in order to include both processes and events, this requirement is :time, as shown below     (:requirements :time)
   Processes  back to contents Support: Medium Usage: Low (:process FALLING
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (< (velocity ?b) 100)
    )
    :effect (and
        (increase (velocity ?b) (* #t 9.8))
        (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
    )
)
 A process is defined in three sections, :parameters, :precondition and :effect which define what a process is acting upon, when a process is acting upon it and what effect that process has when it acts. These directly correspond with the definition of an action found in PDDL 1.2, but can include the expressivity of numerics as seen in PDDL 2.1. Confusingly despite bearing similar behaviour to a durative action, a process conditions over it’s duration, therefore the precondition can be thought of more like an over all condition in PDDL 2.1 #t represents the time of the process, it is used to calculate continuous numeric effects, therefore, if about halfway through the process some action might wish to run which conditions on one of the numeric fluents affected by the process, #t can be used to calculate the intermediate value of such a numeric fluent.   Events  back to contents Support: Medium Usage: Low (:event HIT-GROUND
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (<= (distance-to-floor ?b) 0)
        (> (velocity ?b) 0)
    )
    :effect (
        (assign (velocity ?b) (* -0.8 (velocity ?b)))
    )
)
 An event is defined the same as a process in three sections, :parameters which are the objects upon which the effect acts :precondition which is the condition which must be satisfiend in order for the event to run and :effect which is the effect the event has. Note that the distinctive nature of an event is that whilst it can occur more than once it generally does not happen back to back. Essentially, an event is a discrete moment in time, where as a process is an interval of time. In the case above we see that the condition of hitting the ground is that velocity is greater than 0, and the effect is that velocity is negated, which ensures that - at least for a period - this event cannot run again.\n\n\n\nReport an issue with this page         Reference Planners      Planners  Contributors: Adam Green, An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances.  Table of contents   Planners from A to Z   Planners by tag   Planners by rating\n\n\n\nReport an issue with this page         Reference Planners Planners from A to Z      A to Z of Planners  Contributors: Adam Green, Felipe Meneguzzi, Mau Magnaguagno, The following is an A to Z of all known planners. This list is not a comprehensive list, but rather an attempt to aggregate different planners from as many known creators as possible. If you think a planner is missing, please file an issue here or submit a pull request with the correct changes. If your planner is missing from this list, please fork this repository, correct this page and file a pull request with the main repo. Please see our page on how to add a planner to this guide.    Planner Links tags     A       ACOPlan  (& ACOPlan 2) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Alien  Home Page [Not Found] | Paper tags: IPC2018 Satisfycing   AllPACA  Home Page [Not Found] | Paper tags: IPC2014 Optimising   Arvand  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Arvandherd  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   B       BiFD  Home Page [Not Found] | Paper tags: IPC2014 Satisfycing   BJOLP  Home Page [Not Found] | Paper tags: IPC2011 Optimising   BRT  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   C       C3  Home page [Not Found] | Paper tags: IPC2008 Satisfycing   CBP  (& CBP2) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Cerberus  (& Cerberus-gl) Home Page [Not Found] | Paper tags: IPC2018 Satisfycing   CFDP  Home Page [Not Found] | Paper tags: IPC2008 Optimising   cGamer  Home page [Not Found] | Paper tags: IPC2014 Optimising   COLIN  Home Page [Not Found] | Paper tags: Temporal Numeric   Complementary  (1 & 2) Home Page [Not Found] | Paper, Paper tags: IPC2018 Optimising   CoPlan  (styled Co-Plan) Home Page [Not Found] | Paper tags: IPC2008 Optimising   CP4TP  Home Page [Not Found] | Paper tags: IPC2018 Satisfycing Temporal   CPT  (& 2, 3 & 4) Home Page | Paper (CPT), Paper (CPT 2), Paper (CPT 4) tags: IPC2004 IPC2006 IPC2011 Optimising Temporal   D       DAEYAHSP  (styled DAE-YAHSP) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing Temporal   DecStar  Home Page [Not Found] | Paper tags: IPC2018 Optimising   Delfi  (1 & 2) Home Page [Not Found] | Paper tags: IPC2018 Optimising   DiNo  Home page | Paper Domains tags: temporal numeric   DPMPlan  Home Page [Not Found] | Paper tags: IPC2014 Optimising   E       ENHSP  Home Page | Paper tags: temporal numeric   F       FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper tags: IPC2004 IPC2006 IPC2008 IPC2011 IPC2014 IPC2018 Optimising Satisfycing   FF  The Fast Forward Planning System (and all other FF brand planners) Home Page | Paper tags: IPC2000 Satisfycing   Freelunch  Home Page [Not Found] | Paper tags: IPC2014 Satisfycing   G       Gamer  Home page [Not Found] | Paper tags: IPC2008 Optimising   H       HPlanP  (styled HPlan-P) Home Page [Not Found] | Paper tags: IPC2006 Optimising   HSP  Home Page [Not Found] | Paper tags: IPC1998 IPC2000 Satisfycing   HyperTensioN Guide Page | Home Page | Paper     I       IBaCoP-2018 Guide Page | Home Page | Paper     IBaCoP2-2018 Guide Page | Home Page | Paper     IFork Init Guide Page | Home Page | Paper     Imitation-Net Guide Page | Home Page | Paper     ITSAT Guide Page | Home Page | Paper     J       Jasper Guide Page | Home Page | Paper     JavaFF Guide Page | Home Page | Paper     JSHOP2 Guide Page | Home Page | Paper     K       L       LAMA-2011 Guide Page | Home Page | Paper     Lamar Guide Page | Home Page | Paper     LAPKT-BFWS-Preference Guide Page | Home Page | Paper     LAPKT-DFS+ Guide Page | Home Page | Paper     LAPKT-DUAL-BFWS Guide Page | Home Page | Paper     LAPKT-POLYNOMIAL-BFWS Guide Page | Home Page | Paper     LM-cut Guide Page | Home Page | Paper     LMFork Guide Page | Home Page | Paper     LMTD Guide Page | Home Page | Paper     LPRPG Guide Page | Home Page | Paper     LPRPG-P Guide Page | Home Page | Paper     M       Madagascar Guide Page | Home Page | Paper     Madagascar-pC Guide Page | Home Page | Paper     Marvin Guide Page | Home Page | Paper     maplan-1 Guide Page | Home Page | Paper     maplan-2 Guide Page | Home Page | Paper     mercury2014 Guide Page | Home Page | Paper     Merge and Shrink Guide Page | Home Page | Paper     MERWIN Guide Page | Home Page | Paper     MetricFF Guide Page | Home Page | Paper     Metis1 Guide Page | Home Page | Paper     Metis2 Guide Page | Home Page | Paper     MIPlan Guide Page | Home Page | Paper     Mips XXL Guide Page | Home Page | Paper     MSP Guide Page | Home Page | Paper     N       NuCeLar Guide Page | Home Page | Paper     O       OLCFF Guide Page | Home Page | Paper     OPTIC Guide Page | Home Page | Paper     P       PaaS Guide Page | Home Page | Paper     Panda Guide Page | Home Page | Paper     PHSFF Guide Page | Home Page | Paper     Planets Guide Page | Home Page | Paper     Planning-PDBs Guide Page | Home Page | Paper     PopCorm Guide Page | Home Page | Paper     POPF Guide Page | Home Page | Paper     PROBE Guide Page | Home Page | Paper     Prost-DD-1 Guide Page | Home Page | Paper     Prost-DD-2 Guide Page | Home Page | Paper     Q       R       Random-Bandit Guide Page | Home Page | Paper     Randward Guide Page | Home Page | Paper     Rational Lazy A* Guide Page | Home Page | Paper     RIDA Guide Page | Home Page | Paper     Roamer Guide Page | Home Page | Paper     RPT Guide Page | Home Page | Paper     S       Saarplan Guide Page | Home Page | Paper     SATPLANLM-C Guide Page | Home Page | Paper     Scorpion Guide Page | Home Page | Paper     Selective Max Guide Page | Home Page | Paper     Sharaabi Guide Page | Home Page | Paper     SHOP/SHOP2 Guide Page | Home Page | Paper     SHOP3 Guide Page | Home Page | Paper     SIW Guide Page | Home Page | Paper     SMTPlan+ Guide Page | Home Page | Paper     SPM&S Guide Page | Home Page | Paper     SymBA*-1 Guide Page | Home Page | Paper     SymBA*-2 Guide Page | Home Page | Paper     Symple-1 Guide Page | Home Page | Paper     Symple-2 Guide Page | Home Page | Paper     T       tBURTON Guide Page | Home Page | Paper     TemPorAl Guide Page | Home Page | Paper     Temporal Fast Downwards Guide Page | Home Page | Paper     TFLAP Guide Page | Home Page | Paper     TLP-GP Guide Page | Home Page | Paper     TSGP Guide Page | Home Page | Paper     U       UPMurphi Guide Page | Home Page | Paper     Upwards Guide Page | Home Page | Paper     USE Guide Page | Home Page | Paper     V       W       X       Y       YAHSP3 Guide Page | Home Page | Paper     YAHSP3-MT Guide Page | Home Page | Paper     Z\n\n\n\nReport an issue with this page         Reference Planners Planners by tag      List of all Planner tags  Contributors: Adam Green, Planners work in many different ways solving a variety of planning problems. The way they work under-the-hood dictates the types of problem they’re capable of handling. In some cases a planner capable of handing classical planning problems has no ability to reason with temporal problems. To help users of this guide find planners that meet their needs, we tag planners with tags related to their abilities and various other notable characteristics. The following is a list of tags    tag Description     Classical Planners which perform classical predicate based planning   Optimal Planners which perform optimal planning   Bounded Cost Planners which find search to a bounded cost   Satisfycing Planners which find solutions which satisfy the domain (non-optimal)   Temporal Planners which plan temporal domains   Numeric Planners which plan numeric domains   On Board Planners designed to work on-board low power systems (integrated systems and robotics)   Probabilistic Planners which perform planning on probabilistic domains   IPC2018 Planners which took part in IPC 2018   IPC2014 Planners which took part in IPC 2014   IPC2011 Planners which took part in IPC 2011   IPC2008 Planners which took part in IPC 2008   IPC2006 Planners which took part in IPC 2006   IPC2004 Planners which took part in IPC 2004   IPC2002 Planners which took part in IPC 2002   IPC1998 Planners which took part in IPC 1998     Table of contents   IPC1998 Tags   IPC2000 Tags   IPC2004 Tags   IPC2006 Tags   IPC2008 Tags   IPC2011 Tags   IPC2014 Tags   IPC2018 Tags   Numeric Tag   Optimising Tag   Satisfycing Tag   Temporal Tag\n\n\n\nReport an issue with this page         Reference Planners Planners by rating      Planners by Rating  Contributors: Adam Green, For user convenience we rank planners according to a Quality Assurance metric detailed below. This metric, scores planners between 0 and 100, not based solely on their competitive performance, but rather by a number of factors, with a strong emphasis focused on end user experience. Such a metric was highly controversial when first proposed, and so this metric comes with a caveat, that planning researchers have not agreed to or support this metric. Over time we aim to fine tune this metric to better capture the elements end users of planning value. We welcome debate and further input on this system, so if you have any feedback or wish to voice an opinion, a dedicated issue has been opened to discuss this here   Score system   25 points for coverage  5 points for classical coverage 5 points for classical optimal coverage 10 points for temporal-numeric coverage 5 points for expressive features coverage (TILs, Action Costs, Processes, Events)   50 points for end user usability  25 points for published and maintained code including:  10 points for a code publication on a popular public source control system (GitHub, BitBucket, Mercurial etc.) 5 points for including a readme in text/markdown format on how to compile the code for a defined system (e.g. here’s how to compile in on Ubuntu/Fedora/MacOS/Windows etc) 5 points for including an automated script that is guaranteed to work on a developer defined base system with no pre-requisites installed 5 points for clear updates and bug reporting and patching processes   25 points for documentation of planner including  5 points for a readme detailing the major contribution of the planner, and how to use it (e.g. command line/UI instructions) 10 points for an extended readme detailing supported PDDL features, as defined in this wiki or on the eviscerator testing tool - or equivalent table of support attached clearly to the planner or the software repo 10 points for code documentation that outlines structure and implementation of the code     25 points for IPC competitve ranking  If n planners participate, and rank in position p the score is 25 * (p/n)      Planners by score     Planner Links Score     Alien Guide Page | Home Page [Not Found] | Paper 38.1   AllPACA Guide Page | Home Page [Not Found] | Paper 31.2   Arvandherd Guide Page | Home Page [Not Found] | Paper 30   Arvand Guide Page | Home Page [Not Found] | Paper 22.6   ACOPlan & ACOPlan 2 Guide Page | Home Page [Not Found] | Paper 15.9     Table of contents\n\n\n\nReport an issue with this page          Contributing  Contributors: Adam Green,   Introduction  Contributing to the PDDL reference guide is similar to contributing to other open source projects. You have two options. If you’re keen to contribute to this guide a lot, drop me an email at adam.green@kcl.ac.uk, if you’re looking to add a single or a few pages, or minor changes, you should instead consider forking the repository, pushing the changes to your fork and filing a pull request with this repo. TL;DR - There are two ways to contribute  Forking for simple additions Becoming a contributor for on-going additions    Forking, Changing and Pulling    You can fork the repo at any time by clicking the fork button in the top right hand corner of the repository page on github.   Once you’ve forked the repo, you should clone your copy of the repo to your computer   Make any changes and commit them to a branch on your fork, (you can commit to master on a fork, as this won’t affect the base repository).   Return to the repository page and go to pull requests   To create a pull request click “new pull request”   To pull across forks, find the link labelled “compare across forks”   Select your fork as the head, and the branch to which you committed your changes and select our master as the base   One of our contributors has to review and approve your pull request, once this is done, they will merge it. Alternatively, if you have just minor corrections (e.g. typos), your pull request will likely be merged without review.     Contributing  Contributing offers more flexibility in how quickly your corrections or additions are approved. It also gives you the ability to review other contributions and help improve them.   Contributing by writing    Get contributors access by emailing adam.green@kcl.ac.uk or filing an issue   Clone the repo to your machine   Create your own branch for your changes - you will not be able to push to master directly.   make your changes and push them to the repository   Create a pull request, another contributor will have to verify your pull request and then commit it     Contribute by reviewing  When you are viewing/using/adding to the reference guide, make sure to double check for any outstanding pull requests from other contributors. Reviewing and approving pull requests means that quality is maintained and improved. You can review pull requests by clicking on the pull requests tab of the repo. Writing a comment will require you choose between approving, commenting or requesting changes to a pull request. Requests should be checked for general accuracy, and any semantic typos i.e. typos which change the meaning. Minor corrections can be made inline by collaborators.\n\n\n\nReport an issue with this page          Additional Resources  Contributors: Adam Green, Francisco Martin Rico, To help make this guide as complete and comprehensive as possible for all things planning, below you can find a wide variety of additional resources to help with your PDDL and planning ambitions. For inclusion in this additional resources section please file an issue detailing the resource you believe should be added. Please mark this issue as new content.  Planning.Domains Planner Tools PDDL Tools Learning Resources    Planning.Domains  Planning.Domains is the definitive home of Artificial Intelligence Planning. The sit features a wide variety of tools and resources to help you with AI Planning. Included in its toolset is a Planning as a Service (PaaS) API. An online editor for writing and testing domains and problem files. It also links to education resources, and provides links to institutions that are key players in the field of AI Planning research.   Planner Tools    VAL - The Plan Validator  VAL, also known as Validator, is a tool for validating the solutions produced by a planner against the original domain and problem file. VAL allows you to check that the plan actually achieves the goal whilst adhering to all the preconditions it needs to when applying actions.   Eviscerator - The Planner tester  Eviscerator is a tool developed for this PDDL Reference guide that allows us to automatically test and identify what PDDL requirements a planner supports. It is an open source tool, which comes with a Continuously Deployed Pre-built binary for Linux. This means you can download it and test a planner without worrying about compilation.   ROSPlan - Planning in ROS  ROSPlan is a module for the Robotic Operating System (ROS) that allows for the integration of AI Planning into Robots that make use of ROS. ROSPlan allows for modelling of Robotic environments for the purpose of planning and executing tasks.   Plansys2 - Planning in ROS2  Plansys2 is a project for the new version of Robotic Operating System, ROS2, that integrates Planning and Robotics. It aims to be a framework where different planners can be easily integrated to make robots perform tasks. Actions are implemented using Behavior Trees, and there are a bunch of examples in the repo.   Universal Planning Validator (Under Development)  Universal Planning Validator (Under Development) is a tool designed to validate planning domain and problems. Currently it can only support classical planning problems and domains, but the tool is intended to be expanded to include temporal and multi-agent domains. If you require a Validator that supports more advanced PDDL features than classical planning, then try VAL, the Planning Validator instead.   PDDL Tools    Visual Studio Code + PDDL Plugin  Visual Studio Code is a text editor developed by microsoft with a plethora of fantastic integrations. A fantastically helpful PDDL plugin allows for the development of PDDL with syntax highlighting and then in-editor execution of the domain and problem file on pre-installed planners.   Learning Resources    Learn PDDL by Fares K. Alaboud  Learn PDDL is an introductory tutorial on PDDL which allows you to get to grips with the writing and developing of PDDL files. PDDL1.2 is introduced first using basic predicate logic before proceeding to make progressively more complex domains.   Introduction to AI Planning  Dr Andrew and Amanda Coles introduce AI Planning in this fantastic two part YouTube video that gives a great immersive overview of AI Planning, its applications and its current areas of continuing interest.  Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)    Publicly Available PDDL Domains  Below is a list of links to PDDL domains available publicly.  IPC PDDL Domains\n\n\n\nClick here if you are not redirected.\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Planning.Wiki - The AI Planning & PDDL Wiki  Our Contributors: Adam Green, Benjamin Jacob Reji, ChrisE2018, Christian Muise, Enrico Scala, Felipe Meneguzzi, Francisco Martin Rico, Henry Stairs, Jan Dolejsi, Mau Magnaguagno, Jonathan Mounty Join The Planning Community on Slack   Introduction  This Wiki is here to provide easy access to resources related to the field of AI Planning. AI Planning is difficult to quantify under one roof, due to the variety of ongoing research in the field. The International Conference on Autonomous Planning and Scheduling has in the course of supporting AI Planning research created a competition for the AI Planning Software (Planners) that have been built to solve AI Planning problems. This competition, dating from 1998, has defined a general purpose definition language, Planning Domain Definition Language (PDDL) (Ghallab et al., 1998), which is designed to be capable of specifying any planning or scheduling problem you could come across. In reality, PDDL since it’s first incarnation in 1998 has had serious modifications to make it capable of handling the complex tasks we expect of modern autonomous planning and scheduling techniques. (Fox & Long, 2003; Fox & Long, 2003; Edelkamp & Hoffman, 2004; Gerevini & Long, 2005) For more details on PDDL, Planning, the history, the usage and the research, see the guide.   Using This Guide  This wiki splits into three main sections, guide, reference and examples. The guide section is here to help the uninitiated get an idea of what planning is and how it can be used. It glazes over technical details where they’re complex and difficult to understand. This is not intended to be a substitute to the copious academic literature written in the subject. The reference guide itself splits into two sections, one for the language of planners, PDDL. The other section for the planners which can read and solve PDDL problems. The nature of AI planning and the language means that not all features are supported by all planners and not all techniques are used as often as others. The reference here aims to help with that by firstly showing next to each definition an indication of how well supported the feature is and how commonly used it is. Support: Universal High Medium Poor Usage: High Medium Low Rare/None For planners, this reference will aim to provide indication of what features are supported by what planners. It also provides useful hints and notes about the quirks and specific issues certain planners have in running certain problems.   Community  To help grow the community and support available to new and experienced users alike, we work with The Planning Community slack, to help connect people working and using planning & PDDL. Drop in and say hello   Contributions, Corrections and Feedback   Contributions are always welcome! The best way to provide multiple contributions is to request collaborator access to this repository, either via emailing adam.green@kcl.ac.uk or by filing an issue on this repo. You can fork this repository to your GitHub, make changes and file a pull request. Alternatively, if you are not able to provide a contribution, but maybe think there is something this guide is missing or is incorrect, please add a new issue to this repo, and a correction, or additional will be made based on priority. Please use the “Report a problem with this guide” button available on most pages. Finally, if you have a planner which you think should be included in this reference guide, please ask for collaborator access or fork the repository (if you’re the creator of the planner), or create an issue (if you’re a user) and we’ll try to include it. Any other issues/concerns should be sent to adam.green@kcl.ac.uk and I’ll try to get back to you ASAP.   Contents  This site breaks down into two major content sections  the guide - Focuses on what planning is and using planning and planners to solve planning problems the reference - Provides a “handbook” to the language and the planners which solve the problems modelled in said language.    FAQ    Additional Resources  Below you can find a collection of resources for writing, learning and using PDDL and planning. For more information on what these tools and resources are and how they can help, please visit the additional resources page.  Planning.Domains Planner Tools  VAL - The Plan Validator ROSPlan - Planning in ROS PlanSys2 - Planning in ROS2 Eviscerator - The Planner tester Universal Planning Validator (Under Development)   PDDL Tools  Visual Studio Code  PDDL Plugin for VSCode   Sublime Text Editor  MyPDDL Plugin for Sublime   Atom Text Editor  MyPDDL Plugin for Atom   Planning.Domains PDDL Editor   Learning Resources  Learn PDDL by Fares K. Alaboud Introduction to AI Planning. Part I. (video) Introduction to AI Planning. Part II. (video)   Publicly Available PDDL Domains  IPC PDDL Domains   Book: An Introduction to the Planning Domain Definition Language    References  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Fox, M., & Long, D. (2003). PDDL+ : Modelling Continuous Time-dependent Effects. Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006. Coles, A., Coles, A., Fox, M., & Long, D. (2009). Temporal Planning in Domains with Linear Processes. IJCAI International Joint Conference on Artificial Intelligence, 1671–1676. Coles, A., Coles, A., Fox, M., & Long, D. (2010). Forward-Chaining Partial-Order Planning. Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling, 42–49. Hoffmann, J. (2011). The Metric-FF Planning System: Translating "Ignoring Delete Lists" to Numeric State Variables. Journal of Artificial Intelligence Research, 20. https://doi.org/10.1613/jair.1144 Benton, J., Coles, A., & Coles, A. (2012). Temporal Planning with Preferences and Time-Dependent Continuous Costs. ICAPS 2012 - Proceedings of the 22nd International Conference on Automated Planning and Scheduling. Scala, E., Haslum, P., Thiébaux, S., & Ramírez, M. (2016). Interval-Based Relaxation for General Numeric Planning. ECAI. Cashmore, M., Fox, M., Long, D., & Magazzeni, D. (2016, January). A Compilation of the Full PDDL+ Language into SMT. Piotrowski, W., Fox, M., Long, D., Magazzeni, D., & Mercorio, F. (2016). Heuristic Planning for PDDL+ Domains. Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, 3213–3219.   Non Academic References   OPTIC - Optimising Preferences and Time Dependent Costs PDDL Examples BNF Description of PDDL 3.0 [Gerevini, A. Long, D.]\n\n\n\nReport an issue with this page          Guide  Contributors: The guide here provides an introduction designed for developers, undergraduates and post-graduates with no prior experience in the world of planning & scheduling and/or optimisation research. It is not a substitute for a thorough academic course, or the copious amounts of academic literature written on planning but does provide a solid basis from which to understand and use planning. The guide is constantly being developed and improved, so if you have any criticisms or feedback we really do truly value it. Especially if you’re not a planning expert, as you’re the target of this guide!  Table of contents   What is AI Planning?   What is PDDL?   What is a planner?\n\n\n\nReport an issue with this page          Guide  Contributors: The guide here provides an introduction designed for developers, undergraduates and post-graduates with no prior experience in the world of planning & scheduling and/or optimisation research. It is not a substitute for a thorough academic course, or the copious amounts of academic literature written on planning but does provide a solid basis from which to understand and use planning. The guide is constantly being developed and improved, so if you have any criticisms or feedback we really do truly value it. Especially if you’re not a planning expert, as you’re the target of this guide!  Table of contents   What is AI Planning?   What is PDDL?   What is a planner?\n\n\n\nReport an issue with this page         Guide What is AI Planning?      What is AI Planning?  Contributors: Adam Green,   Introduction  AI Planning is a field of Artificial Intelligence which explores the process of using autonomous techniques to solve planning and scheduling problems. A planning problem is one in which we have some initial starting state, which we wish to transform into a desired goal state through the application of a set of actions. In a simple example, imagine we wish to build a house. On our building site we can assume all the materials are ready to be used and we essentially now have to decide which order to perform construction in. Each step of construction in this situation could be modelled as an action (for example laying foundations, building the walls, installing the plumbing and electricals etc.). Certain actions cannot happen before others - we cannot build a wall before we have a foundation - so through the use of predicate logic we can express this problem by saying “if there is no foundation, we cannot build a wall”. AI planning can leverage this form of expression in order to solve this problem and others. Of course in reality planning the construction of a house is not particularly difficult, but imagine instead we were planning the construction of an Olympic stadium. The same problem can be broken down into similar simple tasks which are dependent on prior conditions being met.   Domain Independent Planning  The core philosophy built into PDDL (Ghallab et al., 1998), and as a result many planners, is that the techniques applied to solving a problem should know nothing about the problem they are solving. That is to say the techniques which we apply to solve for example a logistics problem, we could also apply to a manufacturing problem. This is interesting because unlike other fields of Artificial Intelligence, such as Machine Learning, we are not dependent on there being pre-existing information on the problem, or an example path to a solution. All we need is the starting state, the actions we can apply and the desired end state. Often these three pieces of information are readily available, purely from the nature inherent to the problems a planner is trying to solve. Simply put, you don’t start planning until you know what you’re trying to achieve. For example if we are planning the construction of large stadium, we know what needs to be completed in order for the stadium to be finished, we know that there is currently no stadium built and we know the different actions that can be performed to change the state closer to the position we desire it to be in (build frames, install pipework, raise flags etc.). We need no knowledge of how previous stadiums were built, or what orderings were used (for example building foundations then frames etc.). This lack of need for knowledge means we can apply planning to problems which have not been previously solved. Also, if we assume that previous solutions to a planning problem are sub-optimal (i.e. they’re not as good as they could be), applying a technique like learning would essentially train to solve problems sub-optimally. Therefore we need an appraoch which is methodical, objective and avoids learning from prior approaches which are sub-optimal (read as domain independent).   State Space Search  Although there is a lot more to solving a plan than a state space search, the general (but not universal) unifying factor of different planners is that they perform some kind of “state space” search. If we imagine that from the initial state, we can access various new states, by applying actions, the result is we form a tree of possible states, with the initial state being the root. From that root we perform a search, attempting to find a state as close as possible to the root, which has all of the facts we need in order to satisfy the goal. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Guide What is AI Planning?      What is AI Planning?  Contributors: Adam Green,   Introduction  AI Planning is a field of Artificial Intelligence which explores the process of using autonomous techniques to solve planning and scheduling problems. A planning problem is one in which we have some initial starting state, which we wish to transform into a desired goal state through the application of a set of actions. In a simple example, imagine we wish to build a house. On our building site we can assume all the materials are ready to be used and we essentially now have to decide which order to perform construction in. Each step of construction in this situation could be modelled as an action (for example laying foundations, building the walls, installing the plumbing and electricals etc.). Certain actions cannot happen before others - we cannot build a wall before we have a foundation - so through the use of predicate logic we can express this problem by saying “if there is no foundation, we cannot build a wall”. AI planning can leverage this form of expression in order to solve this problem and others. Of course in reality planning the construction of a house is not particularly difficult, but imagine instead we were planning the construction of an Olympic stadium. The same problem can be broken down into similar simple tasks which are dependent on prior conditions being met.   Domain Independent Planning  The core philosophy built into PDDL (Ghallab et al., 1998), and as a result many planners, is that the techniques applied to solving a problem should know nothing about the problem they are solving. That is to say the techniques which we apply to solve for example a logistics problem, we could also apply to a manufacturing problem. This is interesting because unlike other fields of Artificial Intelligence, such as Machine Learning, we are not dependent on there being pre-existing information on the problem, or an example path to a solution. All we need is the starting state, the actions we can apply and the desired end state. Often these three pieces of information are readily available, purely from the nature inherent to the problems a planner is trying to solve. Simply put, you don’t start planning until you know what you’re trying to achieve. For example if we are planning the construction of large stadium, we know what needs to be completed in order for the stadium to be finished, we know that there is currently no stadium built and we know the different actions that can be performed to change the state closer to the position we desire it to be in (build frames, install pipework, raise flags etc.). We need no knowledge of how previous stadiums were built, or what orderings were used (for example building foundations then frames etc.). This lack of need for knowledge means we can apply planning to problems which have not been previously solved. Also, if we assume that previous solutions to a planning problem are sub-optimal (i.e. they’re not as good as they could be), applying a technique like learning would essentially train to solve problems sub-optimally. Therefore we need an appraoch which is methodical, objective and avoids learning from prior approaches which are sub-optimal (read as domain independent).   State Space Search  Although there is a lot more to solving a plan than a state space search, the general (but not universal) unifying factor of different planners is that they perform some kind of “state space” search. If we imagine that from the initial state, we can access various new states, by applying actions, the result is we form a tree of possible states, with the initial state being the root. From that root we perform a search, attempting to find a state as close as possible to the root, which has all of the facts we need in order to satisfy the goal. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Guide What is AI Planning?      What is AI Planning?  Contributors: Adam Green,   Introduction  AI Planning is a field of Artificial Intelligence which explores the process of using autonomous techniques to solve planning and scheduling problems. A planning problem is one in which we have some initial starting state, which we wish to transform into a desired goal state through the application of a set of actions. In a simple example, imagine we wish to build a house. On our building site we can assume all the materials are ready to be used and we essentially now have to decide which order to perform construction in. Each step of construction in this situation could be modelled as an action (for example laying foundations, building the walls, installing the plumbing and electricals etc.). Certain actions cannot happen before others - we cannot build a wall before we have a foundation - so through the use of predicate logic we can express this problem by saying “if there is no foundation, we cannot build a wall”. AI planning can leverage this form of expression in order to solve this problem and others. Of course in reality planning the construction of a house is not particularly difficult, but imagine instead we were planning the construction of an Olympic stadium. The same problem can be broken down into similar simple tasks which are dependent on prior conditions being met.   Domain Independent Planning  The core philosophy built into PDDL (Ghallab et al., 1998), and as a result many planners, is that the techniques applied to solving a problem should know nothing about the problem they are solving. That is to say the techniques which we apply to solve for example a logistics problem, we could also apply to a manufacturing problem. This is interesting because unlike other fields of Artificial Intelligence, such as Machine Learning, we are not dependent on there being pre-existing information on the problem, or an example path to a solution. All we need is the starting state, the actions we can apply and the desired end state. Often these three pieces of information are readily available, purely from the nature inherent to the problems a planner is trying to solve. Simply put, you don’t start planning until you know what you’re trying to achieve. For example if we are planning the construction of large stadium, we know what needs to be completed in order for the stadium to be finished, we know that there is currently no stadium built and we know the different actions that can be performed to change the state closer to the position we desire it to be in (build frames, install pipework, raise flags etc.). We need no knowledge of how previous stadiums were built, or what orderings were used (for example building foundations then frames etc.). This lack of need for knowledge means we can apply planning to problems which have not been previously solved. Also, if we assume that previous solutions to a planning problem are sub-optimal (i.e. they’re not as good as they could be), applying a technique like learning would essentially train to solve problems sub-optimally. Therefore we need an appraoch which is methodical, objective and avoids learning from prior approaches which are sub-optimal (read as domain independent).   State Space Search  Although there is a lot more to solving a plan than a state space search, the general (but not universal) unifying factor of different planners is that they perform some kind of “state space” search. If we imagine that from the initial state, we can access various new states, by applying actions, the result is we form a tree of possible states, with the initial state being the root. From that root we perform a search, attempting to find a state as close as possible to the root, which has all of the facts we need in order to satisfy the goal. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Guide What is AI Planning?      What is AI Planning?  Contributors: Adam Green,   Introduction  AI Planning is a field of Artificial Intelligence which explores the process of using autonomous techniques to solve planning and scheduling problems. A planning problem is one in which we have some initial starting state, which we wish to transform into a desired goal state through the application of a set of actions. In a simple example, imagine we wish to build a house. On our building site we can assume all the materials are ready to be used and we essentially now have to decide which order to perform construction in. Each step of construction in this situation could be modelled as an action (for example laying foundations, building the walls, installing the plumbing and electricals etc.). Certain actions cannot happen before others - we cannot build a wall before we have a foundation - so through the use of predicate logic we can express this problem by saying “if there is no foundation, we cannot build a wall”. AI planning can leverage this form of expression in order to solve this problem and others. Of course in reality planning the construction of a house is not particularly difficult, but imagine instead we were planning the construction of an Olympic stadium. The same problem can be broken down into similar simple tasks which are dependent on prior conditions being met.   Domain Independent Planning  The core philosophy built into PDDL (Ghallab et al., 1998), and as a result many planners, is that the techniques applied to solving a problem should know nothing about the problem they are solving. That is to say the techniques which we apply to solve for example a logistics problem, we could also apply to a manufacturing problem. This is interesting because unlike other fields of Artificial Intelligence, such as Machine Learning, we are not dependent on there being pre-existing information on the problem, or an example path to a solution. All we need is the starting state, the actions we can apply and the desired end state. Often these three pieces of information are readily available, purely from the nature inherent to the problems a planner is trying to solve. Simply put, you don’t start planning until you know what you’re trying to achieve. For example if we are planning the construction of large stadium, we know what needs to be completed in order for the stadium to be finished, we know that there is currently no stadium built and we know the different actions that can be performed to change the state closer to the position we desire it to be in (build frames, install pipework, raise flags etc.). We need no knowledge of how previous stadiums were built, or what orderings were used (for example building foundations then frames etc.). This lack of need for knowledge means we can apply planning to problems which have not been previously solved. Also, if we assume that previous solutions to a planning problem are sub-optimal (i.e. they’re not as good as they could be), applying a technique like learning would essentially train to solve problems sub-optimally. Therefore we need an appraoch which is methodical, objective and avoids learning from prior approaches which are sub-optimal (read as domain independent).   State Space Search  Although there is a lot more to solving a plan than a state space search, the general (but not universal) unifying factor of different planners is that they perform some kind of “state space” search. If we imagine that from the initial state, we can access various new states, by applying actions, the result is we form a tree of possible states, with the initial state being the root. From that root we perform a search, attempting to find a state as close as possible to the root, which has all of the facts we need in order to satisfy the goal. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Guide What is AI Planning?      What is AI Planning?  Contributors: Adam Green,   Introduction  AI Planning is a field of Artificial Intelligence which explores the process of using autonomous techniques to solve planning and scheduling problems. A planning problem is one in which we have some initial starting state, which we wish to transform into a desired goal state through the application of a set of actions. In a simple example, imagine we wish to build a house. On our building site we can assume all the materials are ready to be used and we essentially now have to decide which order to perform construction in. Each step of construction in this situation could be modelled as an action (for example laying foundations, building the walls, installing the plumbing and electricals etc.). Certain actions cannot happen before others - we cannot build a wall before we have a foundation - so through the use of predicate logic we can express this problem by saying “if there is no foundation, we cannot build a wall”. AI planning can leverage this form of expression in order to solve this problem and others. Of course in reality planning the construction of a house is not particularly difficult, but imagine instead we were planning the construction of an Olympic stadium. The same problem can be broken down into similar simple tasks which are dependent on prior conditions being met.   Domain Independent Planning  The core philosophy built into PDDL (Ghallab et al., 1998), and as a result many planners, is that the techniques applied to solving a problem should know nothing about the problem they are solving. That is to say the techniques which we apply to solve for example a logistics problem, we could also apply to a manufacturing problem. This is interesting because unlike other fields of Artificial Intelligence, such as Machine Learning, we are not dependent on there being pre-existing information on the problem, or an example path to a solution. All we need is the starting state, the actions we can apply and the desired end state. Often these three pieces of information are readily available, purely from the nature inherent to the problems a planner is trying to solve. Simply put, you don’t start planning until you know what you’re trying to achieve. For example if we are planning the construction of large stadium, we know what needs to be completed in order for the stadium to be finished, we know that there is currently no stadium built and we know the different actions that can be performed to change the state closer to the position we desire it to be in (build frames, install pipework, raise flags etc.). We need no knowledge of how previous stadiums were built, or what orderings were used (for example building foundations then frames etc.). This lack of need for knowledge means we can apply planning to problems which have not been previously solved. Also, if we assume that previous solutions to a planning problem are sub-optimal (i.e. they’re not as good as they could be), applying a technique like learning would essentially train to solve problems sub-optimally. Therefore we need an appraoch which is methodical, objective and avoids learning from prior approaches which are sub-optimal (read as domain independent).   State Space Search  Although there is a lot more to solving a plan than a state space search, the general (but not universal) unifying factor of different planners is that they perform some kind of “state space” search. If we imagine that from the initial state, we can access various new states, by applying actions, the result is we form a tree of possible states, with the initial state being the root. From that root we perform a search, attempting to find a state as close as possible to the root, which has all of the facts we need in order to satisfy the goal. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Guide What is AI Planning?      What is AI Planning?  Contributors: Adam Green,   Introduction  AI Planning is a field of Artificial Intelligence which explores the process of using autonomous techniques to solve planning and scheduling problems. A planning problem is one in which we have some initial starting state, which we wish to transform into a desired goal state through the application of a set of actions. In a simple example, imagine we wish to build a house. On our building site we can assume all the materials are ready to be used and we essentially now have to decide which order to perform construction in. Each step of construction in this situation could be modelled as an action (for example laying foundations, building the walls, installing the plumbing and electricals etc.). Certain actions cannot happen before others - we cannot build a wall before we have a foundation - so through the use of predicate logic we can express this problem by saying “if there is no foundation, we cannot build a wall”. AI planning can leverage this form of expression in order to solve this problem and others. Of course in reality planning the construction of a house is not particularly difficult, but imagine instead we were planning the construction of an Olympic stadium. The same problem can be broken down into similar simple tasks which are dependent on prior conditions being met.   Domain Independent Planning  The core philosophy built into PDDL (Ghallab et al., 1998), and as a result many planners, is that the techniques applied to solving a problem should know nothing about the problem they are solving. That is to say the techniques which we apply to solve for example a logistics problem, we could also apply to a manufacturing problem. This is interesting because unlike other fields of Artificial Intelligence, such as Machine Learning, we are not dependent on there being pre-existing information on the problem, or an example path to a solution. All we need is the starting state, the actions we can apply and the desired end state. Often these three pieces of information are readily available, purely from the nature inherent to the problems a planner is trying to solve. Simply put, you don’t start planning until you know what you’re trying to achieve. For example if we are planning the construction of large stadium, we know what needs to be completed in order for the stadium to be finished, we know that there is currently no stadium built and we know the different actions that can be performed to change the state closer to the position we desire it to be in (build frames, install pipework, raise flags etc.). We need no knowledge of how previous stadiums were built, or what orderings were used (for example building foundations then frames etc.). This lack of need for knowledge means we can apply planning to problems which have not been previously solved. Also, if we assume that previous solutions to a planning problem are sub-optimal (i.e. they’re not as good as they could be), applying a technique like learning would essentially train to solve problems sub-optimally. Therefore we need an appraoch which is methodical, objective and avoids learning from prior approaches which are sub-optimal (read as domain independent).   State Space Search  Although there is a lot more to solving a plan than a state space search, the general (but not universal) unifying factor of different planners is that they perform some kind of “state space” search. If we imagine that from the initial state, we can access various new states, by applying actions, the result is we form a tree of possible states, with the initial state being the root. From that root we perform a search, attempting to find a state as close as possible to the root, which has all of the facts we need in order to satisfy the goal. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is PDDL?      What is Planning Domain Definition Language (PDDL)?  Contributors: Adam Green,   Introduction  Planning Domain Definition Language (PDDL) is a family of languages which allow us to define a planning problem. As planning has evolved, so to has the language used to describe it and as such there are now many versions of PDDL available with different levels of expressivity. This guide provides reference for six main evolutions of PDDL, starting with the syntax defined for the 1998 International Conference on Autonomous Planning and Scheduling’s AIPS competition (Ghallab et al., 1998). It then looks at further evolutions into PDDL2.1, PDDL2.2, PDDL3.0 and PDDL+ This guide also provides information on some other flavours of PDDL but does not attempt to provide full on comprehensive documentation.   PDDL  Confusingly, this guide starts with PDDL version 1.2 (Ghallab et al., 1998), which is typically the most basic syntax supported by planners this guide will look at. PDDL 1.2 is primarily driven by a predicate logic way of modelling. In PDDL1.2 we define a set of objects which have predicate properties (properties which are either true or false). We then define a set of actions which condition on, and then change these properties. For example we may have an object called “bricks” with the property “laid” set to false. In order to change this property from false to true our planner may have to apply some action “build wall” which has a condition that the bricks are not laid and the outcome (effect) that they are laid. If we then expand this logic to include and, or, not, implies and the other traditional logical operators, we can begin to express more complex conditions and effects of our actions. Our ultimate aim in planning is achieve some goal state and this two is expressed as some kind of predicate formula. In the case of our construction example we may want the following goal to be true Walls Built AND Roof Built AND Windows Installed AND Plumbing fitted etc.   PDDL 2.1  We now swap our version numbers around to make 2.1 (Fox & Long, 2003) and come onto the first major improvement of PDDL’s expressivity, PDDL2.1 introduced two key elements, time and numbers, something which AI Planning syntax was previous unable to expressive (without contrived predicate based approaches) became possible. Planning with time and numbers is still quite difficult for both AI Planning and other approaches (such as Constraint Programming). PDDL2.1 models time through the use of a new type of action called a durative action. A durative action has essentially similar properties to a traditional PDDL1.2 action however it introduces a duration parameter which models the length of time an action takes. It also creates three new points at which to condition on, at the start of the action, at the end of the action and over the duration of the action. It offers a similar ability with effects, wherein we can apply effects at the beginning or end of an action. Numeric fluents - numbers - allow us to express resources, such as battery charge, materials or anything else which is numeric without distinct properties. Much like predicates, we can both condition on and effect numeric fluents, allowing us to for example model the need for and subsequent consumption of a resource.   PDDL 2.2  PDDL2.2 (Edelkamp & Hoffman, 2004) provides incremental improvements on 2.1, adding two new features, derived predicates and timed initial literals. Derived predicates are predicates based on other predicates, which allow us to create a simple reusable predicate rather than a oredicate formula we repeated express in our actions This could be for example, if plane on runway and has pilot then plane can take off. The “plane on runway” and “pilot in plane” are simple predicates and the “plane can take off” is a derived predicate. Timed Iniial literals are a useful addition to temporal (time) planning, allowing us to express that a fact becomes true at a later point than at the start of the plan. This fact may be for example that a pilot wakes up at 7AM, however our plan starts at 0, which we could consider midnight, therefore the pilot doesn’t become available until later in the plan.   PDDL 3.0  PDDL 3,0 (Gerevini & Long, 2005) introduced soft constraints to AI planning. A soft constraint is one in which we would like something to happen, but if it is not possible, we are happy to live without it happening. This update to the language introduced a few new keywords to express different types of preferences we might want to be met. It also assigns a cost to each preference, which is a measure of how much the plan quality decreases if the preference is not met. This allows the user to express Which of their preferences are more important (if any).   PDDL+  PDDL+ {$ cite pddlplus2003 $} introduced two core concepts, Processes and Events. Both are ways of expressing uncontrollable change in the world we are modelling. A process is something which always happens when it’s preconditions are met and as such implements some effect on the domain. In a physical model, a process might be the effect of gravity on a ball when the ball is not being held. An event provides an instantaneous version of a process. Something that happens exactly once when it’s precondition is met. This could be for example the outcome of a ball hitting the floor and changing direction (from bouncing down to bouncing up) in a physical model.   Other Flavours of PDDL  PDDL has a variety of other (more niche) flavours, such as PPDDL, NDDL, MADDL and a whole host of others all of which can be found conveniently listed on Wikipedia. Documenting these are harder as they tend of have more specific use cases and therefore less examples from which to extract behaviour. If you wish for more information to be available about these, you should consider contributing to this guide. Alternatively, you should add an issue to the github, so we know there’s community demand. Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language. Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Edelkamp, S., & Hoffman, J. (2004). PDDL2. 2: The language for the classical part of the 4th international planning competition. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Guide What is a planner?      What is a planner?  Contributors: Adam Green,   Introduction  An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances. This guide again will focus primarily on the best general purpose planners, in order to complement the focus on general purpose syntax.   Using AI Planners  Almost all AI planners are built with linux based compilation in mind. Some planners have been successfully ported to Windows and Mac and in some cases, the way in which their source code is written makes them easy to port (such as the Java based planner JavaFF). Planners aren’t often distributed in binary form and so often have to be compiled. This guide does not provide approaches for compiling planners. Any guidance on how to compile a planner is provided as guidance only and the planner’s creator should be contacted directly if help is needed with compilation. Once you have a compiled binary for a planner, most planners are designed to be run on the command line. Most planners follow one of two syntaxes for inputting a domain and problem file     ./<planner> <domain> <problem>
     ./<planner> -o <domain> -f <problem>
 The variance largely comes from the fact that the domain file at one point was considered to contain “operators” and the problem file contains “facts” hence the use of command line arguments “o” and “f”. As research tools, planners don’t tend to just pass out a plan onto the output, but rather provide feedback on the problem decomposition and search process it’s conducting. Eviscerator, the planner testing tool, uses a regex argument to automatically detect the plans in the output of the planner. This allows it to handle different planners which use different outputs.   Planner Support  For the benefit of users, this guide has - where possible - provided support tables for planners. These support tables allow you to identify what features a planner does and does not support and make decisions about what planner to apply to the problem you’re writing.\n\n\n\nReport an issue with this page         Guide What is a planner?      What is a planner?  Contributors: Adam Green,   Introduction  An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances. This guide again will focus primarily on the best general purpose planners, in order to complement the focus on general purpose syntax.   Using AI Planners  Almost all AI planners are built with linux based compilation in mind. Some planners have been successfully ported to Windows and Mac and in some cases, the way in which their source code is written makes them easy to port (such as the Java based planner JavaFF). Planners aren’t often distributed in binary form and so often have to be compiled. This guide does not provide approaches for compiling planners. Any guidance on how to compile a planner is provided as guidance only and the planner’s creator should be contacted directly if help is needed with compilation. Once you have a compiled binary for a planner, most planners are designed to be run on the command line. Most planners follow one of two syntaxes for inputting a domain and problem file     ./<planner> <domain> <problem>
     ./<planner> -o <domain> -f <problem>
 The variance largely comes from the fact that the domain file at one point was considered to contain “operators” and the problem file contains “facts” hence the use of command line arguments “o” and “f”. As research tools, planners don’t tend to just pass out a plan onto the output, but rather provide feedback on the problem decomposition and search process it’s conducting. Eviscerator, the planner testing tool, uses a regex argument to automatically detect the plans in the output of the planner. This allows it to handle different planners which use different outputs.   Planner Support  For the benefit of users, this guide has - where possible - provided support tables for planners. These support tables allow you to identify what features a planner does and does not support and make decisions about what planner to apply to the problem you’re writing.\n\n\n\nReport an issue with this page         Guide What is a planner?      What is a planner?  Contributors: Adam Green,   Introduction  An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances. This guide again will focus primarily on the best general purpose planners, in order to complement the focus on general purpose syntax.   Using AI Planners  Almost all AI planners are built with linux based compilation in mind. Some planners have been successfully ported to Windows and Mac and in some cases, the way in which their source code is written makes them easy to port (such as the Java based planner JavaFF). Planners aren’t often distributed in binary form and so often have to be compiled. This guide does not provide approaches for compiling planners. Any guidance on how to compile a planner is provided as guidance only and the planner’s creator should be contacted directly if help is needed with compilation. Once you have a compiled binary for a planner, most planners are designed to be run on the command line. Most planners follow one of two syntaxes for inputting a domain and problem file     ./<planner> <domain> <problem>
     ./<planner> -o <domain> -f <problem>
 The variance largely comes from the fact that the domain file at one point was considered to contain “operators” and the problem file contains “facts” hence the use of command line arguments “o” and “f”. As research tools, planners don’t tend to just pass out a plan onto the output, but rather provide feedback on the problem decomposition and search process it’s conducting. Eviscerator, the planner testing tool, uses a regex argument to automatically detect the plans in the output of the planner. This allows it to handle different planners which use different outputs.   Planner Support  For the benefit of users, this guide has - where possible - provided support tables for planners. These support tables allow you to identify what features a planner does and does not support and make decisions about what planner to apply to the problem you’re writing.\n\n\n\nReport an issue with this page         Guide What is a planner?      What is a planner?  Contributors: Adam Green,   Introduction  An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances. This guide again will focus primarily on the best general purpose planners, in order to complement the focus on general purpose syntax.   Using AI Planners  Almost all AI planners are built with linux based compilation in mind. Some planners have been successfully ported to Windows and Mac and in some cases, the way in which their source code is written makes them easy to port (such as the Java based planner JavaFF). Planners aren’t often distributed in binary form and so often have to be compiled. This guide does not provide approaches for compiling planners. Any guidance on how to compile a planner is provided as guidance only and the planner’s creator should be contacted directly if help is needed with compilation. Once you have a compiled binary for a planner, most planners are designed to be run on the command line. Most planners follow one of two syntaxes for inputting a domain and problem file     ./<planner> <domain> <problem>
     ./<planner> -o <domain> -f <problem>
 The variance largely comes from the fact that the domain file at one point was considered to contain “operators” and the problem file contains “facts” hence the use of command line arguments “o” and “f”. As research tools, planners don’t tend to just pass out a plan onto the output, but rather provide feedback on the problem decomposition and search process it’s conducting. Eviscerator, the planner testing tool, uses a regex argument to automatically detect the plans in the output of the planner. This allows it to handle different planners which use different outputs.   Planner Support  For the benefit of users, this guide has - where possible - provided support tables for planners. These support tables allow you to identify what features a planner does and does not support and make decisions about what planner to apply to the problem you’re writing.\n\n\n\nReport an issue with this page         Guide What is a planner?      What is a planner?  Contributors: Adam Green,   Introduction  An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances. This guide again will focus primarily on the best general purpose planners, in order to complement the focus on general purpose syntax.   Using AI Planners  Almost all AI planners are built with linux based compilation in mind. Some planners have been successfully ported to Windows and Mac and in some cases, the way in which their source code is written makes them easy to port (such as the Java based planner JavaFF). Planners aren’t often distributed in binary form and so often have to be compiled. This guide does not provide approaches for compiling planners. Any guidance on how to compile a planner is provided as guidance only and the planner’s creator should be contacted directly if help is needed with compilation. Once you have a compiled binary for a planner, most planners are designed to be run on the command line. Most planners follow one of two syntaxes for inputting a domain and problem file     ./<planner> <domain> <problem>
     ./<planner> -o <domain> -f <problem>
 The variance largely comes from the fact that the domain file at one point was considered to contain “operators” and the problem file contains “facts” hence the use of command line arguments “o” and “f”. As research tools, planners don’t tend to just pass out a plan onto the output, but rather provide feedback on the problem decomposition and search process it’s conducting. Eviscerator, the planner testing tool, uses a regex argument to automatically detect the plans in the output of the planner. This allows it to handle different planners which use different outputs.   Planner Support  For the benefit of users, this guide has - where possible - provided support tables for planners. These support tables allow you to identify what features a planner does and does not support and make decisions about what planner to apply to the problem you’re writing.\n\n\n\nReport an issue with this page          Reference  Contributors: Adam Green, The reference here is provided to help support developers, researchers and other end users of planning and PDDL with getting quick and easy information to hand whenever and wherever they need it. Our reference offers succinct, clear guidance on a variety of levels of the language and a growing set of docs on the planners you can use to run the language itself  Table of contents   PDDL   PDDL 2.1   PDDL 2.2   PDDL 3   PDDL+   Planners\n\n\n\nReport an issue with this page          Reference  Contributors: Adam Green, The reference here is provided to help support developers, researchers and other end users of planning and PDDL with getting quick and easy information to hand whenever and wherever they need it. Our reference offers succinct, clear guidance on a variety of levels of the language and a growing set of docs on the planners you can use to run the language itself  Table of contents   PDDL   PDDL 2.1   PDDL 2.2   PDDL 3   PDDL+   Planners\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL      PDDL 1.2  Contributors: Adam Green,   Introduction  PDDL 1.2 (Ghallab et al., 1998) formed the basis of the 1998 AIPS Competition. PDDL 1.2 is based largely on concepts set out for STRIPS, a sort of precursor languages which used a similar design pattern for describing problems through the use of predicates and actions. Problems in PDDL are defined in two parts, a domain and a problem file. The following sections divide respectively, representing constituent parts of the domain and the problem.   Domain And Problem File    Domain  (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Problem File  (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects
        s1 - site
        b - bricks
        w - windows
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL Domain   PDDL Problem   PDDL Requirements\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Domain      Domain  Contributors: Adam Green, Jan Dolejsi, A domain file in PDDL 1.2 defines the “universal” aspects of a problem. Essentially, these are the aspects that do not change regardless of what specific situation we’re trying to solve. In PDDL 1.2 this is mostly the object types, predicates and actions that can exist within the the model. (define
    (domain construction)
    (:extends building)
    (:requirements :strips :typing)
    (:types
        site material - object
        bricks cables windows - material
    )
    (:constants mainsite - site)

    ;(:domain-variables ) ;deprecated

    (:predicates
        (walls-built ?s - site)
        (windows-fitted ?s - site)
        (foundations-set ?s - site)
        (cables-installed ?s - site)
        (site-built ?s - site)
        (on-site ?m - material ?s - site)
        (material-used ?m - material)
    )

    (:timeless (foundations-set mainsite))

    ;(:safety
        ;(forall
        ;    (?s - site) (walls-built ?s)))
        ;deprecated

    (:action BUILD-WALL
        :parameters (?s - site ?b - bricks)
        :precondition (and
            (on-site ?b ?s)
            (foundations-set ?s)
            (not (walls-built ?s))
            (not (material-used ?b))
        )
        :effect (and
            (walls-built ?s)
            (material-used ?b)
        )
        ; :expansion ;deprecated
    )

    (:axiom
        :vars (?s - site)
        :context (and
            (walls-built ?s)
            (windows-fitted ?s)
            (cables-installed ?s)
        )
        :implies (site-built ?s)
    )

    ;Actions omitted for brevity
)
   Contents   Domain Name Extends Requirements Object Types Constants Domain Variables Predicates Timeless Predicates Safety Constraint Actions    Domain Name  back to contents Support: Universal Usage: High     (domain <name>)
 A domain always begins by being named. Imediately after we open our first brackets and write (define the next argument should be (domain <name>). Although most planners take the domain from the file you pass them on the command line and won’t bother checking if the domain name in the domain file corresponds to the domain name in the problem file, some will. It is best practice to include this name, just in case.     (domain construction)
 Note that this name is also used when we’re extending a domain.   Extends  back to contents Support: Poor Usage: Rare/None     (:extends <domain_name>)
 The :extends argument allows a domain to extend another “parent” domain. When the :extends argument is used, a domain inherits the following from it’s parent  requirements types constants actions axioms timeless propositions    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements as specified in the 1998 technical manual for the AIPS competition, however, not all are supported anymore.  :strips :typing :disjunctive-preconditions :equality :existential-preconditions :universal-preconditions :quantified-preconditions :conditional-effects :action-expansions :foreach-expansions :dag-expansions :domain-axioms :subgoal-through-axioms :safety-constraints :expression-evaluation :fluents :open-world :true-negation :adl :ucpop    Object Types  back to contents Support: Universal Usage: High (:types
    <type_name_1> ... <type_name_n> - object
    <sub_name_1> ... <sub_name_n> - <type_name_1>
)
 Typing allows us to create basic and subtypes to which we can apply predicates. We use types to restrict what objects can form the parameters of an action. Types and subtypes allow us to declare both general and specific actions and predicates e.g. (:types
    site material - object
    bricks cables windows - material
)
 Here is a types delaration. We have a type site which represents a building site and a type material which represents any generic building material. We then declare sub types bricks, cables and windows which are all types of building materials. We can declare general predicates which apply to any base type e.g.     (material-used ?m - material)
 which applys to anything of a material type. Or we can create specific predicates, such as     (windows-clean ?w - windows)
 Which only apply to a specific sub-type. We can go further and do the same with actions for example. (:action MOVE-MATERIAL
    :parameters (?s1 - site ?s2 - site ?m -material)
    ...
)
 Where we wish to express for example the movement of any material from one site to another. The material which we are moving doesn’t really matter as it’s only being moved. Note that we cannot then use predicates such as (windows-clean) within this action as not all material has this predicate defined for it. Alternatively, if we want to use a specific material, such as when we’re building a wall we might declare an action like so (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    ...
)
 This action above requires that the specific object is a bricks type and therefore we can use predicates which use bricks. However, because all bricks are materials we can also use predicates that take materials for example (material-used) within our action.   Constants  back to contents Support: High Usage: Low     (:constants mainsite - site)
 Constants allow us to declare objects that are present across all instances of a problem. In the example above we assume that all problems contain a mainsite and some may then also contain additional building sites. This isn’t particularly common in practice because we would just declare the object repeatedly in each specific problem.   Domain Variables  back to contents Support: Changed Usage: Rare (in this context)     (:domain-variables (numthings 2) - integer)
 Domain variables are an older way of expressing numerics which is redefined in PDDL2.1. You likely won’t see domains declared like this in favour of the simpler more expressive format used in PDDL2.1. Further, most planners won’t support this syntax.   Predicates  back to contents Support: Universal Usage: High (:predicates
    (<predicate_name> <argument_1> ... <argument_n>)
)
 Predicates apply to a specific type of object, or to all objects. Predicates are either true or false at any point in a plan and when not declared are assumed to be false (except when the Open World Assumption is included as a requirement). An example of a predicate declaration can be seen below. In most cases predicate normally take only one or two objects as arguments. But this is not a restriction and predicates can (in theory) take as many arguments as the user wishes. (:predicates
    (walls-built ?s - site)
    (windows-fitted ?s - site)
    (foundations-set ?s - site)
    (cables-installed ?s - site)
    (site-built ?s - site)
    (on-site ?m - material ?s - site)
    (material-used ?m - material)
)
 In this case, when the predicate (walls-built ?s) is true for a given site, then we can assume that said site has had walls built on it. When it is false, we would assume that the site does not have walls on it. In another case, let’s say with have multiple sites with various materials distributed across them, we can use the predicate on-site to model the location of a material across different sites. e.g. (on-site bricks1 site1) implies that the material bricks1 are currently located on site1. To move the bricks we would create an action which indicates that (on-site bricks1 site1) is now false and (assuming site2 is where we’re moving them to) that (on-site bricks1 site2) is now true.   Timeless Predicates  back to contents Support: Poor Usage: Rare/None     (:timeless (<predicate_name> <arguments>))
 A timeless predicate is a predicate which is always true and cannot be changed by any action in the domain. It’s not clear why you would need to model something that is always true and never changes, but it was included in the spec. An example is provided below.     (:timeless (foundations-set mainsite))
   Safety Constraint  back to contents Support: Poor Usage: Rare/None     (:safety <condition>)
 A safety condition is a condition which for any plan to be valid, must be true at the end of the plan. How this differs from a goal condition is not clear. (:safety
    (forall
        (?s - site) (walls-built ?s)))
 It might be used in order to essentially define global goals, goals which must be met regardless of the specific problem. In reality, these kind of global goals would still be encoded into the problem file.   Actions  back to contents Support: Universal Usage: High (:action <action_name>
    :parameters (<argument_1> ... <argument_n>)
    :precondition (<logical_expression>)
    :effect (<logical_expression>)
    ; :expansion
)
 An action defines a transformation the state of the world. This transformation is typically an action which could be performed in the execution of the plan, such as picking up an object, constructing something or some other change. An action is broken down into three distinct sections, with an alternation possible on the last section. The first is the :parameters section which defines the things we are performing an action on and subsequently what predicates we will be checking and manipulating later. The second is the :precondition section. These are typically a series of predicate conjunctions and disjunctions which must be satisfied in order for the action the applied. Note that although an action’s precondition may be satisfied that doesn’t mean it is applied in a plan. Ultimately it is the effect the action has that matters. The third section is a choice between :effect and :expansion an action cannot have both. Most domains use :effect. No details are provided of how to use :expansion as not enough planners support it.   Action Contents   Action Example Parameters Preconditions Effects    Action Example  (:action BUILD-WALL
    :parameters (?s - site ?b - bricks)
    :precondition (and
        (on-site ?b ?s)
        (foundations-set ?s)
        (not (walls-built ?s))
        (not (material-used ?b))
    )
    :effect (and
        (walls-built ?s)
        (material-used ?b)
    )
)
   Parameters  Support: Universal Usage: High     :parameters (argument_1 ... argument_n)
     :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as:     (BUILD-WALL s1 b1)
    (BUILD-WALL s2 b1)
    (BUILD-WALL s3 b1)
    (BUILD-WALL s1 b2)
    (BUILD-WALL s2 b2)
    (BUILD-WALL s3 b2)
 Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that I don’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt these models.   Either  Support: High Usage: Rare/None     :parameters (?x - (either bricks windows))
 The either term expresses that a parameter may have one of any type within the either expression. In the example above, ?x can be of either type bricks or type windows. This functionality is rarely used in favour of subtyping. However, it might be the case where with direct inheritance it’s not possible to group two distinctly different types.   Preconditions  Support: Universal Usage: High :precondition (<logical_expression>)
 :precondition (and
    (on-site ?b ?s)
    (foundations-set ?s)
    (not (walls-built ?s))
    (not (material-used ?b))
)
 Preconditions are conditions which must be met in order for an action to be possible. Just because an action is possible, does not mean that it is definitely applied and a planner will always consider if an action moves the state closer to the goal state. The statement above is a conjunction and can be thought of as shown below     os(b, s) /\ fs(s) /\ ¬wb(s) /\ ¬mu(b)
 In PDDL and and or apply across all the predicates within them. For more details on logic keywords see below   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks)
    (not (material-used ?b))
)
 Forall cannot be used as an effect.   When  (forall (argument)
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks)
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)
 Exists cannot be used as an effect.   Effects  Support: Universal Usage: High     :effect (logical_expression)
 :effect (and
    (walls-built ?s)
    (material-used ?b)
)
 An effect consists of a conjunctive logical expression, which defines which values should be set to true or false if an action is applied. Note that whilst it is a logical expression, it doesn’t not have the expressivity of preconditions because there can only be one set of truth values we can assign to it. This limits us to using and and not to express the effects of an action. Although in theory we could also use forall as well, this is not supported and does not fit well with the modelling process as typically we take all of the objects (and therefore predicates) which we are planning to have an effect on as parameters.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Axioms  back to contents Support: High Usage: Low (:axiom
    :vars (arguments)
    :context (logical_expression)
    :implies (logical_expression)
)
 (:axiom
    :vars (?s - site)
    :context (and
        (walls-built ?s)
        (windows-fitted ?s)
        (cables-installed ?s)
    )
    :implies (site-built ?s)
)
 An axiom is a derived predicate which essentially takes its value as the result of evaluating a logical expression over other predicates. In the example above, we’re saying that for any given building site, if the walls are built (walls-built) and the windows are fitted (windows-fitted) and the cables installed (cables-installed) then this means the site is built (site-built). This is quite useful if there is a logical expression you’re using repeatedly in several locations, as you can simply reduce it to a single predicate. However, this syntax is not commonly used.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Problem      Problem  Contributors: Adam Green, Jan Dolejsi, A problem forms the other half of a planning problem. In the domain we express the global “worldly” aspects of a problem, such as what actions we can perform and what types of objects exist in the world we’re planning in. The problem then solidifies this expression by define exactly what objects exist, and what is true about them and then finally what the end goal is. What state we want the world to be in once the plan is finished. (define
    (problem buildingahouse)
    (:domain construction)
    ;(:situation <situation_name>) ;deprecated
    (:objects 
        s1 - site 
        b - bricks 
        w - windows 
        c - cables
    )
    (:init
        (on-site b s1)
        (on-site c s1)
        (on-site w s1)
    )
    (:goal (and
            (walls-built ?s1)
            (cables-installed ?s1)
            (windows-fitted ?s1)
        )
    )
)
   Contents   Problem Name Domain Situation Objects Init Goal    Problem Name  back to contents Support: Universal Usage: High     (problem <name>)
 Each problem is given a name, typically this is a unique identifier. This is to allow for usage of the situation keyword which allows a problem to be extended. However whilst the name is commonly included in most problems, the use of situation to extend problems is not. Most problem names are unimaginative like prob1 or p1.     (problem buildingahouse)
   Domain  back to contents Support: Universal Usage: High     (:domain <domain_name>)
 The domain argument refers to the domain in which the problem exists (see Domain for details of what a domain is). Although often defined in problem files, this argument is typically redundant as most planners take the domain and problem file from the command line and assume that the domain defined in one corresponds to the problem defined in the other. This is not always the case so it is worth specifying the domain name anyway.     (:domain construction)
   Situation  back to contents Support: Poor Usage: Rare/None     (:situation <parent_problem_name>)
 A situation argument inherits qualities from another problem file. In some cases all of our problems may have common features which we can express as part of a situation file. An example might be that all of our problems have two sites, a storage depot and a construction site. We could therefore express this as part of a situation and then within our problem file express only the aspects which are unique to the specific problem we’re looking at. The use of situation is not very common and most problem files will define even common elements across each file. It is also not a fully supported feature in some more modern planners.     (:situation generalbuildingproblem)
   Objects  back to contents Support: Universal Usage: High (:objects
    object_name_1 ... object_name_n - some_object_type
    ...
    object_name_1 ... object_name_n - some_object_type
)
 The objects block allows us to declare a set of objects which exist within our problem. each object name must be unique, and should be typed. If not typed then they will typically take on the properties of the base type object (see Domain - Object Types for details) (:objects
    s1 s2 s3 - site
    ba bb bc - bricks
    windowAlpha windowBeta windowCharlie - windows
    uierjiae faufhf uihrai - cables
)
 Note that whilst conventionally we would just use an abbreviation followed by a number, we are not required to, and can use even ridiculously unhelpful names (as shown above). (:objects 
    s1 - site 
    b - bricks 
    w - windows 
    c - cables
)
   Init  back to contents Support: Universal Usage: High (:init
    <predicate>
    ...
    <predicate>
)
 The initial state (init) defines specifically what predicates are true at the start of the problem. This is not a logical expression because it is simply a list of predicates which are true. Unless the planner or domain specify otherwise all problems have the “closed world” assumption applied meaning anything not specified as true is considered false. Therefore we only need to list things which are true. (:init
    (on-site b s1)
    (on-site c s1)
    (on-site w s1)
)
 In the case of our domain and problem, the only facts which are true are that the materials we need to build are on-site.   Goal  back to contents Support: Universal Usage: High (:goal logical_expression)
 The goal is a logical expression of predicates which must be satisfied in order for a plan to be considered a solution. In essence it is what we want the world to look like at the end. Note that as a logical expression, if this expression excludes some predicate, then the value of that predicate is not considered important. This means that a goal should not only consist of the predicates that should be true, but also the predicate which should be false. Note that all standard logical operators such as or and forall are available as part of the goal, which means we can express multiple different goal states all of which are acceptable. (:goal (and
        (walls-built ?s1)
        (cables-installed ?s1)
        (windows-fitted ?s1)
    )
)
 Typically most goals are just conjunctions and negations as there is only one desirable state at the end of the plan.   And      (and (predicate_1) ... (predicate_n))
 A conjunction of predicates, expressing that all values must be true in order to evaluate to true. e.g.     (and (walls-built ?s) (windows-fitted ?s))
   Or      (or (predicate_1) ... (predicate_n))
 A disjunction of predicates, expressing at least one of the values must be true in order to evaluate true. e.g.     (or (windows-fitted ?s) (cables-installed ?s))
   Imply      (imply (antecedent_predicate) (consequent_predicate))
 An implies across an antecedent predicate and a consequence predicate. An implies evaluates true whenever the antecedent is false, or the antecedent and consequent are true. e.g.     (imply (walls-built ?s) (foundations-set ?s))
   Not      (not (logical_expression/predicate_name))
 Not negates a predicate value or logical expression. In a precondition it expresses that some predicate value or logical expression is false. In an effect it assigns false to a predicate value.     (not (material-used ?b))
   Forall      (forall (argument) logical_expression)
 Forall takes an argument and expresses that some logical expression holds true across it. In this case that all brick objects in the domain have not been used. (forall (?b - bricks) 
    (not (material-used ?b))
)
   When  (forall (argument) 
    when (inclusion_expression)
        logical expression
)
 When extends a forall condition to specify an inclusion condition. Essentially it says forall these objects when these conditions are met check that these conditions are met. e.g. (forall (?c - bricks) 
    when (on-site ?c ?s)
        (material-used ?c)
)
 Is expressing that forall bricks, that meet the condition on-site ?c ?s they must also meet the condition that they’ve been used material-used ?c.   Exists      (exists (argument) logical_expression)
 Exists expresses the same as forall except rather than expressing that every object of a given type meet a logical expression, it expresses that at least one meets the logical expression. e.g. (exists
    (?c - bricks)
        (not (material-used ?c))
)\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL PDDL Requirements      Requirements (PDDL 1.2)  Contributors: Adam Green, Jan Dolejsi, The following page offers details of requirements defined in PDDL 1.2 (Ghallab et al., 1998).   Contents   STRIPS Typing Disjunctive Preconditions Equality Existential Preconditions Universal Preconditions Quantified Preconditions Conditional Effects Action Expansions Foreach Expansions DAG Expansions Domain Axioms Subgoals Through Axioms Safety Constraints Expression Evaluation Fluents Open World True Negation ADL UCPOP    STRIPS  Support: Universal Usage: High     (:requirements :strips)
 Allows the usage of basic add and delete effects as specified in STRIPS. e.g. Add:     :effect (walls-built ?s)
 Delete:     :effect (not (walls-built ?s))
   Typing  Support: Universal Usage: High     (:requirements :typing)
 Allows the usage of typing for objects. Typing is similar to classes and sub-classes in Object-Oriented Programming e.g. (:types
    site material - object
    bricks cables windows - material
)
   Disjunctive Preconditions  Support: High Usage: Low     (:requirements :disjunctive-preconditions)
 Allows the usage of or in goals and preconditions e.g. (or
    (walls-built ?s)
    (windows-fitted ?s)
)
   Equality  Support: High Usage: Low     (:requirements :equality)
 Allows the usage of = to compare objects. For example if we have two objects as arguments ?s1 and ?s2 we can compare them to see if they’re the same. e.g.     (not (= ?s1 ?s2))
   Existential Preconditions  Support: High Usage: Low     (:requirements :existential-preconditions)
 Allows for the use of exists in goals and preconditions. Exists is essentially an additional parameter which we don’t need apart from a subset of the conditions for example. (exists (?c - crane)
    (crane-is-free ?c)
)
 Typically, exists is not used in favour of just adding an additional argument to the action parameters.   Universal Preconditions  Support: High Usage: Low     (:requirements :universal-preconditions)
 Allows for the use of forall in goals and preconditions. Universal is essentially the counter-part to the exists statement, providing for a condition that is true across all objects of a type, or just all objects. (forall (?c - crane)
    (crane-is-free ?c)
)
 Conditions that all the cranes in the problem are free.   Quantified Preconditions  Support: High Usage: Low     (:requirements :quantified-preconditions)
 Short hand way of expressing both universal and existential preconditions. It is equivalent to     (:requirements :existential-preconditions :universal-preconditions)
   Conditional Effects  Support: High Usage: Low     (:requirements :conditional-effects)
 Allows for the usage of when in expressing action effects. Essentially saying if something is true, then apply this effect too. (when
    ;Antecedent
    (and (has-hot-chocolate ?p ?c) (has-marshmallows ?c))
    ;Consequence
    (and (person-is-happy ?p))
)
 Here we express that when a person has a hot chocolate with marshmallows in, there is additional effect that the person is happy, which might not otherwise be true had we given them a different beverage or indeed a hot chocolate without marshmallows.   Action Expansions  Support: Poor/None Usage: Rare/None     (:requirements :action-expansions)
 Allows for usage of action expansions. This allows for the definition of variant condition and effects of actions. Essentially, we could define a MOVE action to describe movement of say a person, but include different expansions to describe movement by plane, train, car or foot. This has be rendered redundant as we would instead just express multiple actions such as MOVE-BY-PLANE and MOVE-BY-TRAIN.   Foreach Expansions  Support: Poor/None Usage: Rare/None     (:requirements :foreach-expansions)
 Allows for usage of foreach in action expansions, essentially allowing the application of effects across a type of object or across all objects. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :foreach-expansions)
   DAG Expansions  Support: Poor/None Usage: Rare/None     (:requirements :dag-expansions)
 Allows the expansions described in Action Expansions to labelled so that you can distinguish between which sub-action was chosen by the planner. For example if we defined a move action which makes use of different modes of transport we might want to know exactly what mode was used by labelling. This requirement implies the existence of the :action-expansions requirement and therefore is equivalent to     (:requirements :action-expansions :dag-expansions)
   Domain Axioms  Support: Medium Usage: Low     (:requirements :domain-axioms)
 Allows the use of axioms. Axioms are essentially predicates that are implied by other predicates. See the section on Axioms in the domain reference for PDDL 1.2   Subgoals Through Axioms  Support: Poor/None Usage: Rare/None     (:requirements :subgoals-through-axioms)
 Subgoals through axioms is a way of creating subgoals by showing that an axiom is a subset of the goal. This has become fairly redundant as this is something a planner could extract through domain preprocessing. A user should not have to tell a planner the techniques it should use to solve a problem and so subgoals through axioms runs counter to that in some way.   Safety Constraints  Support: Poor/None Usage: Rare/None     (:requirements :safety-constraints)
 A safety constraint is a predicate which must be true by the end of the plan in order for the plan to be considered valid. How this varies from a goal state is not really clear.   Expression Evaluation  Support: Poor/None Usage: Rare/None     (:requirements :expression-evaluation)
 Allows the usage of eval in axioms, in which two predicates are compared to one another and if they are equivalent eval returns true. e.g.     (eval (im-not-true ?a) (im-true ?b))
 Evaluates to false, if we assume that im-not-true is false and im-true is true. This requirement implies the existence of the :domain-axioms requirement and therefore is equivalent to     (:requirements :domain-axioms :expression-evaluation)
   Fluents  Support: Meaning Has Changed Usage: Rare (in this context)     (:requirements :fluents)
 Allows the usage of (fluents t), fluent support in PDDL1.2 is different to how later versions of PDDL model numeric values. This requirement implies the existence of the :expression-evaluation requirement and therefore is equivalent to     (:requirements :expression-evaluation :fluents)
   Open World  Support: Poor/None Usage: Rare/None     (:requirements :open-world)
 In planning all unknown values are assumed to be false. That is to say that if we do not know the value of a predicate, then we assume it to be false. This is known as the “closed world” assumption. This requirement mutates the planner to make an “open world” assumption. That is that values which are not known are not necessarily false. This is rarely supported in more modern planners and often is a flag in the planner execution and not a requirement in the domain.   True Negation  Support: Poor/None Usage: Rare/None     (:requirements :true-negation)
 Don’t treat negation as failure, treat it how it is in first order logic. This requirement implies the existence of the :open-world requirement and therefore is equivalent to     (:requirements :open-world :true-negation)
   ADL  Support: High Usage: Low     (:requirements :adl)
 ADL is a super requirement which adds the following requirements  :strips :typing :disjunctive-preconditions :equality :quantified-preconditions :conditional-effects    UCPOP  Support: Poor/None Usage: Rare/None     (:requirements :ucpop)
 UCPOP is a super requirement which adds the following requirements  :adl (see above) :domain-axioms :safety-constraints  Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1      PDDL 2.1  Contributors: Adam Green,   Introduction  PDDL 2.1 (Fox & Long, 2003) was the language of the 2002 AIPS Competition and built upon the syntax defined for PDDL 1.2 (Ghallab et al., 1998). In the 2002 Competition, planners were set the challenge of considering more complicated domains and problems which feature both temporal and numeric considerations (scheduling and resources). As a result, additions the language were necessary to facilitate modelling time and numbers. This guide will only show features that have been changed or added to PDDL 1.2 in order to form 2.1   Domain And Problem File    Domain  (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )
    (:predicates
        ... ; Predicates omitted
	)

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Problem  (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
 Fox, M., & Long, D. (2003). PDDL2.1: An Extension to PDDL for Expressing Temporal Planning Domains. CoRR, abs/1106.4561. http://arxiv.org/abs/1106.4561 Ghallab, M., Knoblock, C., Wilkins, D., Barrett, A., Christianson, D., Friedman, M., Kwok, C., Golden, K., Penberthy, S., Smith, D., Sun, Y., & Weld, D. (1998). PDDL - The Planning Domain Definition Language.  Table of contents   PDDL 2.1 Domain   PDDL 2.1 Problem   PDDL 2.1 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Domain      Domain  Contributors: Adam Green, Jan Dolejsi, Mau Magnaguagno, The domain syntax in PDDL2.1 extended upon version 1.2 to include two key new features, durative-actions and functions which are referred to as numeric fluents. Additional new requirements were specified on top of the 1.2 spec to allow older planners to identify that they could not solve these neweer domains. (define (domain rover-domain)
    (:requirements :durative-actions :fluents :duration-inequalities)
    (:types rover waypoint)
    (:predicates
        ... ; Predicates omitted
	)
    (:functions
        (battery-amount ?r - rover)
        (sample-amount ?r - rover)
        (recharge-rate ?r - rover)
        (battery-capacity)
        (sample-capacity)
        (distance-travelled)
    )

    (:durative-action move
        :parameters
            (?r - rover
             ?fromwp - waypoint
             ?towp - waypoint)

        :duration
            (= ?duration 5)

        :condition
	        (and
	            (at start (rover ?rover))
	            (at start (waypoint ?from-waypoint))
	            (at start (waypoint ?to-waypoint))
	            (over all (can-move ?from-waypoint ?to-waypoint))
	            (at start (at ?rover ?from-waypoint))
	            (at start (> (battery-amount ?rover) 8)))

        :effect
	        (and
                (decrease (fuel-level ?t) (* 2 #t))
	            (at end (at ?rover ?to-waypoint))
	            (at end (been-at ?rover ?to-waypoint))
	            (at start (not (at ?rover ?from-waypoint)))
	            (at start (decrease (battery-amount ?rover) 8))
                (at end (increase (distance-travelled) 5))
                )
	)
    ... ; Additional actions omitted
)
   Contents   Requirements  List of Requirements   Numeric Fluents Durative Actions Continuous Effects    Requirements  back to contents Support: Universal Usage: High (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g. (:requirements :strips :adl :typing)
   List of Requirements  The following is a list of requirements that were added by PDDL2.1 to the language of PDDL.  :fluents :durative-actions :durative-inequalities :continuous-effects :negative-preconditions    Numeric Fluents  back to contents Support: High Usage: High (:functions
    (<variable_name> <parameter_name> - <object_type>)
    ...
    (<variable_name> <parameter_name> - <object_type>)
)
 A numeric fluent, similar to a predicate, is a variable which applies to zero or more objects and maintains a value throughout the duration of the plan. It is declared with a name followed by the object type to which it applies. e.g. (:functions
    (battery-level ?r - rover)
)
 Means that every rover object in the domain has a variable which maintains a value for battery-level. A function can apply to zero or more objects, meaning we could also use it to represent a numeric value between two values, for example a distance. (:functions
    (distance ?wp1 - waypoint ?wp2 - waypoint)
)
 Numeric fluents can be altered through the effects of both actions and durative-actions. There are a number of supported effects for numeric fluents.   Prefix Maths (Numeric Expressions)  Support: High Usage: High   Add  (+ (sample-capacity) (battery-capacity))
   Subtract  (- (sample-capacity) (battery-capacity))
   Divide  (/ (sample-capacity) (battery-capacity))
   Multiply  (* (sample-capacity) (battery-capacity))
 Prefix notation is used to represent maths operations on numeric fluents. We can see the four primarily binary operations we can perform on numeric fluents. In all of these cases, to convert to infix notation we place the operator between the name of the two fluents.   Increase  Support: High Usage: High (increase (battery-level ?r) 10)
 An increase effect increases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the increase value for example. (increase (battery-level ?r) (charge-available - ?solarpanel))
   Decrease  Support: High Usage: High (decrease (battery-level ?r) 10)
 A decrease effect decreases the value of a numeric variable by the given amount. It is possible to use another numeric variable as the decrease value for example. (decrease (battery-level ?r) (power-needed-for-work - ?task))
   Assign  Support: High Usage: High (assign (battery-level ?r) 10)
 An assign effect assigns the value of a numeric variable to the given amount. It is possible to use another numeric variable as the assign value for example. (assign (battery-level ?r) (max-charge ?r))
   Scale Up  Support: High Usage: Rare (scale-up (battery-level ?r) 2)
 A scale up effect increases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-up (battery-level ?r) (charge-rate ?r))
   Scale Down  Support: High Usage: Rare (scale-down (battery-level ?r) 2)
 A scale down effect decreases the value of the numeric variable by the given scale factor. The scale factor can be another numeric variable. (scale-down (battery-level ?r) (consumption-rate ?r))
   Durative Actions  back to contents Support: High Usage: High (:durative-action <action_name>
    :parameters (<arguments>)
    :duration (= ?duration <duration_number>)
    :condition (logical_expression)
    :effect (logical_expression)
)
 A durative action is an action which represents an action which takes an amount of time to complete. The amount of time is expressable as either a value or as an inequality (allow for both fixed duration and ranged duration actions). Similar to traditional actions we have conditions and effects, but it should be noted that the keyword in durative actions is condition NOT precondition. This semantic change is designed to represent that a durative action may not just condition when the action starts, but may have conditions which need to be true at the end or over the duration of the action. A good example of this can be found in flight planning, where an action fly requires that a runway be free at the start and end of an action, in order for the plane to take off and land, whilst the runway does not need to be free whilst the plane is flying.   Parameters  Support: Universal Usage: High :parameters (argument_1 ... argument_n)
 :parameters (?s -site ?b - bricks)
 The parameters defines the type of object we’re interested in. Note that a parameter can take any type or subtype. If we have for example three instances of site such as s1, s2 and s3 and we have two instances of bricks b1, b2, our planner considers all possible actions such as: (BUILD-WALL s1 b1) (BUILD-WALL s2 b1) (BUILD-WALL s3 b1) (BUILD-WALL s1 b2) (BUILD-WALL s2 b2) (BUILD-WALL s3 b2) Therefore it is not up to us as a user to specify the specific object to which an action applies but rather the type of objects to which the action applies. In this case, when we build a wall we need to know what bricks we’re using to build it and where we’re building it. Our actions are specific to the problem we’ve chosen to consider and model, therefore there might additional things that other user want/need to model that this model doesn’t. Your domain and problem should only consider and model the aspects of the problem which you’re trying to solve. For example here we haven’t modelled the person who’s actually going to perform the work, but maybe if we were the manager of a larger building site we might want to and therefore we would need to adapt my models.   Duration  Support: Universal (in temporal planners) Usage: High   Fixed Value:  :duration (= ?duration <duration_number>)
   Inequality Value  :duration (> ?duration <duration_number>)
 :duration (< ?duration <duration_number>)
 :duration (and
    (> ?duration <duration_number>)
    (< ?duration <duration_number>))
 A duration can be expressed as either a fixed value or an inequality. It is also possible to express duration as the value of a Numeric Fluent, which means an action such as move can have a duration dependent on say distance between two points. :duration (= ?duration 10)
   Condition  Support: Universal - in temporal planners Usage: High :condition (<logical_temporal_expression>)
 A condition is a logical and temporal expression which must be met in order for a durative action to execute. Because a durative action occurs over time, we may wish to express that additional conditions be met for the duration or end of the action, not just the start. This gives rise to three new keywords at start, at end and over all.   At Start  An expression or predicate with at start prefixed to it, means that the condition must be true at the start of the action in order for the action to be applied. e.g. (at start (at ?rover ?from-waypoint))
 expresses that at start the given rover is at the from-waypoint. Confusingly in this particular domain, the at is a predicate representing the location of an object at a point, whilst at start is a keyword. at start is usually applied per predicate.   At End  An expression or predicate with at end prefixed to it, means that the condition must be true at the end of the action in order for the action to be applied e.g. (at end (>= (battery-amount ?rover) 0))
 In essence we are saying that whilst this fact doesn’t have to be true at the start or during the action, it must be true at the end. In this case, we’re expressing that the battery amount at the end of the action must be greater than zero.   Over All  An expression or predicate with an overall prefixed to it, means that the condition must be true throughout the action, including at the start and end. e.g. (over all (can-move ?from-waypoint ?to-waypoint))
 At all points in the execution of the action the given expression must evaluate to true. In the case above, we are expressing that it must be possible to move from the from waypoint to the to waypoint all the way through the action. I.e. we don’t want to get half way through the action to find that after a certain point a path has become blocked.   Effect  Support: Universal - in temporal planners Usage: High :effect (<logical_temporal_condition>)
 An effect similar to in traditional actions, is a condition which is made true when an action is applied. Note that the effect is always more restrictive and typically only allows and and not as logical expressions. Temporal expressions, such as at start and at end are available, however, over all is typically not used. because it’s not common to express a boolean effect which is true over the duration of the action. Instead you would set it to true at the start, using an at start and set it to false at the end using at end :effect
    (and
        (at start (not (at ?rover ?from-waypoint)))
        (at start (decrease (battery-amount ?rover) 8))
        (at end (at ?rover ?to-waypoint))
        (at end (been-at ?rover ?to-waypoint)))
 The above effect is saying that at start the rover can no longer be considered as being at the from waypoint, and that at end it can now be considered as being at the to waypoint. It also adds a second predicate been-at which indicates that at some point the rover has visited the given waypoint.   Continuous Effects  Support: Medium Usage: High (increase (fuel ?tank) #t)
 (decrease (battery ?battery) (* 5 #t))
 Continuous effects are an additional way of defining effects, which merit their own dedicated section. A continous effect defines an effect on a numeric variable which is continuous through the application of a durative action. Put simply, it defines that a variable changes continously over the duration of the action. We can see these kind of effects in real world fuel and battery problems. As we drive for longer, we consume more fuel, therefore can be modelled using a continous effect. Furthermore, continuous effects allow planning models to consider the application of an action prior to the termination of a durative action. Imagine we have a recharge action which charges 1% of a battery for every unit of time, we would model it with this line within the effects block of an action (increase (battery ?b) #t)
 The #t acts a numeric variable representing the current point in time within the action so a function such as (* 2 #t) we are saying, for every time unit of an action, the value of the change is multiplied by 2. Lets say that our recharge action is half way through being applied and by that point the battery has recharged enough for us to apply another action which may consume some battery, without continuous effects, we would most likely apply the change at the end of the recharge action, meaning any action which wished to consume battery would have to wait for recharge to complete before it can be applied Without Continuous effects (plan length: 15)

b=0
    |--(recharge[10])--|      |--(drive[5])--| 
                    (b+=10) (b>5)          (b-=5)

With Continuous effects (plan length: 10)

b=0
    |--(recharge[10])--|
           (b+=#t)
              |--(drive[5])--|
            (b>5)          (b-=5)
 With continous effects, the battery has recharge to a level that is satisfies the drive action’s precondition half way through recharging. Without, we have to wait until the recharge effect of the recharge action is applied, before we can apply the drive action, resulting in a longer (and arguably sub-optimal) solution.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.1 has to be extended in order to complement the syntax of the domain file. One interesting extension to the syntax in PDDL 2.1 is the addition of a metric. A metric, which behaves like an optimisation function, defines a cost value for a plan. We then express whether we want this metric to be maximised (like in football) or minimised (like in golf). (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
   Contents   Numeric Fluents Metric Length    Numeric Fluents  back to contents Support: High Usage: High     (= (<fluent_name> <argument>) <value>)
 An equals prefix notation is used to assign a value to a numeric fluent. Some planners will require all possible numeric values for numeric fluents should be declared before it will attempt to plan.     (= (battery-amount r1) 10)
   Metric  back to contents Support: Medium Usage: High     (:metric minimize (<numeric_operation>))
     (:metric maximize (<numeric_operation>))
 A metric can be defined using some numeric operation on fluents, including using just a single fluent. The most common method for declaring a metric, is to declare a numeric fluent with no arguments and increase it within the effect of each action by the cost of that action. We can choose to either minimize or maximize the value of the metric function. Note, a metric function is NOT a replacement for a goal.   Length  back to contents Support: Deprecated Usage: Rare/None The length argument is deprecated. Few planners will support it (if any).\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.1 has to be extended in order to complement the syntax of the domain file. One interesting extension to the syntax in PDDL 2.1 is the addition of a metric. A metric, which behaves like an optimisation function, defines a cost value for a plan. We then express whether we want this metric to be maximised (like in football) or minimised (like in golf). (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
   Contents   Numeric Fluents Metric Length    Numeric Fluents  back to contents Support: High Usage: High     (= (<fluent_name> <argument>) <value>)
 An equals prefix notation is used to assign a value to a numeric fluent. Some planners will require all possible numeric values for numeric fluents should be declared before it will attempt to plan.     (= (battery-amount r1) 10)
   Metric  back to contents Support: Medium Usage: High     (:metric minimize (<numeric_operation>))
     (:metric maximize (<numeric_operation>))
 A metric can be defined using some numeric operation on fluents, including using just a single fluent. The most common method for declaring a metric, is to declare a numeric fluent with no arguments and increase it within the effect of each action by the cost of that action. We can choose to either minimize or maximize the value of the metric function. Note, a metric function is NOT a replacement for a goal.   Length  back to contents Support: Deprecated Usage: Rare/None The length argument is deprecated. Few planners will support it (if any).\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.1 has to be extended in order to complement the syntax of the domain file. One interesting extension to the syntax in PDDL 2.1 is the addition of a metric. A metric, which behaves like an optimisation function, defines a cost value for a plan. We then express whether we want this metric to be maximised (like in football) or minimised (like in golf). (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
   Contents   Numeric Fluents Metric Length    Numeric Fluents  back to contents Support: High Usage: High     (= (<fluent_name> <argument>) <value>)
 An equals prefix notation is used to assign a value to a numeric fluent. Some planners will require all possible numeric values for numeric fluents should be declared before it will attempt to plan.     (= (battery-amount r1) 10)
   Metric  back to contents Support: Medium Usage: High     (:metric minimize (<numeric_operation>))
     (:metric maximize (<numeric_operation>))
 A metric can be defined using some numeric operation on fluents, including using just a single fluent. The most common method for declaring a metric, is to declare a numeric fluent with no arguments and increase it within the effect of each action by the cost of that action. We can choose to either minimize or maximize the value of the metric function. Note, a metric function is NOT a replacement for a goal.   Length  back to contents Support: Deprecated Usage: Rare/None The length argument is deprecated. Few planners will support it (if any).\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.1 has to be extended in order to complement the syntax of the domain file. One interesting extension to the syntax in PDDL 2.1 is the addition of a metric. A metric, which behaves like an optimisation function, defines a cost value for a plan. We then express whether we want this metric to be maximised (like in football) or minimised (like in golf). (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
   Contents   Numeric Fluents Metric Length    Numeric Fluents  back to contents Support: High Usage: High     (= (<fluent_name> <argument>) <value>)
 An equals prefix notation is used to assign a value to a numeric fluent. Some planners will require all possible numeric values for numeric fluents should be declared before it will attempt to plan.     (= (battery-amount r1) 10)
   Metric  back to contents Support: Medium Usage: High     (:metric minimize (<numeric_operation>))
     (:metric maximize (<numeric_operation>))
 A metric can be defined using some numeric operation on fluents, including using just a single fluent. The most common method for declaring a metric, is to declare a numeric fluent with no arguments and increase it within the effect of each action by the cost of that action. We can choose to either minimize or maximize the value of the metric function. Note, a metric function is NOT a replacement for a goal.   Length  back to contents Support: Deprecated Usage: Rare/None The length argument is deprecated. Few planners will support it (if any).\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.1 has to be extended in order to complement the syntax of the domain file. One interesting extension to the syntax in PDDL 2.1 is the addition of a metric. A metric, which behaves like an optimisation function, defines a cost value for a plan. We then express whether we want this metric to be maximised (like in football) or minimised (like in golf). (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
   Contents   Numeric Fluents Metric Length    Numeric Fluents  back to contents Support: High Usage: High     (= (<fluent_name> <argument>) <value>)
 An equals prefix notation is used to assign a value to a numeric fluent. Some planners will require all possible numeric values for numeric fluents should be declared before it will attempt to plan.     (= (battery-amount r1) 10)
   Metric  back to contents Support: Medium Usage: High     (:metric minimize (<numeric_operation>))
     (:metric maximize (<numeric_operation>))
 A metric can be defined using some numeric operation on fluents, including using just a single fluent. The most common method for declaring a metric, is to declare a numeric fluent with no arguments and increase it within the effect of each action by the cost of that action. We can choose to either minimize or maximize the value of the metric function. Note, a metric function is NOT a replacement for a goal.   Length  back to contents Support: Deprecated Usage: Rare/None The length argument is deprecated. Few planners will support it (if any).\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.1 has to be extended in order to complement the syntax of the domain file. One interesting extension to the syntax in PDDL 2.1 is the addition of a metric. A metric, which behaves like an optimisation function, defines a cost value for a plan. We then express whether we want this metric to be maximised (like in football) or minimised (like in golf). (define
    (problem rover1)
    (:domain rover-domain)
    (:objects
        r1 r2 - rover
        wp1 wp2 - waypoint
    )
    (:init
        (= (battery-amount r1) 100)
        (= (recharge-rate r1) 2.5)
        ...
    )
    (:goal (and
            ...
        )
    )
    (:metric maximize (+
            (battery-amount r1)
            (battery-amount r2)
        )
    )
)
   Contents   Numeric Fluents Metric Length    Numeric Fluents  back to contents Support: High Usage: High     (= (<fluent_name> <argument>) <value>)
 An equals prefix notation is used to assign a value to a numeric fluent. Some planners will require all possible numeric values for numeric fluents should be declared before it will attempt to plan.     (= (battery-amount r1) 10)
   Metric  back to contents Support: Medium Usage: High     (:metric minimize (<numeric_operation>))
     (:metric maximize (<numeric_operation>))
 A metric can be defined using some numeric operation on fluents, including using just a single fluent. The most common method for declaring a metric, is to declare a numeric fluent with no arguments and increase it within the effect of each action by the cost of that action. We can choose to either minimize or maximize the value of the metric function. Note, a metric function is NOT a replacement for a goal.   Length  back to contents Support: Deprecated Usage: Rare/None The length argument is deprecated. Few planners will support it (if any).\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.1 PDDL 2.1 Requirements      Requirements (PDDL 2.1)  Contributors: Adam Green,   Numeric Fluents  Support: High Usage: High     (:requirements :numeric-fluents)
 Allows the inclusion of a :function block which represent numeric variables in the domain. e.g. (:functions
    (battery-amount ?r - rover)
)
 Note that this overrides the definition in PDDL1.2 in most planners.   Durative Actions  Support: High Usage: High     (:requirements :durative-actions)
 Allows the use of durative-action in the domain definition. Durative actions are actions which have a duration they take to complete. (:durative-action move
    :parameters (<arguments>)
    :duration (= ?duration 5)
    :condition (logical_expression)
    :effect (logical_expression)
)
 Note that this does not imply :fluents   Durative Inequalities  Support: High Usage: High     (:requirements :durative-inequalities)
 Allows the use of inequalities to express a duration. Rather than expressing that an action has a fixed length of time we can express that an action has a duration range using an inequality.   Continuous Effects  Support: Medium Usage: High     (:requirements :continuous-effects)
 Allows the use of continuous effects on numerics within durative actions. Because durative actions take a period of time, we could model the change in a numeric value as some function of time. In reality support for this shaky. Linear functions are relatively easy for planners but non-linear effects are still an area of research.   Negative Preconditions  Support: Low Usage: High     (:requirements :negative-preconditions)
 Allows the use of not in preconditions. The way some planners model actions mean they are not capable of handling negative preconditions. This is more an inconvenience that a serious design flaw as for every predicate their is an opposing predicate which is true when it’s false. I.e. rover-charged and rover-not-charged are mutually exclusive. In the event where negative preconditions are not support we can introduce a second predicate which represents the negation of the predicate we want to express a negative precondition on.\n\n\n\nReport an issue with this page         Reference PDDL 2.2      PDDL 2.2  Contributors: Adam Green,   Introduction  PDDL 2.2 {$ cite pddl222004 %} introduces a key new feature not previously considered in PDDL, Timed Initial Literals. In previous versions, we assumed that a predicate was either true or false at the start. This is not a realistic way of modelling because it fails to consider facts which may become true later. For example, in dynamic planning, where we are planning and re-planning as the world changes, we may wish to represent resources or states which are in the course of changing which we have no control over. Imagine for instance, we are planning a rail schedule. We’ve generated some schedule from a plan, which the trains at this point in time are currently running to. Something goes wrong, for example a train breaks down. We now have less resources, but what we also have is a state that is currently in motion. So for example we may have another dozen trains currently in use that won’t become available until some later stage than the point we’re currently planning at. We can’t represent these realistically with actions because actions are optional, instead we need some mechanism to represent the uncontrollable change of state at a later point in time. This is what timed initial literals allow us to do, by indicating at what point in time a fact which was previously false, becomes true. Now we could arguably jury rig this behaviour with cleverly created durative actions and predicates, that are forced to run at a certain point and then subsequently release the resource after the time has elapsed, but these approaches will almost certainly have a significant overhead to them, because creating a durative action which the planners has to figure out it has to run in order to do everything else, will increase the state space necessary to explore. Bottom line, Timed Initial Literals add a simple yet powerful new aspect to planning. PDDL 2.2 also reintroduces Axioms as derived predicates, with a different simpler syntax to them. To be clear, these features are the same but consist of different syntax, typically planners support the newer syntax. *This is speculative.   Table of contents   PDDL 2.2 Domain   PDDL 2.2 Problem   PDDL 2.2 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.2      PDDL 2.2  Contributors: Adam Green,   Introduction  PDDL 2.2 {$ cite pddl222004 %} introduces a key new feature not previously considered in PDDL, Timed Initial Literals. In previous versions, we assumed that a predicate was either true or false at the start. This is not a realistic way of modelling because it fails to consider facts which may become true later. For example, in dynamic planning, where we are planning and re-planning as the world changes, we may wish to represent resources or states which are in the course of changing which we have no control over. Imagine for instance, we are planning a rail schedule. We’ve generated some schedule from a plan, which the trains at this point in time are currently running to. Something goes wrong, for example a train breaks down. We now have less resources, but what we also have is a state that is currently in motion. So for example we may have another dozen trains currently in use that won’t become available until some later stage than the point we’re currently planning at. We can’t represent these realistically with actions because actions are optional, instead we need some mechanism to represent the uncontrollable change of state at a later point in time. This is what timed initial literals allow us to do, by indicating at what point in time a fact which was previously false, becomes true. Now we could arguably jury rig this behaviour with cleverly created durative actions and predicates, that are forced to run at a certain point and then subsequently release the resource after the time has elapsed, but these approaches will almost certainly have a significant overhead to them, because creating a durative action which the planners has to figure out it has to run in order to do everything else, will increase the state space necessary to explore. Bottom line, Timed Initial Literals add a simple yet powerful new aspect to planning. PDDL 2.2 also reintroduces Axioms as derived predicates, with a different simpler syntax to them. To be clear, these features are the same but consist of different syntax, typically planners support the newer syntax. *This is speculative.   Table of contents   PDDL 2.2 Domain   PDDL 2.2 Problem   PDDL 2.2 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.2      PDDL 2.2  Contributors: Adam Green,   Introduction  PDDL 2.2 {$ cite pddl222004 %} introduces a key new feature not previously considered in PDDL, Timed Initial Literals. In previous versions, we assumed that a predicate was either true or false at the start. This is not a realistic way of modelling because it fails to consider facts which may become true later. For example, in dynamic planning, where we are planning and re-planning as the world changes, we may wish to represent resources or states which are in the course of changing which we have no control over. Imagine for instance, we are planning a rail schedule. We’ve generated some schedule from a plan, which the trains at this point in time are currently running to. Something goes wrong, for example a train breaks down. We now have less resources, but what we also have is a state that is currently in motion. So for example we may have another dozen trains currently in use that won’t become available until some later stage than the point we’re currently planning at. We can’t represent these realistically with actions because actions are optional, instead we need some mechanism to represent the uncontrollable change of state at a later point in time. This is what timed initial literals allow us to do, by indicating at what point in time a fact which was previously false, becomes true. Now we could arguably jury rig this behaviour with cleverly created durative actions and predicates, that are forced to run at a certain point and then subsequently release the resource after the time has elapsed, but these approaches will almost certainly have a significant overhead to them, because creating a durative action which the planners has to figure out it has to run in order to do everything else, will increase the state space necessary to explore. Bottom line, Timed Initial Literals add a simple yet powerful new aspect to planning. PDDL 2.2 also reintroduces Axioms as derived predicates, with a different simpler syntax to them. To be clear, these features are the same but consist of different syntax, typically planners support the newer syntax. *This is speculative.   Table of contents   PDDL 2.2 Domain   PDDL 2.2 Problem   PDDL 2.2 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Domain      Domain  Contributors: Adam Green, Benjamin Jacob Reji, Jan Dolejsi, The domain syntax for PDDL2.2 adds very minimal changes to the domain. As with any update to PDDL it introduces new requirements, however, other than that the only new syntax is Derived Predicates, which are defined in a similar way to how actions are defined, and are defined in the same section of the domain file. (define
    (domain railways)
    (:requirements :derived-predicates :timed-initial-literals)
    (:types
        train station - object
    )
    (:predicates
        (train-not-in-use ?t - train)
        (train-has-guard ?t - train)
        (train-has-driver ?t - train)
        (train-usable ?t - train)
    )
    (:functions
        ... - omitted
    )
    (:durative-action MOVE-TRAIN
        ... - omitted
    )
    (:derived (train-usable ?t - train)
        (and
            (train-has-guard ?t)
            (train-has-driver ?t)
        )
    )
    (:derived
        ... - omitted
    )
)
   Contents   Requirements Derived Predicates    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL2.2 to the language of PDDL.  :derived-predicates :timed-initial-literals    Derived Predicates  back to contents Support: Medium Usage: Low     (:derived <predicate_name> <logical_expression>)
 A derived predicate is declared by naming the predicate who’s result is being derived, and a logical expression which is evaluated to work out the value. Note, that a derived predicate is declared similarly to actions, in that we use the :derived keyword for each declaration of a derived predicate. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
 The example above specifies that a train is only usable if it has a guard and a driver.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Domain      Domain  Contributors: Adam Green, Benjamin Jacob Reji, Jan Dolejsi, The domain syntax for PDDL2.2 adds very minimal changes to the domain. As with any update to PDDL it introduces new requirements, however, other than that the only new syntax is Derived Predicates, which are defined in a similar way to how actions are defined, and are defined in the same section of the domain file. (define
    (domain railways)
    (:requirements :derived-predicates :timed-initial-literals)
    (:types
        train station - object
    )
    (:predicates
        (train-not-in-use ?t - train)
        (train-has-guard ?t - train)
        (train-has-driver ?t - train)
        (train-usable ?t - train)
    )
    (:functions
        ... - omitted
    )
    (:durative-action MOVE-TRAIN
        ... - omitted
    )
    (:derived (train-usable ?t - train)
        (and
            (train-has-guard ?t)
            (train-has-driver ?t)
        )
    )
    (:derived
        ... - omitted
    )
)
   Contents   Requirements Derived Predicates    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL2.2 to the language of PDDL.  :derived-predicates :timed-initial-literals    Derived Predicates  back to contents Support: Medium Usage: Low     (:derived <predicate_name> <logical_expression>)
 A derived predicate is declared by naming the predicate who’s result is being derived, and a logical expression which is evaluated to work out the value. Note, that a derived predicate is declared similarly to actions, in that we use the :derived keyword for each declaration of a derived predicate. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
 The example above specifies that a train is only usable if it has a guard and a driver.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Domain      Domain  Contributors: Adam Green, Benjamin Jacob Reji, Jan Dolejsi, The domain syntax for PDDL2.2 adds very minimal changes to the domain. As with any update to PDDL it introduces new requirements, however, other than that the only new syntax is Derived Predicates, which are defined in a similar way to how actions are defined, and are defined in the same section of the domain file. (define
    (domain railways)
    (:requirements :derived-predicates :timed-initial-literals)
    (:types
        train station - object
    )
    (:predicates
        (train-not-in-use ?t - train)
        (train-has-guard ?t - train)
        (train-has-driver ?t - train)
        (train-usable ?t - train)
    )
    (:functions
        ... - omitted
    )
    (:durative-action MOVE-TRAIN
        ... - omitted
    )
    (:derived (train-usable ?t - train)
        (and
            (train-has-guard ?t)
            (train-has-driver ?t)
        )
    )
    (:derived
        ... - omitted
    )
)
   Contents   Requirements Derived Predicates    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL2.2 to the language of PDDL.  :derived-predicates :timed-initial-literals    Derived Predicates  back to contents Support: Medium Usage: Low     (:derived <predicate_name> <logical_expression>)
 A derived predicate is declared by naming the predicate who’s result is being derived, and a logical expression which is evaluated to work out the value. Note, that a derived predicate is declared similarly to actions, in that we use the :derived keyword for each declaration of a derived predicate. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
 The example above specifies that a train is only usable if it has a guard and a driver.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Domain      Domain  Contributors: Adam Green, Benjamin Jacob Reji, Jan Dolejsi, The domain syntax for PDDL2.2 adds very minimal changes to the domain. As with any update to PDDL it introduces new requirements, however, other than that the only new syntax is Derived Predicates, which are defined in a similar way to how actions are defined, and are defined in the same section of the domain file. (define
    (domain railways)
    (:requirements :derived-predicates :timed-initial-literals)
    (:types
        train station - object
    )
    (:predicates
        (train-not-in-use ?t - train)
        (train-has-guard ?t - train)
        (train-has-driver ?t - train)
        (train-usable ?t - train)
    )
    (:functions
        ... - omitted
    )
    (:durative-action MOVE-TRAIN
        ... - omitted
    )
    (:derived (train-usable ?t - train)
        (and
            (train-has-guard ?t)
            (train-has-driver ?t)
        )
    )
    (:derived
        ... - omitted
    )
)
   Contents   Requirements Derived Predicates    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL2.2 to the language of PDDL.  :derived-predicates :timed-initial-literals    Derived Predicates  back to contents Support: Medium Usage: Low     (:derived <predicate_name> <logical_expression>)
 A derived predicate is declared by naming the predicate who’s result is being derived, and a logical expression which is evaluated to work out the value. Note, that a derived predicate is declared similarly to actions, in that we use the :derived keyword for each declaration of a derived predicate. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
 The example above specifies that a train is only usable if it has a guard and a driver.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Domain      Domain  Contributors: Adam Green, Benjamin Jacob Reji, Jan Dolejsi, The domain syntax for PDDL2.2 adds very minimal changes to the domain. As with any update to PDDL it introduces new requirements, however, other than that the only new syntax is Derived Predicates, which are defined in a similar way to how actions are defined, and are defined in the same section of the domain file. (define
    (domain railways)
    (:requirements :derived-predicates :timed-initial-literals)
    (:types
        train station - object
    )
    (:predicates
        (train-not-in-use ?t - train)
        (train-has-guard ?t - train)
        (train-has-driver ?t - train)
        (train-usable ?t - train)
    )
    (:functions
        ... - omitted
    )
    (:durative-action MOVE-TRAIN
        ... - omitted
    )
    (:derived (train-usable ?t - train)
        (and
            (train-has-guard ?t)
            (train-has-driver ?t)
        )
    )
    (:derived
        ... - omitted
    )
)
   Contents   Requirements Derived Predicates    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL2.2 to the language of PDDL.  :derived-predicates :timed-initial-literals    Derived Predicates  back to contents Support: Medium Usage: Low     (:derived <predicate_name> <logical_expression>)
 A derived predicate is declared by naming the predicate who’s result is being derived, and a logical expression which is evaluated to work out the value. Note, that a derived predicate is declared similarly to actions, in that we use the :derived keyword for each declaration of a derived predicate. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
 The example above specifies that a train is only usable if it has a guard and a driver.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Domain      Domain  Contributors: Adam Green, Benjamin Jacob Reji, Jan Dolejsi, The domain syntax for PDDL2.2 adds very minimal changes to the domain. As with any update to PDDL it introduces new requirements, however, other than that the only new syntax is Derived Predicates, which are defined in a similar way to how actions are defined, and are defined in the same section of the domain file. (define
    (domain railways)
    (:requirements :derived-predicates :timed-initial-literals)
    (:types
        train station - object
    )
    (:predicates
        (train-not-in-use ?t - train)
        (train-has-guard ?t - train)
        (train-has-driver ?t - train)
        (train-usable ?t - train)
    )
    (:functions
        ... - omitted
    )
    (:durative-action MOVE-TRAIN
        ... - omitted
    )
    (:derived (train-usable ?t - train)
        (and
            (train-has-guard ?t)
            (train-has-driver ?t)
        )
    )
    (:derived
        ... - omitted
    )
)
   Contents   Requirements Derived Predicates    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL2.2 to the language of PDDL.  :derived-predicates :timed-initial-literals    Derived Predicates  back to contents Support: Medium Usage: Low     (:derived <predicate_name> <logical_expression>)
 A derived predicate is declared by naming the predicate who’s result is being derived, and a logical expression which is evaluated to work out the value. Note, that a derived predicate is declared similarly to actions, in that we use the :derived keyword for each declaration of a derived predicate. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
 The example above specifies that a train is only usable if it has a guard and a driver.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Requirements      Requirements (PDDL 2.2)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 2.2.   Derived Predicates  Support: Medium Usage: Low     (:requirements :derived-predicates)
 Allows the usage of derived predicates in domains. e.g. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
   Timed Initial Literals  Support: Medium Usage: Medium     (:requirements :timed-initial-literals)
 Allows the use of Timed Initial Literals when defining problems. e.g.     (at 10 (train-not-in-use t1))\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Requirements      Requirements (PDDL 2.2)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 2.2.   Derived Predicates  Support: Medium Usage: Low     (:requirements :derived-predicates)
 Allows the usage of derived predicates in domains. e.g. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
   Timed Initial Literals  Support: Medium Usage: Medium     (:requirements :timed-initial-literals)
 Allows the use of Timed Initial Literals when defining problems. e.g.     (at 10 (train-not-in-use t1))\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.2 is expanded very lightly in order to support Timed Initial Literals. The choice of keyword is an interesting one because at is a commonly used predicate name used to indicate that some locatable is in some location i.e. (at Adam Bush-House). The way in which this keyword is used to define timed initial literals means however that it should not conflict with domains that make use of at as a predicate name. However, this is entirely dependent on how the planner parses a plan. (define
    (problem trainplanning1)
    (:domain railways)
    (:objects
        Pompey Guildford London - station
        train1 train2 - train
    )
    (:init
        (train-not-in-use train1)
        (at 20 (train-not-in-use train2))
    )

    ... goal omitted
)
   Contents   Timed Initial Literals    Timed Initial Literals  back to contents Support: Medium Usage: Medium     (at <time_value> <predicate>)
 A timed initial literal is defined using the time keyword, followed by the value for the point in time which the predicate becomes true, followed by the predicate itself. In planning, time is treated as just a number, and no assumptions are made about the scale it represents, therefore writing something such as at 10 could express 10 seconds, minutes or indeed hours. Ultimately it is the responsibility of the modelling user to determine what scale they wish to map their model to, and therefore the “resolution” they get for the accuracy of time.     (at 20 (train-not-in-use train2))
 The statement above expresses that at some time 20, the train train2 will no longer be in use.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.2 is expanded very lightly in order to support Timed Initial Literals. The choice of keyword is an interesting one because at is a commonly used predicate name used to indicate that some locatable is in some location i.e. (at Adam Bush-House). The way in which this keyword is used to define timed initial literals means however that it should not conflict with domains that make use of at as a predicate name. However, this is entirely dependent on how the planner parses a plan. (define
    (problem trainplanning1)
    (:domain railways)
    (:objects
        Pompey Guildford London - station
        train1 train2 - train
    )
    (:init
        (train-not-in-use train1)
        (at 20 (train-not-in-use train2))
    )

    ... goal omitted
)
   Contents   Timed Initial Literals    Timed Initial Literals  back to contents Support: Medium Usage: Medium     (at <time_value> <predicate>)
 A timed initial literal is defined using the time keyword, followed by the value for the point in time which the predicate becomes true, followed by the predicate itself. In planning, time is treated as just a number, and no assumptions are made about the scale it represents, therefore writing something such as at 10 could express 10 seconds, minutes or indeed hours. Ultimately it is the responsibility of the modelling user to determine what scale they wish to map their model to, and therefore the “resolution” they get for the accuracy of time.     (at 20 (train-not-in-use train2))
 The statement above expresses that at some time 20, the train train2 will no longer be in use.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.2 is expanded very lightly in order to support Timed Initial Literals. The choice of keyword is an interesting one because at is a commonly used predicate name used to indicate that some locatable is in some location i.e. (at Adam Bush-House). The way in which this keyword is used to define timed initial literals means however that it should not conflict with domains that make use of at as a predicate name. However, this is entirely dependent on how the planner parses a plan. (define
    (problem trainplanning1)
    (:domain railways)
    (:objects
        Pompey Guildford London - station
        train1 train2 - train
    )
    (:init
        (train-not-in-use train1)
        (at 20 (train-not-in-use train2))
    )

    ... goal omitted
)
   Contents   Timed Initial Literals    Timed Initial Literals  back to contents Support: Medium Usage: Medium     (at <time_value> <predicate>)
 A timed initial literal is defined using the time keyword, followed by the value for the point in time which the predicate becomes true, followed by the predicate itself. In planning, time is treated as just a number, and no assumptions are made about the scale it represents, therefore writing something such as at 10 could express 10 seconds, minutes or indeed hours. Ultimately it is the responsibility of the modelling user to determine what scale they wish to map their model to, and therefore the “resolution” they get for the accuracy of time.     (at 20 (train-not-in-use train2))
 The statement above expresses that at some time 20, the train train2 will no longer be in use.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, The problem syntax in PDDL 2.2 is expanded very lightly in order to support Timed Initial Literals. The choice of keyword is an interesting one because at is a commonly used predicate name used to indicate that some locatable is in some location i.e. (at Adam Bush-House). The way in which this keyword is used to define timed initial literals means however that it should not conflict with domains that make use of at as a predicate name. However, this is entirely dependent on how the planner parses a plan. (define
    (problem trainplanning1)
    (:domain railways)
    (:objects
        Pompey Guildford London - station
        train1 train2 - train
    )
    (:init
        (train-not-in-use train1)
        (at 20 (train-not-in-use train2))
    )

    ... goal omitted
)
   Contents   Timed Initial Literals    Timed Initial Literals  back to contents Support: Medium Usage: Medium     (at <time_value> <predicate>)
 A timed initial literal is defined using the time keyword, followed by the value for the point in time which the predicate becomes true, followed by the predicate itself. In planning, time is treated as just a number, and no assumptions are made about the scale it represents, therefore writing something such as at 10 could express 10 seconds, minutes or indeed hours. Ultimately it is the responsibility of the modelling user to determine what scale they wish to map their model to, and therefore the “resolution” they get for the accuracy of time.     (at 20 (train-not-in-use train2))
 The statement above expresses that at some time 20, the train train2 will no longer be in use.\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Requirements      Requirements (PDDL 2.2)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 2.2.   Derived Predicates  Support: Medium Usage: Low     (:requirements :derived-predicates)
 Allows the usage of derived predicates in domains. e.g. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
   Timed Initial Literals  Support: Medium Usage: Medium     (:requirements :timed-initial-literals)
 Allows the use of Timed Initial Literals when defining problems. e.g.     (at 10 (train-not-in-use t1))\n\n\n\nReport an issue with this page         Reference PDDL 2.2 PDDL 2.2 Requirements      Requirements (PDDL 2.2)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 2.2.   Derived Predicates  Support: Medium Usage: Low     (:requirements :derived-predicates)
 Allows the usage of derived predicates in domains. e.g. (:derived (train-usable ?t - train)
    (and
        (train-has-guard ?t)
        (train-has-driver ?t)
    )
)
   Timed Initial Literals  Support: Medium Usage: Medium     (:requirements :timed-initial-literals)
 Allows the use of Timed Initial Literals when defining problems. e.g.     (at 10 (train-not-in-use t1))\n\n\n\nReport an issue with this page         Reference PDDL 3      PDDL 3.0  Contributors: Adam Green,   Introduction  PDDL 3.0 (Gerevini & Long, 2005) introduced soft goals to planning. As planning has grown to handle larger more complex problem, the way we express goals has had to change. In previous editions a goal was unavoidable. It had to be met in order for a a plan to be considered valid. With the introduction of preferences (soft goals), we are now able to express a desireable, but inconsequential goal. A goal which we would like to be satisfied but if it is not, then that is acceptable. For each soft goal we express, we include a cost for not meeting it. This cost essentially indicates how the plan quality is affected when such goal is not met. PDDL 3.0 also introduced constraints, a form of strong goal, which essentially can use the same keywords as used for preferences, but instead must be met for the plan to be considered valid. This allows us to express things such as facts that must become true after another, or facts which must always be true. See the keywords included in the Constraints and Preferences sections below. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.  Table of contents   PDDL 3 Domain   PDDL 3 Problem   PDDL 3 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 3      PDDL 3.0  Contributors: Adam Green,   Introduction  PDDL 3.0 (Gerevini & Long, 2005) introduced soft goals to planning. As planning has grown to handle larger more complex problem, the way we express goals has had to change. In previous editions a goal was unavoidable. It had to be met in order for a a plan to be considered valid. With the introduction of preferences (soft goals), we are now able to express a desireable, but inconsequential goal. A goal which we would like to be satisfied but if it is not, then that is acceptable. For each soft goal we express, we include a cost for not meeting it. This cost essentially indicates how the plan quality is affected when such goal is not met. PDDL 3.0 also introduced constraints, a form of strong goal, which essentially can use the same keywords as used for preferences, but instead must be met for the plan to be considered valid. This allows us to express things such as facts that must become true after another, or facts which must always be true. See the keywords included in the Constraints and Preferences sections below. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.  Table of contents   PDDL 3 Domain   PDDL 3 Problem   PDDL 3 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 3      PDDL 3.0  Contributors: Adam Green,   Introduction  PDDL 3.0 (Gerevini & Long, 2005) introduced soft goals to planning. As planning has grown to handle larger more complex problem, the way we express goals has had to change. In previous editions a goal was unavoidable. It had to be met in order for a a plan to be considered valid. With the introduction of preferences (soft goals), we are now able to express a desireable, but inconsequential goal. A goal which we would like to be satisfied but if it is not, then that is acceptable. For each soft goal we express, we include a cost for not meeting it. This cost essentially indicates how the plan quality is affected when such goal is not met. PDDL 3.0 also introduced constraints, a form of strong goal, which essentially can use the same keywords as used for preferences, but instead must be met for the plan to be considered valid. This allows us to express things such as facts that must become true after another, or facts which must always be true. See the keywords included in the Constraints and Preferences sections below. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.  Table of contents   PDDL 3 Domain   PDDL 3 Problem   PDDL 3 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 3      PDDL 3.0  Contributors: Adam Green,   Introduction  PDDL 3.0 (Gerevini & Long, 2005) introduced soft goals to planning. As planning has grown to handle larger more complex problem, the way we express goals has had to change. In previous editions a goal was unavoidable. It had to be met in order for a a plan to be considered valid. With the introduction of preferences (soft goals), we are now able to express a desireable, but inconsequential goal. A goal which we would like to be satisfied but if it is not, then that is acceptable. For each soft goal we express, we include a cost for not meeting it. This cost essentially indicates how the plan quality is affected when such goal is not met. PDDL 3.0 also introduced constraints, a form of strong goal, which essentially can use the same keywords as used for preferences, but instead must be met for the plan to be considered valid. This allows us to express things such as facts that must become true after another, or facts which must always be true. See the keywords included in the Constraints and Preferences sections below. Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.  Table of contents   PDDL 3 Domain   PDDL 3 Problem   PDDL 3 Requirements\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Requirements      Requirements (PDDL 3.0)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 3.0.   Preferences  Support: Medium Usage: Medium     (:requirements :preferences)
 Allows for the usage of preferences within problem definitions (soft goals).   Constraints  Support: Medium Usage: Low     (:requirements :constraints)
 Allows for the use of constraints within domain definitions (goals which must be satisfied in every state). e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
    )
)\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Requirements      Requirements (PDDL 3.0)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 3.0.   Preferences  Support: Medium Usage: Medium     (:requirements :preferences)
 Allows for the usage of preferences within problem definitions (soft goals).   Constraints  Support: Medium Usage: Low     (:requirements :constraints)
 Allows for the use of constraints within domain definitions (goals which must be satisfied in every state). e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
    )
)\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Domain      Domain  Contributors: Adam Green, ChrisE2018, Jan Dolejsi, As with all previous installations of PDDL, PDDL 3.0 introduces new requirements. It also introduces syntax for defining constraints. Constraints are form of goal which must be satisfied in all states of the plan. As an additional curiosity note, whilst it may seem that a constraint adds more complexity to a state space, in general it allows us to reduce it significantly, by increasing the number of invalid states. (define
    (domain logistics)
    (:requirements :preferences :constraints)
    (:types
        lorry package recipient location - object
    )
    (:predicates
        (deliver-to ?r - recipient ?p - package)
        (delivered ?p - package)
        (in ?p - package ?l - lorry)
        (at ?l - lorry ?loc - location)
    )
    (:constraints
        (and
            (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
            ... additional constraints omitted
        )
    )
    ; Actions omitted
)
   Contents   Requirements Constraints    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
   List of Requirements  This is a list of requirements that were added by PDDL3.0 to the language of PDDL.  :preferences :constraints    Constraints  back to contents Support: Medium Usage: Low (:constraints
    <logical_expression>
)
 Constraints are a conjunction of various forall/exists statements, which can make use of the keywords designed to facilitate preferences. Constraints are essentially facts which must be true in all states within a valid plan. Essentially a constraint expresses something we want to always be true, or some state-trajectory constraint (A constraint on how the state changes over time) . e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
        ... additional constraints omitted
    )
)
 The single constraint shown above expresses that for each lorry and location, the lorry should visit that location at most once. These kind of expressions can help planners reduce the number of states they need to explore by enforcing common sense logic. Now it may seem logical that if packages can be delivered in any particular order and there could potentially be more than one package to be delivered to a single location, that we would want to express that we only visit any given location exactly once with a given lorry (thus preventing us going to the same place twice). Users of this feature should be cautious of not ruling out non-apparent solutions. If for example we were planning a lorry based on fuel cost, it may be appropriate for a lorry to visit a location (such as a city) twice, once to deliver a package at the start of the journey, and once at the end to refuel for the journey home at a cheap fuel station.   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Problem      Problem  Contributors: Adam Green, Jan Dolejsi, New syntax is added to PDDL problems in PDDL3. This syntax allows us to express preferences as part of the :goal or :constraint sections of a problem file. Preferences over state trajectory constraints are expressed in the (:constraints ...) field,\ while preferences over goals are expressed in the (:goal ...) field. If a preference involves both a constraint and a goal, it is expressed in the :constraints field. Goal preferences expressed in the :goal field are implicitly interpreted under the at end modality. (define
    (problem logistics1)
    (:domain logistics)
    (:objects
        lorry1 lorry2 lorry3 - lorry
        p1 p2 p3 p4 - package
        r1 r2 r3 - recipient
        london portsmouth glasgow - location
    )
    (:init
        ... omitted
    )
    (:goal
        (at lorry1 glasgow)
        (preference atl2l (at lorry1 london))
        (preference atl2p (at lorry1 portsmouth))
    )
    (:constraints
        (preference visitLDNthenGLS
            (sometime-after (at lorry1 london) (at lorry1 glasgow))
        )
    )
    (:metric (minimize (+
        (* (is-violated atl2l) 1.2)
        (* (is-violated atl2p) 1.3)
        (* (is-violated visitLDNthenGLS) 3)
    )))
)
   Contents   Preferences  sometime-after sometime-before always-within hold-during hold-after at end   Metric    Preferences  back to contents Support: Medium Usage: Medium     preference <name> <goal>
 A preference is a soft goal, which often uses a state-trajectory constraint to express its goal. A preference/soft goal is a goal which does not need to be met in order for a plan to be valid but may incur a cost if the preference is not met. The syntax of a preference is defined such that it can be used as part of a conjunctive goal definition, meaning we can define preferences and goals together. An example preference below shows that lorry1 would ideally visit london before it visits glasgow (preference visitLDNthenGLS
    (sometime-after (at lorry1 london) (at lorry1 glasgow))
)
   always      always <predicate>
 The always state-trajectory constraint expresses that every state reached in the execution of the plan, contains the predicate specified. It essentially creates a constant predicate. In the case below we say that package1 is in lorry1 for all states reached by the plan.     always (in package1 lorry1)
   sometime      sometime <predicate>
 The sometime state trajectory constraint expresses at some point within the states reached by a plan, that the predicate specified is true. It essentially says, at some point, this fact is true. In the case below we’re saying that at some point, lorry1 should be in glasgow     sometime (at lorry1 glasgow)
   within      within <number> <predicate>
 The within state-trajectory constraint express that some predicate must become true within the specified number of plan steps. This is a rather unusual constraint because it varies between temporal and STRIPS domain. The number in the statement expresses the point in time in temporal plans. The number in the statement expresses the number of plan steps in STRIPS plans.     within 10 (at lorry1 collectionpoint)
   at-most-once      at-most-once <predicate>
 The at-most-once state-trajectory constraint expresses that a fact be true at most once. It is useful to prevent repeated visits to the same fact. e.g.     at-most-once (at lorry1 theendoftheworld)
   sometime-after      sometime-after <before_predicate> <after_predicate>
 The sometime-after state-trajectory constraint expresses that some predicate becomes true, at some point after a separate predicate becomes true.     sometime-after (at lorry1 london) (at lorry1 pompey)
 The above statement expresses that once lorry1 has been in london some point afterwards in should be in pompey.   sometime-before      sometime-before <after_predicate> <before_predicate>
 The sometime-before state-trajectory constraint expresses that some predicate should become true, before a separate predicate becomes true. e.g.     sometime-before (delivering lorry1) (at lorry1 warehouse)
 The above statement expresses that before lorry1 is marked as delivering it should have been at the warehouse (i.e. to pickup goods).   always-within      always-within <number> <condition> <predicate>
 The always within expresses a composition of always and within, essentially it says that whenever some condition/predicate is true, then within the specified number of steps/time, the other predicate should become true.   hold-during      hold-during <number> <number> <predicate>
 The holding-during state-trajectory constraint expresses that a predicate should hold true between the two points in time expressed. Essentially, action as an always with a fixed start and end point.     hold-during 20 30 (at lorry1 lorrycarpark)
 The statement above expresses that lorry1 should be parked between the points in time 20 and 30. If we imagine that time in our problem represents hours, then 20 would be 8PM on the first day, and 30 would be 6AM on the next day.   hold-after      hold-after <number> <predicate>
 The hold-after state-trajectory constraint expresses that a predicate should hold true after some point in time. Note that this predicate must remain true, forever after the give point. This makes it assymetric to within which only expresses a fact must become true before some point at least once.     hold-after 40 (empty lorry1)
 The above statement indicates that lorry1 should be empty after 40 and remain empty.   at end      at end <predicate>
 The at end goal preference expresses that a predicate should hold true at the end of the plan.     at end (at lorry1 london)
   Metric  For a full definition of the metric block in PDDl, please see PDDL 2.1 The metric is a numeric function which must either be minimized or maximised. PDDL3 extends on the definition in PDDL2.1 to include a helper function is-violated <name> which when given the name of a preference, gives a count of the number of times that constraint has been violated. In some cases, users may wish to weight certain preferences as being more costly than others, using a * operator, we can multiply the number of violations by a violation cost, to give us a total cost for violating that preference. e.g. Imagine we have two preferences, visitLDNthenGLS and lorryEndsAtDepot we can define a metric something like this (:metric
    (+
        (* (is-violated visitLDNthenGLS) 10)
        (* (is-violated lorryEndsAtDepot) 5)
    )
)
 The metric above essentially costs more not to visit london before glasgow than for the lorry to end at the depot. Usage notes: a preference can be violated once, or multiple times depending on how it’s defined. This is not covered in this reference, for more details see section 3.1 of “Plan Constraints and Preferences in PDDL 3” (Gerevini & Long, 2005) Gerevini, A., & Long, D. (2005). Plan Constraints and Preferences in PDDL3 The Language of the Fifth International Planning Competition. ICAPS 2006.\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Requirements      Requirements (PDDL 3.0)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 3.0.   Preferences  Support: Medium Usage: Medium     (:requirements :preferences)
 Allows for the usage of preferences within problem definitions (soft goals).   Constraints  Support: Medium Usage: Low     (:requirements :constraints)
 Allows for the use of constraints within domain definitions (goals which must be satisfied in every state). e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
    )
)\n\n\n\nReport an issue with this page         Reference PDDL 3 PDDL 3 Requirements      Requirements (PDDL 3.0)  Contributors: Adam Green, The following page offers details of requirements defined in PDDL 3.0.   Preferences  Support: Medium Usage: Medium     (:requirements :preferences)
 Allows for the usage of preferences within problem definitions (soft goals).   Constraints  Support: Medium Usage: Low     (:requirements :constraints)
 Allows for the use of constraints within domain definitions (goals which must be satisfied in every state). e.g. (:constraints
    (and
        (forall (?l - lorry ?loc - location) (at-most-once (at ?l ?loc)))
    )
)\n\n\n\nReport an issue with this page         Reference PDDL+      PDDL+  Contributors: Adam Green, PDDL+ (missing reference) introduced processes and events, to the domain of PDDL. Where previous updates to PDDL had introduced intractable rules such as Derived Predicates and Constraints, PDDL+ is the first to consider essentially actions which must be applied when their preconditions are met. Processes directly correspond to a durative action and last for as long as their pre-condition is met. A process is something like gravity’s effect on a ball, increases the velocity of the ball until it either reaches terminal velocity or indeed, it hits the ground. Events directly correspond to instantaneous actions, and happen the instant their preconditions are met, usually with the effect of transforming their state such that their precondition is no longer met. Events are uncontrollable, and in our ball example, we might consider an event to be the ball hitting the ground. In that instance, the velocity of the ball is negated, and multiplied by some bounce coefficient. Processes and events are still very much a challenge for some planners, and support is somewhat patch, with certain planners losing support for earlier features in PDDL in order to support this new feature. Most notably, Processes can (and usually do) have a continuous effect in a state, and therefore cause problems if we define a preference such as preference (always (< (velocity ball) 10)).   Table of contents   PDDL+ Domain\n\n\n\nReport an issue with this page         Reference PDDL+      PDDL+  Contributors: Adam Green, PDDL+ (missing reference) introduced processes and events, to the domain of PDDL. Where previous updates to PDDL had introduced intractable rules such as Derived Predicates and Constraints, PDDL+ is the first to consider essentially actions which must be applied when their preconditions are met. Processes directly correspond to a durative action and last for as long as their pre-condition is met. A process is something like gravity’s effect on a ball, increases the velocity of the ball until it either reaches terminal velocity or indeed, it hits the ground. Events directly correspond to instantaneous actions, and happen the instant their preconditions are met, usually with the effect of transforming their state such that their precondition is no longer met. Events are uncontrollable, and in our ball example, we might consider an event to be the ball hitting the ground. In that instance, the velocity of the ball is negated, and multiplied by some bounce coefficient. Processes and events are still very much a challenge for some planners, and support is somewhat patch, with certain planners losing support for earlier features in PDDL in order to support this new feature. Most notably, Processes can (and usually do) have a continuous effect in a state, and therefore cause problems if we define a preference such as preference (always (< (velocity ball) 10)).   Table of contents   PDDL+ Domain\n\n\n\nReport an issue with this page         Reference PDDL+ PDDL+ Domain      Domain  Contributors: Adam Green, Jan Dolejsi, PDDL+ (missing reference) introduces two new constructs to domains in PDDL, the first is Processes and the second is Events, both can essentially be thought of as uncontrollable durative actions, and uncontrollable instantaneous actions respectively. (define
    (domain ballphysics)
    (:requirements :time :typing)
    (:types
        ball - object
    )
    (:predicates
        (held ?b - ball)
    )
    (:functions
        (velocity ?b - ball)
        (distance-to-floor ?b - ball)
    )
    (:process FALLING
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (< (velocity ?b) 100)
        )
        :effect (and
            (increase (velocity ?b) (* #t 9.8))
            (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
        )
    )
    (:event HIT-GROUND
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (<= (distance-to-floor ?b) 0)
            (> (velocity ?b) 0)
        )
        :effect (
            (assign (velocity ?b) (* -0.8 (velocity ?b)))
        )
    )

    ; Actions omitted
)
   Contents   Requirements Processes Events    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
 Only one additional requirement is necessary in order to include both processes and events, this requirement is :time, as shown below     (:requirements :time)
   Processes  back to contents Support: Medium Usage: Low (:process FALLING
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (< (velocity ?b) 100)
    )
    :effect (and
        (increase (velocity ?b) (* #t 9.8))
        (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
    )
)
 A process is defined in three sections, :parameters, :precondition and :effect which define what a process is acting upon, when a process is acting upon it and what effect that process has when it acts. These directly correspond with the definition of an action found in PDDL 1.2, but can include the expressivity of numerics as seen in PDDL 2.1. Confusingly despite bearing similar behaviour to a durative action, a process conditions over it’s duration, therefore the precondition can be thought of more like an over all condition in PDDL 2.1 #t represents the time of the process, it is used to calculate continuous numeric effects, therefore, if about halfway through the process some action might wish to run which conditions on one of the numeric fluents affected by the process, #t can be used to calculate the intermediate value of such a numeric fluent.   Events  back to contents Support: Medium Usage: Low (:event HIT-GROUND
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (<= (distance-to-floor ?b) 0)
        (> (velocity ?b) 0)
    )
    :effect (
        (assign (velocity ?b) (* -0.8 (velocity ?b)))
    )
)
 An event is defined the same as a process in three sections, :parameters which are the objects upon which the effect acts :precondition which is the condition which must be satisfiend in order for the event to run and :effect which is the effect the event has. Note that the distinctive nature of an event is that whilst it can occur more than once it generally does not happen back to back. Essentially, an event is a discrete moment in time, where as a process is an interval of time. In the case above we see that the condition of hitting the ground is that velocity is greater than 0, and the effect is that velocity is negated, which ensures that - at least for a period - this event cannot run again.\n\n\n\nReport an issue with this page         Reference PDDL+ PDDL+ Domain      Domain  Contributors: Adam Green, Jan Dolejsi, PDDL+ (missing reference) introduces two new constructs to domains in PDDL, the first is Processes and the second is Events, both can essentially be thought of as uncontrollable durative actions, and uncontrollable instantaneous actions respectively. (define
    (domain ballphysics)
    (:requirements :time :typing)
    (:types
        ball - object
    )
    (:predicates
        (held ?b - ball)
    )
    (:functions
        (velocity ?b - ball)
        (distance-to-floor ?b - ball)
    )
    (:process FALLING
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (< (velocity ?b) 100)
        )
        :effect (and
            (increase (velocity ?b) (* #t 9.8))
            (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
        )
    )
    (:event HIT-GROUND
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (<= (distance-to-floor ?b) 0)
            (> (velocity ?b) 0)
        )
        :effect (
            (assign (velocity ?b) (* -0.8 (velocity ?b)))
        )
    )

    ; Actions omitted
)
   Contents   Requirements Processes Events    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
 Only one additional requirement is necessary in order to include both processes and events, this requirement is :time, as shown below     (:requirements :time)
   Processes  back to contents Support: Medium Usage: Low (:process FALLING
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (< (velocity ?b) 100)
    )
    :effect (and
        (increase (velocity ?b) (* #t 9.8))
        (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
    )
)
 A process is defined in three sections, :parameters, :precondition and :effect which define what a process is acting upon, when a process is acting upon it and what effect that process has when it acts. These directly correspond with the definition of an action found in PDDL 1.2, but can include the expressivity of numerics as seen in PDDL 2.1. Confusingly despite bearing similar behaviour to a durative action, a process conditions over it’s duration, therefore the precondition can be thought of more like an over all condition in PDDL 2.1 #t represents the time of the process, it is used to calculate continuous numeric effects, therefore, if about halfway through the process some action might wish to run which conditions on one of the numeric fluents affected by the process, #t can be used to calculate the intermediate value of such a numeric fluent.   Events  back to contents Support: Medium Usage: Low (:event HIT-GROUND
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (<= (distance-to-floor ?b) 0)
        (> (velocity ?b) 0)
    )
    :effect (
        (assign (velocity ?b) (* -0.8 (velocity ?b)))
    )
)
 An event is defined the same as a process in three sections, :parameters which are the objects upon which the effect acts :precondition which is the condition which must be satisfiend in order for the event to run and :effect which is the effect the event has. Note that the distinctive nature of an event is that whilst it can occur more than once it generally does not happen back to back. Essentially, an event is a discrete moment in time, where as a process is an interval of time. In the case above we see that the condition of hitting the ground is that velocity is greater than 0, and the effect is that velocity is negated, which ensures that - at least for a period - this event cannot run again.\n\n\n\nReport an issue with this page         Reference PDDL+ PDDL+ Domain      Domain  Contributors: Adam Green, Jan Dolejsi, PDDL+ (missing reference) introduces two new constructs to domains in PDDL, the first is Processes and the second is Events, both can essentially be thought of as uncontrollable durative actions, and uncontrollable instantaneous actions respectively. (define
    (domain ballphysics)
    (:requirements :time :typing)
    (:types
        ball - object
    )
    (:predicates
        (held ?b - ball)
    )
    (:functions
        (velocity ?b - ball)
        (distance-to-floor ?b - ball)
    )
    (:process FALLING
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (< (velocity ?b) 100)
        )
        :effect (and
            (increase (velocity ?b) (* #t 9.8))
            (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
        )
    )
    (:event HIT-GROUND
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (<= (distance-to-floor ?b) 0)
            (> (velocity ?b) 0)
        )
        :effect (
            (assign (velocity ?b) (* -0.8 (velocity ?b)))
        )
    )

    ; Actions omitted
)
   Contents   Requirements Processes Events    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
 Only one additional requirement is necessary in order to include both processes and events, this requirement is :time, as shown below     (:requirements :time)
   Processes  back to contents Support: Medium Usage: Low (:process FALLING
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (< (velocity ?b) 100)
    )
    :effect (and
        (increase (velocity ?b) (* #t 9.8))
        (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
    )
)
 A process is defined in three sections, :parameters, :precondition and :effect which define what a process is acting upon, when a process is acting upon it and what effect that process has when it acts. These directly correspond with the definition of an action found in PDDL 1.2, but can include the expressivity of numerics as seen in PDDL 2.1. Confusingly despite bearing similar behaviour to a durative action, a process conditions over it’s duration, therefore the precondition can be thought of more like an over all condition in PDDL 2.1 #t represents the time of the process, it is used to calculate continuous numeric effects, therefore, if about halfway through the process some action might wish to run which conditions on one of the numeric fluents affected by the process, #t can be used to calculate the intermediate value of such a numeric fluent.   Events  back to contents Support: Medium Usage: Low (:event HIT-GROUND
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (<= (distance-to-floor ?b) 0)
        (> (velocity ?b) 0)
    )
    :effect (
        (assign (velocity ?b) (* -0.8 (velocity ?b)))
    )
)
 An event is defined the same as a process in three sections, :parameters which are the objects upon which the effect acts :precondition which is the condition which must be satisfiend in order for the event to run and :effect which is the effect the event has. Note that the distinctive nature of an event is that whilst it can occur more than once it generally does not happen back to back. Essentially, an event is a discrete moment in time, where as a process is an interval of time. In the case above we see that the condition of hitting the ground is that velocity is greater than 0, and the effect is that velocity is negated, which ensures that - at least for a period - this event cannot run again.\n\n\n\nReport an issue with this page         Reference PDDL+ PDDL+ Domain      Domain  Contributors: Adam Green, Jan Dolejsi, PDDL+ (missing reference) introduces two new constructs to domains in PDDL, the first is Processes and the second is Events, both can essentially be thought of as uncontrollable durative actions, and uncontrollable instantaneous actions respectively. (define
    (domain ballphysics)
    (:requirements :time :typing)
    (:types
        ball - object
    )
    (:predicates
        (held ?b - ball)
    )
    (:functions
        (velocity ?b - ball)
        (distance-to-floor ?b - ball)
    )
    (:process FALLING
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (< (velocity ?b) 100)
        )
        :effect (and
            (increase (velocity ?b) (* #t 9.8))
            (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
        )
    )
    (:event HIT-GROUND
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (<= (distance-to-floor ?b) 0)
            (> (velocity ?b) 0)
        )
        :effect (
            (assign (velocity ?b) (* -0.8 (velocity ?b)))
        )
    )

    ; Actions omitted
)
   Contents   Requirements Processes Events    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
 Only one additional requirement is necessary in order to include both processes and events, this requirement is :time, as shown below     (:requirements :time)
   Processes  back to contents Support: Medium Usage: Low (:process FALLING
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (< (velocity ?b) 100)
    )
    :effect (and
        (increase (velocity ?b) (* #t 9.8))
        (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
    )
)
 A process is defined in three sections, :parameters, :precondition and :effect which define what a process is acting upon, when a process is acting upon it and what effect that process has when it acts. These directly correspond with the definition of an action found in PDDL 1.2, but can include the expressivity of numerics as seen in PDDL 2.1. Confusingly despite bearing similar behaviour to a durative action, a process conditions over it’s duration, therefore the precondition can be thought of more like an over all condition in PDDL 2.1 #t represents the time of the process, it is used to calculate continuous numeric effects, therefore, if about halfway through the process some action might wish to run which conditions on one of the numeric fluents affected by the process, #t can be used to calculate the intermediate value of such a numeric fluent.   Events  back to contents Support: Medium Usage: Low (:event HIT-GROUND
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (<= (distance-to-floor ?b) 0)
        (> (velocity ?b) 0)
    )
    :effect (
        (assign (velocity ?b) (* -0.8 (velocity ?b)))
    )
)
 An event is defined the same as a process in three sections, :parameters which are the objects upon which the effect acts :precondition which is the condition which must be satisfiend in order for the event to run and :effect which is the effect the event has. Note that the distinctive nature of an event is that whilst it can occur more than once it generally does not happen back to back. Essentially, an event is a discrete moment in time, where as a process is an interval of time. In the case above we see that the condition of hitting the ground is that velocity is greater than 0, and the effect is that velocity is negated, which ensures that - at least for a period - this event cannot run again.\n\n\n\nReport an issue with this page         Reference PDDL+ PDDL+ Domain      Domain  Contributors: Adam Green, Jan Dolejsi, PDDL+ (missing reference) introduces two new constructs to domains in PDDL, the first is Processes and the second is Events, both can essentially be thought of as uncontrollable durative actions, and uncontrollable instantaneous actions respectively. (define
    (domain ballphysics)
    (:requirements :time :typing)
    (:types
        ball - object
    )
    (:predicates
        (held ?b - ball)
    )
    (:functions
        (velocity ?b - ball)
        (distance-to-floor ?b - ball)
    )
    (:process FALLING
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (< (velocity ?b) 100)
        )
        :effect (and
            (increase (velocity ?b) (* #t 9.8))
            (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
        )
    )
    (:event HIT-GROUND
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (<= (distance-to-floor ?b) 0)
            (> (velocity ?b) 0)
        )
        :effect (
            (assign (velocity ?b) (* -0.8 (velocity ?b)))
        )
    )

    ; Actions omitted
)
   Contents   Requirements Processes Events    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
 Only one additional requirement is necessary in order to include both processes and events, this requirement is :time, as shown below     (:requirements :time)
   Processes  back to contents Support: Medium Usage: Low (:process FALLING
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (< (velocity ?b) 100)
    )
    :effect (and
        (increase (velocity ?b) (* #t 9.8))
        (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
    )
)
 A process is defined in three sections, :parameters, :precondition and :effect which define what a process is acting upon, when a process is acting upon it and what effect that process has when it acts. These directly correspond with the definition of an action found in PDDL 1.2, but can include the expressivity of numerics as seen in PDDL 2.1. Confusingly despite bearing similar behaviour to a durative action, a process conditions over it’s duration, therefore the precondition can be thought of more like an over all condition in PDDL 2.1 #t represents the time of the process, it is used to calculate continuous numeric effects, therefore, if about halfway through the process some action might wish to run which conditions on one of the numeric fluents affected by the process, #t can be used to calculate the intermediate value of such a numeric fluent.   Events  back to contents Support: Medium Usage: Low (:event HIT-GROUND
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (<= (distance-to-floor ?b) 0)
        (> (velocity ?b) 0)
    )
    :effect (
        (assign (velocity ?b) (* -0.8 (velocity ?b)))
    )
)
 An event is defined the same as a process in three sections, :parameters which are the objects upon which the effect acts :precondition which is the condition which must be satisfiend in order for the event to run and :effect which is the effect the event has. Note that the distinctive nature of an event is that whilst it can occur more than once it generally does not happen back to back. Essentially, an event is a discrete moment in time, where as a process is an interval of time. In the case above we see that the condition of hitting the ground is that velocity is greater than 0, and the effect is that velocity is negated, which ensures that - at least for a period - this event cannot run again.\n\n\n\nReport an issue with this page         Reference PDDL+ PDDL+ Domain      Domain  Contributors: Adam Green, Jan Dolejsi, PDDL+ (missing reference) introduces two new constructs to domains in PDDL, the first is Processes and the second is Events, both can essentially be thought of as uncontrollable durative actions, and uncontrollable instantaneous actions respectively. (define
    (domain ballphysics)
    (:requirements :time :typing)
    (:types
        ball - object
    )
    (:predicates
        (held ?b - ball)
    )
    (:functions
        (velocity ?b - ball)
        (distance-to-floor ?b - ball)
    )
    (:process FALLING
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (< (velocity ?b) 100)
        )
        :effect (and
            (increase (velocity ?b) (* #t 9.8))
            (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
        )
    )
    (:event HIT-GROUND
        :parameters (?b - ball)
        :precondition (and
            (not (held ?b))
            (<= (distance-to-floor ?b) 0)
            (> (velocity ?b) 0)
        )
        :effect (
            (assign (velocity ?b) (* -0.8 (velocity ?b)))
        )
    )

    ; Actions omitted
)
   Contents   Requirements Processes Events    Requirements  back to contents Support: Universal Usage: High     (:requirements <requirement_name>)
 Requirements are similar to import/include statements in programming languages, however as PDDL is a kind of declarative language, it is a :requirement as a given planner is “required” to facilitate some aspect of the language. Multiple :requirements can be specified through a space separated list e.g.     (:requirements :strips :adl :typing)
 Only one additional requirement is necessary in order to include both processes and events, this requirement is :time, as shown below     (:requirements :time)
   Processes  back to contents Support: Medium Usage: Low (:process FALLING
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (< (velocity ?b) 100)
    )
    :effect (and
        (increase (velocity ?b) (* #t 9.8))
        (decrease (distance-to-floor ?b) (* #t (velocity ?b)))
    )
)
 A process is defined in three sections, :parameters, :precondition and :effect which define what a process is acting upon, when a process is acting upon it and what effect that process has when it acts. These directly correspond with the definition of an action found in PDDL 1.2, but can include the expressivity of numerics as seen in PDDL 2.1. Confusingly despite bearing similar behaviour to a durative action, a process conditions over it’s duration, therefore the precondition can be thought of more like an over all condition in PDDL 2.1 #t represents the time of the process, it is used to calculate continuous numeric effects, therefore, if about halfway through the process some action might wish to run which conditions on one of the numeric fluents affected by the process, #t can be used to calculate the intermediate value of such a numeric fluent.   Events  back to contents Support: Medium Usage: Low (:event HIT-GROUND
    :parameters (?b - ball)
    :precondition (and
        (not (held ?b))
        (<= (distance-to-floor ?b) 0)
        (> (velocity ?b) 0)
    )
    :effect (
        (assign (velocity ?b) (* -0.8 (velocity ?b)))
    )
)
 An event is defined the same as a process in three sections, :parameters which are the objects upon which the effect acts :precondition which is the condition which must be satisfiend in order for the event to run and :effect which is the effect the event has. Note that the distinctive nature of an event is that whilst it can occur more than once it generally does not happen back to back. Essentially, an event is a discrete moment in time, where as a process is an interval of time. In the case above we see that the condition of hitting the ground is that velocity is greater than 0, and the effect is that velocity is negated, which ensures that - at least for a period - this event cannot run again.\n\n\n\nReport an issue with this page         Reference Planners      Planners  Contributors: Adam Green, An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances.  Table of contents   Planners from A to Z   Planners by tag   Planners by rating\n\n\n\nReport an issue with this page         Reference Planners      Planners  Contributors: Adam Green, An AI Planner is the other half of the proverbial planning equation. Where PDDL allows us to define an AI Planning problem, an AI Planner allows us to attempt to solve one. An AI planner reads in PDDL and uses it in order to decompose and solve the problem. As AI Planners have evolved alongside the languages they use, different planners have different levels of support for different syntaxes. Older planners do not support more expressive syntaxes such as PDDL3.0 or PDDL+. In some cases, however, older styles of syntax have been deprecated and as such some newer planners may not support certain variants of syntax. This means that in some cases a newer planner may not be capable of running an older problem and an older planner may not be capable of running a newer problem. In an attempt to combat this problem, as this guide evolves we’ll attempt to include notes about what functionality a broad range of planners support. There are however a really wide array of planners and some are objectively better or worse than others either unilaterally or in solving specific instances.  Table of contents   Planners from A to Z   Planners by tag   Planners by rating\n\n\n\nReport an issue with this page         Reference Planners Planners from A to Z      A to Z of Planners  Contributors: Adam Green, Felipe Meneguzzi, Mau Magnaguagno, The following is an A to Z of all known planners. This list is not a comprehensive list, but rather an attempt to aggregate different planners from as many known creators as possible. If you think a planner is missing, please file an issue here or submit a pull request with the correct changes. If your planner is missing from this list, please fork this repository, correct this page and file a pull request with the main repo. Please see our page on how to add a planner to this guide.    Planner Links tags     A       ACOPlan  (& ACOPlan 2) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Alien  Home Page [Not Found] | Paper tags: IPC2018 Satisfycing   AllPACA  Home Page [Not Found] | Paper tags: IPC2014 Optimising   Arvand  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Arvandherd  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   B       BiFD  Home Page [Not Found] | Paper tags: IPC2014 Satisfycing   BJOLP  Home Page [Not Found] | Paper tags: IPC2011 Optimising   BRT  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   C       C3  Home page [Not Found] | Paper tags: IPC2008 Satisfycing   CBP  (& CBP2) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Cerberus  (& Cerberus-gl) Home Page [Not Found] | Paper tags: IPC2018 Satisfycing   CFDP  Home Page [Not Found] | Paper tags: IPC2008 Optimising   cGamer  Home page [Not Found] | Paper tags: IPC2014 Optimising   COLIN  Home Page [Not Found] | Paper tags: Temporal Numeric   Complementary  (1 & 2) Home Page [Not Found] | Paper, Paper tags: IPC2018 Optimising   CoPlan  (styled Co-Plan) Home Page [Not Found] | Paper tags: IPC2008 Optimising   CP4TP  Home Page [Not Found] | Paper tags: IPC2018 Satisfycing Temporal   CPT  (& 2, 3 & 4) Home Page | Paper (CPT), Paper (CPT 2), Paper (CPT 4) tags: IPC2004 IPC2006 IPC2011 Optimising Temporal   D       DAEYAHSP  (styled DAE-YAHSP) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing Temporal   DecStar  Home Page [Not Found] | Paper tags: IPC2018 Optimising   Delfi  (1 & 2) Home Page [Not Found] | Paper tags: IPC2018 Optimising   DiNo  Home page | Paper Domains tags: temporal numeric   DPMPlan  Home Page [Not Found] | Paper tags: IPC2014 Optimising   E       ENHSP  Home Page | Paper tags: temporal numeric   F       FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper tags: IPC2004 IPC2006 IPC2008 IPC2011 IPC2014 IPC2018 Optimising Satisfycing   FF  The Fast Forward Planning System (and all other FF brand planners) Home Page | Paper tags: IPC2000 Satisfycing   Freelunch  Home Page [Not Found] | Paper tags: IPC2014 Satisfycing   G       Gamer  Home page [Not Found] | Paper tags: IPC2008 Optimising   H       HPlanP  (styled HPlan-P) Home Page [Not Found] | Paper tags: IPC2006 Optimising   HSP  Home Page [Not Found] | Paper tags: IPC1998 IPC2000 Satisfycing   HyperTensioN Guide Page | Home Page | Paper     I       IBaCoP-2018 Guide Page | Home Page | Paper     IBaCoP2-2018 Guide Page | Home Page | Paper     IFork Init Guide Page | Home Page | Paper     Imitation-Net Guide Page | Home Page | Paper     ITSAT Guide Page | Home Page | Paper     J       Jasper Guide Page | Home Page | Paper     JavaFF Guide Page | Home Page | Paper     JSHOP2 Guide Page | Home Page | Paper     K       L       LAMA-2011 Guide Page | Home Page | Paper     Lamar Guide Page | Home Page | Paper     LAPKT-BFWS-Preference Guide Page | Home Page | Paper     LAPKT-DFS+ Guide Page | Home Page | Paper     LAPKT-DUAL-BFWS Guide Page | Home Page | Paper     LAPKT-POLYNOMIAL-BFWS Guide Page | Home Page | Paper     LM-cut Guide Page | Home Page | Paper     LMFork Guide Page | Home Page | Paper     LMTD Guide Page | Home Page | Paper     LPRPG Guide Page | Home Page | Paper     LPRPG-P Guide Page | Home Page | Paper     M       Madagascar Guide Page | Home Page | Paper     Madagascar-pC Guide Page | Home Page | Paper     Marvin Guide Page | Home Page | Paper     maplan-1 Guide Page | Home Page | Paper     maplan-2 Guide Page | Home Page | Paper     mercury2014 Guide Page | Home Page | Paper     Merge and Shrink Guide Page | Home Page | Paper     MERWIN Guide Page | Home Page | Paper     MetricFF Guide Page | Home Page | Paper     Metis1 Guide Page | Home Page | Paper     Metis2 Guide Page | Home Page | Paper     MIPlan Guide Page | Home Page | Paper     Mips XXL Guide Page | Home Page | Paper     MSP Guide Page | Home Page | Paper     N       NuCeLar Guide Page | Home Page | Paper     O       OLCFF Guide Page | Home Page | Paper     OPTIC Guide Page | Home Page | Paper     P       PaaS Guide Page | Home Page | Paper     Panda Guide Page | Home Page | Paper     PHSFF Guide Page | Home Page | Paper     Planets Guide Page | Home Page | Paper     Planning-PDBs Guide Page | Home Page | Paper     PopCorm Guide Page | Home Page | Paper     POPF Guide Page | Home Page | Paper     PROBE Guide Page | Home Page | Paper     Prost-DD-1 Guide Page | Home Page | Paper     Prost-DD-2 Guide Page | Home Page | Paper     Q       R       Random-Bandit Guide Page | Home Page | Paper     Randward Guide Page | Home Page | Paper     Rational Lazy A* Guide Page | Home Page | Paper     RIDA Guide Page | Home Page | Paper     Roamer Guide Page | Home Page | Paper     RPT Guide Page | Home Page | Paper     S       Saarplan Guide Page | Home Page | Paper     SATPLANLM-C Guide Page | Home Page | Paper     Scorpion Guide Page | Home Page | Paper     Selective Max Guide Page | Home Page | Paper     Sharaabi Guide Page | Home Page | Paper     SHOP/SHOP2 Guide Page | Home Page | Paper     SHOP3 Guide Page | Home Page | Paper     SIW Guide Page | Home Page | Paper     SMTPlan+ Guide Page | Home Page | Paper     SPM&S Guide Page | Home Page | Paper     SymBA*-1 Guide Page | Home Page | Paper     SymBA*-2 Guide Page | Home Page | Paper     Symple-1 Guide Page | Home Page | Paper     Symple-2 Guide Page | Home Page | Paper     T       tBURTON Guide Page | Home Page | Paper     TemPorAl Guide Page | Home Page | Paper     Temporal Fast Downwards Guide Page | Home Page | Paper     TFLAP Guide Page | Home Page | Paper     TLP-GP Guide Page | Home Page | Paper     TSGP Guide Page | Home Page | Paper     U       UPMurphi Guide Page | Home Page | Paper     Upwards Guide Page | Home Page | Paper     USE Guide Page | Home Page | Paper     V       W       X       Y       YAHSP3 Guide Page | Home Page | Paper     YAHSP3-MT Guide Page | Home Page | Paper     Z\n\n\n\nReport an issue with this page         Reference Planners Planners from A to Z      A to Z of Planners  Contributors: Adam Green, Felipe Meneguzzi, Mau Magnaguagno, The following is an A to Z of all known planners. This list is not a comprehensive list, but rather an attempt to aggregate different planners from as many known creators as possible. If you think a planner is missing, please file an issue here or submit a pull request with the correct changes. If your planner is missing from this list, please fork this repository, correct this page and file a pull request with the main repo. Please see our page on how to add a planner to this guide.    Planner Links tags     A       ACOPlan  (& ACOPlan 2) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Alien  Home Page [Not Found] | Paper tags: IPC2018 Satisfycing   AllPACA  Home Page [Not Found] | Paper tags: IPC2014 Optimising   Arvand  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Arvandherd  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   B       BiFD  Home Page [Not Found] | Paper tags: IPC2014 Satisfycing   BJOLP  Home Page [Not Found] | Paper tags: IPC2011 Optimising   BRT  Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   C       C3  Home page [Not Found] | Paper tags: IPC2008 Satisfycing   CBP  (& CBP2) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing   Cerberus  (& Cerberus-gl) Home Page [Not Found] | Paper tags: IPC2018 Satisfycing   CFDP  Home Page [Not Found] | Paper tags: IPC2008 Optimising   cGamer  Home page [Not Found] | Paper tags: IPC2014 Optimising   COLIN  Home Page [Not Found] | Paper tags: Temporal Numeric   Complementary  (1 & 2) Home Page [Not Found] | Paper, Paper tags: IPC2018 Optimising   CoPlan  (styled Co-Plan) Home Page [Not Found] | Paper tags: IPC2008 Optimising   CP4TP  Home Page [Not Found] | Paper tags: IPC2018 Satisfycing Temporal   CPT  (& 2, 3 & 4) Home Page | Paper (CPT), Paper (CPT 2), Paper (CPT 4) tags: IPC2004 IPC2006 IPC2011 Optimising Temporal   D       DAEYAHSP  (styled DAE-YAHSP) Home Page [Not Found] | Paper tags: IPC2011 Satisfycing Temporal   DecStar  Home Page [Not Found] | Paper tags: IPC2018 Optimising   Delfi  (1 & 2) Home Page [Not Found] | Paper tags: IPC2018 Optimising   DiNo  Home page | Paper Domains tags: temporal numeric   DPMPlan  Home Page [Not Found] | Paper tags: IPC2014 Optimising   E       ENHSP  Home Page | Paper tags: temporal numeric   F       FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper tags: IPC2004 IPC2006 IPC2008 IPC2011 IPC2014 IPC2018 Optimising Satisfycing   FF  The Fast Forward Planning System (and all other FF brand planners) Home Page | Paper tags: IPC2000 Satisfycing   Freelunch  Home Page [Not Found] | Paper tags: IPC2014 Satisfycing   G       Gamer  Home page [Not Found] | Paper tags: IPC2008 Optimising   H       HPlanP  (styled HPlan-P) Home Page [Not Found] | Paper tags: IPC2006 Optimising   HSP  Home Page [Not Found] | Paper tags: IPC1998 IPC2000 Satisfycing   HyperTensioN Guide Page | Home Page | Paper     I       IBaCoP-2018 Guide Page | Home Page | Paper     IBaCoP2-2018 Guide Page | Home Page | Paper     IFork Init Guide Page | Home Page | Paper     Imitation-Net Guide Page | Home Page | Paper     ITSAT Guide Page | Home Page | Paper     J       Jasper Guide Page | Home Page | Paper     JavaFF Guide Page | Home Page | Paper     JSHOP2 Guide Page | Home Page | Paper     K       L       LAMA-2011 Guide Page | Home Page | Paper     Lamar Guide Page | Home Page | Paper     LAPKT-BFWS-Preference Guide Page | Home Page | Paper     LAPKT-DFS+ Guide Page | Home Page | Paper     LAPKT-DUAL-BFWS Guide Page | Home Page | Paper     LAPKT-POLYNOMIAL-BFWS Guide Page | Home Page | Paper     LM-cut Guide Page | Home Page | Paper     LMFork Guide Page | Home Page | Paper     LMTD Guide Page | Home Page | Paper     LPRPG Guide Page | Home Page | Paper     LPRPG-P Guide Page | Home Page | Paper     M       Madagascar Guide Page | Home Page | Paper     Madagascar-pC Guide Page | Home Page | Paper     Marvin Guide Page | Home Page | Paper     maplan-1 Guide Page | Home Page | Paper     maplan-2 Guide Page | Home Page | Paper     mercury2014 Guide Page | Home Page | Paper     Merge and Shrink Guide Page | Home Page | Paper     MERWIN Guide Page | Home Page | Paper     MetricFF Guide Page | Home Page | Paper     Metis1 Guide Page | Home Page | Paper     Metis2 Guide Page | Home Page | Paper     MIPlan Guide Page | Home Page | Paper     Mips XXL Guide Page | Home Page | Paper     MSP Guide Page | Home Page | Paper     N       NuCeLar Guide Page | Home Page | Paper     O       OLCFF Guide Page | Home Page | Paper     OPTIC Guide Page | Home Page | Paper     P       PaaS Guide Page | Home Page | Paper     Panda Guide Page | Home Page | Paper     PHSFF Guide Page | Home Page | Paper     Planets Guide Page | Home Page | Paper     Planning-PDBs Guide Page | Home Page | Paper     PopCorm Guide Page | Home Page | Paper     POPF Guide Page | Home Page | Paper     PROBE Guide Page | Home Page | Paper     Prost-DD-1 Guide Page | Home Page | Paper     Prost-DD-2 Guide Page | Home Page | Paper     Q       R       Random-Bandit Guide Page | Home Page | Paper     Randward Guide Page | Home Page | Paper     Rational Lazy A* Guide Page | Home Page | Paper     RIDA Guide Page | Home Page | Paper     Roamer Guide Page | Home Page | Paper     RPT Guide Page | Home Page | Paper     S       Saarplan Guide Page | Home Page | Paper     SATPLANLM-C Guide Page | Home Page | Paper     Scorpion Guide Page | Home Page | Paper     Selective Max Guide Page | Home Page | Paper     Sharaabi Guide Page | Home Page | Paper     SHOP/SHOP2 Guide Page | Home Page | Paper     SHOP3 Guide Page | Home Page | Paper     SIW Guide Page | Home Page | Paper     SMTPlan+ Guide Page | Home Page | Paper     SPM&S Guide Page | Home Page | Paper     SymBA*-1 Guide Page | Home Page | Paper     SymBA*-2 Guide Page | Home Page | Paper     Symple-1 Guide Page | Home Page | Paper     Symple-2 Guide Page | Home Page | Paper     T       tBURTON Guide Page | Home Page | Paper     TemPorAl Guide Page | Home Page | Paper     Temporal Fast Downwards Guide Page | Home Page | Paper     TFLAP Guide Page | Home Page | Paper     TLP-GP Guide Page | Home Page | Paper     TSGP Guide Page | Home Page | Paper     U       UPMurphi Guide Page | Home Page | Paper     Upwards Guide Page | Home Page | Paper     USE Guide Page | Home Page | Paper     V       W       X       Y       YAHSP3 Guide Page | Home Page | Paper     YAHSP3-MT Guide Page | Home Page | Paper     Z\n\n\n\nReport an issue with this page         Planners ACOPlan      Ant Colony Optimisation (ACO) Plan  Page Contributors: Adam Green, tags: IPC2011 Satisfycing Planner Quality: 14.9 out of 100 Year Published: 2009 Paper: ACO Plan: Planning with Ants [ Baioletti, M. Milani, A. Poggioni, V. Rossi, F ] Preceded By: - ACOPlan is a planner based on the ant colony optimization framework, in which a colony of planning ants searches for near optimal solution plans with respect to an overall plan cost metric. This approach is motivated by the strong similarity between the process used by artificial ants to build solutions and the methods used by state–based planners to search solution plans. Planning ants perform a stochastic and heuristic based search by interacting through a pheromone model.   Support  ACOPlan has not been tested with eviscerator as we could not find source code for the planner, or we couldn’t get the source code to compile. ACOPlan appears to be targeted to solving classical planning problems, so likely does not support any temporal or numeric features in PDDL.   Downloading and Compiling ACOPlan  No Source code could be located for ACOPlan\n\n\n\nReport an issue with this page         Planners Planners by tag IPC2011 Tags      International Planning Competition 2011  Page Contributors: Adam Green, The planners listed below are participating planners in the International Planning Competition that took place in 2011. The seventh such planning competition, This competition consisted of three tracks:  deterministic track  Satisfycing Optimal Multi-core Temporal Satisfycing   planning and learning track uncertainty track  For more information on this competition, please refer to the original competition page which you can find here   Participating Planners by A to Z     Planner Links     A     ACOPlan  (& ACOPlan 2) Home Page [Not Found] | Paper   Arvand  Home Page [Not Found] | Paper   Arvandherd  Home Page [Not Found] | Paper   B     BJOLP  Home Page [Not Found] | Paper   BRT  Home Page [Not Found] | Paper   C     CBP  (& CBP2) Home Page [Not Found] | Paper   CPT  (& 2, 3 & 4) Home Page | Paper (CPT), Paper (CPT 2), Paper (CPT 4)   D     DAEYAHSP  (styled DAE-YAHSP) Home Page [Not Found] | Paper   F     FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper\n\n\n\nReport an issue with this page         Planners Planners by tag Satisfycing Tag      Satisfycing Planners  Page Contributors: Adam Green, The planners listed below are planners that belong to subset of satisfycing planners. Planners are satisfycing if they find any plan to problem presented, regardless of quality. In Satisfycing planning resource management, particularly time, is the determining factor. Satisfycing planners should attempt to find any solution in as short a time as possible. This page makes no distinction between classically satisfycing planners and temporal numeric satisfycing planners.   Satisfycing Planners by A to Z     Planner Links     A     ACOPlan  (& ACOPlan 2) Home Page [Not Found] | Paper   Alien  Home Page [Not Found] | Paper   Arvand  Home Page [Not Found] | Paper   Arvandherd  Home Page [Not Found] | Paper   B     BRT  Home Page [Not Found] | Paper   C     C3  Home page [Not Found] | Paper   CBP  (& CBP2) Home Page [Not Found] | Paper   {$ planner Cerberus %} (& Cerberus-gl) Paper   CP4TP  Home Page [Not Found] | Paper   D     DAEYAHSP  (styled DAE-YAHSP) Home Page [Not Found] | Paper   F     FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper   Freelunch  Home Page [Not Found] | Paper   H     HSP  Home Page [Not Found] | Paper\n\n\n\nReport an issue with this page         Planners Alien      Alien Planner  Page Contributors: Adam Green, tags: IPC2018 Satisfycing Planner Quality: 38.1 out of 100 Year Published: 2018 Paper: Alien: Return of Alien Technology to Classical Planning [ Asai, M. ] Preceded By: - Alien puts an emphasis on preprocessing and low-level performance. This planner is intended to an alternative framework to The Fast Downward Planning [Link Needed], and gives an emphasis to improved preprocessing stages, code quality, and low-level performance.   Support  Alien planner has yet to be successfully tested with Eviscerator, although we believe it is possible and will attempt to conduct a test soon [test needed]. Alien states it is a classical planner in its IPC planner submission so most likely does not support temporal numerics   Downloading and Compiling Alien Planner  Alien planner source code with a singularity container support can be found as part of a BitBucket submission to IPC2018\n\n\n\nReport an issue with this page         Planners Planners by tag IPC2018 Tags      International Planning Competition 2014  Page Contributors: Adam Green, The planners listed below are participating planners in the International Planning Competition that took place in 2018. The Ninth such planning competition, This competition consisted of three tracks:  Deterministic Track Probablistic Track Temporal Track  For more information on this competition, please refer to the original competition pages which are linked to above   Participating Planners by A to Z     Planner Links     A     Alien  Home Page [Not Found] | Paper   C     {$ planner Cerberus %} (& Cerberus-gl) Paper   Complementary  (1 & 2) Home Page [Not Found] | Paper, Paper   CP4TP  Home Page [Not Found] | Paper   D     DecStar  Home Page | Paper   Delfi  (1 & 2) Home Page [Not Found] | Paper   F     FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper\n\n\n\nReport an issue with this page         Planners AllPACA      The AllPACA Planner: All Planners Automatic Choice Algorithm  Page Contributors: Adam Green, tags: IPC2014 Optimising Planner Quality: 31.2 out of 100 Year Published: 2014 Paper: IPC 2014 Booklet [ Malitsky, Y. Wang, D. Karpas, E. ] Preceded By: Fast Downward The AllPACA planner is a portfolio planner, which automatically chooses which of several planners to run for the planning task that it is given. AllPACA is based on machine learning techniques, which attempt to choose the planner that will result in the fastest solution time, based on the features of the planning task. In the sequential optimal track, AllPACA was pre-trained on all planning tasks the sequential optimal track in all previous editions of the International Planning Competition. For the learning track, AllPACA can also learn to predict planner performance on tasks from each domain during the training phase, and can additionally exploit domainspecific features.   Support  AllPACA has not been tested with eviscerator as we couldn’t get the source code to compile. Fast Downward forms the base planner of AllPACA, please refer to the Fast Downward [Link Needed] page for an idea of the supported features in this planner   Downloading and Compiling AllPACA  Source code for AllPACA was zipped with all IPC 2014 submissions here\n\n\n\nReport an issue with this page         Planners Planners by tag IPC2014 Tags      International Planning Competition 2014  Page Contributors: Adam Green, The planners listed below are participating planners in the International Planning Competition that took place in 2014. The Eighth such planning competition, This competition consisted of three tracks:  Deterministic track  Satisfycing Optimal Multi-core Temporal Satisfycing   Planning and Learning track Uncertainty track  Continuous Discrete    For more information on this competition, please refer to the original competition pages which are linked to above   Participating Planners by A to Z     Planner Links     A     AllPACA  Home Page [Not Found] | Paper   B     BiFD  Home Page [Not Found] | Paper   C     cGamer  Home page [Not Found] | Paper   D     DPMPlan  Home Page [Not Found] | Paper   F     FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper   Freelunch  Home Page [Not Found] | Paper\n\n\n\nReport an issue with this page         Planners Planners by tag Optimising Tag      Optimising Planners  Page Contributors: Adam Green, The planners listed below are planners that belong to the subset of optimising planners. Planners are optimising if they attempt to find the optimal plan achievable. In optimising planning the goal is typically to reach optimality or as close to optimality as possible within the time limit. Optimising planners should attempt to find the best solution first, and then give consideration to the speed at which they do it. This page makes no distinction between classically optimising planners and temporal numeric optimising planners; that said there are very few planners which are optimising temporal numeric. Arguably optimising planners are a subset of satisfycing planners, because a planner still needs to find a valid plan, but must achieve the additional criteria of being optimal. We do not take this view. We only mark a planner as optimising if it has specifically entered itself into the optimising track of the IPC. If it enters itself in both the Optimal and Satisfycing tracks, we reflect this by including them in both lists.   Optimising Planners by A to Z     Planner Links     A     AllPACA  Home Page [Not Found] | Paper   B     BJOLP  Home Page [Not Found] | Paper   C     CFDP  Home Page [Not Found] | Paper   cGamer  Home page [Not Found] | Paper   Complementary  (1 & 2) Home Page [Not Found] | Paper, Paper   CoPlan  (styled Co-Plan) Home Page [Not Found] | Paper   CPT  (& 2, 3 & 4) Home Page | Paper (CPT), Paper (CPT 2), Paper (CPT 4)   D     DecStar  Home Page | Paper   Delfi  (1 & 2) Home Page [Not Found] | Paper   DPMPlan  Home Page [Not Found] | Paper   F     FD  The Fast Downward Planning System (and all other FD brand planners) Home Page | Paper   G     Gamer  Home page [Not Found] | Paper   H     HPlanP  (styled HPlan-P) Home Page [Not Found] | Paper\n\n\n\nReport an issue with this page         Planners Arvand      Arvand Planner  Page Contributors: Adam Green, tags: IPC2011 Satisfycing Planner Quality: 22.6 out of 100 Year Published: 2011 Paper: Arvand: The Art of Random Walks [ Nakhost, H. Muller, M. Valenzano, R. Xie, F. ] Preceded By: Fast Downward Arvand is a stochastic planner that uses Monte Carlo random walks (MRW) planning to balance exploration and exploitation in heuristic search. Arvand is built on top of the Fast Downward Planning System [link needed]   Support  Arvand has not been tested with eviscerator as we could not find source code for the planner, or we couldn’t get the source code to compile. Fast Downward forms the base planner of Arvand, please refer to the Fast Downward [Link Needed] page for an idea of the supported features in this planner   Downloading and Compiling Arvand  No Source code could be located for Arvand\n\n\n\nReport an issue with this page         Planners Arvandherd      Arvandherd Planner  Page Contributors: Adam Green, tags: IPC2011 Satisfycing Planner Quality: 30 out of 100 Year Published: 2011 Paper: ArvandHerd: Parallel Planning with Portfolios [ Nakhost, H. Muller, M. Valenzano, R. Schaeffer, J. Sturtevant, N. ] Preceded By: Fast Downward ArvandHerd is a satisficing parallel planner that has been entered in the 2011 International Planning Competition (IPC 2011). It uses a portfolio-based approach where the portfolio contains four configurations of the Arvand planner and one configuration of the LAMA planner. Each processor runs a single planner, and the execution is mostly independent from the other processors so as to minimize overhead due to communication. ArvandHerd also uses the Aras plan-improvement system to improve plan quality   Support  Arvandherd has not been tested with eviscerator as we could not find source code for the planner, or we couldn’t get the source code to compile. Fast Downward forms the base planner of Arvandherd, please refer to the Fast Downward [Link Needed] page for an idea of the supported features in this planner.   Downloading and Compiling Arvandherd  No Source code could be located for Arvandherd\n\n\n\nReport an issue with this page         Planners BiFD      BiFD - Bi-directional Fast Downwards  Page Contributors: Adam Green, tags: IPC2014 Satisfycing Planner Quality: - Year Published: 2014 Paper: IPC 2014 Booklet [ Alcazar, V. Fernandez, S. Borrajo, D. ] Preceded By: Fast Downward Bi-directional Fast Downward is a 2-portfolio planner comprising of Fast Downward and Fast Downward Regression (FDr), when searching it conducts search from the initial state to the goal state, and vice versa. Most domains used as benchmarks in automated planning are asymmetrical. In general, it is unclear whether searching forward or backward is the best option a priori. Furthermore, planners that search backward have important differences (both advantageous and disadvantageous) with those that search forward. Here we propose BiFD, which combines Fast Downward with FDr (Fast Downward Regression) in a portfolio. This aims to exploit the advantages of searching in both directions while trying to minimize their disadvantages.   Support  BiFD has not been tested with eviscerator as we could not find source code for the planner, or we couldn’t get the source code to compile. Fast Downward forms the base planner of BiFD, please refer to the Fast Downward [Link Needed] page for an idea of the supported features in this planner.   Downloading and Compiling BiFD  No Source code could be located for BiFD\n\n\n\nReport an issue with this page         Planners BJOLP      BJOLP - Big Joint Optimal Landmarks Planner  Page Contributors: Adam Green, tags: IPC2011 Optimising Planner Quality: - Year Published: 2011 Paper: BJOLP: The Big Joint Optimal Landmarks Planner [ Domshlak, C. Helmert, M. Karpas, E. Keyder, E. Richter, S. Roger, G. Seipp, J. Westphal, M. ] Preceded By: Fast Downward BJOLP, The Big Joint Optimal Landmarks Planner uses landmarks to derive an admissible heuristic, which is then used to guide a search for a cost-optimal plan. Landmarks are a common concept in planning, in which a planner seeks to infer facts that must become true at some point in any valid plan. For more information, please see our page on Landmark based search [In Progress].   Support  BJOLP has not been tested with eviscerator as we could not find source code for the planner, or we couldn’t get the source code to compile. Fast Downward forms the base planner of BJOLP, please refer to the Fast Downward [Link Needed] page for an idea of the supported features in this planner   Downloading and Compiling BJOLP  No Source code could be located for BJOLP\n\n\n\n