Fetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS: Cascading Style SheetsCascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS describes how elements should be rendered on screen, on paper, in speech, or on other media.
CSS is among the core languages of the open web and is standardized across Web browsers according to W3C specifications. Previously, the development of various parts of CSS specification was done synchronously, which allowed the versioning of the latest recommendations. You might have heard about CSS1, CSS2.1, or even CSS3. There will never be a CSS3 or a CSS4; rather, everything is now just "CSS" with individual CSS modules having version numbers.
After CSS 2.1, the scope of the specification increased significantly and the progress on different CSS modules started to differ so much, that it became more effective to develop and release recommendations separately per module. Instead of versioning the CSS specification, W3C now periodically takes a snapshot of the latest stable state of the CSS specification and individual modules progress. CSS modules now have version numbers, or levels, such as CSS Color Module Level 5.Beginner's tutorials
Your first website: Styling the content

This article provides a brief tour of what CSS is and how to use it, aimed at people who are completely new to web development.

CSS styling basics

Our Learn web development section's CSS basics module teaches CSS fundamentals from the ground up.

CSS text styling

Here we look at fundamentals including setting font, boldness, italics, line and letter spacing, drop shadows, and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

CSS layout

Now it's time to look at how to correctly lay out your boxes in relation to one another, and the browser viewport. This module looks at floats, positioning, other modern layout tools, and building responsive designs that will adapt to different devices, screen sizes, and resolutions.

ReferenceThe CSS reference is an exhaustive reference for seasoned Web developers, describing every property and concept of CSS, including:

The syntax and forms of the language
Specificity, inheritance, and the cascade
CSS selectors, including pseudo-elements, nesting, scoping and shadow parts
CSS at-rules, including media and container queries
CSS values and units module, including numeric data types, textual data types and functional notations
Box model and margin collapse
The containing block
Stacking and block-formatting contexts
Initial, computed, used, and actual values
CSS shorthand properties
CSS flexible box, multi-column and grid layout
Animation, transitions, and transforms
CookbookThe CSS layout cookbook aims to bring together recipes for common layout patterns, things you might need to implement in your sites. In addition to providing code you can use as a starting point in your projects, these recipes highlight the different ways layout specifications can be used and the choices you can make as a developer.Tools for CSS development
You can use the W3C CSS Validation Service to check if your CSS is valid. This is an invaluable debugging tool.
Firefox Developer Tools lets you view and edit a page's live CSS via the Inspector and Style Editor tools.
The Web Developer extension for Firefox lets you track and edit live CSS on watched sites.
Meta bugs
Firefox: Firefox bug 1323667
See also
Web languages to which CSS is often applied: HTML, SVG, MathML, XHTML, and XML.
Stack Overflow questions about CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nJavaScriptJavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g., functional programming) styles.
JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via eval), object introspection (via for...in and Object utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through toString()).
This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.
The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.
Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java". Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.
JavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:

The JavaScript guide
The JavaScript reference

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview.Beginner's tutorialsLearn how to program in JavaScript from the ground up with our beginner's tutorials.

Your first website: Adding interactivity

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

Dynamic scripting with JavaScript

Our Learn web development section's JavaScript module teaches all the JavaScript fundamentals from the ground up.

JavaScript frameworks and libraries

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. In this set of articles, we aim to give you a comfortable starting point to help you begin learning frameworks.

JavaScript guidesFundamental language guides
JavaScript Guide

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

Intermediate
Advanced JavaScript objects

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

Asynchronous JavaScript

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

Client-side web APIs

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

JavaScript language overview

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

JavaScript data structures

Overview of available data structures in JavaScript.

Equality comparisons and sameness

JavaScript provides three different value comparison operations: strict equality using ===, loose equality using ==, and the Object.is() method.

Enumerability and ownership of properties

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

Closures

A closure is the combination of a function and the lexical environment within which that function was declared.

Advanced
Inheritance and the prototype chain

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

Memory Management

Memory life cycle and garbage collection in JavaScript.

ReferenceBrowse the complete JavaScript reference documentation.

Standard objects

Get to know standard built-in objects: Array, Boolean, Error, Function, JSON, Math, Number, Object, RegExp, String, Map, Set, WeakMap, WeakSet, and others.

Expressions and operators

Learn more about the behavior of JavaScript's operators instanceof, typeof, new, this, the operator precedence, and more.

Statements and declarations

Learn how do-while, for-in, for-of, try-catch, let, var, const, if-else, switch, and more JavaScript statements and keywords work.

Functions

Learn how to work with JavaScript's functions to develop your applications.

Classes

JavaScript classes are the most appropriate way to do object-oriented programming.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTTPHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML.
It was designed for communication between web browsers and web servers, but it can also be used for other purposes, such as machine-to-machine communication, programmatic access to APIs, and more.
HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response from the server.
HTTP is a stateless protocol, meaning that the server does not keep any session data between two requests, although the later addition of cookies adds state to some client-server interactions.Reference documentationThe HTTP reference documentation contains detailed information about headers, request methods, status responses, and lists relevant specifications and standards documents.

HTTP headers

Message headers are used to send metadata about a resource or a HTTP message, and to describe the behavior of the client or the server.

HTTP request methods

Request methods indicate the purpose of the request and what is expected if the request is successful.
The most common methods are GET and POST for retrieving and sending data to servers, respectively, but there are other methods which serve different purposes.

HTTP response status codes

Response status codes indicate the outcome of a specific HTTP request.
Responses are grouped in five classes: informational, successful, redirections, client errors, and server errors.

HTTP resources and specifications

This page lists relevant resources about HTTP since it was first specified in the early 1990s.


The following subsections are also notable:

CSP directives

The Content-Security-Policy (CSP) response header allows website administrators to specify which resources the user agent is allowed to load for a given page.
This section lists directives that can be used in a CSP header, with individual documentation pages that describe how the directives work and how to use them.

Permissions-Policy directives

The Permissions-Policy response header provides a mechanism to allow or deny the use of browser features in a document or within any <iframe> element in the document.
This section lists directives that can be used in a Permissions-Policy header, with individual documentation pages that describe how the directives work and how to use them.

HTTP guidesHTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), a basic message structure, and client-server communication model.
On top of these concepts, numerous extensions have been developed over the years that add functionality and updated semantics, including additional HTTP methods and headers.
The guides below are listed in order from general overviews to specialized, use-case-driven topics.
Beginners are encouraged to start with the foundational guides before exploring more focused articles.

Overview of HTTP

The basic features of HTTP, what it can do, its intended use in web architecture, and its position in the protocol stack.

Evolution of HTTP

HTTP was created in the early 1990s and has been extended several times.
This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, through HTTP/2 and HTTP/3, as well as novelties introduced over the years.

A typical HTTP session

Describes the flow of an HTTP session, from establishing a connection, sending a request, to receiving a response.

HTTP messages

HTTP messages transmitted as requests and responses have a defined structure.
This article describes this general structure, its purpose, and the different types of messages.

MIME types

Since HTTP/1.0, different types of content can be transmitted.
This article explains how this is accomplished using the Content-Type header and the MIME standard.
A shortlist of common types used by web developers can be found in Common MIME types.

Compression in HTTP

Browsers and servers compress their messages before sending them over the network to reduce the amount of data that needs to be transmitted, improving transfer speed and bandwidth utilization.

HTTP caching

Caching is a highly important mechanism for delivering fast experiences on the Web and for efficient use of resources.
This article describes different methods of caching and how to use HTTP headers to control them.

HTTP authentication

Authentication is a way to verify the identity of a client when making requests to a server.
It ensures that only authorized users or systems can access certain resources.

Using HTTP cookies

Although HTTP is a stateless protocol, a server can send a Set-Cookie header with the response.
The client then returns the cookie's value with every subsequent request to the server in the form of a Cookie request header.
This adds the ability to store and exchange a small amount of data which effectively adds state to some client-server interactions.

Redirections in HTTP

URL redirection, also known as URL forwarding, is a technique to give more than one URL address to a page, a form, a whole website, or a web application.
HTTP has a special kind of response, called a HTTP redirect, for this operation.

HTTP conditional requests

In conditional requests, the outcome of a request depends on the value of a validator in the request.
This method is used heavily in caching and use cases such as resuming a download, preventing lost updates when modifying a document on the server, and more.

HTTP range requests

A range request asks the server to send a specific part (or parts) of a resource back to a client instead of the full resource.
Range requests are useful for cases when a client knows they need only part of a large file, or for cases where an application allows the user to pause and resume a download.

Content negotiation

HTTP defines a set of message headers, starting with Accept as a way for a browser to announce the format, language, or encoding it prefers.
This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response to a request.

Connection management in HTTP/1.x

HTTP/1.1 was the first version of HTTP to support persistent connections and pipelining.
This article explains both concepts, including the pros and cons of each.

Protocol upgrade mechanism

HTTP/1.1 provides a mechanism to upgrade an already-established connection to a different protocol using the Upgrade header.
A client can upgrade a connection from HTTP/1.1 to HTTP/2, or an HTTP(S) connection to a WebSocket (ws / wss).

Proxy servers and tunneling

A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet.
This page outlines some basics about proxies and introduces a few configuration options.

HTTP Client hints

Client Hints are a set of response headers that a server can use to proactively request information from a client about the device, network, user, and user-agent-specific preferences.
The server can then determine which resources to send, based on the information that the client chooses to provide.

Network Error Logging 
Experimental


Network Error Logging is a mechanism that can be configured via the NEL HTTP response header.
This experimental header allows websites and applications to opt-in to receive reports about failed (or even successful) network fetches from supporting browsers.

Browser detection using the user agent

It's very rarely a good idea to use user agent sniffing to detect a browser, but there are edge cases that require it.
This document will guide you in doing this as correctly as possible when this is necessary, with an emphasis on considerations to make before embarking on this route.

Security and privacy
Permissions Policy

Permissions Policy provides mechanisms for web developers to explicitly declare what functionality can and cannot be used on a website.
You define a set of "policies" that restrict what APIs the site's code can access or modify the browser's default behavior for certain features.

Cross-Origin Resource Sharing (CORS)

Cross-site HTTP requests are requests for resources from a different domain than that of the resource making the request.
Web pages today very commonly load cross-site resources, for example, a page 'Domain A' (http://domaina.example/) requests an image on 'Domain B' (http://domainb.foo/image.jpg) via the img element.
CORS allows web developers to control how their site reacts to cross-site requests.

Content Security Policy (CSP)

CSP allows website administrators to use the Content-Security-Policy response header to control which resources the client is allowed to load for a given page.
The CSP guide describes the overall Content Security Policy mechanism which helps detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks.

Cross-Origin Resource Policy (CORP)

CORP lets websites and applications opt in to protection against specific requests from other origins (such as those issued with elements like <script> and <img>), to mitigate speculative side-channel attacks.

Mozilla web security guidelines

A collection of tips to help operational teams with creating secure web applications.

Related resources
URIs

Uniform Resource Identifiers (URIs) are used to describe and locate resources on the web and are an essential component in HTTP requests.

Configuring servers for Ogg media

This guide covers a few server configuration changes that may be necessary for your web server to correctly serve Ogg media files.
This information may also be useful if you encounter other media types your server isn't already configured to recognize.

Tools & resourcesHelpful tools and resources for understanding and debugging HTTP.

Firefox Developer Tools

Network monitor

HTTP Observatory

A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.

RedBot

Tools to check your cache-related headers.

nghttp2

An HTTP/2 client, server and proxy implementation written in C with load test and benchmarking tools and an HPACK encoder and decoder.

curl

A command-line tool for transferring data specified with URL syntax.
Supports HTTP, HTTPS, WS, WSS, among many other protocols.

How Browsers Work (2011)

A very comprehensive article on browser internals and request flow through HTTP protocol.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessor
Experimental
MediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessor
Experimental
MediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb APIsWhen writing code for the Web, there are a large number of Web APIs available. Below is a list of all the APIs and interfaces (object types) that you may be able to use while developing your Web app or site.
Web APIs are typically used with JavaScript, although this doesn't always have to be the case.SpecificationsThis is a list of all the APIs that are available.
AAttribution Reporting API
Experimental
Audio Output Devices API
Experimental
BBackground Fetch API
Experimental
Background Synchronization APIBackground Tasks APIBadging APIBarcode Detection API
Experimental
Battery Status APIBeacon APIWeb Bluetooth API
Experimental
Broadcast Channel APICCSS Custom Highlight APICSS Font Loading APICSS Painting API
Experimental
CSS Properties and Values APICSS Typed Object Model APICSS Object Model (CSSOM)Canvas APIChannel Messaging APIClipboard APICompression Streams APICompute Pressure API
Experimental
Console APIContact Picker API
Experimental
Content Index API
Experimental
Cookie Store APICredential Management APIDDocument Object Model (DOM)Device Memory APIDevice orientation eventsDevice Posture API
Experimental
Document Picture-in-Picture API
Experimental
EEditContext API
Experimental
Encoding APIEncrypted Media Extensions APIEyeDropper API
Experimental
FFederated Credential Management (FedCM) API
Experimental
Fenced Frame API
Experimental
Fetch APIFile APIFile System APIFile and Directory Entries APIForce Touch events
Non-standard
Fullscreen APIGGamepad APIGeolocation APIGeometry interfacesHThe HTML DOM APIHTML Drag and Drop APIHistory APIHoudini APIsIIdle Detection API
Experimental
MediaStream Image Capture APIIndexedDB APIInk API
Experimental
InputDeviceCapabilities API
Experimental
Insertable Streams for MediaStreamTrack APIIntersection Observer APIInvoker Commands APIJJS Self-Profiling API
Experimental
KKeyboard API
Experimental
LLaunch Handler API
Experimental
Local Font Access API
Experimental
MMedia Capabilities APIMedia Capture and Streams API (Media Stream)Media Session APIMedia Source API
Experimental
MediaStream Recording APINNavigation API
Experimental
Network Information APIPPage Visibility APIPayment Handler API
Experimental
Payment Request APIPerformance APIsWeb Periodic Background Synchronization API
Experimental
Permissions APIPicture-in-Picture APIPointer eventsPointer Lock APIPopover APIPresentation API
Experimental
Prioritized Task Scheduling APIPush APIRRemote Playback APIReporting APIResize Observer APISSVG APIScreen Capture APIScreen Orientation APIScreen Wake Lock APISelection APISensor APIsServer-sent eventsService Worker APIShared Storage API
Experimental
Speculation Rules API
Experimental
Storage APIStorage Access APIStreams APITTopics API
Experimental

Non-standard
Touch eventsTrusted Types APIUUI EventsURL APIURL Fragment Text DirectivesURL Pattern API
Experimental
User-Agent Client Hints API
Experimental
VVibration APIView Transition APIVirtualKeyboard API
Experimental
Visual Viewport APIWWeb Animations APIWeb Audio APIWeb Authentication APIWeb ComponentsWeb Crypto APIWeb Locks APIWeb MIDI APIWeb NFC API
Experimental
Notifications APIWeb Serial API
Experimental
Web Share APIWeb Speech APIWeb Storage APIWeb Workers APIWebCodecs APIWebGL: 2D and 3D graphics for the webWebGPU API
Experimental
WebHID API
Experimental
WebOTP APIWebRTC APIThe WebSocket API (WebSockets)WebTransport APIWebUSB API
Experimental
WebVR API
Non-standard

Deprecated
WebVTT APIWebXR Device API
Experimental
Window Controls Overlay API
Experimental
Window Management API
Experimental
XXMLHttpRequest APIffetchLater() API
Experimental
InterfacesThis is a list of all the interfaces (that is, types of objects) that are available.
AAbortControllerAbortSignalAbsoluteOrientationSensorAbstractRangeAccelerometer
Experimental
AesCbcParamsAesCtrParamsAesGcmParamsAesKeyGenParamsAmbientLightSensor
Experimental
AnalyserNodeANGLE_instanced_arraysAnimationAnimationEffectAnimationEventAnimationPlaybackEventAnimationTimelineAttrAudioBufferAudioBufferSourceNodeAudioContextAudioDataAudioDecoderAudioDestinationNodeAudioEncoderAudioListenerAudioNodeAudioParamAudioParamDescriptorAudioParamMapAudioProcessingEvent
Deprecated
AudioScheduledSourceNodeAudioSinkInfo
Experimental
AudioTrackAudioTrackListAudioWorkletAudioWorkletGlobalScopeAudioWorkletNodeAudioWorkletProcessorAuthenticatorAssertionResponseAuthenticatorAttestationResponseAuthenticatorResponseBBackgroundFetchEvent
Experimental
BackgroundFetchManager
Experimental
BackgroundFetchRecord
Experimental
BackgroundFetchRegistration
Experimental
BackgroundFetchUpdateUIEvent
Experimental
BarcodeDetector
Experimental
BarPropBaseAudioContextBatteryManagerBeforeInstallPromptEvent
Experimental

Non-standard
BeforeUnloadEventBiquadFilterNodeBlobBlobEventBluetooth
Experimental
BluetoothCharacteristicProperties
Experimental
BluetoothDevice
Experimental
BluetoothRemoteGATTCharacteristic
Experimental
BluetoothRemoteGATTDescriptor
Experimental
BluetoothRemoteGATTServer
Experimental
BluetoothRemoteGATTService
Experimental
BluetoothUUIDBroadcastChannelBrowserCaptureMediaStreamTrack
Experimental
ByteLengthQueuingStrategyCCacheCacheStorageCanMakePaymentEvent
Experimental
CanvasCaptureMediaStreamTrackCanvasGradientCanvasPatternCanvasRenderingContext2DCaptureController
Experimental
CaretPositionCDATASectionChannelMergerNodeChannelSplitterNodeChapterInformation
Experimental
CharacterBoundsUpdateEvent
Experimental
CharacterDataClientClientsClipboardClipboardEventClipboardItemCloseEventCloseWatcher
Experimental
CommandEventCommentCompositionEventCompressionStreamcconsoleCConstantSourceNodeContactAddress
Experimental
ContactsManager
Experimental
ContentIndex
Experimental
ContentIndexEvent
Experimental
ContentVisibilityAutoStateChangeEventConvolverNodeCookieChangeEventCookieStoreCookieStoreManagerCountQueuingStrategyCredentialCredentialsContainerCropTarget
Experimental
CryptoCryptoKeyCryptoKeyPairCSPViolationReportBodyCSSCSSAnimationCSSConditionRuleCSSContainerRuleCSSCounterStyleRuleCSSFontFaceRuleCSSFontFeatureValuesRuleCSSFontPaletteValuesRuleCSSGroupingRuleCSSImageValueCSSImportRuleCSSKeyframeRuleCSSKeyframesRuleCSSKeywordValueCSSLayerBlockRuleCSSLayerStatementRuleCSSMathInvertCSSMathMaxCSSMathMinCSSMathNegateCSSMathProductCSSMathSumCSSMathValueCSSMatrixComponentCSSMediaRuleCSSNamespaceRuleCSSNestedDeclarationsCSSNumericArrayCSSNumericValueCSSPageDescriptors
Experimental
CSSPageRuleCSSPerspectiveCSSPositionTryDescriptors
Experimental
CSSPositionTryRule
Experimental
CSSPositionValue
Non-standard

Deprecated
CSSPrimitiveValue
Deprecated
CSSPropertyRuleCSSPseudoElement
Experimental
CSSRotateCSSRuleCSSRuleListCSSScaleCSSScopeRuleCSSSkewCSSSkewXCSSSkewYCSSStartingStyleRuleCSSStyleDeclarationCSSStyleRuleCSSStyleSheetCSSStyleValueCSSSupportsRuleCSSTransformComponentCSSTransformValueCSSTransitionCSSTranslateCSSUnitValueCSSUnparsedValueCSSValue
Deprecated
CSSValueList
Deprecated
CSSVariableReferenceValueCustomElementRegistryCustomEventCustomStateSetDDataTransferDataTransferItemDataTransferItemListDecompressionStreamDedicatedWorkerGlobalScopeDeferredRequestInit
Experimental
DelayNodeDelegatedInkTrailPresenter
Experimental
DeprecationReportBody
Experimental
DeviceMotionEventDeviceMotionEventAccelerationDeviceMotionEventRotationRateDeviceOrientationEventDevicePosture
Experimental
DirectoryEntrySync
Non-standard

Deprecated
DirectoryReaderSync
Non-standard

Deprecated
DocumentDocumentFragmentDocumentPictureInPicture
Experimental
DocumentPictureInPictureEvent
Experimental
DocumentTimelineDocumentTypeDOMError
Deprecated
DOMExceptionDOMHighResTimeStampDOMImplementationDOMMatrixDOMMatrixReadOnlyDOMParserDOMPointDOMPointReadOnlyDOMQuadDOMRectDOMRectListDOMRectReadOnlyDOMStringListDOMStringMapDOMTokenListDragEventDynamicsCompressorNodeEEcdhKeyDeriveParamsEcdsaParamsEcKeyGenParamsEcKeyImportParamsEditContext
Experimental
ElementElementInternalsEncodedAudioChunkEncodedVideoChunkErrorEventEventEventCountsEventSourceEventTargetExtendableCookieChangeEventExtendableEventExtendableMessageEventEyeDropper
Experimental
FFeaturePolicy
Experimental
FederatedCredential
Experimental
FederatedCredentialInitFence
Experimental
FencedFrameConfig
Experimental
FetchEventFetchLaterResult
Experimental
FileFileEntrySync
Non-standard

Deprecated
FileListFileReaderFileReaderSyncFileSystemFileSystemChangeRecordFileSystemDirectoryEntryFileSystemDirectoryHandleFileSystemDirectoryReaderFileSystemEntryFileSystemFileEntryFileSystemFileHandleFileSystemHandleFileSystemObserver
Experimental

Non-standard
FileSystemSync
Non-standard

Deprecated
FileSystemSyncAccessHandleFileSystemWritableFileStreamFocusEventFontData
Experimental
FontFaceFontFaceSetFontFaceSetLoadEventFormDataFormDataEventFragmentDirectiveGGainNodeGamepadGamepadButtonGamepadEventGamepadHapticActuatorGamepadPose
Experimental
GeolocationGeolocationCoordinatesGeolocationPositionGeolocationPositionErrorGestureEvent
Non-standard
GPU
Experimental
GPUAdapter
Experimental
GPUAdapterInfo
Experimental
GPUBindGroup
Experimental
GPUBindGroupLayout
Experimental
GPUBuffer
Experimental
GPUCanvasContext
Experimental
GPUCommandBuffer
Experimental
GPUCommandEncoder
Experimental
GPUCompilationInfo
Experimental
GPUCompilationMessage
Experimental
GPUComputePassEncoder
Experimental
GPUComputePipeline
Experimental
GPUDevice
Experimental
GPUDeviceLostInfo
Experimental
GPUError
Experimental
GPUExternalTexture
Experimental
GPUInternalError
Experimental
GPUOutOfMemoryError
Experimental
GPUPipelineError
Experimental
GPUPipelineLayout
Experimental
GPUQuerySet
Experimental
GPUQueue
Experimental
GPURenderBundle
Experimental
GPURenderBundleEncoder
Experimental
GPURenderPassEncoder
Experimental
GPURenderPipeline
Experimental
GPUSampler
Experimental
GPUShaderModule
Experimental
GPUSupportedFeatures
Experimental
GPUSupportedLimits
Experimental
GPUTexture
Experimental
GPUTextureView
Experimental
GPUUncapturedErrorEvent
Experimental
GPUValidationError
Experimental
GravitySensorGyroscopeHHashChangeEventHeadersHID
Experimental
HIDConnectionEvent
Experimental
HIDDevice
Experimental
HIDInputReportEvent
Experimental
HighlightHighlightRegistryHistoryHkdfParamsHmacImportParamsHmacKeyGenParamsHMDVRDevice
Non-standard

Deprecated
HTMLAllCollectionHTMLAnchorElementHTMLAreaElementHTMLAudioElementHTMLBaseElementHTMLBodyElementHTMLBRElementHTMLButtonElementHTMLCanvasElementHTMLCollectionHTMLDataElementHTMLDataListElementHTMLDetailsElementHTMLDialogElementHTMLDivElementHTMLDListElementHTMLDocumentHTMLElementHTMLEmbedElementHTMLFencedFrameElement
Experimental
HTMLFieldSetElementHTMLFontElement
Deprecated
HTMLFormControlsCollectionHTMLFormElementHTMLFrameSetElement
Deprecated
HTMLHeadElementHTMLHeadingElementHTMLHRElementHTMLHtmlElementHTMLIFrameElementHTMLImageElementHTMLInputElementHTMLLabelElementHTMLLegendElementHTMLLIElementHTMLLinkElementHTMLMapElementHTMLMarqueeElement
Deprecated
HTMLMediaElementHTMLMenuElementHTMLMetaElementHTMLMeterElementHTMLModElementHTMLObjectElementHTMLOListElementHTMLOptGroupElementHTMLOptionElementHTMLOptionsCollectionHTMLOutputElementHTMLParagraphElementHTMLParamElement
Deprecated
HTMLPictureElementHTMLPreElementHTMLProgressElementHTMLQuoteElementHTMLScriptElementHTMLSelectedContentElementHTMLSelectElementHTMLSlotElementHTMLSourceElementHTMLSpanElementHTMLStyleElementHTMLTableCaptionElementHTMLTableCellElementHTMLTableColElementHTMLTableElementHTMLTableRowElementHTMLTableSectionElementHTMLTemplateElementHTMLTextAreaElementHTMLTimeElementHTMLTitleElementHTMLTrackElementHTMLUListElementHTMLUnknownElementHTMLVideoElementIIDBCursorIDBCursorWithValueIDBDatabaseIDBFactoryIDBIndexIDBKeyRangeIDBObjectStoreIDBOpenDBRequestIDBRequestIDBTransactionIDBVersionChangeEventIdentityCredential
Experimental
IdentityCredentialRequestOptionsIdentityProvider
Experimental
IdleDeadlineIdleDetector
Experimental
IIRFilterNodeImageBitmapImageBitmapRenderingContextImageCaptureImageDataImageDecoderImageTrackImageTrackListInk
Experimental
InputDeviceCapabilities
Experimental
InputDeviceInfoInputEventInstallEventIntersectionObserverIntersectionObserverEntryInterventionReportBody
Experimental
KKeyboard
Experimental
KeyboardEventKeyboardLayoutMap
Experimental
KeyframeEffectLLargestContentfulPaintLaunchParams
Experimental
LaunchQueue
Experimental
LayoutShift
Experimental
LayoutShiftAttribution
Experimental
LinearAccelerationSensorLocationLockLockManagerMMagnetometer
Experimental
MathMLElementMediaCapabilitiesMediaDeviceInfoMediaDevicesMediaElementAudioSourceNodeMediaEncryptedEventMediaErrorMediaKeyMessageEventMediaKeysMediaKeySessionMediaKeyStatusMapMediaKeySystemAccessMediaListMediaMetadataMediaQueryListMediaQueryListEventMediaRecorderMediaRecorderErrorEvent
Non-standard

Deprecated
MediaSessionMediaSourceMediaSourceHandleMediaStreamMediaStreamAudioDestinationNodeMediaStreamAudioSourceNodeMediaStreamEvent
Non-standard

Deprecated
MediaStreamTrackMediaStreamTrackAudioSourceNodeMediaStreamTrackEventMediaStreamTrackGenerator
Experimental

Non-standard
MediaStreamTrackProcessor
Experimental
MediaTrackConstraintsMediaTrackSettingsMediaTrackSupportedConstraintsMerchantValidationEvent
Deprecated
MessageChannelMessageEventMessagePortMetadata
Experimental

Non-standard
MIDIAccessMIDIConnectionEventMIDIInputMIDIInputMapMIDIMessageEventMIDIOutputMIDIOutputMapMIDIPortMimeType
Deprecated
MimeTypeArray
Deprecated
MouseEventMouseScrollEvent
Non-standard

Deprecated
MutationEvent
Non-standard

Deprecated
MutationObserverMutationRecordNNamedNodeMapNavigateEvent
Experimental
Navigation
Experimental
NavigationActivation
Experimental
NavigationCurrentEntryChangeEvent
Experimental
NavigationDestination
Experimental
NavigationHistoryEntry
Experimental
NavigationPreloadManagerNavigationTransition
Experimental
NavigatorNavigatorLoginNavigatorUAData
Experimental
NDEFMessage
Experimental
NDEFReader
Experimental
NDEFReadingEvent
Experimental
NDEFRecord
Experimental
NetworkInformationNodeNodeIteratorNodeListNotificationNotificationEventNotRestoredReasonDetails
Experimental
NotRestoredReasons
Experimental
OOES_draw_buffers_indexedOfflineAudioCompletionEventOfflineAudioContextOffscreenCanvasOffscreenCanvasRenderingContext2DOrientationSensorOscillatorNodeOTPCredential
Experimental
OverconstrainedErrorPPageRevealEventPageSwapEventPageTransitionEventPaintRenderingContext2DPaintSizePaintWorkletGlobalScope
Experimental
PannerNodePasswordCredential
Experimental
PasswordCredentialInitPath2DPaymentAddress
Non-standard

Deprecated
PaymentManager
Experimental
PaymentMethodChangeEventPaymentRequestPaymentRequestEvent
Experimental
PaymentRequestUpdateEventPaymentResponsePbkdf2ParamsPerformancePerformanceElementTiming
Experimental
PerformanceEntryPerformanceEventTimingPerformanceLongAnimationFrameTiming
Experimental
PerformanceLongTaskTiming
Experimental
PerformanceMarkPerformanceMeasurePerformanceNavigation
Deprecated
PerformanceNavigationTimingPerformanceObserverPerformanceObserverEntryListPerformancePaintTimingPerformanceResourceTimingPerformanceScriptTiming
Experimental
PerformanceServerTimingPerformanceTiming
Deprecated
PeriodicSyncEvent
Experimental
PeriodicSyncManager
Experimental
PeriodicWavePermissionsPermissionStatusPictureInPictureEventPictureInPictureWindowPlugin
Deprecated
PluginArray
Deprecated
Point
Non-standard

Deprecated
PointerEventPopStateEventPositionSensorVRDevice
Non-standard

Deprecated
Presentation
Experimental
PresentationAvailability
Experimental
PresentationConnection
Experimental
PresentationConnectionAvailableEvent
Experimental
PresentationConnectionCloseEvent
Experimental
PresentationConnectionList
Experimental
PresentationReceiver
Experimental
PresentationRequest
Experimental
PressureObserver
Experimental
PressureRecord
Experimental
ProcessingInstructionProfiler
Experimental
ProgressEventPromiseRejectionEventPublicKeyCredentialPublicKeyCredentialCreationOptionsPublicKeyCredentialRequestOptionsPushEventPushManagerPushMessageDataPushSubscriptionPushSubscriptionOptionsRRadioNodeListRangeReadableByteStreamControllerReadableStreamReadableStreamBYOBReaderReadableStreamBYOBRequestReadableStreamDefaultControllerReadableStreamDefaultReaderRelativeOrientationSensorRemotePlaybackReportReportBodyReportingObserverRequestRequestInitResizeObserverResizeObserverEntryResizeObserverSizeResponseRestrictionTarget
Experimental
RsaHashedImportParamsRsaHashedKeyGenParamsRsaOaepParamsRsaPssParamsRTCAudioSourceStatsRTCCertificateRTCCertificateStatsRTCCodecStatsRTCDataChannelRTCDataChannelEventRTCDataChannelStatsRTCDtlsTransportRTCDTMFSenderRTCDTMFToneChangeEventRTCEncodedAudioFrameRTCEncodedVideoFrameRTCErrorRTCErrorEventRTCIceCandidateRTCIceCandidatePairRTCIceCandidatePairStatsRTCIceCandidateStatsRTCIceParametersRTCIceTransportRTCIdentityAssertion
Experimental
RTCInboundRtpStreamStatsRTCOutboundRtpStreamStatsRTCPeerConnectionRTCPeerConnectionIceErrorEventRTCPeerConnectionIceEventRTCPeerConnectionStatsRTCRemoteInboundRtpStreamStatsRTCRemoteOutboundRtpStreamStatsRTCRtpReceiverRTCRtpScriptTransformRTCRtpScriptTransformerRTCRtpSenderRTCRtpTransceiverRTCSctpTransportRTCSessionDescriptionRTCStatsReportRTCTrackEventRTCTransformEventRTCTransportStatsRTCVideoSourceStatsSSchedulerScheduling
Experimental
ScreenScreenDetailed
Experimental
ScreenDetails
Experimental
ScreenOrientationScriptProcessorNode
Deprecated
ScrollTimeline
Experimental
SecurePaymentConfirmationRequestSecurityPolicyViolationEventSelectionSensorSensorErrorEventSerial
Experimental
SerialPort
Experimental
ServiceWorkerServiceWorkerContainerServiceWorkerGlobalScopeServiceWorkerRegistrationShadowRootSharedStorage
Experimental
SharedStorageOperation
Experimental
SharedStorageRunOperation
Experimental
SharedStorageSelectURLOperation
Experimental
SharedStorageWorklet
Experimental
SharedStorageWorkletGlobalScope
Experimental
SharedWorkerSharedWorkerGlobalScopeSnapEvent
Experimental
SourceBufferSourceBufferListSpeechGrammar
Non-standard

Deprecated
SpeechGrammarList
Experimental
SpeechRecognitionSpeechRecognitionAlternativeSpeechRecognitionErrorEventSpeechRecognitionEventSpeechRecognitionResultSpeechRecognitionResultListSpeechSynthesisSpeechSynthesisErrorEventSpeechSynthesisEventSpeechSynthesisUtteranceSpeechSynthesisVoiceStaticRangeStereoPannerNodeStorageStorageAccessHandleStorageEventStorageManagerStylePropertyMapStylePropertyMapReadOnlyStyleSheetStyleSheetListSubmitEventSubtleCryptoSVGAElementSVGAngleSVGAnimateColorElement
Deprecated
SVGAnimatedAngleSVGAnimatedBooleanSVGAnimatedEnumerationSVGAnimatedIntegerSVGAnimatedLengthSVGAnimatedLengthListSVGAnimatedNumberSVGAnimatedNumberListSVGAnimatedPreserveAspectRatioSVGAnimatedRectSVGAnimatedStringSVGAnimatedTransformListSVGAnimateElementSVGAnimateMotionElementSVGAnimateTransformElementSVGAnimationElementSVGCircleElementSVGClipPathElementSVGComponentTransferFunctionElementSVGDefsElementSVGDescElementSVGDiscardElement
Experimental
SVGElementSVGEllipseElementSVGFEBlendElementSVGFEColorMatrixElementSVGFEComponentTransferElementSVGFECompositeElementSVGFEConvolveMatrixElementSVGFEDiffuseLightingElementSVGFEDisplacementMapElementSVGFEDistantLightElementSVGFEDropShadowElementSVGFEFloodElementSVGFEFuncAElementSVGFEFuncBElementSVGFEFuncGElementSVGFEFuncRElementSVGFEGaussianBlurElementSVGFEImageElementSVGFEMergeElementSVGFEMergeNodeElementSVGFEMorphologyElementSVGFEOffsetElementSVGFEPointLightElementSVGFESpecularLightingElementSVGFESpotLightElementSVGFETileElementSVGFETurbulenceElementSVGFilterElementSVGForeignObjectElementSVGGElementSVGGeometryElementSVGGradientElementSVGGraphicsElementSVGImageElementSVGLengthSVGLengthListSVGLinearGradientElementSVGLineElementSVGMarkerElementSVGMaskElementSVGMetadataElementSVGMPathElementSVGNumberSVGNumberListSVGPathElementSVGPatternElementSVGPoint
Deprecated
SVGPointListSVGPolygonElementSVGPolylineElementSVGPreserveAspectRatioSVGRadialGradientElementSVGRectSVGRectElementSVGRenderingIntent
Deprecated
SVGScriptElementSVGSetElementSVGStopElementSVGStringListSVGStyleElementSVGSVGElementSVGSwitchElementSVGSymbolElementSVGTextContentElementSVGTextElementSVGTextPathElementSVGTextPositioningElementSVGTitleElementSVGTransformSVGTransformListSVGTSpanElementSVGUnitTypesSVGUseElementSVGViewElementSyncEventSyncManagerTTaskAttributionTiming
Experimental
TaskControllerTaskPriorityChangeEventTaskSignalTextTextDecoderTextDecoderStreamTextEncoderTextEncoderStreamTextEvent
Deprecated
TextFormat
Experimental
TextFormatUpdateEvent
Experimental
TextMetricsTextTrackTextTrackCueTextTrackCueListTextTrackListTextUpdateEvent
Experimental
TimeEventTimeRangesToggleEventTouchTouchEventTouchListTrackEventTransformStreamTransformStreamDefaultControllerTransitionEventTreeWalkerTrustedHTMLTrustedScriptTrustedScriptURLTrustedTypePolicyTrustedTypePolicyFactoryUUIEventURLURLPattern
Experimental
URLSearchParamsUSB
Experimental
USBAlternateInterface
Experimental
USBConfiguration
Experimental
USBConnectionEvent
Experimental
USBDevice
Experimental
USBEndpoint
Experimental
USBInterface
Experimental
USBInTransferResult
Experimental
USBIsochronousInTransferPacket
Experimental
USBIsochronousInTransferResult
Experimental
USBIsochronousOutTransferPacket
Experimental
USBIsochronousOutTransferResult
Experimental
USBOutTransferResult
Experimental
UserActivationVValidityStateVideoColorSpaceVideoDecoderVideoEncoderVideoFrameVideoPlaybackQualityVideoTrackVideoTrackGenerator
Experimental
VideoTrackListViewTimeline
Experimental
ViewTransitionVirtualKeyboard
Experimental
VisibilityStateEntry
Experimental
VisualViewportVRDisplay
Non-standard

Deprecated
VRDisplayCapabilities
Non-standard

Deprecated
VRDisplayEvent
Non-standard

Deprecated
VREyeParameters
Non-standard

Deprecated
VRFieldOfView
Non-standard

Deprecated
VRFrameData
Non-standard

Deprecated
VRLayerInit
Deprecated
VRPose
Non-standard

Deprecated
VRStageParameters
Non-standard

Deprecated
VTTCueVTTRegionWWakeLockWakeLockSentinelWaveShaperNodeWebGL2RenderingContextWebGLActiveInfoWebGLBufferWebGLContextEventWebGLFramebufferWebGLObject
Experimental
WebGLProgramWebGLQueryWebGLRenderbufferWebGLRenderingContextWebGLSamplerWebGLShaderWebGLShaderPrecisionFormatWebGLSyncWebGLTextureWebGLTransformFeedbackWebGLUniformLocationWebGLVertexArrayObjectWebSocketWebSocketStream
Experimental
WebTransportWebTransportBidirectionalStreamWebTransportDatagramDuplexStreamWebTransportErrorWebTransportReceiveStream
Experimental
WebTransportSendStream
Experimental
WGSLLanguageFeatures
Experimental
WheelEventWindowWindowClientWindowControlsOverlay
Experimental
WindowControlsOverlayGeometryChangeEvent
Experimental
WindowSharedStorage
Experimental
WorkerWorkerGlobalScopeWorkerLocationWorkerNavigatorWorkletWorkletGlobalScopeWorkletSharedStorage
Experimental
WritableStreamWritableStreamDefaultControllerWritableStreamDefaultWriterXXMLDocumentXMLHttpRequestXMLHttpRequestEventTargetXMLHttpRequestUploadXMLSerializerXPathEvaluatorXPathExpressionXPathResultXRAnchor
Experimental
XRAnchorSet
Experimental
XRBoundedReferenceSpace
Experimental
XRCompositionLayer
Experimental
XRCPUDepthInformation
Experimental
XRCubeLayer
Experimental
XRCylinderLayer
Experimental
XRDepthInformation
Experimental
XREquirectLayer
Experimental
XRFrame
Experimental
XRHandXRHitTestResult
Experimental
XRHitTestSource
Experimental
XRInputSourceXRInputSourceArray
Experimental
XRInputSourceEventXRInputSourcesChangeEventXRJointPoseXRJointSpaceXRLayer
Experimental
XRLayerEvent
Experimental
XRLightEstimate
Experimental
XRLightProbe
Experimental
XRMediaBinding
Experimental
XRPoseXRProjectionLayer
Experimental
XRQuadLayer
Experimental
XRRay
Experimental
XRReferenceSpaceXRReferenceSpaceEventXRRenderState
Experimental
XRRigidTransformXRSession
Experimental
XRSessionEventXRSpaceXRSubImage
Experimental
XRSystem
Experimental
XRTransientInputHitTestResult
Experimental
XRTransientInputHitTestSource
Experimental
XRView
Experimental
XRViewerPoseXRViewportXRWebGLBinding
Experimental
XRWebGLDepthInformation
Experimental
XRWebGLLayer
Experimental
XRWebGLSubImage
Experimental
XSLTProcessorSee also
Web API event reference
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 20, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBrowser extensionsExtensions, or add-ons, can modify and enhance the capability of a browser. Extensions for Firefox are built using the WebExtensions API cross-browser technology.
The technology for extensions in Firefox is, to a large extent, compatible with the extension API supported by Chromium-based browsers (such as Google Chrome, Microsoft Edge, Opera, Vivaldi). In most cases, extensions written for Chromium-based browsers run in Firefox with just a few changes.Key resources
Guides

Whether you're just beginning or looking for more advanced advice, learn about how extensions work and use the WebExtensions API from our extensive range of tutorials and guides.

References

Get comprehensive details about the methods, properties, types, and events of the WebExtensions APIs and full details about the manifest keys.

Firefox workflow

Discover how to build and publish extensions for Firefox: get the lowdown on developer tools, publication and distribution, and porting on Extension Workshop.



Note:
If you have ideas or questions or need help, you can reach us on the community forum or in the Add-ons Room on Matrix.
Get startedDiscover what extensions can do before building your first extension. Learn about the anatomy of an extension and get an overview of the extension development and publication workflow, Firefox style. Explore a little deeper with a comprehensive selection of example extensions that you can run right in Firefox.ConceptsGet detailed information on the concept that underpin extensions from an overview of the JavaScript API, through content scripts, match patterns, working with files, internationalization, and content security policy, to more advanced subjects such as native messaging, using the devtools APIs, and native manifests.User interfaceDiscover all the user interface components you can use in your extensions, with coding examples and tips.How toFrom patterns you'll regularly use such as work with the Tabs API and adding a button to the toolbar to more advanced topics such as intercepting HTTP requests and working with contextual identities, you'll find a range of tutorials to get you started.Firefox workflowWhen you are ready to create your extension for Firefox or port your Chrome extension, head over to Extension Workshop. It has details on:

The Firefox workflow, such as temporarily installing extensions during development, debugging, request the right permissions, and more.
The web-ext developer tool.
Porting a Google Chrome extension, differences between desktop and Android, and more.
Publishing and distribution overview, promoting your extension, the extension lifecycle best practices, and more.
ReferenceJavaScript APIsGet comprehensive details about the methods, properties, types, and events for all the JavaScript APIs. There is also detailed information about the compatibility of each API with the major browsers. Most reference pages also include coding examples and links to the extension examples that use the API.Manifest keysGet full details about the manifest keys, including all their properties and settings.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 22, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibilityAccessibility (often abbreviated to A11y — as in, "a", then 11 characters, and then "y") in web development means enabling as many people as possible to use websites, even when those people's abilities are limited in some way.
For many people, technology makes things easier. For people with disabilities, technology makes things possible. Accessibility means developing content to be as accessible as possible, no matter an individual's physical and cognitive abilities and how they access the web.

The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability.
When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. 
– (W3C - Accessibility)
Accessibility guides
Accessibility information for web authors

This document lists guidelines and regulations, how-to's, and tools for checking and repairing accessibility problems with websites.

Personalization to help browse safely

This article discusses making web content accessible for those with vestibular disorders, and those who support them, by taking advantage of personalization and accessibility settings built into the operating systems.

Accessible web applications and widgets

Most JavaScript libraries offer a library of client-side widgets that mimic the behavior of familiar desktop interfaces.
While this results in a widget that looks like its desktop counterpart, there usually isn't enough semantic information in the markup to be usable by an assistive technology.
This document describes techniques to improve accessibility of such widgets.

Keyboard-navigable JavaScript widgets

Until now, web developers who wanted to make their styled <div> and <span> based widgets accessible have lacked proper techniques.
Keyboard accessibility is part of the minimum accessibility requirements, which a developer should be aware of.
This document describes techniques to make JavaScript widgets accessible with the keyboard.

Mobile accessibility checklist

This document provides a concise checklist of accessibility requirements for mobile app developers.

Understanding the Web Content Accessibility Guidelines (WCAG)

A set of articles that provide quick explanations to help you understand the steps that need to be taken to conform to the recommendations outlined in the Web Content Accessibility Guidelines (WCAG).

Cognitive accessibility

Cognitive accessibility covers accessibility considerations for people with cognition and learning disabilities.
This document introduces cognitive accessibility and improving accessibility of the web for people with cognitive and learning differences.

Accessibility and spatial patterns

This document describes visual patterns that can induce physical symptoms in people who have photosensitive epilepsy, vestibular disorders, or other perceptual issues.

Web Accessibility: Understanding Colors and Luminance

While understanding color, luminance, and saturation is important for design and readability for all sighted users, they are essential for those with reduced vision and color-deficient vision and those with specific neurological, cognitive, and other impairments.

Web accessibility for seizures and physical reactions

Some types of visual web content can induce seizures in people with certain brain disorders.
This article helps you understand the types of content that can be problematic and find tools and strategies to help you avoid them.

ARIA

This is a collection of articles to learn how to use Accessible Rich Internet Applications (ARIA) to make your HTML documents more accessible.

Tutorials for beginnersThe MDN Accessibility Learning Area contains modern, up-to-date tutorials covering the following accessibility essentials:

What is accessibility?

This article starts off the module with a good look at what accessibility actually is — this includes what groups of people we need to consider and why, what tools different people use to interact with the Web, and how we can make accessibility part of our web development workflow.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure that the correct HTML elements are used for the correct purpose at all times. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences. They can significantly harm accessibility if misused. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives so that they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

References
ARIA reference

Reference documentation for Accessible Rich Internet Applications (ARIA) attributes and roles.

See also
Developer guides
WAI Interest Group
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nStructuring content with HTML Overview: Core learning modules Next  
HTML is the technology that defines the content and structure of any website. Written properly, it should also define the semantics (meaning) of the content in a machine-readable way, which is vital for accessibility, search engine optimization, and making use of the built-in features browsers provide for content to work optimally. This module covers the basics of the language, before looking at key areas such as document structure, links, lists, images, forms, and more.PrerequisitesBefore starting this module, you don't need any previous HTML knowledge, but you should have at least basic familiarity with using computers and using the web passively (i.e., just looking at it and consuming content). You should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). Both are parts of our Getting started with the web complete beginner's module.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
Basic HTML syntax

Covers the absolute basics of HTML, to get you started — we define elements, attributes, and other important terms, and show where they fit in the language. We also show how a typical HTML page is structured and how an HTML element is structured, and explain other important basic language features. Along the way, we'll play with some HTML to get you interested!

What's in the head? Web page metadata

The head of an HTML document is the part that is not displayed in the web browser when the page is loaded. It contains metadata information such as the page <title>, links to CSS (if you want to style your HTML content with CSS), links to custom favicons, and metadata (data about the HTML, such as who wrote it, and important keywords that describe the document).

Headings and paragraphs

One of HTML's main jobs is to give text structure so that a browser can display an HTML document the way its developer intends. This article explains how HTML can be used to provide fundamental page structure by defining headings and paragraphs.

Emphasis and importance

The previous article looked at why semantics are important in HTML, and focused on headings and paragraphs. This article continues on the theme of semantics, looking at HTML elements that apply emphasis and importance to text (parallel to italics and bold text in print media).

Lists

Lists are everywhere in life—from your shopping list to the list of directions you subconsciously follow to get to your house every day, to the lists of instructions you are following in these tutorials! It may not surprise you that HTML has a convenient set of elements that allows us to define different types of list. On the web, we have three types of lists: unordered, ordered, and description lists. This lesson shows you how to use the different types.

Structuring documents

In addition to defining individual parts of your page (such as "a paragraph" or "an image"), HTML also boasts a number of block level elements used to define areas of your website (such as "the header", "the navigation menu", "the main content column"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure.

Advanced text features

There are many other elements in HTML for defining text semantics, which we didn't get to in the Emphasis and importance article. The elements described in this article are less known, but still useful to know about (and this is still not a complete list by any means). Here you'll learn about marking up quotations, computer code and other related text, subscript and superscript, contact information, and more.

Creating links

Links (also known as hyperlinks) are really important — they are what makes the Web a web. This article shows the syntax required to make a link, and discusses link best practices.

Marking up a letter Challenge

We all learn to write a letter sooner or later; it is also a useful example to test our text formatting skills. In this challenge, you'll have a letter to mark up as a test for your HTML text formatting skills, as well as hyperlinks and proper use of the HTML <head> element.

Structuring a page of content Challenge

Structuring a page of content ready for laying it out using CSS is a very important skill to master, so in this challenge you'll be tested on your ability to think about how a page might end up looking, and choose appropriate structural semantics to build a layout on top of.

HTML images

In the beginning, the web was just text, and it was really quite boring. Fortunately, it wasn't too long before the ability to embed images (and other more interesting types of content) inside web pages was added. In this article we'll look at how to use the <img> element in depth, including the basics, annotating it with captions using <figure>, and detailing how it relates to CSS background images.

HTML video and audio

Now that we are comfortable with adding simple images to a webpage, the next step is to start adding video and audio players to your HTML documents! In this article we'll look at doing just that with the <video> and <audio> elements; we'll then finish off by looking at how to add captions/subtitles to your videos.

Mozilla splash page Challenge

In this challenge, we'll test your knowledge of some of the techniques discussed in the last couple of lessons, getting you to add some images and video to a funky splash page all about Mozilla!

HTML table basics

This article gets you started with HTML tables, covering the very basics such as rows, cells, headings, making cells span multiple columns and rows, and how to group together all the cells in a column for styling purposes.

HTML table accessibility

In this article we look at more HTML table accessibility features such as captions/summaries, grouping your rows into table head, body and footer sections, and scoping columns and rows.

Structuring a planet data table Challenge

In this challenge, we provide you with some data on the planets in our solar system. Your job is to structure it into an accessible HTML table.

Forms and buttons in HTML

HTML forms and buttons are powerful tools for interacting with users — most commonly they are used for collecting data from users or allowing them to control a user interface. In this article we provide an introduction to the basics of forms and buttons.

Debugging HTML

Writing HTML is fine, but what if something goes wrong, and you can't work out where the error in the code is? This article will introduce you to some tools that can help you find and fix errors in HTML.

Test your skills: HTML

This page lists HTML tests you can try so you can verify if you've understood the content in this module.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Including vector graphics in HTML

Vector graphics are very useful in many circumstances — they have small file sizes and are highly scalable, so they don't pixelate when zoomed in or blown up to a large size. In this article we'll show you how to include one in your webpage.

From object to iframe — general embedding technologies

Developers commonly think of embedding media such as images, video and audio into web pages. In this article we take somewhat of a sideways step, looking at some elements that allow you to embed a wide variety of content types into your webpages: the <iframe>, <embed> and <object> elements. <iframe>s are for embedding other web pages, and the other two allow you to embed external resources such as PDF files.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Learn HTML, Codecademy

Another useful resource for learning HTML basics.

The basics of semantic HTML, Scrimba MDN learning partner

This interactive lesson provides a useful description of HTML, with particular emphasis on why the semantic aspect of it is important.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS styling basics Overview: Core learning modules Next  
CSS (Cascading Style Sheets) is used to style and layout web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides all the CSS fundamentals you'll need for now, including syntax, features, and techniques.PrerequisitesBefore starting this module, you should have a basic work environment set up (as detailed in Installing basic software), and understand how to create and manage files (as detailed in Dealing with files). You should also be familiar with HTML (work through our Structuring content with HTML module if not).

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is CSS?

CSS allows you to create great-looking web pages, but how does it work under the hood? This article explains what CSS, what the basic syntax looks like, and how your browser applies CSS to HTML to style it.

Getting started with CSS

In this article, we will take a simple HTML document and apply CSS to it, learning some practical details of the language along the way. We will also review the CSS syntax features you've not looked at yet.

Styling a biography page Challenge

In this challenge you will style a simple bio page, testing you on some of the skills you learned in the last couple of lessons including writing selectors and text styling.

Basic CSS selectors

In this article we'll recap some selector fundamentals, including the basic type, class, and ID selectors.

Attribute selectors

As you know from your study of HTML, elements can have attributes that give further detail about the element being marked up. In CSS you can use attribute selectors to target elements with certain attributes. This lesson will show you how to use these very useful selectors.

Pseudo-classes and pseudo-elements

The next set of selectors we will look at are referred to as pseudo-classes and pseudo-elements. There are a large number of these, and they often serve quite specific purposes. Once you know how to use them, you can look through the different types to see if there is something which works for the task you are trying to achieve.

Combinators

The final selectors we will look at are called combinators. Combinators are used to combine other selectors in a way that allows us to select elements based on their location in the DOM relative to other elements (for example, child or sibling).

The box model

Everything in CSS has a box around it, and understanding these boxes is key to being able to create more complex layouts with CSS, or to align items with other items. In this lesson, we will take a look at the CSS Box model. You'll get an understanding of how it works and the terminology that relates to it.

Handling conflicts

The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved.

Values and units

CSS rules contain declarations, which in turn are composed of properties and values. Each property used in CSS has a value type that describes what kind of values it is allowed to have. In this lesson, we will take a look at some of the most frequently used value types, what they are, and how they work.

Sizing items in CSS

Understanding how big the different features in your design will be is important. In this lesson we will summarize the various ways elements get a size via CSS and define a few terms about sizing that will help you in the future.

Backgrounds and borders

In this lesson, we will take a look at some of the creative things you can do with CSS backgrounds and borders. From adding gradients, background images, and rounded corners, backgrounds and borders are the answer to a lot of styling questions in CSS.

Overflowing content

Overflow is what happens when there is too much content to fit inside an element box. In this lesson, you will learn how to manage overflow using CSS.

Images, media, and form elements

In this lesson we will take a look at how certain special elements are treated in CSS. Images, other media, and form elements behave a little differently from regular boxes in terms of your ability to style them with CSS. Understanding what is and isn't possible can save some frustration, and this lesson will highlight some of the main things that you need to know.

Styling tables

Styling an HTML table isn't the most glamorous job in the world, but sometimes we all have to do it. This article explains how to make HTML tables look good, with some specific table styling techniques highlighted.

Debugging CSS

This article will give you guidance on how to go about debugging a CSS problem, and show you how the DevTools included in all modern browsers can help you to find out what is going on.

Challenge: Fundamental CSS comprehension Challenge

This challenge provides a number of related exercises that must be completed in order to create the final design — a business card/gamer card/social media profile.

Challenge: Creating fancy letterheaded paper Challenge

If you want to make the right impression, writing a letter on nice letterheaded paper can be a really good start. In this challenge you will create an online template to achieve such a look.

Challenge: A cool-looking box Challenge

In this challenge, you'll get some more practice in creating cool-looking boxes by trying to create an eye-catching box.

Additional tutorialsThese tutorials are not part of the learning pathway, but they are interesting nonetheless — you should consider these as stretch goals, to optionally study when you are done with the main Core articles.

Advanced styling effects

This article acts as a box of tricks, providing an introduction to some interesting advanced styling features such as box shadows, blend modes, and filters.

Cascade layers

This lesson aims to introduce you to cascade layers, a more advanced feature that builds on the fundamental concepts of the CSS cascade and CSS specificity.

Handling different text directions

In recent years, CSS has evolved in order to better support different directionality of content, including right-to-left but also top-to-bottom content (such as Japanese) — these different directionalities are called writing modes. As you progress in your study and begin to work with layout, an understanding of writing modes will be very helpful to you, therefore we will introduce them in this article.

Organizing CSS

As you start to work on larger stylesheets and big projects you will discover that maintaining a huge CSS file can be challenging. In this article we will take a brief look at some best practices for writing your CSS to make it easily maintainable, and some of the solutions you will find in use by others to help improve maintainability.

See also
Learn HTML and CSS, Scrimba MDN learning partner

Scrimba's Learn HTML and CSS course teaches you HTML and CSS through building and deploying five awesome projects, with fun interactive lessons and challenges taught by knowledgeable teachers.

Write your first lines of CSS!, Scrimba MDN learning partner

This interactive lesson provides a useful introduction to CSS syntax.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 27, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDynamic scripting with JavaScript Overview: Core learning modules Next  
JavaScript is a huge topic, with so many different features, styles, and techniques to learn, and so many APIs and tools built on top of it. This module focuses mostly on the essentials of the core language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.PrerequisitesBefore starting this module, you don't need any previous JavaScript knowledge, but you should have worked through the previous modules in the course. You should at least know HTML and the basic fundamentals of CSS.

Note:
If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you could try out (most of) the code examples in an online coding program such as JSBin or Glitch.
Tutorials and challenges
What is JavaScript?

Welcome to the MDN beginner's JavaScript course! In this first article we will look at JavaScript from a high level, answering questions such as "what is it?", and "what is it doing?", and making sure you are comfortable with JavaScript's purpose.

A first splash into JavaScript

Now you've learned something about the theory of JavaScript, and what you can do with it, we are going to give you a crash course on the basic features of JavaScript via a completely practical tutorial. Here you'll build up a simple "Guess the number" game, step by step.

What went wrong? Troubleshooting JavaScript

When you built up the "Guess the number" game in the previous article, you may have found that it didn't work. Never fear — this article aims to save you from tearing your hair out over such problems by providing you with some simple tips on how to find and fix errors in JavaScript programs.

Storing the information you need — Variables

After reading the last couple of articles you should now know what JavaScript is, what it can do for you, how you use it alongside other web technologies, and what its main features look like from a high level. In this article, we will get down to the real basics, looking at how to work with the most basic building blocks of JavaScript — Variables.

Basic math in JavaScript — numbers and operators

At this point in the course, we discuss maths in JavaScript — how we can combine operators and other features to successfully manipulate numbers to do our bidding.

Handling text — strings in JavaScript

Next, we'll turn our attention to strings — this is what pieces of text are called in programming. In this article, we'll look at all the common things that you really ought to know about strings when learning JavaScript, such as creating strings, escaping quotes in strings, and joining them together.

Useful string methods

Now we've looked at the very basics of strings, let's move up a gear and start thinking about what useful operations we can do on strings with built-in methods, such as finding the length of a text string, joining and splitting strings, substituting one character in a string for another, and more.

Arrays

In this lesson we'll look at arrays — a neat way of storing a list of data items under a single variable name. Here we look at why this is useful, then explore how to create an array, retrieve, add, and remove items stored in an array, and more besides.

Challenge: Silly story generator Challenge

In this challenge, you'll be tasked with taking some of the knowledge you've picked up in this module's articles and applying it to creating a fun app that generates random silly stories. Have fun!

Making decisions in your code — conditionals

In any programming language, the code needs to make decisions and carry out actions accordingly depending on different inputs. For example, in a game, if the player's number of lives is 0, then it's game over. In a weather app, if it is being looked at in the morning, show a sunrise graphic; show stars and a moon if it is nighttime. In this article, we'll explore how so-called conditional statements work in JavaScript.

Looping code

Programming languages are very useful for rapidly completing repetitive tasks, from multiple basic calculations to just about any other situation where you've got a lot of similar items of work to complete. Here we'll look at the loop structures available in JavaScript that handle such needs.

Functions — reusable blocks of code

Another essential concept in coding is functions, which allow you to store a piece of code that does a single task inside a defined block, and then call that code whenever you need it using a single short command — rather than having to type out the same code multiple times. In this article we'll explore fundamental concepts behind functions such as basic syntax, how to invoke and define them, scope, and parameters.

Build your own function

With most of the essential theory dealt with in the previous article, this article provides practical experience. Here you will get some practice building your own, custom function. Along the way, we'll also explain some useful details of dealing with functions.

Function return values

There's one last essential concept about functions for us to discuss — return values. Some functions don't return a significant value, but others do. It's important to understand what their values are, how to use them in your code, and how to make functions return useful values. We'll cover all of these below.

Introduction to events

In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers.

Event bubbling

This article introduces the concepts of event bubbling, event capture, and event delegation, which are all about what happens when you add a listener to an element that contains another element, and an event then happens to the contained element.

Challenge: Image gallery Challenge

Now that we've looked at the fundamental building blocks of JavaScript, we'll test your knowledge of loops, functions, conditionals and events by getting you to build a fairly common item you'll see on a lot of websites — a JavaScript-powered image gallery.

Object basics

In this article, we'll look at fundamental JavaScript object syntax, and revisit some JavaScript features that we've already seen earlier in the course, reiterating the fact that many of the features you've already dealt with are objects.

DOM scripting introduction

When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting.

Making network requests with JavaScript

Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible.

Working with JSON

JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON.

JavaScript debugging and error handling

In this lesson, we will return to the subject of debugging JavaScript (which we first looked at in What went wrong?). Here we will delve deeper into techniques for tracking down errors, but also look at how to code defensively and handle errors in your code, avoiding problems in the first place.

Test your skills: JavaScript

This page lists JavaScript tests you can try so you can verify if you've understood the content in this module.

See also
Scrimba: Learn JavaScript MDN learning partner

Scrimba's Learn JavaScript course teaches you JavaScript through solving 140+ interactive coding challenges, building projects including a game, a browser extension, and even a mobile app. Scrimba features fun interactive lessons taught by knowledgeable teachers.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAccessibility on the web Overview: Core learning modules Next  
Access to web content such as public services, education, e-commerce sites, and entertainment is a human right. No one should be excluded based on disability, race, geography, or other human characteristics. This module discusses the best practices and techniques you should learn to make your websites as accessible as possible.PrerequisitesYou should be familiar with HTML, CSS, and JavaScript before starting this module.

Note:
If you are working on a computer/tablet/other devices where you don't have the ability to create your own files, you can try out most of the code examples in an online coding program such as JS Bin or Glitch.
Tutorials and challenges
What is accessibility?

This article starts off the module with a good look at what accessibility is — this includes what groups of people we need to consider and why, what tools different people use to interact with the web, and how we can make accessibility part of our web development workflow.

Accessibility tooling and assistive technology

Next we turn our attention to accessibility tooling, providing information on the kinds of tools you can use to help solve accessibility issues, and the assistive technologies used by people with disabilities as they browse the web. You'll be using these tools throughout subsequent articles.

HTML: A good basis for accessibility

A great deal of web content can be made accessible just by making sure the correct HTML elements are always used for the correct purpose. This article looks in detail at how HTML can be used to ensure maximum accessibility.

CSS and JavaScript accessibility best practices

CSS and JavaScript, when used properly, also have the potential to allow for accessible web experiences, but if misused they can significantly harm accessibility. This article outlines some CSS and JavaScript best practices that should be considered to ensure that even complex content is as accessible as possible.

WAI-ARIA basics

Following on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.

Accessible multimedia

Another category of content that can create accessibility problems is multimedia — video, audio, and image content need to be given proper textual alternatives, so they can be understood by assistive technologies and their users. This article shows how.

Mobile accessibility

With web access on mobile devices being so popular, and popular platforms such as iOS and Android having fully-fledged accessibility tools, it is important to consider the accessibility of your web content on these platforms. This article looks at mobile-specific accessibility considerations.

Accessibility troubleshooting Challenge

In this challenge, we present to you a simple site with several accessibility issues that you need to diagnose and fix.

See also
Start Building Accessible Web Applications Today

An excellent series of video tutorials by Marcy Sutton.

Deque University resources

Includes code examples, screen reader references, and other useful resources.

WebAIM resources

Includes guides, checklists, tools, and more.

Web Accessibility Evaluation Tools List

Includes a list of web accessibility evaluation tools.

Learn Accessible Web Design MDN learning partner

Scrimba's Learn Accessible Web Design course teaches you how to write accessible HTML by solving interactive coding challenges and fixing a real-world website.


 Overview: Core learning modules Next  Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 15, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\nMore MDN. Your MDN.Support MDN and make it your own.Get startedWhat's includedGo ads freeEnjoy MDN ads-free with an MDN Plus subscription.Support MDN and enjoy a focused, ad-free experience alongside other features such as curated collections, custom web platform updates, offline access, and more. Subscribers to paid tiers of MDN Plus have the option to browse MDN without ads.Learn more →AI HelpGet real-time assistance and support.No need to scroll through page after page to find your answers. Introducing an AI assistant that can answer all your web development questions in real time. Powered by OpenAI GPT-4o and GPT-4o mini.Learn more →PlaygroundWrite,Test and Share your code.Your playground to learn and share your amazing work with the world. By simply logging in, you can now spread your creativity far and wide.Learn more →UpdatesCompatibility changes at a glance.Filter and sort updates that matter most to build your projectThe Web doesn't have a changelog, but MDN can help. You can personalize and filter compatibility changes based on browsers or the tech category you are interested in whether that is JavaScript, CSS, etc.Learn more →CollectionsBuild your perfect library. Or let us build it for you.No more haphazard hunting through the vast virtual library: unleash your inner curator and collect your favorite articles in one place for convenient consultation.Learn more →Loading available plans…* Do you need MDN Plus for your company? Let us know and we’ll get back to you when it becomes available.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\nOverview

More MDN. Your MDN. Get started.
This page is an overview of the MDN Plus documentation and related resources.

MDN Plus is a premium subscription service launched by Mozilla. The service
allows users to customize their MDN Web Docs experience through premium features
such as Collections, filtering Updates and MDN Offline.
Learn more about MDN Plus on our website or in this
blogpost.\n\n\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\nFrequently asked questionsWhat is MDN Plus?MDN Plus is a premium subscription service launched in March 2022 by Mozilla.
The service allows users to customize their MDN Web Docs experience through
premium features such as Updates,
Collections and
MDN Offline.Why are we working on premium features on MDN?The extensive research we have done in 2020 and 2021 showed us that MDN users
would appreciate a customized experience on MDN. We’ve got information on what
you would find useful and what you would be interested in. All the premium
features we propose today reflect that feedback. MDN Plus is an initial step
towards making the experience on the site more interactive and helpful for our
users.How much does MDN Plus cost?A three-tiered pricing model has been put in place in order to try and
accommodate our users’ needs as much as possible:

MDN Core - A free plan, for those ones who want to try out a limited version
of the premium features.
MDN Plus 5 - A $5/month or $50/year plan that offers unlimited access to the
premium features included in MDN Plus.
MDN Supporter 10 - A $10/month or $100/year plan for users who want to
support MDN with a higher amount. On top of the MDN Plus premium features, MDN
supporters will be able to contribute and shape the product moving forward, by
having early access to premium features and a direct feedback channel with the
MDN team.

Subscribing for a yearly plan activates a 20% discount for all the paid options.Can I upgrade/downgrade my plan?Currently, you can only upgrade your plan. For getting a downgrade, please
cancel your current subscription first and then activate the new one.What is happening with the existing MDN Web Docs?Nothing. We will continue to develop & maintain our web documentation that will
remain free and accessible for everyone. There will be no change there. Even
more, we believe that MDN Web Docs will benefit from MDN Plus, as we plan to
reinvest part of the gains from MDN Plus and improve our documentation as well
as the overall user experience on the website.Are we violating any OS license obligation by adding a paid product to MDN?MDN content is made available under a CC BY-SA 2.5 license. That license doesn't
preclude Mozilla (or other users of MDN content) from having a paid product. MDN
Plus adds premium features like updates and collections on top of the free
content. Regular users can still access and reuse MDN content under the Creative
Commons license.Where will the money from MDN Plus go?Since its beginning in 2005, MDN Web Docs has been a project hosted and provided
by Mozilla. Mozilla covers the cost of infrastructure, development and
maintenance of the MDN platform, including a team of engineers and its own team
of dedicated writers.
Mozilla wants MDN Plus to help ensure that MDN's open source content continues
to be supported into the future. MDN Plus has been built only with Mozilla
resources, and any revenue generated by MDN Plus will stay within Mozilla. We
are looking into ways to reinvest some of these additional funds into open
source projects contributing to MDN but it is still in the early stages.Does the launch of MDN Plus impact the relationship with partners like OWD?The existence of a new subscription model will not detract from MDN's current
free Web Docs offering in any way. The current experience of accessing web
documentation will not change for users who do not wish to sign up for a premium
subscription. Open Web Docs (OWD) and Mozilla will continue to work closely
together on MDN for the best possible web platform documentation for everyone.
For more information about how our organizations work together, please check
this article.What regions is MDN Plus available in?The free version of MDN Plus is available worldwide. Anyone can create an MDN
Plus account and try out a limited version of the premium features. As for the
paid plans, they are currently available as follows: in the United States,
Canada (since March 24th, 2022), Austria, Belgium, Finland, France, the United
Kingdom, Germany, Ireland, Italy, Malaysia, the Netherlands, New Zealand, Puerto
Rico, Sweden, Singapore, Switzerland, Spain (since April 28th, 2022), Estonia,
Greece, Latvia, Lithuania, Portugal, Slovakia and Slovenia (since June 15th,
2022). We are working on expanding this list even further.I have an idea for MDN Plus, who should I contact?In case you have an idea you would like to share about MDN Plus, you can add
your suggestions to our mdn-community
repo.
If a subscriber, you can also leave us feedback by accessing the ‘Feedback’
option in the user menu.\n\n\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\nMDN CurriculumThe essential skillset for new front-end developersThe MDN Curriculum provides a structured guide to the essential skills and practices for being a successful front-end developer, along with recommended learning resources.
Last updated: February 2024About the curriculum
Beginner's level
Self-paced
Free

Defines the essential skills and knowledge every front-end developer needs for career success and industry relevance.
Created by Mozilla and refined with insights from students, educators, and developers from the broader web community.
Includes learning resource recommendations covering every curriculum topic, helping you become job-ready.
Learn moreLearn our curriculum with Scrimba's interactive Frontend Developer Career Path.ModulesGetting started1. Soft skillsDevelop a great attitude towards learning, researching, and collaborating to enhance your chances of success.Best Practices2. Environment setupFamiliarize yourself with your development environment and the tools you'll use to build websites.ToolingLet's beginCore1. Web standardsUnderstand how the web works at a high level, and the process for creating web technologies.Web Standards & Semantics2. Semantic HTMLLearn the fundamentals of HTML, the language used to define and structure web content.Web Standards & Semantics3. CSS fundamentalsDive into the fundamentals of CSS, the language you'll use to style and layout websites.Styling4. CSS text stylingFocus on using CSS to style text and apply custom web fonts.Styling5. CSS layoutLearn modern techniques for creating flexible layouts that work on a wide variety of devices.Styling6. JavaScript fundamentalsFocus on the core JavaScript language and fundamental surrounding topics.Scripting7. AccessibilityUnderstand the need for universal access to web content and how to write accessible code.Best Practices8. Design for developersAppreciate basic design theory, how to speak design language, and what makes websites look good.Best Practices9. Version controlUnderstand why version control is necessary, and use GitHub to store code and collaborate with others.ToolingLet's beginExtensions1. Transform & animate CSSAdd animations to your toolbox to enhance user experience and perceived performance.Web Standards & Semantics2. Custom JS objectsCreate custom JavaScript objects to gain a deeper understanding of object-oriented programming.Scripting3. Web APIsStudy common WebAPIs in depth to appreciate how WebAPIs work in general.Scripting4. PerformanceExplore how to create performant, fast-loading websites and enhance perceived performance.Best Practices5. Security and privacyLearn how to protect data from unauthorized access and how to treat user data responsibly.Best Practices6. TestingExplore the need for testing, and learn how to implement common test types.Best Practices7. JavaScript frameworksStudy the features of popular JavaScript frameworks, and use them to implement common use cases.Tooling8. CSS toolingLook at popular CSS tooling and understand what code problems they can solve.Tooling9. Other tooling typesUnderstand the purpose and usage of other tooling types commonly found in a web project.ToolingLet's beginLearn the curriculum with Scrimba and become job readyScrimba's Frontend Developer Career Path teaches the MDN Curriculum Core with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job!Find out moreHow can youboost your employability with the MDNCurriculum?Learn about research collaboration and other essential soft skills.Balance between modern tooling and long-term best practices.Get access to high-quality recommended resources.Get guidance from trusted voices.Don't know where toget started? 

Starting out with coding?
Begin with our "Getting started" and "Core" modules to grasp the essential skills for web development.
Core modules


Beyond the basics?
Dive deeper with our "Extensions" modules to develop specialized skills.
Extensions modules


Seeking employment?
Our "Soft skills" module, part of "Getting started", offers crucial insights to help you land your job.
Getting started modules


Working at a school?
Use our modules to guide your teaching, or enroll your students in Scrimba's Frontend Path.
Frontend Path\n\n\n\nDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\nBlog it betterDefault styles for h1 elements are changingSimon PietersApril 11, 20254 minute readBrowsers are starting to roll out changes in default UA styles for nested section headings. This post describes the incoming changes, how to identify if it's an issue on your websites, and hints for conformant and better-structured pages.
Read more →Implications of Global Privacy ControlLola OdelolaMarch 15, 20255 minute readGlobal Privacy Control (GPC) is on the way to becoming a formal privacy standard with the recent publication of its first working draft. Let's take a look at what the implications are for developers and users.Read more →JavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
Read more →Fix your website's Largest Contentful Paint by optimizing image loadingDebugBearJanuary 13, 202510 minute readLearn techniques to improve the Largest Contentful Paint metric, a part of Core Web Vitals, for your website.
SponsoredRead more →MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readLet's have a look at MDN Web Docs content projects in 2024, with highlights of our top picks and recommended reading, and at what's next on MDN for 2025.
Read more →A new learning experience on MDNRuth JohnDecember 20, 20244 minute readThere's a new Learn Web Development section on MDN that merges the MDN Curriculum with the Learn section. Here's the background to these changes, what's new, and what you can expect to see in the future.
Read more →Countdown to the holidays with daily coding challengesSonal SoodDecember 1, 20242 minute readJoin JavaScriptmas this December for daily coding challenges designed to boost your skills and bring festive fun. Solve challenges on Scrimba, learn something new, and take part for a chance to win exciting prizes!
Read more →Monitoring and optimizing website performanceDebugBearNovember 11, 202412 minute readLearn about reading network request waterfalls, identifying common network performance issues, and optimizing page rendering.
SponsoredRead more →How to land your first developer jobPer BorgenNovember 1, 202411 minute readHere are six effective strategies for landing your first developer job. These are especially relevant if you're self-taught or breaking into the tech industry without a traditional CS degree.
SponsoredRead more →Introducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readWe are thrilled to announce the new MDN community page that will be a hub to recognize our contributors and a place for contributors to get involved.
Read more →Fixing your website's JavaScript performanceDebugBearOctober 9, 20249 minute readLearn about lesser-known web performance bottlenecks connected to excessive JavaScript usage, like long tasks, large bundle sizes, and hydration issues.
SponsoredRead more →Get back to school! Supercharge your learning with MDN and ScrimbaHermina CondeiSeptember 12, 20242 minute readFor many of us, the holidays are over, and the time has come to focus.  Now is an ideal time to dive into learning web development, and you're in luck — MDN and Scrimba are offering a 30% discount on select courses for the next month!
Read more →Efficient data handling with the Streams APIVultrSeptember 6, 20246 minute readThis post demonstrates how to use the Streams API in a web application to fetch and transform text on the fly.  By processing the data as it arrives, this approach enhances performance, responsiveness, and resource efficiency.
SponsoredRead more →Locale-sensitive text segmentation in JavaScript with Intl.SegmenterBrian SmithSeptember 3, 20245 minute readLearn how to use Intl.Segmenter for locale-sensitive text segmentation in JavaScript to simplify localization, count words or sentences in different languages, and more.Read more →Optimize your workflow with Git stashGitLabAugust 28, 20248 minute readLearn how to use Git stash to break down large commits. Discover a better approach for saving work when switching branches.SponsoredRead more →How to debug mobile apps across devicesLambdaTestAugust 7, 20248 minute readThis post explores what mobile app debugging is, commonly used techniques, and how you can debug mobile apps on multiple devices.SponsoredRead more →Exclusive accordions using the HTML details elementBrian SmithAugust 5, 20243 minute readThe 'name' attribute of the HTML details element is gaining more support across browsers. Learn how this feature allows creating exclusive accordions without scripting widgets from scratch.Read more →Exploring the Broadcast Channel API for cross-tab communicationVultrJuly 12, 20244 minute readThis article explains how to use the Broadcast Channel API to build synchronized and interconnected web applications.SponsoredRead more →MDN partners with Scrimba to enhance web development learningHermina CondeiJuly 9, 20246 minute readWe have chosen Scrimba as a course partner for the MDN Curriculum. This blog post explores what the partnership means practically, and how we will provide an even better web education experience together.Read more →Introducing the MDN HTTP ObservatoryHermina CondeiJuly 2, 20247 minute readFirst released in 2016, the HTTP Observatory became popular in the web community with a combination of helpful security audits and educational material. Fast forward to 2024, and we are delighted to announce that Observatory's new home is MDN. Read on to find out more about what this entails, and give the HTTP Observatory a warm welcome!Read more →Static Site Generation (SSG) with Next.jsVultrJune 28, 20247 minute readThis guide explains how to use Static Site Generation in Next.js to build scalable and secure web applications with fast loading times and a focus on performance.SponsoredRead more →New JavaScript Set methodsBrian SmithJune 24, 20245 minute readNew JavaScript Set methods are landing across browsers. Learn about sets, how you can use these methods to compare different sets, create new sets with specific properties, and more.Read more →Securing APIs: Express rate limit and slow downVultrMay 28, 20246 minute readThis guide introduces you to rate limits and slow down mechanisms. Learn how to apply slow down and rate limit mechanisms in Express applications.SponsoredRead more →Using the Page Visibility APIBrian SmithMay 10, 20246 minute readThis post takes a look at what page visibility is, how you can use the Page Visibility API in your applications, and describes pitfalls to avoid if you build features around this functionality.Read more →A year of publishing the MDN BlogThe MDN TeamMay 3, 20245 minute readWe've been writing about web development and the web platform on the MDN Blog since May 2023. Here's our highlights and top posts along with our favorites.Read more →Setting up service workers on VultrVultrApril 23, 20246 minute readThis guide introduces you to service workers and their lifecycle. Learn how to deploy a project using service workers with HTTPS on Vultr.SponsoredRead more →Interop 2023: MDN updatesBrian SmithMarch 27, 20246 minute readInterop 2023 has successfully concluded, and the Interop 2024 project is now officially underway. Learn what Interop is, discover the updates from Interop 2023 now on MDN, and find out what's coming to the web next.Read more →Testing JavaScript with Jest on VultrVultrMarch 22, 20247 minute readThis guide introduces you to the common types of tests and the testing conventions. Learn how to test JavaScript with Jest on Vultr.SponsoredRead more →Creating color palettes with the CSS color-mix() functionMichelle BarkerMarch 8, 20247 minute readWorking with colors on the web just got more interesting! In this article, we’ll explore how to use the CSS color-mix() function to create variations in color palettes.Read more →Modernizing conventional test automation with TestGridTestGridFebruary 29, 202412 minute readThis post reflects on the conventional test automation methods using Selenium and Appium. Learn how you can use TestGrid's unified testing platform to enhance the conventional methods and also leverage the modern codeless testing techniques.SponsoredRead more →Lift-off: The MDN Curriculum launchHermina CondeiFebruary 27, 20246 minute readThe long-awaited MDN Curriculum is now live on MDN, providing a structured guide to the essential front-end development skills and best practices for industry newcomers. Learn all the key details in this article.Read more →Creating effective technical documentationDipika BhattacharyaFebruary 13, 20247 minute readThis article provides an overview of the core components required for creating effective technical documentation. Learn the best practices to make your documentation clear, consistent, and well-structured.Read more →Leveraging Bun on Vultr: A superior Node.js alternativeVultrJanuary 17, 20245 minute readThis guide explains Bun functionalities as a runtime package manager and a bundler. It also explains the benefits of built-in Bun APIs and how to use Bun's Vultr marketplace application.SponsoredRead more →Border images in CSS: A key focus area for Interop 2023Dipika BhattacharyaDecember 19, 202310 minute readAligning with Interop 2023's emphasis on cross-browser consistency, this post walks you through various `border-image` properties that you can control to create captivating web designs. Learn how to use custom graphics for enhancing the look of your websites that appear consistent across different browsers.Read more →Build AI-powered applications using OpenLLM and Vultr Cloud GPUVultrDecember 12, 20237 minute readLearn how to build AI-powered apps using OpenLLM and Vultr Cloud GPU. This guide shows how to generate API responses using a Large Language Model. It also covers instructions for setting up an Nginx server and implementing SSL security.SponsoredRead more →Saying goodbye to third-party cookies in 2024Chris MillsDecember 8, 20238 minute readThe tail end of 2023 welcomes positive news for web privacy, as Chrome announces it is to join Firefox and Safari in deprecating third-party cookies in 2024. Find out more details about these changes, and what they mean for web developers.Read more →Baseline's evolution on MDNVadim MakeevDecember 5, 20234 minute readToday we're updating the Baseline widgets and introducing a new one, along with the updated definition of Baseline.Read more →Developer essentials: JavaScript console methodsBrian SmithNovember 30, 20236 minute readThe JavaScript console is an essential tool for web development. Learn new and fun ways to use the console to display data and debug your code.Read more →Getting started with CSS container queriesMichelle BarkerNovember 16, 20238 minute readCSS container queries are a powerful new tool for our CSS layout toolbox. In this post we'll dive into the practicalities of building a layout with container queries.Read more →Deploying Node.js applications with PM2 on VultrVultrNovember 8, 20237 minute readLearn how to deploy a Node.js application on Vultr using PM2 to create persistent services. This guide shows how to efficiently use resources via PM2 cluster mode. It also covers Nginx server setup and SSL security.SponsoredRead more →VS Code: Tips and tricks for beginnersDipika BhattacharyaNovember 7, 20238 minute readDiscover essential tips and tricks for using Visual Studio Code (VS Code), a powerful IDE. Learn how to leverage its integrated editing features and Git support, and explore a few extensions.Read more →Coming Soon: MDN Observatory 2.0The MDN TeamOctober 25, 20232 minute readObservatory 2.0 is launching soon as part of the Mozilla Developer Network as the MDN Observatory with new security scoring standards and other exciting updates.Read more →Optimizing DevSecOps workflows with GitLab's conditional CI/CD pipelinesGitLabOctober 23, 20238 minute readThis guide explores the various types of CI/CD pipelines and helps you understand their specific use cases. Learn how to leverage rules to create highly efficient DevSecOps workflows.SponsoredRead more →Introduction to web sustainabilityMichelle BarkerOctober 11, 20238 minute readWhat can web designers and developers do to build a more sustainable web? This post explores the environmental impacts of web technologies and looks at some of the ways we can build greener websites.Read more →Migrating from GitHub to GitLab seamlessly: A step-by-step guideGitLabOctober 5, 20239 minute readThinking about making the move from GitHub to GitLab? This guide demystifies the migration process, addressing common concerns for DevSecOps teams that are looking to seamlessly transition between the two platforms. This post provides a step-by-step guided tutorial on how to migrate your data from GitHub into GitLab.SponsoredRead more →Announcing the MDN front-end developer curriculumThe MDN TeamAugust 14, 20235 minute readMDN has created a curriculum for aspiring front-end developers to build a rewarding and successful career. Take a look at the curriculum, who it's for, and the research it's based on.Read more →Creating custom easing effects in CSS animations using the linear() functionMichelle BarkerAugust 1, 202310 minute readThe new CSS linear() timing function enables custom easing in animations. Explore how linear() works compared with other timing functions used for easing, with practical examples.Read more →Securing your CDN: Why and how should you use SRITerence EdenJuly 21, 20234 minute readRelying on external resources for your website is always fraught with risks. Learn how to protect your website and its visitors by using SRI to secure third-party content.Read more →Scroll progress animations in CSSMichelle BarkerJuly 14, 20237 minute readScroll-driven animations are coming to CSS! In this post, we'll look at a few types of animations and learn how to link them to the scroll progress of a container.Read more →Reflections on AI Explain: A postmortemThe MDN TeamJuly 11, 202310 minute readWe recently launched a feature called AI Explain, but we have rolled this back for now. In this post, we look into the story behind AI Explain: its development, launch, and the reasons that led us to press the pause button.Read more →Developer essentials: How to search code using grepBrian SmithJuly 3, 20239 minute readgrep is a powerful tool for searching code from the terminal. This post will show you how to use grep and why it's an essential developer tool.Read more →Introducing AI Help (Beta): Your Companion for Web DevelopmentHermina CondeiJune 27, 20233 minute readWe're introducing an AI assistant powered by MDN and OpenAI GPT 3.5 to answer all your web development questions in real time.Read more →Learn how to use hue in CSS colors with HSLBrian SmithJune 26, 20237 minute readHues are a bright way to define colors in CSS. Learn about hues, color wheels, how to use color functions, and how you can create vibrant color palettes for your website using hue.Read more →Introducing the MDN Playground: Bring your code to life!Florian DiemingerJune 22, 20236 minute readMDN is launching a code Playground. Users can prototype ideas and expand all live samples into an interactive experience.Read more →MDN doc updates: CSS selectors & media queries, WebGPU & WebTransport APIs, Progressive web appsDipika BhattacharyaJune 13, 20236 minute readDiscover CSS :lang(), experimental media queries, manipulating graphics with WebGPU, client-server communication with WebTransport, ECMAScript module support, and more.Read more →How to draw any regular shape with just one JavaScript functionRuth JohnMay 26, 20234 minute readLearn how to use JavaScript to draw any regular shape to a HTML canvas with a single function, and how to modify it to draw multiple shapes.Read more →New reference pages on MDN for JavaScript regular expressionsBrian SmithMay 23, 20235 minute readSee the latest updates to the MDN reference pages about JavaScript regular expressions, including new sections on sub-features and browser compatibility information.Read more →Celebrating Global Accessibility Awareness DaySchalk NeethlingMay 18, 20236 minute readIn celebration of Global Accessibility Awareness Day in 2023, we share some tools and guidelines to help you make the web more accessible.Read more →Using HTML landmark roles to improve accessibilitySchalk NeethlingMay 15, 202311 minute readLearn what HTML landmark roles are, how they improve accessibility, and how you can include them on your website effectively.Read more →Introducing Baseline: a unified view of stable web featuresHermina CondeiMay 10, 20233 minute readMDN leads the way in implementing WebDX community group's efforts, delivering a clear and simple baseline for the web platform to developers.Read more →How :not() chains multiple selectorsDipika BhattacharyaMay 5, 20234 minute readLearn how the CSS `:not()` pseudo-class behaves when multiple selectors are passed as argument.Read more →New functions, gradients, and hues in CSS colors (Level 4)Brian SmithMay 3, 20239 minute readLearn what's new in CSS Colors Module Level 4, including color spaces, color functions, fancy gradients, and support for wide-gamut displays.Read more →Welcome to the MDN blogRuth JohnMay 3, 20232 minute readThe MDN blog publishes web development news, tutorials, and insights as an extension of MDN Web Docs, helping you discover, learn, and create for the web.Read more →\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Hinweis: Diese Funktion ist in Web Workers verfügbar.
Die Fetch API bietet eine Schnittstelle zum Abrufen von Ressourcen (einschließlich über das Netzwerk). Sie ist ein leistungsfähigerer und flexiblerer Ersatz für XMLHttpRequest.Konzepte und NutzungDie Fetch API verwendet Request- und Response-Objekte (und andere Dinge, die mit Netzwerkanfragen verbunden sind), sowie verwandte Konzepte wie CORS und die Semantik des HTTP-Origin-Headers.
Um eine Anfrage zu stellen und eine Ressource abzurufen, verwenden Sie die Methode fetch(). Es ist eine globale Methode sowohl im Window- als auch im Worker-Kontext. Dies macht sie in so ziemlich jedem Kontext verfügbar, in dem Sie Ressourcen abrufen möchten.
Die fetch()-Methode erfordert ein obligatorisches Argument, den Pfad zu der Ressource, die Sie abrufen möchten. Sie gibt ein Promise zurück, das zur Response auf diese Anfrage aufgelöst wird – sobald der Server mit den Headern antwortet – auch wenn die Serverantwort ein HTTP-Fehlerstatus ist. Sie können optional auch ein init-Optionsobjekt als zweites Argument übergeben (siehe Request).
Sobald eine Response abgerufen wurde, stehen eine Reihe von Methoden zur Verfügung, um zu definieren, was der Inhalt des Körpers ist und wie damit umgegangen werden soll.
Sie können eine Anfrage und Antwort direkt mit den Konstruktoren Request() und Response() erstellen, aber es ist ungewöhnlich, dies direkt zu tun. Diese werden stattdessen häufiger als Ergebnisse anderer API-Aktionen erstellt (zum Beispiel FetchEvent.respondWith() aus Service Workern).
Erfahren Sie mehr über die Verwendung der Fetch API-Funktionen im Verwenden von Fetch.Schnittstellen
Window.fetch() und WorkerGlobalScope.fetch()

Die fetch()-Methode, die zum Abrufen einer Ressource verwendet wird.

Headers

Repräsentiert Antwort-/Anfrage-Header und ermöglicht es Ihnen, sie abzufragen und je nach Ergebnis unterschiedliche Aktionen durchzuführen.

Request

Repräsentiert eine Ressourcenanforderung.

Response

Repräsentiert die Antwort auf eine Anfrage.

SpezifikationenSpecificationFetch # fetch-methodBrowser-KompatibilitätSiehe auch
Verwenden von Fetch
Service Worker API
HTTP-Zugriffskontrolle (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Hinweis: Diese Funktion ist in Web Workers verfügbar.
Die Fetch API bietet eine Schnittstelle zum Abrufen von Ressourcen (einschließlich über das Netzwerk). Sie ist ein leistungsfähigerer und flexiblerer Ersatz für XMLHttpRequest.Konzepte und NutzungDie Fetch API verwendet Request- und Response-Objekte (und andere Dinge, die mit Netzwerkanfragen verbunden sind), sowie verwandte Konzepte wie CORS und die Semantik des HTTP-Origin-Headers.
Um eine Anfrage zu stellen und eine Ressource abzurufen, verwenden Sie die Methode fetch(). Es ist eine globale Methode sowohl im Window- als auch im Worker-Kontext. Dies macht sie in so ziemlich jedem Kontext verfügbar, in dem Sie Ressourcen abrufen möchten.
Die fetch()-Methode erfordert ein obligatorisches Argument, den Pfad zu der Ressource, die Sie abrufen möchten. Sie gibt ein Promise zurück, das zur Response auf diese Anfrage aufgelöst wird – sobald der Server mit den Headern antwortet – auch wenn die Serverantwort ein HTTP-Fehlerstatus ist. Sie können optional auch ein init-Optionsobjekt als zweites Argument übergeben (siehe Request).
Sobald eine Response abgerufen wurde, stehen eine Reihe von Methoden zur Verfügung, um zu definieren, was der Inhalt des Körpers ist und wie damit umgegangen werden soll.
Sie können eine Anfrage und Antwort direkt mit den Konstruktoren Request() und Response() erstellen, aber es ist ungewöhnlich, dies direkt zu tun. Diese werden stattdessen häufiger als Ergebnisse anderer API-Aktionen erstellt (zum Beispiel FetchEvent.respondWith() aus Service Workern).
Erfahren Sie mehr über die Verwendung der Fetch API-Funktionen im Verwenden von Fetch.Schnittstellen
Window.fetch() und WorkerGlobalScope.fetch()

Die fetch()-Methode, die zum Abrufen einer Ressource verwendet wird.

Headers

Repräsentiert Antwort-/Anfrage-Header und ermöglicht es Ihnen, sie abzufragen und je nach Ergebnis unterschiedliche Aktionen durchzuführen.

Request

Repräsentiert eine Ressourcenanforderung.

Response

Repräsentiert die Antwort auf eine Anfrage.

SpezifikationenSpecificationFetch # fetch-methodBrowser-KompatibilitätSiehe auch
Verwenden von Fetch
Service Worker API
HTTP-Zugriffskontrolle (CORS)
HTTP
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Hinweis: Diese Funktion ist in Web Workers verfügbar.
Die Fetch API bietet eine Schnittstelle zum Abrufen von Ressourcen (einschließlich über das Netzwerk). Sie ist ein leistungsfähigerer und flexiblerer Ersatz für XMLHttpRequest.Konzepte und NutzungDie Fetch API verwendet Request- und Response-Objekte (und andere Dinge, die mit Netzwerkanfragen verbunden sind), sowie verwandte Konzepte wie CORS und die Semantik des HTTP-Origin-Headers.
Um eine Anfrage zu stellen und eine Ressource abzurufen, verwenden Sie die Methode fetch(). Es ist eine globale Methode sowohl im Window- als auch im Worker-Kontext. Dies macht sie in so ziemlich jedem Kontext verfügbar, in dem Sie Ressourcen abrufen möchten.
Die fetch()-Methode erfordert ein obligatorisches Argument, den Pfad zu der Ressource, die Sie abrufen möchten. Sie gibt ein Promise zurück, das zur Response auf diese Anfrage aufgelöst wird – sobald der Server mit den Headern antwortet – auch wenn die Serverantwort ein HTTP-Fehlerstatus ist. Sie können optional auch ein init-Optionsobjekt als zweites Argument übergeben (siehe Request).
Sobald eine Response abgerufen wurde, stehen eine Reihe von Methoden zur Verfügung, um zu definieren, was der Inhalt des Körpers ist und wie damit umgegangen werden soll.
Sie können eine Anfrage und Antwort direkt mit den Konstruktoren Request() und Response() erstellen, aber es ist ungewöhnlich, dies direkt zu tun. Diese werden stattdessen häufiger als Ergebnisse anderer API-Aktionen erstellt (zum Beispiel FetchEvent.respondWith() aus Service Workern).
Erfahren Sie mehr über die Verwendung der Fetch API-Funktionen im Verwenden von Fetch.Schnittstellen
Window.fetch() und WorkerGlobalScope.fetch()

Die fetch()-Methode, die zum Abrufen einer Ressource verwendet wird.

Headers

Repräsentiert Antwort-/Anfrage-Header und ermöglicht es Ihnen, sie abzufragen und je nach Ergebnis unterschiedliche Aktionen durchzuführen.

Request

Repräsentiert eine Ressourcenanforderung.

Response

Repräsentiert die Antwort auf eine Anfrage.

SpezifikationenSpecificationFetch # fetch-methodBrowser-KompatibilitätSiehe auch
Verwenden von Fetch
Service Worker API
HTTP-Zugriffskontrolle (CORS)
HTTP
MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback
La API Fetch proporciona una interfaz para recuperar recursos (incluso a través de la red). Resultará familiar a cualquiera que haya usado XMLHttpRequest, pero la nueva API ofrece un conjunto de características más potente y flexible.Conceptos y usoFetch ofrece una definición genérica de los objetos Request y Response (y otras cosas relacionadas con las solicitudes de red). Esto permitirá su uso donde sea necesario en un futuro, ya sea para operadores de servicios, API caché y otras cosas similares que manipulen o modifiquen las solicitudes y respuestas, o cualquier otro tipo de caso de uso que pudiera requerirle la generación de sus propias respuestas mediante programación.
También proporciona una definición para conceptos relacionados, como CORS y la semántica de encabezado HTTP origen, suplantando sus definiciones separadas en otros lugares.
Para hacer una solicitud y recuperar un recurso, utilice el método GlobalFetch.fetch. Se implementa en múltiples interfaces, específicamente Window y WorkerGlobalScope. Esto hace que esté disponible en casi cualquier contexto donde quiera buscar recursos.
El método fetch() toma un argumento obligatorio, la ruta de acceso al recurso que desea recuperar. Devuelve una Promise que resuelve en Response a esa petición, sea o no correcta. También puede pasar opcionalmente un objeto de opciones init como segundo argumento (ver Request).
Una vez que Response es recuperada, hay varios métodos disponibles para definir cuál es el contenido del cuerpo y como se debe manejar (ver Body).
Puede crear una solicitud y respuesta directamente a con los constructores Request() y Response(), pero no es recomendable hacerlo directamente. En su lugar, es preferible que sean creados como resultado de otras acciones de la API (por ejemplo, FetchEvent.respondWith desde los operadores de servicios).

Nota:
Puede encontrar mas información sobre las características de la API Fetch en Usando Fetch, y aprender los conceptos en Fetch: conceptos básicos.
Abortar una peticiónLos navegadores han empezado a añadir soporte experimental para las interfaces AbortController y AbortSignal (Conocidas también como La API Abort), las cuales permiten que operaciones como Fetch y XHR puedan ser abortadas si no han terminado todavía. Visita las páginas de las interfaces para más detalles.Fetch Interfaces o Métodos
GlobalFetch

Contiene el método fetch() utilizado para obtener o inicializar un recurso.

Headers

Representa los encabezados de la respuesta/solicitud, lo que le permite consultar y tomar diferentes acciones en función de los resultados.

Request

Representa una solicitud de recursos.

Response

Representa la respuesta a una solicitud.

Fetch mixin
Body

Proporciona métodos relacionados con el contenido de la respuesta/solicitud, lo que le permite declarar cuál es su tipo y cómo debe manejarse.

EspecificacionesSpecificationFetch # fetch-methodCompatibilidad de navegadoresVer también
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts
Fetch API Examples\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback
La API Fetch proporciona una interfaz para recuperar recursos (incluso a través de la red). Resultará familiar a cualquiera que haya usado XMLHttpRequest, pero la nueva API ofrece un conjunto de características más potente y flexible.Conceptos y usoFetch ofrece una definición genérica de los objetos Request y Response (y otras cosas relacionadas con las solicitudes de red). Esto permitirá su uso donde sea necesario en un futuro, ya sea para operadores de servicios, API caché y otras cosas similares que manipulen o modifiquen las solicitudes y respuestas, o cualquier otro tipo de caso de uso que pudiera requerirle la generación de sus propias respuestas mediante programación.
También proporciona una definición para conceptos relacionados, como CORS y la semántica de encabezado HTTP origen, suplantando sus definiciones separadas en otros lugares.
Para hacer una solicitud y recuperar un recurso, utilice el método GlobalFetch.fetch. Se implementa en múltiples interfaces, específicamente Window y WorkerGlobalScope. Esto hace que esté disponible en casi cualquier contexto donde quiera buscar recursos.
El método fetch() toma un argumento obligatorio, la ruta de acceso al recurso que desea recuperar. Devuelve una Promise que resuelve en Response a esa petición, sea o no correcta. También puede pasar opcionalmente un objeto de opciones init como segundo argumento (ver Request).
Una vez que Response es recuperada, hay varios métodos disponibles para definir cuál es el contenido del cuerpo y como se debe manejar (ver Body).
Puede crear una solicitud y respuesta directamente a con los constructores Request() y Response(), pero no es recomendable hacerlo directamente. En su lugar, es preferible que sean creados como resultado de otras acciones de la API (por ejemplo, FetchEvent.respondWith desde los operadores de servicios).

Nota:
Puede encontrar mas información sobre las características de la API Fetch en Usando Fetch, y aprender los conceptos en Fetch: conceptos básicos.
Abortar una peticiónLos navegadores han empezado a añadir soporte experimental para las interfaces AbortController y AbortSignal (Conocidas también como La API Abort), las cuales permiten que operaciones como Fetch y XHR puedan ser abortadas si no han terminado todavía. Visita las páginas de las interfaces para más detalles.Fetch Interfaces o Métodos
GlobalFetch

Contiene el método fetch() utilizado para obtener o inicializar un recurso.

Headers

Representa los encabezados de la respuesta/solicitud, lo que le permite consultar y tomar diferentes acciones en función de los resultados.

Request

Representa una solicitud de recursos.

Response

Representa la respuesta a una solicitud.

Fetch mixin
Body

Proporciona métodos relacionados con el contenido de la respuesta/solicitud, lo que le permite declarar cuál es su tipo y cómo debe manejarse.

EspecificacionesSpecificationFetch # fetch-methodCompatibilidad de navegadoresVer también
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts
Fetch API Examples
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback
La API Fetch proporciona una interfaz para recuperar recursos (incluso a través de la red). Resultará familiar a cualquiera que haya usado XMLHttpRequest, pero la nueva API ofrece un conjunto de características más potente y flexible.Conceptos y usoFetch ofrece una definición genérica de los objetos Request y Response (y otras cosas relacionadas con las solicitudes de red). Esto permitirá su uso donde sea necesario en un futuro, ya sea para operadores de servicios, API caché y otras cosas similares que manipulen o modifiquen las solicitudes y respuestas, o cualquier otro tipo de caso de uso que pudiera requerirle la generación de sus propias respuestas mediante programación.
También proporciona una definición para conceptos relacionados, como CORS y la semántica de encabezado HTTP origen, suplantando sus definiciones separadas en otros lugares.
Para hacer una solicitud y recuperar un recurso, utilice el método GlobalFetch.fetch. Se implementa en múltiples interfaces, específicamente Window y WorkerGlobalScope. Esto hace que esté disponible en casi cualquier contexto donde quiera buscar recursos.
El método fetch() toma un argumento obligatorio, la ruta de acceso al recurso que desea recuperar. Devuelve una Promise que resuelve en Response a esa petición, sea o no correcta. También puede pasar opcionalmente un objeto de opciones init como segundo argumento (ver Request).
Una vez que Response es recuperada, hay varios métodos disponibles para definir cuál es el contenido del cuerpo y como se debe manejar (ver Body).
Puede crear una solicitud y respuesta directamente a con los constructores Request() y Response(), pero no es recomendable hacerlo directamente. En su lugar, es preferible que sean creados como resultado de otras acciones de la API (por ejemplo, FetchEvent.respondWith desde los operadores de servicios).

Nota:
Puede encontrar mas información sobre las características de la API Fetch en Usando Fetch, y aprender los conceptos en Fetch: conceptos básicos.
Abortar una peticiónLos navegadores han empezado a añadir soporte experimental para las interfaces AbortController y AbortSignal (Conocidas también como La API Abort), las cuales permiten que operaciones como Fetch y XHR puedan ser abortadas si no han terminado todavía. Visita las páginas de las interfaces para más detalles.Fetch Interfaces o Métodos
GlobalFetch

Contiene el método fetch() utilizado para obtener o inicializar un recurso.

Headers

Representa los encabezados de la respuesta/solicitud, lo que le permite consultar y tomar diferentes acciones en función de los resultados.

Request

Representa una solicitud de recursos.

Response

Representa la respuesta a una solicitud.

Fetch mixin
Body

Proporciona métodos relacionados con el contenido de la respuesta/solicitud, lo que le permite declarar cuál es su tipo y cómo debe manejarse.

EspecificacionesSpecificationFetch # fetch-methodCompatibilidad de navegadoresVer también
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts
Fetch API Examples
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAPI FetchBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'API Fetch fournit une interface pour la récupération de ressources (e.g., à travers le réseau.) Elle paraîtra familière à tout utilisateur de XMLHttpRequest, mais cette nouvelle API propose néanmoins un ensemble de fonctionnalités plus souples et plus puissantes.Concepts et usageFetch fournit une définition générique des objets Request et Response (et d'autres choses impliquées par les requêtes réseau). Ainsi il sera possible de les utiliser dès que nécessaire à l'avenir, même si c'est dans le cadre de service workers, de l'API Cache ou d'autres mécanismes similaires qui manipulent ou modifient des requêtes et des réponses, ou n'importe quelle situation qui pourrait requérir que vous génériez vos propres réponses au moyen d'un programme.
Elle fournit également une définition pour des concepts associés tels que CORS et la sémantique de l'en-tête HTTP origin, supplantant les définitions précédemment proposées ailleurs.
Pour effectuer une requête et obtenir une ressource, utilisez la méthode GlobalFetch.fetch. Elle est implémentée dans de multiples interfaces, et en particulier dans Window et WorkerGlobalScope. Ce qui la rend disponible de la même manière dans tout contexte où vous souhaiteriez récupérer des ressources.
La méthode fetch() prend un argument obligatoire, le chemin vers la ressource souhaitée. Elle retourne une promesse qui résout la Response de cette requête, qu'elle soit couronnée de succès ou non. Vous pouvez aussi optionnellement lui passer un objet d'options init comme second argument (voir Request.)
Une fois que la Response a été retournée, il y a un ensemble de méthodes disponibles pour déterminer ce que doit être le contenu du corps et comment il doit être manipulé (voir Body.)
Vous pourriez créer une requête et une réponse directement en utilisant les constructeurs Request() et Response(), même s'il est improbable que vous procédiez ainsi. Il est plus probable cependant que leur création résulte des actions d'une autre API (par exemple, FetchEvent.respondWith des service workers).

Note :
Pour en savoir plus sur l'utilisation des fonctionnalités de l'API Fetch et en approfondir les concepts, consulter respectivement Utiliser Fetch et Fetch, les concepts de base.
Interrompre un fetchLes navigateurs ont commencé à ajouter le support expérimental des interfaces AbortController et AbortSignal (connue aussi sous le nom d'API d'interruption), qui autorisent les opérations telles que Fetch et XHR à être interrompue si elles ne sont pas encore achevées. Voir les pages des interfaces pour plus de détails.Les interfaces de Fetch
GlobalFetch

La méthode fetch() est utilisée pour récuperer une ressource.

Headers

Représente les en-têtes de requête et de réponse, vous permettant de les consulter et de prendre différentes décisions en fonction du résultat.

Request

Représente la requête d'une ressource.

Response

Représente la réponse à une requête.

Mixin de Fetch
Body

Fournit les méthodes relatives au corps de la requête/réponse, vous permettant de déclarer quel est son type de contenu et comment il doit être manipulé.

SpécificationsSpecificationFetch # fetch-methodCompatibilité des navigateursVoir aussi
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts\n\nAPI FetchBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'API Fetch fournit une interface pour la récupération de ressources (e.g., à travers le réseau.) Elle paraîtra familière à tout utilisateur de XMLHttpRequest, mais cette nouvelle API propose néanmoins un ensemble de fonctionnalités plus souples et plus puissantes.Concepts et usageFetch fournit une définition générique des objets Request et Response (et d'autres choses impliquées par les requêtes réseau). Ainsi il sera possible de les utiliser dès que nécessaire à l'avenir, même si c'est dans le cadre de service workers, de l'API Cache ou d'autres mécanismes similaires qui manipulent ou modifient des requêtes et des réponses, ou n'importe quelle situation qui pourrait requérir que vous génériez vos propres réponses au moyen d'un programme.
Elle fournit également une définition pour des concepts associés tels que CORS et la sémantique de l'en-tête HTTP origin, supplantant les définitions précédemment proposées ailleurs.
Pour effectuer une requête et obtenir une ressource, utilisez la méthode GlobalFetch.fetch. Elle est implémentée dans de multiples interfaces, et en particulier dans Window et WorkerGlobalScope. Ce qui la rend disponible de la même manière dans tout contexte où vous souhaiteriez récupérer des ressources.
La méthode fetch() prend un argument obligatoire, le chemin vers la ressource souhaitée. Elle retourne une promesse qui résout la Response de cette requête, qu'elle soit couronnée de succès ou non. Vous pouvez aussi optionnellement lui passer un objet d'options init comme second argument (voir Request.)
Une fois que la Response a été retournée, il y a un ensemble de méthodes disponibles pour déterminer ce que doit être le contenu du corps et comment il doit être manipulé (voir Body.)
Vous pourriez créer une requête et une réponse directement en utilisant les constructeurs Request() et Response(), même s'il est improbable que vous procédiez ainsi. Il est plus probable cependant que leur création résulte des actions d'une autre API (par exemple, FetchEvent.respondWith des service workers).

Note :
Pour en savoir plus sur l'utilisation des fonctionnalités de l'API Fetch et en approfondir les concepts, consulter respectivement Utiliser Fetch et Fetch, les concepts de base.
Interrompre un fetchLes navigateurs ont commencé à ajouter le support expérimental des interfaces AbortController et AbortSignal (connue aussi sous le nom d'API d'interruption), qui autorisent les opérations telles que Fetch et XHR à être interrompue si elles ne sont pas encore achevées. Voir les pages des interfaces pour plus de détails.Les interfaces de Fetch
GlobalFetch

La méthode fetch() est utilisée pour récuperer une ressource.

Headers

Représente les en-têtes de requête et de réponse, vous permettant de les consulter et de prendre différentes décisions en fonction du résultat.

Request

Représente la requête d'une ressource.

Response

Représente la réponse à une requête.

Mixin de Fetch
Body

Fournit les méthodes relatives au corps de la requête/réponse, vous permettant de déclarer quel est son type de contenu et comment il doit être manipulé.

SpécificationsSpecificationFetch # fetch-methodCompatibilité des navigateursVoir aussi
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAPI FetchBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackL'API Fetch fournit une interface pour la récupération de ressources (e.g., à travers le réseau.) Elle paraîtra familière à tout utilisateur de XMLHttpRequest, mais cette nouvelle API propose néanmoins un ensemble de fonctionnalités plus souples et plus puissantes.Concepts et usageFetch fournit une définition générique des objets Request et Response (et d'autres choses impliquées par les requêtes réseau). Ainsi il sera possible de les utiliser dès que nécessaire à l'avenir, même si c'est dans le cadre de service workers, de l'API Cache ou d'autres mécanismes similaires qui manipulent ou modifient des requêtes et des réponses, ou n'importe quelle situation qui pourrait requérir que vous génériez vos propres réponses au moyen d'un programme.
Elle fournit également une définition pour des concepts associés tels que CORS et la sémantique de l'en-tête HTTP origin, supplantant les définitions précédemment proposées ailleurs.
Pour effectuer une requête et obtenir une ressource, utilisez la méthode GlobalFetch.fetch. Elle est implémentée dans de multiples interfaces, et en particulier dans Window et WorkerGlobalScope. Ce qui la rend disponible de la même manière dans tout contexte où vous souhaiteriez récupérer des ressources.
La méthode fetch() prend un argument obligatoire, le chemin vers la ressource souhaitée. Elle retourne une promesse qui résout la Response de cette requête, qu'elle soit couronnée de succès ou non. Vous pouvez aussi optionnellement lui passer un objet d'options init comme second argument (voir Request.)
Une fois que la Response a été retournée, il y a un ensemble de méthodes disponibles pour déterminer ce que doit être le contenu du corps et comment il doit être manipulé (voir Body.)
Vous pourriez créer une requête et une réponse directement en utilisant les constructeurs Request() et Response(), même s'il est improbable que vous procédiez ainsi. Il est plus probable cependant que leur création résulte des actions d'une autre API (par exemple, FetchEvent.respondWith des service workers).

Note :
Pour en savoir plus sur l'utilisation des fonctionnalités de l'API Fetch et en approfondir les concepts, consulter respectivement Utiliser Fetch et Fetch, les concepts de base.
Interrompre un fetchLes navigateurs ont commencé à ajouter le support expérimental des interfaces AbortController et AbortSignal (connue aussi sous le nom d'API d'interruption), qui autorisent les opérations telles que Fetch et XHR à être interrompue si elles ne sont pas encore achevées. Voir les pages des interfaces pour plus de détails.Les interfaces de Fetch
GlobalFetch

La méthode fetch() est utilisée pour récuperer une ressource.

Headers

Représente les en-têtes de requête et de réponse, vous permettant de les consulter et de prendre différentes décisions en fonction du résultat.

Request

Représente la requête d'une ressource.

Response

Représente la réponse à une requête.

Mixin de Fetch
Body

Fournit les méthodes relatives au corps de la requête/réponse, vous permettant de déclarer quel est son type de contenu et comment il doit être manipulé.

SpécificationsSpecificationFetch # fetch-methodCompatibilité des navigateursVoir aussi
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nフェッチ APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
メモ: この機能はウェブワーカー内で利用可能です。
フェッチ API は（ネットワーク越しの通信を含む）リソース取得のためのインターフェイスを提供しています。これは XMLHttpRequest をより強力かつ柔軟に置き換えたものです。概念と使用方法フェッチ API は Request と Response オブジェクト（他にもネットワークリクエストに関係すること）と、CORS や HTTP の Origin ヘッダーの意味づけのような関連の概念を使用します。
リクエストを行い、リソースを読み取るには、fetch() メソッドを使用します。これは Window と Worker コンテキストの両方でグローバルメソッドです。このため、リソースを取得するほとんどのコンテキストで利用できます。
fetch() メソッドは必須の引数を 1 つ取り、取得したいリソースのパスを指定します。これは Promise を返します。これはサーバーがヘッダーで返答するとすぐに、サーバーレスポンスが HTTP エラーステータスであったとしても、 Response に解決します。第 2 引数は任意で、 init オプションオブジェクトを渡すことができます（Request を参照してください）。
Response を受け取ると、レスポンスに含まれるコンテンツ本体と、その処理方法を定義するための多数のメソッドが利用できるようになります。
Request() および Response() を利用することで、リクエストとレスポンスを直接作成できます。ただしこれらのオブジェクトは、FetchEvent.respondWith() のような他の API 呼び出しの結果として取得されるべきもので、直接作成しないほうが良いでしょう。
フェッチ API の詳しい利用方法は フェッチの使用を参照してください。Fetch インターフェイス
fetch()

fetch() メソッドはリソース取得のために使用されます。

Headers

リクエストとレスポンスのヘッダーを表現しています。ヘッダー情報への問い合わせや、結果による振る舞いの選択が可能です。

Request

リソースのリクエストを表します。

Response

リクエストに対するレスポンスを表します。

仕様書SpecificationFetch # fetch-methodブラウザーの互換性関連情報
フェッチの使用
サービスワーカー API
HTTP アクセス制御 (CORS)
HTTP
フェッチのポリフィル\n\nフェッチ APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
メモ: この機能はウェブワーカー内で利用可能です。
フェッチ API は（ネットワーク越しの通信を含む）リソース取得のためのインターフェイスを提供しています。これは XMLHttpRequest をより強力かつ柔軟に置き換えたものです。概念と使用方法フェッチ API は Request と Response オブジェクト（他にもネットワークリクエストに関係すること）と、CORS や HTTP の Origin ヘッダーの意味づけのような関連の概念を使用します。
リクエストを行い、リソースを読み取るには、fetch() メソッドを使用します。これは Window と Worker コンテキストの両方でグローバルメソッドです。このため、リソースを取得するほとんどのコンテキストで利用できます。
fetch() メソッドは必須の引数を 1 つ取り、取得したいリソースのパスを指定します。これは Promise を返します。これはサーバーがヘッダーで返答するとすぐに、サーバーレスポンスが HTTP エラーステータスであったとしても、 Response に解決します。第 2 引数は任意で、 init オプションオブジェクトを渡すことができます（Request を参照してください）。
Response を受け取ると、レスポンスに含まれるコンテンツ本体と、その処理方法を定義するための多数のメソッドが利用できるようになります。
Request() および Response() を利用することで、リクエストとレスポンスを直接作成できます。ただしこれらのオブジェクトは、FetchEvent.respondWith() のような他の API 呼び出しの結果として取得されるべきもので、直接作成しないほうが良いでしょう。
フェッチ API の詳しい利用方法は フェッチの使用を参照してください。Fetch インターフェイス
fetch()

fetch() メソッドはリソース取得のために使用されます。

Headers

リクエストとレスポンスのヘッダーを表現しています。ヘッダー情報への問い合わせや、結果による振る舞いの選択が可能です。

Request

リソースのリクエストを表します。

Response

リクエストに対するレスポンスを表します。

仕様書SpecificationFetch # fetch-methodブラウザーの互換性関連情報
フェッチの使用
サービスワーカー API
HTTP アクセス制御 (CORS)
HTTP
フェッチのポリフィル
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nフェッチ APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
メモ: この機能はウェブワーカー内で利用可能です。
フェッチ API は（ネットワーク越しの通信を含む）リソース取得のためのインターフェイスを提供しています。これは XMLHttpRequest をより強力かつ柔軟に置き換えたものです。概念と使用方法フェッチ API は Request と Response オブジェクト（他にもネットワークリクエストに関係すること）と、CORS や HTTP の Origin ヘッダーの意味づけのような関連の概念を使用します。
リクエストを行い、リソースを読み取るには、fetch() メソッドを使用します。これは Window と Worker コンテキストの両方でグローバルメソッドです。このため、リソースを取得するほとんどのコンテキストで利用できます。
fetch() メソッドは必須の引数を 1 つ取り、取得したいリソースのパスを指定します。これは Promise を返します。これはサーバーがヘッダーで返答するとすぐに、サーバーレスポンスが HTTP エラーステータスであったとしても、 Response に解決します。第 2 引数は任意で、 init オプションオブジェクトを渡すことができます（Request を参照してください）。
Response を受け取ると、レスポンスに含まれるコンテンツ本体と、その処理方法を定義するための多数のメソッドが利用できるようになります。
Request() および Response() を利用することで、リクエストとレスポンスを直接作成できます。ただしこれらのオブジェクトは、FetchEvent.respondWith() のような他の API 呼び出しの結果として取得されるべきもので、直接作成しないほうが良いでしょう。
フェッチ API の詳しい利用方法は フェッチの使用を参照してください。Fetch インターフェイス
fetch()

fetch() メソッドはリソース取得のために使用されます。

Headers

リクエストとレスポンスのヘッダーを表現しています。ヘッダー情報への問い合わせや、結果による振る舞いの選択が可能です。

Request

リソースのリクエストを表します。

Response

リクエストに対するレスポンスを表します。

仕様書SpecificationFetch # fetch-methodブラウザーの互換性関連情報
フェッチの使用
サービスワーカー API
HTTP アクセス制御 (CORS)
HTTP
フェッチのポリフィル
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API는 네트워크 통신을 포함한 리소스 취득을 위한 인터페이스를 제공하며, XMLHttpRequest보다 강력하고 유연한 대체제입니다.
참고 : 이 기능은 Web Worker에서 사용할 수 있습니다.개념과 사용법Fetch API는 Request와 Response 객체, 그리고 기타 네트워크 요청에 관련된 것들을 사용하고, CORS와 HTTP Origin 헤더 행동 등 관련한 개념도 포함하고 있습니다.
요청을 생성하고 리소스를 취득하려면 fetch 메서드를 사용하세요. fetch()는 Window와 Worker 컨텍스트 양쪽에서 모두 사용할 수 있는 전역 메서드입니다. 그러므로 리소스를 취득할 상황이 생기는 거의 모든 컨텍스트에서 사용할 수 있습니다.
fetch() 메서드는 하나의 필수 매개변수로 가져오려는 리소스 경로를 받습니다. 반환 값은 해당 요청에 대한 Response로 이행하는 Promise인데, 서버가 헤더를 포함한 응답을 하는 순간 이행합니다. 이는 서버가 HTTP 오류 응답 코드로 응답해도 이행한다는 뜻입니다. 선택 사항으로, 두 번째 매개변수에 init 옵션 객체를 제공할 수 있습니다(Request 를 참고하세요).
Response를 가져온 후에는 본문 콘텐츠의 유형과 처리 방법을 정의할 수 있는 다양한 메서드를 사용할 수 있습니다.
Request()와 Response() 생성자를 직접 호출해서 요청과 응답을 생성할 수 있지만, 이런 사용법은 흔치 않습니다. 보통 이 두 객체는 다른 API(예를 들어, 서비스 워커의 FetchEvent.respondWith())에 의해 생성됩니다.
Fetch API가 제공하는 기능의 자세한 정보는 Fetch 사용하기에서, 개념 학습은 Fetch 기본 개념에서 확인하세요.Fetch 인터페이스
fetch()

리소스를 취득하기 위한 fetch() 메서드입니다.

Headers

요청/응답 헤더를 나타냅니다. 헤더를 질의하고 그 결과에 따라 다양한 동작을 취하기 위해 사용할 수 있습니다.

Request

리소스 요청을 나타냅니다.

Response

요청에 대한 응답을 나타냅니다.

명세서SpecificationFetch # fetch-method브라우저 호환성관련정보
Fetch 사용하기
Service Worker API
HTTP 접근 제어 (CORS)
HTTP
Fetch 폴리필
Fetch 기본 개념\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API는 네트워크 통신을 포함한 리소스 취득을 위한 인터페이스를 제공하며, XMLHttpRequest보다 강력하고 유연한 대체제입니다.
참고 : 이 기능은 Web Worker에서 사용할 수 있습니다.개념과 사용법Fetch API는 Request와 Response 객체, 그리고 기타 네트워크 요청에 관련된 것들을 사용하고, CORS와 HTTP Origin 헤더 행동 등 관련한 개념도 포함하고 있습니다.
요청을 생성하고 리소스를 취득하려면 fetch 메서드를 사용하세요. fetch()는 Window와 Worker 컨텍스트 양쪽에서 모두 사용할 수 있는 전역 메서드입니다. 그러므로 리소스를 취득할 상황이 생기는 거의 모든 컨텍스트에서 사용할 수 있습니다.
fetch() 메서드는 하나의 필수 매개변수로 가져오려는 리소스 경로를 받습니다. 반환 값은 해당 요청에 대한 Response로 이행하는 Promise인데, 서버가 헤더를 포함한 응답을 하는 순간 이행합니다. 이는 서버가 HTTP 오류 응답 코드로 응답해도 이행한다는 뜻입니다. 선택 사항으로, 두 번째 매개변수에 init 옵션 객체를 제공할 수 있습니다(Request 를 참고하세요).
Response를 가져온 후에는 본문 콘텐츠의 유형과 처리 방법을 정의할 수 있는 다양한 메서드를 사용할 수 있습니다.
Request()와 Response() 생성자를 직접 호출해서 요청과 응답을 생성할 수 있지만, 이런 사용법은 흔치 않습니다. 보통 이 두 객체는 다른 API(예를 들어, 서비스 워커의 FetchEvent.respondWith())에 의해 생성됩니다.
Fetch API가 제공하는 기능의 자세한 정보는 Fetch 사용하기에서, 개념 학습은 Fetch 기본 개념에서 확인하세요.Fetch 인터페이스
fetch()

리소스를 취득하기 위한 fetch() 메서드입니다.

Headers

요청/응답 헤더를 나타냅니다. 헤더를 질의하고 그 결과에 따라 다양한 동작을 취하기 위해 사용할 수 있습니다.

Request

리소스 요청을 나타냅니다.

Response

요청에 대한 응답을 나타냅니다.

명세서SpecificationFetch # fetch-method브라우저 호환성관련정보
Fetch 사용하기
Service Worker API
HTTP 접근 제어 (CORS)
HTTP
Fetch 폴리필
Fetch 기본 개념
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024년 12월 17일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API는 네트워크 통신을 포함한 리소스 취득을 위한 인터페이스를 제공하며, XMLHttpRequest보다 강력하고 유연한 대체제입니다.
참고 : 이 기능은 Web Worker에서 사용할 수 있습니다.개념과 사용법Fetch API는 Request와 Response 객체, 그리고 기타 네트워크 요청에 관련된 것들을 사용하고, CORS와 HTTP Origin 헤더 행동 등 관련한 개념도 포함하고 있습니다.
요청을 생성하고 리소스를 취득하려면 fetch 메서드를 사용하세요. fetch()는 Window와 Worker 컨텍스트 양쪽에서 모두 사용할 수 있는 전역 메서드입니다. 그러므로 리소스를 취득할 상황이 생기는 거의 모든 컨텍스트에서 사용할 수 있습니다.
fetch() 메서드는 하나의 필수 매개변수로 가져오려는 리소스 경로를 받습니다. 반환 값은 해당 요청에 대한 Response로 이행하는 Promise인데, 서버가 헤더를 포함한 응답을 하는 순간 이행합니다. 이는 서버가 HTTP 오류 응답 코드로 응답해도 이행한다는 뜻입니다. 선택 사항으로, 두 번째 매개변수에 init 옵션 객체를 제공할 수 있습니다(Request 를 참고하세요).
Response를 가져온 후에는 본문 콘텐츠의 유형과 처리 방법을 정의할 수 있는 다양한 메서드를 사용할 수 있습니다.
Request()와 Response() 생성자를 직접 호출해서 요청과 응답을 생성할 수 있지만, 이런 사용법은 흔치 않습니다. 보통 이 두 객체는 다른 API(예를 들어, 서비스 워커의 FetchEvent.respondWith())에 의해 생성됩니다.
Fetch API가 제공하는 기능의 자세한 정보는 Fetch 사용하기에서, 개념 학습은 Fetch 기본 개념에서 확인하세요.Fetch 인터페이스
fetch()

리소스를 취득하기 위한 fetch() 메서드입니다.

Headers

요청/응답 헤더를 나타냅니다. 헤더를 질의하고 그 결과에 따라 다양한 동작을 취하기 위해 사용할 수 있습니다.

Request

리소스 요청을 나타냅니다.

Response

요청에 대한 응답을 나타냅니다.

명세서SpecificationFetch # fetch-method브라우저 호환성관련정보
Fetch 사용하기
Service Worker API
HTTP 접근 제어 (CORS)
HTTP
Fetch 폴리필
Fetch 기본 개념
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2024년 12월 17일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackExperimental: Esta é uma tecnologia experimentalVerifique a tabela de compatibilidade entre Navegadores cuidadosamente antes de usar essa funcionalidade em produção.
A Fetch API fornece uma interface para buscar recursos (por exemplo, em toda a rede). Parecerá familiar para qualquer pessoa que tenha usado XMLHttpRequest, porém a nova API oferece um conjunto de recursos mais poderoso e flexível.Conceitos e usoO Fetch fornece uma definição genérica de objetos de Request e Response (e outras coisas envolvidas com solicitações de rede). Isso permitirá que eles sejam usados onde quer que sejam necessários no futuro, seja para service workers, Cache API e outras coisas similares que manipulam ou modifiquem pedidos e respostas ou qualquer tipo de caso de uso que possa exigir que você gere suas próprias responses programaticamente.
Ele também fornece uma definição para conceitos relacionados como CORS e a semântica de cabeçalho de origem HTTP, suplantando suas definições separadas em outro lugar.
Para fazer uma solicitação e buscar um recurso, use o método GlobalFetch.fetch . Ele é implementado em várias interfaces, especificamente Window e WorkerGlobalScope. Isso torna disponível em praticamente qualquer contexto em que você possa querer obter recursos.
O método fetch () tem um argumento obrigatório, o caminho para o recurso que deseja obter. Ele retorna uma promessa que resolve a Response para esta requisição, seja ele bem-sucedido ou não. Você também pode, opcionalmente, passar um objeto de opções de inicialização como o segundo argumento (consulte Request).
Uma vez que uma Response é recuperada, há uma série de métodos disponíveis para definir o conteúdo do corpo e como ele deve ser tratado (veja Body.)
Você pode criar um pedido e uma resposta diretamente usando os construtores Request() e Response(), mas é improvável que você faça isso diretamente. Em vez disso, é mais provável que sejam criados como resultados de outras ações da API (por exemplo, FetchEvent.respondWith de service workers).

Nota:
Encontre mais informações sobre os recursos do Fetch API em Using Fetch, e conceitos para estudos em Fetch basic concepts.
Fetch Interfaces
GlobalFetch

Contém o método fetch() usado para buscar um recurso.

Headers

Representa cabeçalhos response/request, permitindo que você os consulte e faça diferentes ações dependendo dos resultados.

Request

Representa um pedido de recursos.

Response

Representa a resposta de uma requisição.

Fetch mixin
Body

Providencia métodos relacionados ao corpo da resposta/requisição, permitindo que você declare qual seu tipo de conteúdo e como ele deve ser tratado.

EspecificaçõesSpecificationFetch # fetch-methodCompatibilidade com navegadoresVeja também
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackExperimental: Esta é uma tecnologia experimentalVerifique a tabela de compatibilidade entre Navegadores cuidadosamente antes de usar essa funcionalidade em produção.
A Fetch API fornece uma interface para buscar recursos (por exemplo, em toda a rede). Parecerá familiar para qualquer pessoa que tenha usado XMLHttpRequest, porém a nova API oferece um conjunto de recursos mais poderoso e flexível.Conceitos e usoO Fetch fornece uma definição genérica de objetos de Request e Response (e outras coisas envolvidas com solicitações de rede). Isso permitirá que eles sejam usados onde quer que sejam necessários no futuro, seja para service workers, Cache API e outras coisas similares que manipulam ou modifiquem pedidos e respostas ou qualquer tipo de caso de uso que possa exigir que você gere suas próprias responses programaticamente.
Ele também fornece uma definição para conceitos relacionados como CORS e a semântica de cabeçalho de origem HTTP, suplantando suas definições separadas em outro lugar.
Para fazer uma solicitação e buscar um recurso, use o método GlobalFetch.fetch . Ele é implementado em várias interfaces, especificamente Window e WorkerGlobalScope. Isso torna disponível em praticamente qualquer contexto em que você possa querer obter recursos.
O método fetch () tem um argumento obrigatório, o caminho para o recurso que deseja obter. Ele retorna uma promessa que resolve a Response para esta requisição, seja ele bem-sucedido ou não. Você também pode, opcionalmente, passar um objeto de opções de inicialização como o segundo argumento (consulte Request).
Uma vez que uma Response é recuperada, há uma série de métodos disponíveis para definir o conteúdo do corpo e como ele deve ser tratado (veja Body.)
Você pode criar um pedido e uma resposta diretamente usando os construtores Request() e Response(), mas é improvável que você faça isso diretamente. Em vez disso, é mais provável que sejam criados como resultados de outras ações da API (por exemplo, FetchEvent.respondWith de service workers).

Nota:
Encontre mais informações sobre os recursos do Fetch API em Using Fetch, e conceitos para estudos em Fetch basic concepts.
Fetch Interfaces
GlobalFetch

Contém o método fetch() usado para buscar um recurso.

Headers

Representa cabeçalhos response/request, permitindo que você os consulte e faça diferentes ações dependendo dos resultados.

Request

Representa um pedido de recursos.

Response

Representa a resposta de uma requisição.

Fetch mixin
Body

Providencia métodos relacionados ao corpo da resposta/requisição, permitindo que você declare qual seu tipo de conteúdo e como ele deve ser tratado.

EspecificaçõesSpecificationFetch # fetch-methodCompatibilidade com navegadoresVeja também
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackExperimental: Esta é uma tecnologia experimentalVerifique a tabela de compatibilidade entre Navegadores cuidadosamente antes de usar essa funcionalidade em produção.
A Fetch API fornece uma interface para buscar recursos (por exemplo, em toda a rede). Parecerá familiar para qualquer pessoa que tenha usado XMLHttpRequest, porém a nova API oferece um conjunto de recursos mais poderoso e flexível.Conceitos e usoO Fetch fornece uma definição genérica de objetos de Request e Response (e outras coisas envolvidas com solicitações de rede). Isso permitirá que eles sejam usados onde quer que sejam necessários no futuro, seja para service workers, Cache API e outras coisas similares que manipulam ou modifiquem pedidos e respostas ou qualquer tipo de caso de uso que possa exigir que você gere suas próprias responses programaticamente.
Ele também fornece uma definição para conceitos relacionados como CORS e a semântica de cabeçalho de origem HTTP, suplantando suas definições separadas em outro lugar.
Para fazer uma solicitação e buscar um recurso, use o método GlobalFetch.fetch . Ele é implementado em várias interfaces, especificamente Window e WorkerGlobalScope. Isso torna disponível em praticamente qualquer contexto em que você possa querer obter recursos.
O método fetch () tem um argumento obrigatório, o caminho para o recurso que deseja obter. Ele retorna uma promessa que resolve a Response para esta requisição, seja ele bem-sucedido ou não. Você também pode, opcionalmente, passar um objeto de opções de inicialização como o segundo argumento (consulte Request).
Uma vez que uma Response é recuperada, há uma série de métodos disponíveis para definir o conteúdo do corpo e como ele deve ser tratado (veja Body.)
Você pode criar um pedido e uma resposta diretamente usando os construtores Request() e Response(), mas é improvável que você faça isso diretamente. Em vez disso, é mais provável que sejam criados como resultados de outras ações da API (por exemplo, FetchEvent.respondWith de service workers).

Nota:
Encontre mais informações sobre os recursos do Fetch API em Using Fetch, e conceitos para estudos em Fetch basic concepts.
Fetch Interfaces
GlobalFetch

Contém o método fetch() usado para buscar um recurso.

Headers

Representa cabeçalhos response/request, permitindo que você os consulte e faça diferentes ações dependendo dos resultados.

Request

Representa um pedido de recursos.

Response

Representa a resposta de uma requisição.

Fetch mixin
Body

Providencia métodos relacionados ao corpo da resposta/requisição, permitindo que você declare qual seu tipo de conteúdo e como ele deve ser tratado.

EspecificaçõesSpecificationFetch # fetch-methodCompatibilidade com navegadoresVeja também
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch basic concepts
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API предоставляет интерфейс для получения ресурсов (в том числе по сети). Он покажется знакомым любому, кто использовал XMLHttpRequest, но новый API является более мощным и гибким набором функций.Определения и использованиеFetch обеспечивает обобщённое определение объектов Request и Response (и других вещей, связанных с сетевыми запросами). Это позволит им использоваться везде, где необходимо в будущем, в том числе и для service workers, Cache API и других подобных технологий, которые обрабатывают или изменяют запросы (requests) и ответы (responses), а так же в любых других случаях, которые могут потребовать от вас генерировать свой собственный ответ программно.
Это также предоставляет определение в отношение таких понятий, как CORS и семантика заголовков HTTP origin, заменяя их обособленные определения где бы то ни было.
Чтобы создать запрос и получить данные, используется метод GlobalFetch.fetch. Он реализован во множестве интерфейсов, в том числе в Window и WorkerGlobalScope. Это позволяет использовать его практически в любом контексте для получения данных.
Метод fetch() принимает один обязательный аргумент — путь к данным, которые вы хотите получить. Он возвращает promise, который разрешается в (Response) независимо от того, был ли запрос удачным. Вы можете также передать во втором аргументе необязательный объект с указанием опций (см. Request.)
Как только Response выполнится успешно, становятся доступными несколько методов для определения тела контента и, как его содержимое должно быть обработано (см. Body.)
Вы можете создавать запрос и ответ непосредственно, используя конструкторы Request() и Response(), но маловероятно, что в этом есть необходимость. Напротив, более вероятно, что они будут созданы как результат работы другого API (например, FetchEvent.respondWith в service workers.)Отличия от jQueryСпецификации fetch() отличаются от jQuery.ajax() тремя основными способами:

Промис, возвращённый из fetch(), не будет отвергнут при статусе ошибки HTTP, даже если ответ является HTTP 404 или 500. Вместо этого, оно будет разрешаться нормально (со статусом ok установленным в false), и будет отклоняться только при сбое в сети или если что-то помешало завершению запроса.
fetch() может получать межсайтовые куки-файлы; таким образом вы можете установить межсайтовую сессию используя fetch.
fetch() не будет посылать куки-файлы, если только не указано credentials: 'same-origin'.


Примечание:
Узнайте больше об использовании Fetch API на Using Fetch и изучите концепции на Fetch basic concepts.
Прерывание выборкиБраузеры начали добавлять экспериментальную поддержку для AbortController и AbortSignal интерфейсов (aka The Abort API), которые позволяют прерывать операции, такие как Fetch и XHR, если они ещё не завершены. Подробности смотрите на страницах интерфейсов.Fetch интерфейсы
GlobalFetch

Содержит метод fetch(), используемый для получения ресурсов.

Headers

Представляет заголовки запроса/ответа, позволяет запрашивать данные и выполнять различные действия в зависимости от результата.

Request

Запрашивает ресурс.

Response

Представляет ответ на запрос.

Fetch примесь
Body

Предоставляет методы, относящиеся к телу запроса/ответа, позволяя вам определять content-type и то, как ответ должен быть обработан.

СпецификацииSpecificationFetch # fetch-methodСовместимость с браузерамиСмотрите также
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch полифил
Fetch базовые понятия\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API предоставляет интерфейс для получения ресурсов (в том числе по сети). Он покажется знакомым любому, кто использовал XMLHttpRequest, но новый API является более мощным и гибким набором функций.Определения и использованиеFetch обеспечивает обобщённое определение объектов Request и Response (и других вещей, связанных с сетевыми запросами). Это позволит им использоваться везде, где необходимо в будущем, в том числе и для service workers, Cache API и других подобных технологий, которые обрабатывают или изменяют запросы (requests) и ответы (responses), а так же в любых других случаях, которые могут потребовать от вас генерировать свой собственный ответ программно.
Это также предоставляет определение в отношение таких понятий, как CORS и семантика заголовков HTTP origin, заменяя их обособленные определения где бы то ни было.
Чтобы создать запрос и получить данные, используется метод GlobalFetch.fetch. Он реализован во множестве интерфейсов, в том числе в Window и WorkerGlobalScope. Это позволяет использовать его практически в любом контексте для получения данных.
Метод fetch() принимает один обязательный аргумент — путь к данным, которые вы хотите получить. Он возвращает promise, который разрешается в (Response) независимо от того, был ли запрос удачным. Вы можете также передать во втором аргументе необязательный объект с указанием опций (см. Request.)
Как только Response выполнится успешно, становятся доступными несколько методов для определения тела контента и, как его содержимое должно быть обработано (см. Body.)
Вы можете создавать запрос и ответ непосредственно, используя конструкторы Request() и Response(), но маловероятно, что в этом есть необходимость. Напротив, более вероятно, что они будут созданы как результат работы другого API (например, FetchEvent.respondWith в service workers.)Отличия от jQueryСпецификации fetch() отличаются от jQuery.ajax() тремя основными способами:

Промис, возвращённый из fetch(), не будет отвергнут при статусе ошибки HTTP, даже если ответ является HTTP 404 или 500. Вместо этого, оно будет разрешаться нормально (со статусом ok установленным в false), и будет отклоняться только при сбое в сети или если что-то помешало завершению запроса.
fetch() может получать межсайтовые куки-файлы; таким образом вы можете установить межсайтовую сессию используя fetch.
fetch() не будет посылать куки-файлы, если только не указано credentials: 'same-origin'.


Примечание:
Узнайте больше об использовании Fetch API на Using Fetch и изучите концепции на Fetch basic concepts.
Прерывание выборкиБраузеры начали добавлять экспериментальную поддержку для AbortController и AbortSignal интерфейсов (aka The Abort API), которые позволяют прерывать операции, такие как Fetch и XHR, если они ещё не завершены. Подробности смотрите на страницах интерфейсов.Fetch интерфейсы
GlobalFetch

Содержит метод fetch(), используемый для получения ресурсов.

Headers

Представляет заголовки запроса/ответа, позволяет запрашивать данные и выполнять различные действия в зависимости от результата.

Request

Запрашивает ресурс.

Response

Представляет ответ на запрос.

Fetch примесь
Body

Предоставляет методы, относящиеся к телу запроса/ответа, позволяя вам определять content-type и то, как ответ должен быть обработан.

СпецификацииSpecificationFetch # fetch-methodСовместимость с браузерамиСмотрите также
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch полифил
Fetch базовые понятия
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API предоставляет интерфейс для получения ресурсов (в том числе по сети). Он покажется знакомым любому, кто использовал XMLHttpRequest, но новый API является более мощным и гибким набором функций.Определения и использованиеFetch обеспечивает обобщённое определение объектов Request и Response (и других вещей, связанных с сетевыми запросами). Это позволит им использоваться везде, где необходимо в будущем, в том числе и для service workers, Cache API и других подобных технологий, которые обрабатывают или изменяют запросы (requests) и ответы (responses), а так же в любых других случаях, которые могут потребовать от вас генерировать свой собственный ответ программно.
Это также предоставляет определение в отношение таких понятий, как CORS и семантика заголовков HTTP origin, заменяя их обособленные определения где бы то ни было.
Чтобы создать запрос и получить данные, используется метод GlobalFetch.fetch. Он реализован во множестве интерфейсов, в том числе в Window и WorkerGlobalScope. Это позволяет использовать его практически в любом контексте для получения данных.
Метод fetch() принимает один обязательный аргумент — путь к данным, которые вы хотите получить. Он возвращает promise, который разрешается в (Response) независимо от того, был ли запрос удачным. Вы можете также передать во втором аргументе необязательный объект с указанием опций (см. Request.)
Как только Response выполнится успешно, становятся доступными несколько методов для определения тела контента и, как его содержимое должно быть обработано (см. Body.)
Вы можете создавать запрос и ответ непосредственно, используя конструкторы Request() и Response(), но маловероятно, что в этом есть необходимость. Напротив, более вероятно, что они будут созданы как результат работы другого API (например, FetchEvent.respondWith в service workers.)Отличия от jQueryСпецификации fetch() отличаются от jQuery.ajax() тремя основными способами:

Промис, возвращённый из fetch(), не будет отвергнут при статусе ошибки HTTP, даже если ответ является HTTP 404 или 500. Вместо этого, оно будет разрешаться нормально (со статусом ok установленным в false), и будет отклоняться только при сбое в сети или если что-то помешало завершению запроса.
fetch() может получать межсайтовые куки-файлы; таким образом вы можете установить межсайтовую сессию используя fetch.
fetch() не будет посылать куки-файлы, если только не указано credentials: 'same-origin'.


Примечание:
Узнайте больше об использовании Fetch API на Using Fetch и изучите концепции на Fetch basic concepts.
Прерывание выборкиБраузеры начали добавлять экспериментальную поддержку для AbortController и AbortSignal интерфейсов (aka The Abort API), которые позволяют прерывать операции, такие как Fetch и XHR, если они ещё не завершены. Подробности смотрите на страницах интерфейсов.Fetch интерфейсы
GlobalFetch

Содержит метод fetch(), используемый для получения ресурсов.

Headers

Представляет заголовки запроса/ответа, позволяет запрашивать данные и выполнять различные действия в зависимости от результата.

Request

Запрашивает ресурс.

Response

Представляет ответ на запрос.

Fetch примесь
Body

Предоставляет методы, относящиеся к телу запроса/ответа, позволяя вам определять content-type и то, как ответ должен быть обработан.

СпецификацииSpecificationFetch # fetch-methodСовместимость с браузерамиСмотрите также
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch полифил
Fetch базовые понятия
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API 提供了一个获取资源的接口（包括跨网络通信）。对于任何使用过 XMLHttpRequest 的人都能轻松上手，而且新的 API 提供了更强大和灵活的功能集。
备注： 此特性在 Web Worker 中可用。概念和用法Fetch 提供了对 Request 和 Response（以及其他与网络请求有关的）对象的通用定义。这将在未来更多需要它们的地方使用它们，无论是 service worker、Cache API，又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式（即使用计算机程序或者个人编程指令）。
它同时还为有关联性的概念，例如 CORS 和 HTTP Origin 标头信息，提供一种新的定义，取代它们原来那种分离的定义。
发送请求或者获取资源，请使用 fetch() 方法。它在很多接口中都被实现了，更具体地说，是在 Window 和 WorkerGlobalScope 接口上。因此在几乎所有环境中都可以用这个方法获取资源。
fetch() 强制接受一个参数，即要获取的资源的路径。它返回一个 Promise，该 Promise 会在服务器使用标头响应后，兑现为该请求的 Response——即使服务器的响应是 HTTP 错误状态。你也可以传一个可选的第二个参数 init（参见 Request）。
一旦 Response 被返回，有许多方法可以获取主体定义的内容以及如何处理它。
你也可以通过 Request() 和 Response() 构造函数直接创建请求和响应。但是我们不建议这么做，它们更可能被创建为其他的 API 操作的结果（比如，service worker 中的 FetchEvent.respondWith）。与 jQuery 的区别fetch 规范主要在三个方面与 jQuery.ajax() 不同：


从 fetch() 返回的 Promise 不会因 HTTP 的错误状态而被拒绝，即使响应是 HTTP 404 或 500。相反，它将正常兑现（ok 状态会被设置为 false），并且只有在网络故障或者有任何阻止请求完成时，才拒绝。


除非你在 init 对象中设置（去包含）credentials，否则 fetch() 将不会发送跨源 cookie。

2018 年 4 月，该规范将默认的 credentials 策略更改为 'same-origin'。以下浏览器发布了过时的原生 fetch，并在以下版本中更新：Firefox 61.0b13、Safari 12、Chrome 68。
如果你的目标是这些旧的浏览器，请务必在所有可能接受 cookie/用户登录状态影响的 API 请求中包含拥有 credentials: 'same-origin' 的 init 对象。




备注：
更多关于 Fetch API 的用法，参考使用 Fetch。
中止 fetch要中止未完成的 fetch()，甚至 XMLHttpRequest 操作，请使用 AbortController 和 AbortSignal 接口。Fetch 接口
fetch()

包含了 fetch() 方法，用于获取资源。

Headers

表示响应/请求的标头信息，允许你查询它们，或者针对不同的结果做不同的操作。

Request

相当于一个资源请求。

Response

相当于请求的响应

规范SpecificationFetch # fetch-method浏览器兼容性参见
使用 Fetch
ServiceWorker API
HTTP 访问控制（CORS）
HTTP
Fetch polyfill\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API 提供了一个获取资源的接口（包括跨网络通信）。对于任何使用过 XMLHttpRequest 的人都能轻松上手，而且新的 API 提供了更强大和灵活的功能集。
备注： 此特性在 Web Worker 中可用。概念和用法Fetch 提供了对 Request 和 Response（以及其他与网络请求有关的）对象的通用定义。这将在未来更多需要它们的地方使用它们，无论是 service worker、Cache API，又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式（即使用计算机程序或者个人编程指令）。
它同时还为有关联性的概念，例如 CORS 和 HTTP Origin 标头信息，提供一种新的定义，取代它们原来那种分离的定义。
发送请求或者获取资源，请使用 fetch() 方法。它在很多接口中都被实现了，更具体地说，是在 Window 和 WorkerGlobalScope 接口上。因此在几乎所有环境中都可以用这个方法获取资源。
fetch() 强制接受一个参数，即要获取的资源的路径。它返回一个 Promise，该 Promise 会在服务器使用标头响应后，兑现为该请求的 Response——即使服务器的响应是 HTTP 错误状态。你也可以传一个可选的第二个参数 init（参见 Request）。
一旦 Response 被返回，有许多方法可以获取主体定义的内容以及如何处理它。
你也可以通过 Request() 和 Response() 构造函数直接创建请求和响应。但是我们不建议这么做，它们更可能被创建为其他的 API 操作的结果（比如，service worker 中的 FetchEvent.respondWith）。与 jQuery 的区别fetch 规范主要在三个方面与 jQuery.ajax() 不同：


从 fetch() 返回的 Promise 不会因 HTTP 的错误状态而被拒绝，即使响应是 HTTP 404 或 500。相反，它将正常兑现（ok 状态会被设置为 false），并且只有在网络故障或者有任何阻止请求完成时，才拒绝。


除非你在 init 对象中设置（去包含）credentials，否则 fetch() 将不会发送跨源 cookie。

2018 年 4 月，该规范将默认的 credentials 策略更改为 'same-origin'。以下浏览器发布了过时的原生 fetch，并在以下版本中更新：Firefox 61.0b13、Safari 12、Chrome 68。
如果你的目标是这些旧的浏览器，请务必在所有可能接受 cookie/用户登录状态影响的 API 请求中包含拥有 credentials: 'same-origin' 的 init 对象。




备注：
更多关于 Fetch API 的用法，参考使用 Fetch。
中止 fetch要中止未完成的 fetch()，甚至 XMLHttpRequest 操作，请使用 AbortController 和 AbortSignal 接口。Fetch 接口
fetch()

包含了 fetch() 方法，用于获取资源。

Headers

表示响应/请求的标头信息，允许你查询它们，或者针对不同的结果做不同的操作。

Request

相当于一个资源请求。

Response

相当于请求的响应

规范SpecificationFetch # fetch-method浏览器兼容性参见
使用 Fetch
ServiceWorker API
HTTP 访问控制（CORS）
HTTP
Fetch polyfill
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月14日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API 提供了一个获取资源的接口（包括跨网络通信）。对于任何使用过 XMLHttpRequest 的人都能轻松上手，而且新的 API 提供了更强大和灵活的功能集。
备注： 此特性在 Web Worker 中可用。概念和用法Fetch 提供了对 Request 和 Response（以及其他与网络请求有关的）对象的通用定义。这将在未来更多需要它们的地方使用它们，无论是 service worker、Cache API，又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式（即使用计算机程序或者个人编程指令）。
它同时还为有关联性的概念，例如 CORS 和 HTTP Origin 标头信息，提供一种新的定义，取代它们原来那种分离的定义。
发送请求或者获取资源，请使用 fetch() 方法。它在很多接口中都被实现了，更具体地说，是在 Window 和 WorkerGlobalScope 接口上。因此在几乎所有环境中都可以用这个方法获取资源。
fetch() 强制接受一个参数，即要获取的资源的路径。它返回一个 Promise，该 Promise 会在服务器使用标头响应后，兑现为该请求的 Response——即使服务器的响应是 HTTP 错误状态。你也可以传一个可选的第二个参数 init（参见 Request）。
一旦 Response 被返回，有许多方法可以获取主体定义的内容以及如何处理它。
你也可以通过 Request() 和 Response() 构造函数直接创建请求和响应。但是我们不建议这么做，它们更可能被创建为其他的 API 操作的结果（比如，service worker 中的 FetchEvent.respondWith）。与 jQuery 的区别fetch 规范主要在三个方面与 jQuery.ajax() 不同：


从 fetch() 返回的 Promise 不会因 HTTP 的错误状态而被拒绝，即使响应是 HTTP 404 或 500。相反，它将正常兑现（ok 状态会被设置为 false），并且只有在网络故障或者有任何阻止请求完成时，才拒绝。


除非你在 init 对象中设置（去包含）credentials，否则 fetch() 将不会发送跨源 cookie。

2018 年 4 月，该规范将默认的 credentials 策略更改为 'same-origin'。以下浏览器发布了过时的原生 fetch，并在以下版本中更新：Firefox 61.0b13、Safari 12、Chrome 68。
如果你的目标是这些旧的浏览器，请务必在所有可能接受 cookie/用户登录状态影响的 API 请求中包含拥有 credentials: 'same-origin' 的 init 对象。




备注：
更多关于 Fetch API 的用法，参考使用 Fetch。
中止 fetch要中止未完成的 fetch()，甚至 XMLHttpRequest 操作，请使用 AbortController 和 AbortSignal 接口。Fetch 接口
fetch()

包含了 fetch() 方法，用于获取资源。

Headers

表示响应/请求的标头信息，允许你查询它们，或者针对不同的结果做不同的操作。

Request

相当于一个资源请求。

Response

相当于请求的响应

规范SpecificationFetch # fetch-method浏览器兼容性参见
使用 Fetch
ServiceWorker API
HTTP 访问控制（CORS）
HTTP
Fetch polyfill
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月14日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API 提供了一個能獲取包含跨網路資源在的資源介面。它有點像我們所熟悉的 XMLHttpRequest ，但這個新的 API 提供了更強更彈性的功能。概念與應用Fetch 提供了 Request 與 Response 物件，還有其他牽涉網路請求的通用定義。這能讓他們在需要的時候被使用到，不管是 service worker、Cache API、還是其他處理或更動請求回應的相類事物、或是任何需要產生有序化產生回應的用例（use case）。
它也提供了諸如 CORS 與 HTTP origin 標頭語意的分散定義，能取代分散的定義。
要發動請求並取得資源的話，請使用 GlobalFetch.fetch 方法。他實作了數種介面，並指定了 Window 與 WorkerGlobalScope，使它可以在任何想獲取資源的環境中使用。
fetch() 方法有一個強制性的參數，就是要取得資源的網址。該方法會回傳一個不論請求成敗，都會 resolve 的 promise 回應。你也能選擇性地使用第二個稱為 init 的物件參數（請參見 Request）。
當 Response 檢索後，在請求體裡面會定義一些請求體為何，還有要如何處理的方法（請參見 Body）。
你也可以直接用 Request() 與 Response() 建構子來建立請求與回應，不過你不太可能直接使用他，反而更可能是以其他 API 行動的結果為形式存在。（例如來自 service worker 的 FetchEvent.respondWith）

備註：
你可以在使用 Fetch深入理解 Fetch，並在Fetch 的基本概念文章內理解概念。
中斷一次 Fetch各家瀏覽器已經開始加入 AbortController 與 AbortSignal 介面（也就是 Abort API）的實驗性支援，讓 Fetch 和 XHR 這類的操作在完成前可以被中斷。詳情請參閱相關介面的文件。Fetch 介面
fetch()

用於取得資源的 fetch() 方法。

Headers

代表請求/回應標頭，讓你能 query 並針對結果不同，採取不同行動。

Request

代表資源請求。

Response

代表資源請求的回應。

Fetch mixin
Body

提供請求/回應訊息體的相關方法，能宣告內容的類別為何，以及該如何處理。

規範SpecificationFetch # fetch-method瀏覽器相容性參見
使用 Fetch
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch 基本概念\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API 提供了一個能獲取包含跨網路資源在的資源介面。它有點像我們所熟悉的 XMLHttpRequest ，但這個新的 API 提供了更強更彈性的功能。概念與應用Fetch 提供了 Request 與 Response 物件，還有其他牽涉網路請求的通用定義。這能讓他們在需要的時候被使用到，不管是 service worker、Cache API、還是其他處理或更動請求回應的相類事物、或是任何需要產生有序化產生回應的用例（use case）。
它也提供了諸如 CORS 與 HTTP origin 標頭語意的分散定義，能取代分散的定義。
要發動請求並取得資源的話，請使用 GlobalFetch.fetch 方法。他實作了數種介面，並指定了 Window 與 WorkerGlobalScope，使它可以在任何想獲取資源的環境中使用。
fetch() 方法有一個強制性的參數，就是要取得資源的網址。該方法會回傳一個不論請求成敗，都會 resolve 的 promise 回應。你也能選擇性地使用第二個稱為 init 的物件參數（請參見 Request）。
當 Response 檢索後，在請求體裡面會定義一些請求體為何，還有要如何處理的方法（請參見 Body）。
你也可以直接用 Request() 與 Response() 建構子來建立請求與回應，不過你不太可能直接使用他，反而更可能是以其他 API 行動的結果為形式存在。（例如來自 service worker 的 FetchEvent.respondWith）

備註：
你可以在使用 Fetch深入理解 Fetch，並在Fetch 的基本概念文章內理解概念。
中斷一次 Fetch各家瀏覽器已經開始加入 AbortController 與 AbortSignal 介面（也就是 Abort API）的實驗性支援，讓 Fetch 和 XHR 這類的操作在完成前可以被中斷。詳情請參閱相關介面的文件。Fetch 介面
fetch()

用於取得資源的 fetch() 方法。

Headers

代表請求/回應標頭，讓你能 query 並針對結果不同，採取不同行動。

Request

代表資源請求。

Response

代表資源請求的回應。

Fetch mixin
Body

提供請求/回應訊息體的相關方法，能宣告內容的類別為何，以及該如何處理。

規範SpecificationFetch # fetch-method瀏覽器相容性參見
使用 Fetch
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch 基本概念
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月14日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackFetch API 提供了一個能獲取包含跨網路資源在的資源介面。它有點像我們所熟悉的 XMLHttpRequest ，但這個新的 API 提供了更強更彈性的功能。概念與應用Fetch 提供了 Request 與 Response 物件，還有其他牽涉網路請求的通用定義。這能讓他們在需要的時候被使用到，不管是 service worker、Cache API、還是其他處理或更動請求回應的相類事物、或是任何需要產生有序化產生回應的用例（use case）。
它也提供了諸如 CORS 與 HTTP origin 標頭語意的分散定義，能取代分散的定義。
要發動請求並取得資源的話，請使用 GlobalFetch.fetch 方法。他實作了數種介面，並指定了 Window 與 WorkerGlobalScope，使它可以在任何想獲取資源的環境中使用。
fetch() 方法有一個強制性的參數，就是要取得資源的網址。該方法會回傳一個不論請求成敗，都會 resolve 的 promise 回應。你也能選擇性地使用第二個稱為 init 的物件參數（請參見 Request）。
當 Response 檢索後，在請求體裡面會定義一些請求體為何，還有要如何處理的方法（請參見 Body）。
你也可以直接用 Request() 與 Response() 建構子來建立請求與回應，不過你不太可能直接使用他，反而更可能是以其他 API 行動的結果為形式存在。（例如來自 service worker 的 FetchEvent.respondWith）

備註：
你可以在使用 Fetch深入理解 Fetch，並在Fetch 的基本概念文章內理解概念。
中斷一次 Fetch各家瀏覽器已經開始加入 AbortController 與 AbortSignal 介面（也就是 Abort API）的實驗性支援，讓 Fetch 和 XHR 這類的操作在完成前可以被中斷。詳情請參閱相關介面的文件。Fetch 介面
fetch()

用於取得資源的 fetch() 方法。

Headers

代表請求/回應標頭，讓你能 query 並針對結果不同，採取不同行動。

Request

代表資源請求。

Response

代表資源請求的回應。

Fetch mixin
Body

提供請求/回應訊息體的相關方法，能宣告內容的類別為何，以及該如何處理。

規範SpecificationFetch # fetch-method瀏覽器相容性參見
使用 Fetch
ServiceWorker API
HTTP access control (CORS)
HTTP
Fetch polyfill
Fetch 基本概念
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月14日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetch APIBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.Concepts and usageThe Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.
For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in.
The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request).
Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.
You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers).
Find out more about using the Fetch API features in Using Fetch.Interfaces
Window.fetch() and WorkerGlobalScope.fetch()

The fetch() method used to fetch a resource.

Headers

Represents response/request headers, allowing you to query them and take different actions depending on the results.

Request

Represents a resource request.

Response

Represents the response to a request.

SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Using Fetch
Service Worker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 9, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nUsing the Fetch APIThe Fetch API provides a JavaScript interface for making HTTP requests and processing the responses.
Fetch is the modern replacement for XMLHttpRequest: unlike XMLHttpRequest, which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS).
With the Fetch API, you make a request by calling fetch(), which is available as a global function in both window and worker contexts. You pass it a Request object or a string containing the URL to fetch, along with an optional argument to configure the request.
The fetch() function returns a Promise which is fulfilled with a Response object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response.
Here's a minimal function that uses fetch() to retrieve some JSON data from a server:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const json = await response.json();
    console.log(json);
  } catch (error) {
    console.error(error.message);
  }
}

We declare a string containing the URL and then call fetch(), passing the URL with no extra options.
The fetch() function will reject the promise on some errors, but not if the server responds with an error status like 404: so we also check the response status and throw if it is not OK.
Otherwise, we fetch the response body content as JSON by calling the json() method of Response, and log one of its values. Note that like fetch() itself, json() is asynchronous, as are all the other methods to access the response body content.
In the rest of this page we'll look in more detail at the different stages of this process.Making a requestTo make a request, call fetch(), passing in:

a definition of the resource to fetch. This can be any one of:

a string containing the URL
an object, such as an instance of URL, which has a stringifier that produces a string containing the URL
a Request instance


optionally, an object containing options to configure the request.

In this section we'll look at some of the most commonly-used options. To read about all the options that can be given, see the fetch() reference page.Setting the methodBy default, fetch() makes a GET request, but you can use the method option to use a different request method:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  // ...
});

If the mode option is set to no-cors, then method must be one of GET, POST or HEAD.Setting a bodyThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with GET requests, but it's useful for requests that send content to the server, such as POST or PUT requests. For example, if you want to upload a file to the server, you might make a POST request and include the file as the request body.
To set a request body, pass it as the body option:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  // ...
});

You can supply the body as an instance of any of the following types:

a string
ArrayBuffer
TypedArray
DataView
Blob
File
URLSearchParams
FormData
ReadableStream

Other objects are converted to strings using their toString() method. For example, you can use a URLSearchParams object to encode form data (see setting headers for more information):
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/x-www-form-urlencoded",
  },
  // Automatically converted to "username=example&password=password"
  body: new URLSearchParams({ username: "example", password: "password" }),
  // ...
});

Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice:
jsconst request = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
});

const response1 = await fetch(request);
console.log(response1.status);

// Will throw: "Body has already been consumed."
const response2 = await fetch(request);
console.log(response2.status);

Instead, you would need to create a clone of the request before sending it:
jsconst request1 = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
});

const request2 = request1.clone();

const response1 = await fetch(request1);
console.log(response1.status);

const response2 = await fetch(request2);
console.log(response2.status);

See Locked and disturbed streams for more information.Setting headersRequest headers give the server information about the request: for example, in a POST request, the Content-Type header tells the server the format of the request's body.
To set request headers, assign them to the headers option.
You can pass an object literal here containing header-name: header-value properties:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ username: "example" }),
  // ...
});

Alternatively, you can construct a Headers object, add headers to that object using Headers.append(), then assign the Headers object to the headers option:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const response = await fetch("https://example.org/post", {
  method: "POST",
  headers: myHeaders,
  body: JSON.stringify({ username: "example" }),
  // ...
});

Compared to using plain objects, the Headers object provides some additional input sanitization. For example, it normalizes header names to lowercase, strips leading and trailing whitespace from header values, and prevents certain headers from being set. Many headers are set automatically by the browser and can't be set by a script: these are called Forbidden request headers. If the mode option is set to no-cors, then the set of permitted headers is further restricted.Sending data in a GET requestGET requests don't have a body, but you can still send data to the server by appending it to the URL as a query string. This is a common way to send form data to the server. You can do this by using URLSearchParams to encode the data, and then appending it to the URL:
jsconst params = new URLSearchParams();
params.append("username", "example");

// GET request sent to https://example.org/login?username=example
const response = await fetch(`https://example.org/login?${params}`);
Making cross-origin requestsWhether a request can be made cross-origin or not is determined by the value of the RequestInit.mode option. This may take one of three values: cors, same-origin, or no-cors.


For fetch requests the default value of mode is cors, meaning that if the request is cross-origin then it will use the Cross-Origin Resource Sharing (CORS) mechanism. This means that:

if the request is a simple request, then the request will always be sent, but the server must respond with the correct Access-Control-Allow-Origin header or the browser will not share the response with the caller.
if the request is not a simple request, then the browser will send a preflighted request to check that the server understands CORS and allows the request, and the real request will not be sent unless the server responds to the preflighted request with the appropriate CORS headers.



Setting mode to same-origin disallows cross-origin requests completely.


Setting mode to no-cors disables CORS for cross-origin requests. This restricts the headers that may be set, and restricts methods to GET, HEAD, and POST. The response is opaque, meaning that its headers and body are not available to JavaScript. Most of the time a website should not use no-cors: the main application of it is for certain service worker use cases.


See the reference documentation for RequestInit.mode for more details.Including credentialsCredentials are cookies, TLS client certificates, or authentication headers containing a username and password.
To control whether or not the browser sends credentials, as well as whether the browser respects any Set-Cookie response headers, set the credentials option, which can take one of the following three values:

omit: never send credentials in the request or include credentials in the response.
same-origin (the default): only send and include credentials for same-origin requests.
include: always include credentials, even cross-origin.

Note that if a cookie's SameSite attribute is set to Strict or Lax, then the cookie will not be sent cross-site, even if credentials is set to include.
Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if credentials is set to include, the server must also agree to their inclusion by including the Access-Control-Allow-Credentials header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the Access-Control-Allow-Origin response header (that is, * is not allowed).
This means that if credentials is set to include and the request is cross-origin, then:


If the request is a simple request, then the request will be sent with credentials, but the server must set the Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.


If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.

Creating a Request objectThe Request() constructor takes the same arguments as fetch() itself. This means that instead of passing options into fetch(), you can pass the same options to the Request() constructor, and then pass that object to fetch().
For example, we can make a POST request by passing options into fetch() using code like this:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const response = await fetch("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  headers: myHeaders,
});

However, we could rewrite this to pass the same arguments to the Request() constructor:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const myRequest = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  headers: myHeaders,
});

const response = await fetch(myRequest);

This also means that you can create a request from another request, while changing some of its properties using the second argument:
jsasync function post(request) {
  try {
    const response = await fetch(request);
    const result = await response.json();
    console.log("Success:", result);
  } catch (error) {
    console.error("Error:", error);
  }
}

const request1 = new Request("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ username: "example1" }),
});

const request2 = new Request(request1, {
  body: JSON.stringify({ username: "example2" }),
});

post(request1);
post(request2);
Canceling a requestTo make a request cancelable, create an AbortController, and assign its AbortSignal to the request's signal property.
To cancel the request, call the controller's abort() method. The fetch() call will reject the promise with an AbortError exception.
jsconst controller = new AbortController();

const fetchButton = document.querySelector("#fetch");
fetchButton.addEventListener("click", async () => {
  try {
    console.log("Starting fetch");
    const response = await fetch("https://example.org/get", {
      signal: controller.signal,
    });
    console.log(`Response: ${response.status}`);
  } catch (e) {
    console.error(`Error: ${e}`);
  }
});

const cancelButton = document.querySelector("#cancel");
cancelButton.addEventListener("click", () => {
  controller.abort();
  console.log("Canceled fetch");
});

If the request is aborted after the fetch() call has been fulfilled but before the response body has been read, then attempting to read the response body will reject with an AbortError exception.
jsasync function get() {
  const controller = new AbortController();
  const request = new Request("https://example.org/get", {
    signal: controller.signal,
  });

  const response = await fetch(request);
  controller.abort();
  // The next line will throw `AbortError`
  const text = await response.text();
  console.log(text);
}
Handling the responseAs soon as the browser has received the response status and headers from the server (and potentially before the response body itself has been received), the promise returned by fetch() is fulfilled with a Response object.Checking response statusThe promise returned by fetch() will reject on some errors, such as a network error or a bad scheme. However, if the server responds with an error like 404, then fetch() fulfills with a Response, so we have to check the status before we can read the response body.
The Response.status property tells us the numerical status code, and the Response.ok property returns true if the status is in the 200 range.
A common pattern is to check the value of ok and throw if it is false:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }
    // ...
  } catch (error) {
    console.error(error.message);
  }
}
Checking the response typeResponses have a type property that can be one of the following:

basic: the request was a same-origin request.
cors: the request was a cross-origin CORS request.
opaque: the request was a cross-origin simple request made with the no-cors mode.
opaqueredirect: the request set the redirect option to manual, and the server returned a redirect status.

The type determines the possible contents of the response, as follows:


Basic responses exclude response headers from the Forbidden response header name list.


CORS responses include only response headers from the CORS-safelisted response header list.


Opaque responses and opaque redirect responses have a status of 0, an empty header list, and a null body.

Checking headersJust like the request, the response has a headers property which is a Headers object, and this contains any response headers that are exposed to scripts, subject to the exclusions made based on the response type.
A common use case for this is to check the content type before trying to read the body:
jsasync function fetchJSON(request) {
  try {
    const response = await fetch(request);
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.includes("application/json")) {
      throw new TypeError("Oops, we haven't got JSON!");
    }
    // Otherwise, we can read the body as JSON
  } catch (error) {
    console.error("Error:", error);
  }
}
Reading the response bodyThe Response interface provides a number of methods to retrieve the entire body contents in a variety of different formats:

Response.arrayBuffer()
Response.blob()
Response.formData()
Response.json()
Response.text()

These are all asynchronous methods, returning a Promise which will be fulfilled with the body content.
In this example, we fetch an image and read it as a Blob, which we can then use to create an object URL:
jsconst image = document.querySelector("img");

const url = "flowers.jpg";

async function setImage() {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }
    const blob = await response.blob();
    const objectURL = URL.createObjectURL(blob);
    image.src = objectURL;
  } catch (e) {
    console.error(e);
  }
}

The method will throw an exception if the response body is not in the appropriate format: for example, if you call json() on a response that can't be parsed as JSON.Streaming the response bodyRequest and response bodies are actually ReadableStream objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like json().
This also means that the caller can process the content incrementally as it is received.
For example, consider a GET request that fetches a large text file and processes it in some way, or displays it to the user:
jsconst url = "https://www.example.org/a-large-file.txt";

async function fetchText(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const text = await response.text();
    console.log(text);
  } catch (e) {
    console.error(e);
  }
}

If we use Response.text(), as above, we must wait until the whole file has been received before we can process any of it.
If we stream the response instead, we can process chunks of the body as they are received from the network:
jsconst url = "https://www.example.org/a-large-file.txt";

async function fetchTextAsStream(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const stream = response.body.pipeThrough(new TextDecoderStream());
    for await (const value of stream) {
      console.log(value);
    }
  } catch (e) {
    console.error(e);
  }
}

In this example, we iterate asynchronously over the stream, processing each chunk as it arrives.
Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call ReadableStream.pipeThrough() to pipe the response through a TextDecoderStream, which decodes the UTF-8-encoded body data as text.Processing a text file line by lineIn the example below, we fetch a text resource and process it line by line, using a regular expression to look for line endings. For simplicity, we assume the text is UTF-8, and don't handle fetch errors:
jsasync function* makeTextFileLineIterator(fileURL) {
  const response = await fetch(fileURL);
  const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();

  let { value: chunk, done: readerDone } = await reader.read();
  chunk = chunk || "";

  const newline = /\r?\n/gm;
  let startIndex = 0;

  while (true) {
    const result = newline.exec(chunk);
    if (!result) {
      if (readerDone) break;
      const remainder = chunk.substr(startIndex);
      ({ value: chunk, done: readerDone } = await reader.read());
      chunk = remainder + (chunk || "");
      startIndex = newline.lastIndex = 0;
      continue;
    }
    yield chunk.substring(startIndex, result.index);
    startIndex = newline.lastIndex;
  }

  if (startIndex < chunk.length) {
    // Last line didn't end in a newline char
    yield chunk.substring(startIndex);
  }
}

async function run(urlOfFile) {
  for await (const line of makeTextFileLineIterator(urlOfFile)) {
    processLine(line);
  }
}

function processLine(line) {
  console.log(line);
}

run("https://www.example.org/a-large-file.txt");
Locked and disturbed streamsThe consequences of request and response bodies being streams are that:

if a reader has been attached to a stream using ReadableStream.getReader(), then the stream is locked, and nothing else can read the stream.
if any content has been read from the stream, then the stream is disturbed, and nothing else can read from the stream.

This means it's not possible to read the same response (or request) body more than once:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const json1 = await response.json();
    const json2 = await response.json(); // will throw
  } catch (error) {
    console.error(error.message);
  }
}

If you do need to read the body more than once, you must call Response.clone() before reading the body:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response1 = await fetch(url);
    if (!response1.ok) {
      throw new Error(`Response status: ${response1.status}`);
    }

    const response2 = response1.clone();

    const json1 = await response1.json();
    const json2 = await response2.json();
  } catch (error) {
    console.error(error.message);
  }
}

This is a common pattern when implementing an offline cache with service workers. The service worker wants to return the response to the app, but also to cache the response. So it clones the response, returns the original, and caches the clone:
jsasync function cacheFirst(request) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open("MyCache_1");
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    return Response.error();
  }
}

self.addEventListener("fetch", (event) => {
  if (precachedResources.includes(url.pathname)) {
    event.respondWith(cacheFirst(event.request));
  }
});
See also
Service Worker API
Streams API
CORS
HTTP
Fetch examples on GitHub\n\nUsing the Fetch APIThe Fetch API provides a JavaScript interface for making HTTP requests and processing the responses.
Fetch is the modern replacement for XMLHttpRequest: unlike XMLHttpRequest, which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS).
With the Fetch API, you make a request by calling fetch(), which is available as a global function in both window and worker contexts. You pass it a Request object or a string containing the URL to fetch, along with an optional argument to configure the request.
The fetch() function returns a Promise which is fulfilled with a Response object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response.
Here's a minimal function that uses fetch() to retrieve some JSON data from a server:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const json = await response.json();
    console.log(json);
  } catch (error) {
    console.error(error.message);
  }
}

We declare a string containing the URL and then call fetch(), passing the URL with no extra options.
The fetch() function will reject the promise on some errors, but not if the server responds with an error status like 404: so we also check the response status and throw if it is not OK.
Otherwise, we fetch the response body content as JSON by calling the json() method of Response, and log one of its values. Note that like fetch() itself, json() is asynchronous, as are all the other methods to access the response body content.
In the rest of this page we'll look in more detail at the different stages of this process.Making a requestTo make a request, call fetch(), passing in:

a definition of the resource to fetch. This can be any one of:

a string containing the URL
an object, such as an instance of URL, which has a stringifier that produces a string containing the URL
a Request instance


optionally, an object containing options to configure the request.

In this section we'll look at some of the most commonly-used options. To read about all the options that can be given, see the fetch() reference page.Setting the methodBy default, fetch() makes a GET request, but you can use the method option to use a different request method:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  // ...
});

If the mode option is set to no-cors, then method must be one of GET, POST or HEAD.Setting a bodyThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with GET requests, but it's useful for requests that send content to the server, such as POST or PUT requests. For example, if you want to upload a file to the server, you might make a POST request and include the file as the request body.
To set a request body, pass it as the body option:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  // ...
});

You can supply the body as an instance of any of the following types:

a string
ArrayBuffer
TypedArray
DataView
Blob
File
URLSearchParams
FormData
ReadableStream

Other objects are converted to strings using their toString() method. For example, you can use a URLSearchParams object to encode form data (see setting headers for more information):
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/x-www-form-urlencoded",
  },
  // Automatically converted to "username=example&password=password"
  body: new URLSearchParams({ username: "example", password: "password" }),
  // ...
});

Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice:
jsconst request = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
});

const response1 = await fetch(request);
console.log(response1.status);

// Will throw: "Body has already been consumed."
const response2 = await fetch(request);
console.log(response2.status);

Instead, you would need to create a clone of the request before sending it:
jsconst request1 = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
});

const request2 = request1.clone();

const response1 = await fetch(request1);
console.log(response1.status);

const response2 = await fetch(request2);
console.log(response2.status);

See Locked and disturbed streams for more information.Setting headersRequest headers give the server information about the request: for example, in a POST request, the Content-Type header tells the server the format of the request's body.
To set request headers, assign them to the headers option.
You can pass an object literal here containing header-name: header-value properties:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ username: "example" }),
  // ...
});

Alternatively, you can construct a Headers object, add headers to that object using Headers.append(), then assign the Headers object to the headers option:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const response = await fetch("https://example.org/post", {
  method: "POST",
  headers: myHeaders,
  body: JSON.stringify({ username: "example" }),
  // ...
});

Compared to using plain objects, the Headers object provides some additional input sanitization. For example, it normalizes header names to lowercase, strips leading and trailing whitespace from header values, and prevents certain headers from being set. Many headers are set automatically by the browser and can't be set by a script: these are called Forbidden request headers. If the mode option is set to no-cors, then the set of permitted headers is further restricted.Sending data in a GET requestGET requests don't have a body, but you can still send data to the server by appending it to the URL as a query string. This is a common way to send form data to the server. You can do this by using URLSearchParams to encode the data, and then appending it to the URL:
jsconst params = new URLSearchParams();
params.append("username", "example");

// GET request sent to https://example.org/login?username=example
const response = await fetch(`https://example.org/login?${params}`);
Making cross-origin requestsWhether a request can be made cross-origin or not is determined by the value of the RequestInit.mode option. This may take one of three values: cors, same-origin, or no-cors.


For fetch requests the default value of mode is cors, meaning that if the request is cross-origin then it will use the Cross-Origin Resource Sharing (CORS) mechanism. This means that:

if the request is a simple request, then the request will always be sent, but the server must respond with the correct Access-Control-Allow-Origin header or the browser will not share the response with the caller.
if the request is not a simple request, then the browser will send a preflighted request to check that the server understands CORS and allows the request, and the real request will not be sent unless the server responds to the preflighted request with the appropriate CORS headers.



Setting mode to same-origin disallows cross-origin requests completely.


Setting mode to no-cors disables CORS for cross-origin requests. This restricts the headers that may be set, and restricts methods to GET, HEAD, and POST. The response is opaque, meaning that its headers and body are not available to JavaScript. Most of the time a website should not use no-cors: the main application of it is for certain service worker use cases.


See the reference documentation for RequestInit.mode for more details.Including credentialsCredentials are cookies, TLS client certificates, or authentication headers containing a username and password.
To control whether or not the browser sends credentials, as well as whether the browser respects any Set-Cookie response headers, set the credentials option, which can take one of the following three values:

omit: never send credentials in the request or include credentials in the response.
same-origin (the default): only send and include credentials for same-origin requests.
include: always include credentials, even cross-origin.

Note that if a cookie's SameSite attribute is set to Strict or Lax, then the cookie will not be sent cross-site, even if credentials is set to include.
Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if credentials is set to include, the server must also agree to their inclusion by including the Access-Control-Allow-Credentials header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the Access-Control-Allow-Origin response header (that is, * is not allowed).
This means that if credentials is set to include and the request is cross-origin, then:


If the request is a simple request, then the request will be sent with credentials, but the server must set the Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.


If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.

Creating a Request objectThe Request() constructor takes the same arguments as fetch() itself. This means that instead of passing options into fetch(), you can pass the same options to the Request() constructor, and then pass that object to fetch().
For example, we can make a POST request by passing options into fetch() using code like this:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const response = await fetch("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  headers: myHeaders,
});

However, we could rewrite this to pass the same arguments to the Request() constructor:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const myRequest = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  headers: myHeaders,
});

const response = await fetch(myRequest);

This also means that you can create a request from another request, while changing some of its properties using the second argument:
jsasync function post(request) {
  try {
    const response = await fetch(request);
    const result = await response.json();
    console.log("Success:", result);
  } catch (error) {
    console.error("Error:", error);
  }
}

const request1 = new Request("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ username: "example1" }),
});

const request2 = new Request(request1, {
  body: JSON.stringify({ username: "example2" }),
});

post(request1);
post(request2);
Canceling a requestTo make a request cancelable, create an AbortController, and assign its AbortSignal to the request's signal property.
To cancel the request, call the controller's abort() method. The fetch() call will reject the promise with an AbortError exception.
jsconst controller = new AbortController();

const fetchButton = document.querySelector("#fetch");
fetchButton.addEventListener("click", async () => {
  try {
    console.log("Starting fetch");
    const response = await fetch("https://example.org/get", {
      signal: controller.signal,
    });
    console.log(`Response: ${response.status}`);
  } catch (e) {
    console.error(`Error: ${e}`);
  }
});

const cancelButton = document.querySelector("#cancel");
cancelButton.addEventListener("click", () => {
  controller.abort();
  console.log("Canceled fetch");
});

If the request is aborted after the fetch() call has been fulfilled but before the response body has been read, then attempting to read the response body will reject with an AbortError exception.
jsasync function get() {
  const controller = new AbortController();
  const request = new Request("https://example.org/get", {
    signal: controller.signal,
  });

  const response = await fetch(request);
  controller.abort();
  // The next line will throw `AbortError`
  const text = await response.text();
  console.log(text);
}
Handling the responseAs soon as the browser has received the response status and headers from the server (and potentially before the response body itself has been received), the promise returned by fetch() is fulfilled with a Response object.Checking response statusThe promise returned by fetch() will reject on some errors, such as a network error or a bad scheme. However, if the server responds with an error like 404, then fetch() fulfills with a Response, so we have to check the status before we can read the response body.
The Response.status property tells us the numerical status code, and the Response.ok property returns true if the status is in the 200 range.
A common pattern is to check the value of ok and throw if it is false:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }
    // ...
  } catch (error) {
    console.error(error.message);
  }
}
Checking the response typeResponses have a type property that can be one of the following:

basic: the request was a same-origin request.
cors: the request was a cross-origin CORS request.
opaque: the request was a cross-origin simple request made with the no-cors mode.
opaqueredirect: the request set the redirect option to manual, and the server returned a redirect status.

The type determines the possible contents of the response, as follows:


Basic responses exclude response headers from the Forbidden response header name list.


CORS responses include only response headers from the CORS-safelisted response header list.


Opaque responses and opaque redirect responses have a status of 0, an empty header list, and a null body.

Checking headersJust like the request, the response has a headers property which is a Headers object, and this contains any response headers that are exposed to scripts, subject to the exclusions made based on the response type.
A common use case for this is to check the content type before trying to read the body:
jsasync function fetchJSON(request) {
  try {
    const response = await fetch(request);
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.includes("application/json")) {
      throw new TypeError("Oops, we haven't got JSON!");
    }
    // Otherwise, we can read the body as JSON
  } catch (error) {
    console.error("Error:", error);
  }
}
Reading the response bodyThe Response interface provides a number of methods to retrieve the entire body contents in a variety of different formats:

Response.arrayBuffer()
Response.blob()
Response.formData()
Response.json()
Response.text()

These are all asynchronous methods, returning a Promise which will be fulfilled with the body content.
In this example, we fetch an image and read it as a Blob, which we can then use to create an object URL:
jsconst image = document.querySelector("img");

const url = "flowers.jpg";

async function setImage() {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }
    const blob = await response.blob();
    const objectURL = URL.createObjectURL(blob);
    image.src = objectURL;
  } catch (e) {
    console.error(e);
  }
}

The method will throw an exception if the response body is not in the appropriate format: for example, if you call json() on a response that can't be parsed as JSON.Streaming the response bodyRequest and response bodies are actually ReadableStream objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like json().
This also means that the caller can process the content incrementally as it is received.
For example, consider a GET request that fetches a large text file and processes it in some way, or displays it to the user:
jsconst url = "https://www.example.org/a-large-file.txt";

async function fetchText(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const text = await response.text();
    console.log(text);
  } catch (e) {
    console.error(e);
  }
}

If we use Response.text(), as above, we must wait until the whole file has been received before we can process any of it.
If we stream the response instead, we can process chunks of the body as they are received from the network:
jsconst url = "https://www.example.org/a-large-file.txt";

async function fetchTextAsStream(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const stream = response.body.pipeThrough(new TextDecoderStream());
    for await (const value of stream) {
      console.log(value);
    }
  } catch (e) {
    console.error(e);
  }
}

In this example, we iterate asynchronously over the stream, processing each chunk as it arrives.
Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call ReadableStream.pipeThrough() to pipe the response through a TextDecoderStream, which decodes the UTF-8-encoded body data as text.Processing a text file line by lineIn the example below, we fetch a text resource and process it line by line, using a regular expression to look for line endings. For simplicity, we assume the text is UTF-8, and don't handle fetch errors:
jsasync function* makeTextFileLineIterator(fileURL) {
  const response = await fetch(fileURL);
  const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();

  let { value: chunk, done: readerDone } = await reader.read();
  chunk = chunk || "";

  const newline = /\r?\n/gm;
  let startIndex = 0;

  while (true) {
    const result = newline.exec(chunk);
    if (!result) {
      if (readerDone) break;
      const remainder = chunk.substr(startIndex);
      ({ value: chunk, done: readerDone } = await reader.read());
      chunk = remainder + (chunk || "");
      startIndex = newline.lastIndex = 0;
      continue;
    }
    yield chunk.substring(startIndex, result.index);
    startIndex = newline.lastIndex;
  }

  if (startIndex < chunk.length) {
    // Last line didn't end in a newline char
    yield chunk.substring(startIndex);
  }
}

async function run(urlOfFile) {
  for await (const line of makeTextFileLineIterator(urlOfFile)) {
    processLine(line);
  }
}

function processLine(line) {
  console.log(line);
}

run("https://www.example.org/a-large-file.txt");
Locked and disturbed streamsThe consequences of request and response bodies being streams are that:

if a reader has been attached to a stream using ReadableStream.getReader(), then the stream is locked, and nothing else can read the stream.
if any content has been read from the stream, then the stream is disturbed, and nothing else can read from the stream.

This means it's not possible to read the same response (or request) body more than once:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const json1 = await response.json();
    const json2 = await response.json(); // will throw
  } catch (error) {
    console.error(error.message);
  }
}

If you do need to read the body more than once, you must call Response.clone() before reading the body:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response1 = await fetch(url);
    if (!response1.ok) {
      throw new Error(`Response status: ${response1.status}`);
    }

    const response2 = response1.clone();

    const json1 = await response1.json();
    const json2 = await response2.json();
  } catch (error) {
    console.error(error.message);
  }
}

This is a common pattern when implementing an offline cache with service workers. The service worker wants to return the response to the app, but also to cache the response. So it clones the response, returns the original, and caches the clone:
jsasync function cacheFirst(request) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open("MyCache_1");
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    return Response.error();
  }
}

self.addEventListener("fetch", (event) => {
  if (precachedResources.includes(url.pathname)) {
    event.respondWith(cacheFirst(event.request));
  }
});
See also
Service Worker API
Streams API
CORS
HTTP
Fetch examples on GitHub
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nUsing the Fetch APIThe Fetch API provides a JavaScript interface for making HTTP requests and processing the responses.
Fetch is the modern replacement for XMLHttpRequest: unlike XMLHttpRequest, which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS).
With the Fetch API, you make a request by calling fetch(), which is available as a global function in both window and worker contexts. You pass it a Request object or a string containing the URL to fetch, along with an optional argument to configure the request.
The fetch() function returns a Promise which is fulfilled with a Response object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response.
Here's a minimal function that uses fetch() to retrieve some JSON data from a server:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const json = await response.json();
    console.log(json);
  } catch (error) {
    console.error(error.message);
  }
}

We declare a string containing the URL and then call fetch(), passing the URL with no extra options.
The fetch() function will reject the promise on some errors, but not if the server responds with an error status like 404: so we also check the response status and throw if it is not OK.
Otherwise, we fetch the response body content as JSON by calling the json() method of Response, and log one of its values. Note that like fetch() itself, json() is asynchronous, as are all the other methods to access the response body content.
In the rest of this page we'll look in more detail at the different stages of this process.Making a requestTo make a request, call fetch(), passing in:

a definition of the resource to fetch. This can be any one of:

a string containing the URL
an object, such as an instance of URL, which has a stringifier that produces a string containing the URL
a Request instance


optionally, an object containing options to configure the request.

In this section we'll look at some of the most commonly-used options. To read about all the options that can be given, see the fetch() reference page.Setting the methodBy default, fetch() makes a GET request, but you can use the method option to use a different request method:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  // ...
});

If the mode option is set to no-cors, then method must be one of GET, POST or HEAD.Setting a bodyThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with GET requests, but it's useful for requests that send content to the server, such as POST or PUT requests. For example, if you want to upload a file to the server, you might make a POST request and include the file as the request body.
To set a request body, pass it as the body option:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  // ...
});

You can supply the body as an instance of any of the following types:

a string
ArrayBuffer
TypedArray
DataView
Blob
File
URLSearchParams
FormData
ReadableStream

Other objects are converted to strings using their toString() method. For example, you can use a URLSearchParams object to encode form data (see setting headers for more information):
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/x-www-form-urlencoded",
  },
  // Automatically converted to "username=example&password=password"
  body: new URLSearchParams({ username: "example", password: "password" }),
  // ...
});

Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice:
jsconst request = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
});

const response1 = await fetch(request);
console.log(response1.status);

// Will throw: "Body has already been consumed."
const response2 = await fetch(request);
console.log(response2.status);

Instead, you would need to create a clone of the request before sending it:
jsconst request1 = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
});

const request2 = request1.clone();

const response1 = await fetch(request1);
console.log(response1.status);

const response2 = await fetch(request2);
console.log(response2.status);

See Locked and disturbed streams for more information.Setting headersRequest headers give the server information about the request: for example, in a POST request, the Content-Type header tells the server the format of the request's body.
To set request headers, assign them to the headers option.
You can pass an object literal here containing header-name: header-value properties:
jsconst response = await fetch("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ username: "example" }),
  // ...
});

Alternatively, you can construct a Headers object, add headers to that object using Headers.append(), then assign the Headers object to the headers option:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const response = await fetch("https://example.org/post", {
  method: "POST",
  headers: myHeaders,
  body: JSON.stringify({ username: "example" }),
  // ...
});

Compared to using plain objects, the Headers object provides some additional input sanitization. For example, it normalizes header names to lowercase, strips leading and trailing whitespace from header values, and prevents certain headers from being set. Many headers are set automatically by the browser and can't be set by a script: these are called Forbidden request headers. If the mode option is set to no-cors, then the set of permitted headers is further restricted.Sending data in a GET requestGET requests don't have a body, but you can still send data to the server by appending it to the URL as a query string. This is a common way to send form data to the server. You can do this by using URLSearchParams to encode the data, and then appending it to the URL:
jsconst params = new URLSearchParams();
params.append("username", "example");

// GET request sent to https://example.org/login?username=example
const response = await fetch(`https://example.org/login?${params}`);
Making cross-origin requestsWhether a request can be made cross-origin or not is determined by the value of the RequestInit.mode option. This may take one of three values: cors, same-origin, or no-cors.


For fetch requests the default value of mode is cors, meaning that if the request is cross-origin then it will use the Cross-Origin Resource Sharing (CORS) mechanism. This means that:

if the request is a simple request, then the request will always be sent, but the server must respond with the correct Access-Control-Allow-Origin header or the browser will not share the response with the caller.
if the request is not a simple request, then the browser will send a preflighted request to check that the server understands CORS and allows the request, and the real request will not be sent unless the server responds to the preflighted request with the appropriate CORS headers.



Setting mode to same-origin disallows cross-origin requests completely.


Setting mode to no-cors disables CORS for cross-origin requests. This restricts the headers that may be set, and restricts methods to GET, HEAD, and POST. The response is opaque, meaning that its headers and body are not available to JavaScript. Most of the time a website should not use no-cors: the main application of it is for certain service worker use cases.


See the reference documentation for RequestInit.mode for more details.Including credentialsCredentials are cookies, TLS client certificates, or authentication headers containing a username and password.
To control whether or not the browser sends credentials, as well as whether the browser respects any Set-Cookie response headers, set the credentials option, which can take one of the following three values:

omit: never send credentials in the request or include credentials in the response.
same-origin (the default): only send and include credentials for same-origin requests.
include: always include credentials, even cross-origin.

Note that if a cookie's SameSite attribute is set to Strict or Lax, then the cookie will not be sent cross-site, even if credentials is set to include.
Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if credentials is set to include, the server must also agree to their inclusion by including the Access-Control-Allow-Credentials header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the Access-Control-Allow-Origin response header (that is, * is not allowed).
This means that if credentials is set to include and the request is cross-origin, then:


If the request is a simple request, then the request will be sent with credentials, but the server must set the Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.


If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.

Creating a Request objectThe Request() constructor takes the same arguments as fetch() itself. This means that instead of passing options into fetch(), you can pass the same options to the Request() constructor, and then pass that object to fetch().
For example, we can make a POST request by passing options into fetch() using code like this:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const response = await fetch("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  headers: myHeaders,
});

However, we could rewrite this to pass the same arguments to the Request() constructor:
jsconst myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");

const myRequest = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" }),
  headers: myHeaders,
});

const response = await fetch(myRequest);

This also means that you can create a request from another request, while changing some of its properties using the second argument:
jsasync function post(request) {
  try {
    const response = await fetch(request);
    const result = await response.json();
    console.log("Success:", result);
  } catch (error) {
    console.error("Error:", error);
  }
}

const request1 = new Request("https://example.org/post", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ username: "example1" }),
});

const request2 = new Request(request1, {
  body: JSON.stringify({ username: "example2" }),
});

post(request1);
post(request2);
Canceling a requestTo make a request cancelable, create an AbortController, and assign its AbortSignal to the request's signal property.
To cancel the request, call the controller's abort() method. The fetch() call will reject the promise with an AbortError exception.
jsconst controller = new AbortController();

const fetchButton = document.querySelector("#fetch");
fetchButton.addEventListener("click", async () => {
  try {
    console.log("Starting fetch");
    const response = await fetch("https://example.org/get", {
      signal: controller.signal,
    });
    console.log(`Response: ${response.status}`);
  } catch (e) {
    console.error(`Error: ${e}`);
  }
});

const cancelButton = document.querySelector("#cancel");
cancelButton.addEventListener("click", () => {
  controller.abort();
  console.log("Canceled fetch");
});

If the request is aborted after the fetch() call has been fulfilled but before the response body has been read, then attempting to read the response body will reject with an AbortError exception.
jsasync function get() {
  const controller = new AbortController();
  const request = new Request("https://example.org/get", {
    signal: controller.signal,
  });

  const response = await fetch(request);
  controller.abort();
  // The next line will throw `AbortError`
  const text = await response.text();
  console.log(text);
}
Handling the responseAs soon as the browser has received the response status and headers from the server (and potentially before the response body itself has been received), the promise returned by fetch() is fulfilled with a Response object.Checking response statusThe promise returned by fetch() will reject on some errors, such as a network error or a bad scheme. However, if the server responds with an error like 404, then fetch() fulfills with a Response, so we have to check the status before we can read the response body.
The Response.status property tells us the numerical status code, and the Response.ok property returns true if the status is in the 200 range.
A common pattern is to check the value of ok and throw if it is false:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }
    // ...
  } catch (error) {
    console.error(error.message);
  }
}
Checking the response typeResponses have a type property that can be one of the following:

basic: the request was a same-origin request.
cors: the request was a cross-origin CORS request.
opaque: the request was a cross-origin simple request made with the no-cors mode.
opaqueredirect: the request set the redirect option to manual, and the server returned a redirect status.

The type determines the possible contents of the response, as follows:


Basic responses exclude response headers from the Forbidden response header name list.


CORS responses include only response headers from the CORS-safelisted response header list.


Opaque responses and opaque redirect responses have a status of 0, an empty header list, and a null body.

Checking headersJust like the request, the response has a headers property which is a Headers object, and this contains any response headers that are exposed to scripts, subject to the exclusions made based on the response type.
A common use case for this is to check the content type before trying to read the body:
jsasync function fetchJSON(request) {
  try {
    const response = await fetch(request);
    const contentType = response.headers.get("content-type");
    if (!contentType || !contentType.includes("application/json")) {
      throw new TypeError("Oops, we haven't got JSON!");
    }
    // Otherwise, we can read the body as JSON
  } catch (error) {
    console.error("Error:", error);
  }
}
Reading the response bodyThe Response interface provides a number of methods to retrieve the entire body contents in a variety of different formats:

Response.arrayBuffer()
Response.blob()
Response.formData()
Response.json()
Response.text()

These are all asynchronous methods, returning a Promise which will be fulfilled with the body content.
In this example, we fetch an image and read it as a Blob, which we can then use to create an object URL:
jsconst image = document.querySelector("img");

const url = "flowers.jpg";

async function setImage() {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }
    const blob = await response.blob();
    const objectURL = URL.createObjectURL(blob);
    image.src = objectURL;
  } catch (e) {
    console.error(e);
  }
}

The method will throw an exception if the response body is not in the appropriate format: for example, if you call json() on a response that can't be parsed as JSON.Streaming the response bodyRequest and response bodies are actually ReadableStream objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like json().
This also means that the caller can process the content incrementally as it is received.
For example, consider a GET request that fetches a large text file and processes it in some way, or displays it to the user:
jsconst url = "https://www.example.org/a-large-file.txt";

async function fetchText(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const text = await response.text();
    console.log(text);
  } catch (e) {
    console.error(e);
  }
}

If we use Response.text(), as above, we must wait until the whole file has been received before we can process any of it.
If we stream the response instead, we can process chunks of the body as they are received from the network:
jsconst url = "https://www.example.org/a-large-file.txt";

async function fetchTextAsStream(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const stream = response.body.pipeThrough(new TextDecoderStream());
    for await (const value of stream) {
      console.log(value);
    }
  } catch (e) {
    console.error(e);
  }
}

In this example, we iterate asynchronously over the stream, processing each chunk as it arrives.
Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call ReadableStream.pipeThrough() to pipe the response through a TextDecoderStream, which decodes the UTF-8-encoded body data as text.Processing a text file line by lineIn the example below, we fetch a text resource and process it line by line, using a regular expression to look for line endings. For simplicity, we assume the text is UTF-8, and don't handle fetch errors:
jsasync function* makeTextFileLineIterator(fileURL) {
  const response = await fetch(fileURL);
  const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();

  let { value: chunk, done: readerDone } = await reader.read();
  chunk = chunk || "";

  const newline = /\r?\n/gm;
  let startIndex = 0;

  while (true) {
    const result = newline.exec(chunk);
    if (!result) {
      if (readerDone) break;
      const remainder = chunk.substr(startIndex);
      ({ value: chunk, done: readerDone } = await reader.read());
      chunk = remainder + (chunk || "");
      startIndex = newline.lastIndex = 0;
      continue;
    }
    yield chunk.substring(startIndex, result.index);
    startIndex = newline.lastIndex;
  }

  if (startIndex < chunk.length) {
    // Last line didn't end in a newline char
    yield chunk.substring(startIndex);
  }
}

async function run(urlOfFile) {
  for await (const line of makeTextFileLineIterator(urlOfFile)) {
    processLine(line);
  }
}

function processLine(line) {
  console.log(line);
}

run("https://www.example.org/a-large-file.txt");
Locked and disturbed streamsThe consequences of request and response bodies being streams are that:

if a reader has been attached to a stream using ReadableStream.getReader(), then the stream is locked, and nothing else can read the stream.
if any content has been read from the stream, then the stream is disturbed, and nothing else can read from the stream.

This means it's not possible to read the same response (or request) body more than once:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Response status: ${response.status}`);
    }

    const json1 = await response.json();
    const json2 = await response.json(); // will throw
  } catch (error) {
    console.error(error.message);
  }
}

If you do need to read the body more than once, you must call Response.clone() before reading the body:
jsasync function getData() {
  const url = "https://example.org/products.json";
  try {
    const response1 = await fetch(url);
    if (!response1.ok) {
      throw new Error(`Response status: ${response1.status}`);
    }

    const response2 = response1.clone();

    const json1 = await response1.json();
    const json2 = await response2.json();
  } catch (error) {
    console.error(error.message);
  }
}

This is a common pattern when implementing an offline cache with service workers. The service worker wants to return the response to the app, but also to cache the response. So it clones the response, returns the original, and caches the clone:
jsasync function cacheFirst(request) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open("MyCache_1");
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    return Response.error();
  }
}

self.addEventListener("fetch", (event) => {
  if (precachedResources.includes(url.pathname)) {
    event.respondWith(cacheFirst(event.request));
  }
});
See also
Service Worker API
Streams API
CORS
HTTP
Fetch examples on GitHub
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 20, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHeadersBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Headers interface of the Fetch API allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing headers from the list of the request's headers.
You can retrieve a Headers object via the Request.headers and Response.headers properties, and create a new Headers object using the Headers() constructor. Compared to using plain objects, using Headers objects to send requests provides some additional input sanitization. For example, it normalizes header names to lowercase, strips leading and trailing whitespace from header values, and prevents certain headers from being set.

Note:
You can find out more about the available headers by reading our HTTP headers reference.
DescriptionA Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs. You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.
An object implementing Headers can directly be used in a for...of structure, instead of entries(): for (const p of myHeaders) is equivalent to for (const p of myHeaders.entries()).Modification restrictionsSome Headers objects have restrictions on whether the set(), delete(), and append() methods can mutate the header. The modification restrictions are set depending on how the Headers object is created.

For headers created with Headers() constructor, there are no modification restrictions.
For headers of Request objects:

If the request's mode is no-cors, you can modify any CORS-safelisted request header name/value.
Otherwise, you can modify any non-forbidden request header name/value.


For headers of Response objects:

If the response is created using Response.error() or Response.redirect(), or received from a fetch() call, the headers are immutable and cannot be modified.
Otherwise, if the response is created using Response() or Response.json(), you can modify any non-forbidden response header name/value.



All of the Headers methods will throw a TypeError if you try to pass in a reference to a name that isn't a valid HTTP Header name. The mutation operations will throw a TypeError if the header is immutable. In any other failure case they fail silently.Constructor
Headers()

Creates a new Headers object.

Instance methods
Headers.append()

Appends a new value onto an existing header inside a Headers object, or adds the header if it does not already exist.

Headers.delete()

Deletes a header from a Headers object.

Headers.entries()

Returns an iterator allowing to go through all key/value pairs contained in this object.

Headers.forEach()

Executes a provided function once for each key/value pair in this Headers object.

Headers.get()

Returns a String sequence of all the values of a header within a Headers object with a given name.

Headers.getSetCookie()

Returns an array containing the values of all Set-Cookie headers associated with a response.

Headers.has()

Returns a boolean stating whether a Headers object contains a certain header.

Headers.keys()

Returns an iterator allowing you to go through all keys of the key/value pairs contained in this object.

Headers.set()

Sets a new value for an existing header inside a Headers object, or adds the header if it does not already exist.

Headers.values()

Returns an iterator allowing you to go through all values of the key/value pairs contained in this object.



Note:
To be clear, the difference between Headers.set() and Headers.append() is that if the specified header does already exist and does accept multiple values, Headers.set() will overwrite the existing value with the new one, whereas Headers.append() will append the new value onto the end of the set of values. See their dedicated pages for example code.


Note:
When Header values are iterated over, they are automatically sorted in lexicographical order, and values from duplicate header names are combined.
ExamplesIn the following snippet, we create a new header using the Headers() constructor, add a new header to it using append(), then return that header value using get():
jsconst myHeaders = new Headers();

myHeaders.append("Content-Type", "text/xml");
myHeaders.get("Content-Type"); // should return 'text/xml'

The same can be achieved by passing an array of arrays or an object literal to the constructor:
jslet myHeaders = new Headers({
  "Content-Type": "text/xml",
});

// or, using an array of arrays:
myHeaders = new Headers([["Content-Type", "text/xml"]]);

myHeaders.get("Content-Type"); // should return 'text/xml'
SpecificationsSpecificationFetch # headers-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nHeadersBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Headers interface of the Fetch API allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing headers from the list of the request's headers.
You can retrieve a Headers object via the Request.headers and Response.headers properties, and create a new Headers object using the Headers() constructor. Compared to using plain objects, using Headers objects to send requests provides some additional input sanitization. For example, it normalizes header names to lowercase, strips leading and trailing whitespace from header values, and prevents certain headers from being set.

Note:
You can find out more about the available headers by reading our HTTP headers reference.
DescriptionA Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs. You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.
An object implementing Headers can directly be used in a for...of structure, instead of entries(): for (const p of myHeaders) is equivalent to for (const p of myHeaders.entries()).Modification restrictionsSome Headers objects have restrictions on whether the set(), delete(), and append() methods can mutate the header. The modification restrictions are set depending on how the Headers object is created.

For headers created with Headers() constructor, there are no modification restrictions.
For headers of Request objects:

If the request's mode is no-cors, you can modify any CORS-safelisted request header name/value.
Otherwise, you can modify any non-forbidden request header name/value.


For headers of Response objects:

If the response is created using Response.error() or Response.redirect(), or received from a fetch() call, the headers are immutable and cannot be modified.
Otherwise, if the response is created using Response() or Response.json(), you can modify any non-forbidden response header name/value.



All of the Headers methods will throw a TypeError if you try to pass in a reference to a name that isn't a valid HTTP Header name. The mutation operations will throw a TypeError if the header is immutable. In any other failure case they fail silently.Constructor
Headers()

Creates a new Headers object.

Instance methods
Headers.append()

Appends a new value onto an existing header inside a Headers object, or adds the header if it does not already exist.

Headers.delete()

Deletes a header from a Headers object.

Headers.entries()

Returns an iterator allowing to go through all key/value pairs contained in this object.

Headers.forEach()

Executes a provided function once for each key/value pair in this Headers object.

Headers.get()

Returns a String sequence of all the values of a header within a Headers object with a given name.

Headers.getSetCookie()

Returns an array containing the values of all Set-Cookie headers associated with a response.

Headers.has()

Returns a boolean stating whether a Headers object contains a certain header.

Headers.keys()

Returns an iterator allowing you to go through all keys of the key/value pairs contained in this object.

Headers.set()

Sets a new value for an existing header inside a Headers object, or adds the header if it does not already exist.

Headers.values()

Returns an iterator allowing you to go through all values of the key/value pairs contained in this object.



Note:
To be clear, the difference between Headers.set() and Headers.append() is that if the specified header does already exist and does accept multiple values, Headers.set() will overwrite the existing value with the new one, whereas Headers.append() will append the new value onto the end of the set of values. See their dedicated pages for example code.


Note:
When Header values are iterated over, they are automatically sorted in lexicographical order, and values from duplicate header names are combined.
ExamplesIn the following snippet, we create a new header using the Headers() constructor, add a new header to it using append(), then return that header value using get():
jsconst myHeaders = new Headers();

myHeaders.append("Content-Type", "text/xml");
myHeaders.get("Content-Type"); // should return 'text/xml'

The same can be achieved by passing an array of arrays or an object literal to the constructor:
jslet myHeaders = new Headers({
  "Content-Type": "text/xml",
});

// or, using an array of arrays:
myHeaders = new Headers([["Content-Type", "text/xml"]]);

myHeaders.get("Content-Type"); // should return 'text/xml'
SpecificationsSpecificationFetch # headers-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHeadersBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers.
The Headers interface of the Fetch API allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing headers from the list of the request's headers.
You can retrieve a Headers object via the Request.headers and Response.headers properties, and create a new Headers object using the Headers() constructor. Compared to using plain objects, using Headers objects to send requests provides some additional input sanitization. For example, it normalizes header names to lowercase, strips leading and trailing whitespace from header values, and prevents certain headers from being set.

Note:
You can find out more about the available headers by reading our HTTP headers reference.
DescriptionA Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs. You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.
An object implementing Headers can directly be used in a for...of structure, instead of entries(): for (const p of myHeaders) is equivalent to for (const p of myHeaders.entries()).Modification restrictionsSome Headers objects have restrictions on whether the set(), delete(), and append() methods can mutate the header. The modification restrictions are set depending on how the Headers object is created.

For headers created with Headers() constructor, there are no modification restrictions.
For headers of Request objects:

If the request's mode is no-cors, you can modify any CORS-safelisted request header name/value.
Otherwise, you can modify any non-forbidden request header name/value.


For headers of Response objects:

If the response is created using Response.error() or Response.redirect(), or received from a fetch() call, the headers are immutable and cannot be modified.
Otherwise, if the response is created using Response() or Response.json(), you can modify any non-forbidden response header name/value.



All of the Headers methods will throw a TypeError if you try to pass in a reference to a name that isn't a valid HTTP Header name. The mutation operations will throw a TypeError if the header is immutable. In any other failure case they fail silently.Constructor
Headers()

Creates a new Headers object.

Instance methods
Headers.append()

Appends a new value onto an existing header inside a Headers object, or adds the header if it does not already exist.

Headers.delete()

Deletes a header from a Headers object.

Headers.entries()

Returns an iterator allowing to go through all key/value pairs contained in this object.

Headers.forEach()

Executes a provided function once for each key/value pair in this Headers object.

Headers.get()

Returns a String sequence of all the values of a header within a Headers object with a given name.

Headers.getSetCookie()

Returns an array containing the values of all Set-Cookie headers associated with a response.

Headers.has()

Returns a boolean stating whether a Headers object contains a certain header.

Headers.keys()

Returns an iterator allowing you to go through all keys of the key/value pairs contained in this object.

Headers.set()

Sets a new value for an existing header inside a Headers object, or adds the header if it does not already exist.

Headers.values()

Returns an iterator allowing you to go through all values of the key/value pairs contained in this object.



Note:
To be clear, the difference between Headers.set() and Headers.append() is that if the specified header does already exist and does accept multiple values, Headers.set() will overwrite the existing value with the new one, whereas Headers.append() will append the new value onto the end of the set of values. See their dedicated pages for example code.


Note:
When Header values are iterated over, they are automatically sorted in lexicographical order, and values from duplicate header names are combined.
ExamplesIn the following snippet, we create a new header using the Headers() constructor, add a new header to it using append(), then return that header value using get():
jsconst myHeaders = new Headers();

myHeaders.append("Content-Type", "text/xml");
myHeaders.get("Content-Type"); // should return 'text/xml'

The same can be achieved by passing an array of arrays or an object literal to the constructor:
jslet myHeaders = new Headers({
  "Content-Type": "text/xml",
});

// or, using an array of arrays:
myHeaders = new Headers([["Content-Type", "text/xml"]]);

myHeaders.get("Content-Type"); // should return 'text/xml'
SpecificationsSpecificationFetch # headers-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nRequestBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Request interface of the Fetch API represents a resource request.
You can create a new Request object using the Request() constructor, but you are more likely to encounter a Request object being returned as the result of another API operation, such as a service worker FetchEvent.request.Constructor
Request()

Creates a new Request object.

Instance properties
Request.body Read only

A ReadableStream of the body contents.

Request.bodyUsed Read only

Stores true or false to indicate whether or not the body has been used in a request yet.

Request.cache Read only

Contains the cache mode of the request (e.g., default, reload, no-cache).

Request.credentials Read only

Contains the credentials of the request (e.g., omit, same-origin, include). The default is same-origin.

Request.destination Read only

A string describing the type of content being requested.

Request.headers Read only

Contains the associated Headers object of the request.

Request.integrity Read only

Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).

Request.isHistoryNavigation Read only

A boolean indicating whether the request is a history navigation.

Request.keepalive Read only

Contains the request's keepalive setting (true or false), which indicates whether the browser will keep the associated request alive if the page that initiated it is unloaded before the request is complete.

Request.method Read only

Contains the request's method (GET, POST, etc.)

Request.mode Read only

Contains the mode of the request (e.g., cors, no-cors, same-origin, navigate.)

Request.redirect Read only

Contains the mode for how redirects are handled. It may be one of follow, error, or manual.

Request.referrer Read only

Contains the referrer of the request (e.g., client).

Request.referrerPolicy Read only

Contains the referrer policy of the request (e.g., no-referrer).

Request.signal Read only

Returns the AbortSignal associated with the request

Request.url Read only

Contains the URL of the request.

Instance methods
Request.arrayBuffer()

Returns a promise that resolves with an ArrayBuffer representation of the request body.

Request.blob()

Returns a promise that resolves with a Blob representation of the request body.

Request.bytes()

Returns a promise that resolves with a Uint8Array representation of the request body.

Request.clone()

Creates a copy of the current Request object.

Request.formData()

Returns a promise that resolves with a FormData representation of the request body.

Request.json()

Returns a promise that resolves with the result of parsing the request body as JSON.

Request.text()

Returns a promise that resolves with a text representation of the request body.



Note:
The request body functions can be run only once; subsequent calls will reject with TypeError showing that the body stream has already used.
ExamplesIn the following snippet, we create a new request using the Request() constructor (for an image file in the same directory as the script), then return some property values of the request:
jsconst request = new Request("https://www.mozilla.org/favicon.ico");

const url = request.url;
const method = request.method;
const credentials = request.credentials;

You could then fetch this request by passing the Request object in as a parameter to a fetch() call, for example:
jsfetch(request)
  .then((response) => response.blob())
  .then((blob) => {
    image.src = URL.createObjectURL(blob);
  });

In the following snippet, we create a new request using the Request() constructor with some initial data and body content for an API request which needs a body payload:
jsconst request = new Request("https://example.com", {
  method: "POST",
  body: '{"foo": "bar"}',
});

const url = request.url;
const method = request.method;
const credentials = request.credentials;
const bodyUsed = request.bodyUsed;


Note:
The body can only be a Blob, an ArrayBuffer, a TypedArray, a DataView, a FormData, a URLSearchParams, a ReadableStream, or a String object, as well as a string literal, so for adding a JSON object to the payload you need to stringify that object.

You could then fetch this API request by passing the Request object in as a parameter to a fetch() call, for example and get the response:
jsfetch(request)
  .then((response) => {
    if (response.status === 200) {
      return response.json();
    } else {
      throw new Error("Something went wrong on API server!");
    }
  })
  .then((response) => {
    console.debug(response);
    // …
  })
  .catch((error) => {
    console.error(error);
  });
SpecificationsSpecificationFetch # request-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nRequestBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Request interface of the Fetch API represents a resource request.
You can create a new Request object using the Request() constructor, but you are more likely to encounter a Request object being returned as the result of another API operation, such as a service worker FetchEvent.request.Constructor
Request()

Creates a new Request object.

Instance properties
Request.body Read only

A ReadableStream of the body contents.

Request.bodyUsed Read only

Stores true or false to indicate whether or not the body has been used in a request yet.

Request.cache Read only

Contains the cache mode of the request (e.g., default, reload, no-cache).

Request.credentials Read only

Contains the credentials of the request (e.g., omit, same-origin, include). The default is same-origin.

Request.destination Read only

A string describing the type of content being requested.

Request.headers Read only

Contains the associated Headers object of the request.

Request.integrity Read only

Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).

Request.isHistoryNavigation Read only

A boolean indicating whether the request is a history navigation.

Request.keepalive Read only

Contains the request's keepalive setting (true or false), which indicates whether the browser will keep the associated request alive if the page that initiated it is unloaded before the request is complete.

Request.method Read only

Contains the request's method (GET, POST, etc.)

Request.mode Read only

Contains the mode of the request (e.g., cors, no-cors, same-origin, navigate.)

Request.redirect Read only

Contains the mode for how redirects are handled. It may be one of follow, error, or manual.

Request.referrer Read only

Contains the referrer of the request (e.g., client).

Request.referrerPolicy Read only

Contains the referrer policy of the request (e.g., no-referrer).

Request.signal Read only

Returns the AbortSignal associated with the request

Request.url Read only

Contains the URL of the request.

Instance methods
Request.arrayBuffer()

Returns a promise that resolves with an ArrayBuffer representation of the request body.

Request.blob()

Returns a promise that resolves with a Blob representation of the request body.

Request.bytes()

Returns a promise that resolves with a Uint8Array representation of the request body.

Request.clone()

Creates a copy of the current Request object.

Request.formData()

Returns a promise that resolves with a FormData representation of the request body.

Request.json()

Returns a promise that resolves with the result of parsing the request body as JSON.

Request.text()

Returns a promise that resolves with a text representation of the request body.



Note:
The request body functions can be run only once; subsequent calls will reject with TypeError showing that the body stream has already used.
ExamplesIn the following snippet, we create a new request using the Request() constructor (for an image file in the same directory as the script), then return some property values of the request:
jsconst request = new Request("https://www.mozilla.org/favicon.ico");

const url = request.url;
const method = request.method;
const credentials = request.credentials;

You could then fetch this request by passing the Request object in as a parameter to a fetch() call, for example:
jsfetch(request)
  .then((response) => response.blob())
  .then((blob) => {
    image.src = URL.createObjectURL(blob);
  });

In the following snippet, we create a new request using the Request() constructor with some initial data and body content for an API request which needs a body payload:
jsconst request = new Request("https://example.com", {
  method: "POST",
  body: '{"foo": "bar"}',
});

const url = request.url;
const method = request.method;
const credentials = request.credentials;
const bodyUsed = request.bodyUsed;


Note:
The body can only be a Blob, an ArrayBuffer, a TypedArray, a DataView, a FormData, a URLSearchParams, a ReadableStream, or a String object, as well as a string literal, so for adding a JSON object to the payload you need to stringify that object.

You could then fetch this API request by passing the Request object in as a parameter to a fetch() call, for example and get the response:
jsfetch(request)
  .then((response) => {
    if (response.status === 200) {
      return response.json();
    } else {
      throw new Error("Something went wrong on API server!");
    }
  })
  .then((response) => {
    console.debug(response);
    // …
  })
  .catch((error) => {
    console.error(error);
  });
SpecificationsSpecificationFetch # request-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nRequestBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Request interface of the Fetch API represents a resource request.
You can create a new Request object using the Request() constructor, but you are more likely to encounter a Request object being returned as the result of another API operation, such as a service worker FetchEvent.request.Constructor
Request()

Creates a new Request object.

Instance properties
Request.body Read only

A ReadableStream of the body contents.

Request.bodyUsed Read only

Stores true or false to indicate whether or not the body has been used in a request yet.

Request.cache Read only

Contains the cache mode of the request (e.g., default, reload, no-cache).

Request.credentials Read only

Contains the credentials of the request (e.g., omit, same-origin, include). The default is same-origin.

Request.destination Read only

A string describing the type of content being requested.

Request.headers Read only

Contains the associated Headers object of the request.

Request.integrity Read only

Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).

Request.isHistoryNavigation Read only

A boolean indicating whether the request is a history navigation.

Request.keepalive Read only

Contains the request's keepalive setting (true or false), which indicates whether the browser will keep the associated request alive if the page that initiated it is unloaded before the request is complete.

Request.method Read only

Contains the request's method (GET, POST, etc.)

Request.mode Read only

Contains the mode of the request (e.g., cors, no-cors, same-origin, navigate.)

Request.redirect Read only

Contains the mode for how redirects are handled. It may be one of follow, error, or manual.

Request.referrer Read only

Contains the referrer of the request (e.g., client).

Request.referrerPolicy Read only

Contains the referrer policy of the request (e.g., no-referrer).

Request.signal Read only

Returns the AbortSignal associated with the request

Request.url Read only

Contains the URL of the request.

Instance methods
Request.arrayBuffer()

Returns a promise that resolves with an ArrayBuffer representation of the request body.

Request.blob()

Returns a promise that resolves with a Blob representation of the request body.

Request.bytes()

Returns a promise that resolves with a Uint8Array representation of the request body.

Request.clone()

Creates a copy of the current Request object.

Request.formData()

Returns a promise that resolves with a FormData representation of the request body.

Request.json()

Returns a promise that resolves with the result of parsing the request body as JSON.

Request.text()

Returns a promise that resolves with a text representation of the request body.



Note:
The request body functions can be run only once; subsequent calls will reject with TypeError showing that the body stream has already used.
ExamplesIn the following snippet, we create a new request using the Request() constructor (for an image file in the same directory as the script), then return some property values of the request:
jsconst request = new Request("https://www.mozilla.org/favicon.ico");

const url = request.url;
const method = request.method;
const credentials = request.credentials;

You could then fetch this request by passing the Request object in as a parameter to a fetch() call, for example:
jsfetch(request)
  .then((response) => response.blob())
  .then((blob) => {
    image.src = URL.createObjectURL(blob);
  });

In the following snippet, we create a new request using the Request() constructor with some initial data and body content for an API request which needs a body payload:
jsconst request = new Request("https://example.com", {
  method: "POST",
  body: '{"foo": "bar"}',
});

const url = request.url;
const method = request.method;
const credentials = request.credentials;
const bodyUsed = request.bodyUsed;


Note:
The body can only be a Blob, an ArrayBuffer, a TypedArray, a DataView, a FormData, a URLSearchParams, a ReadableStream, or a String object, as well as a string literal, so for adding a JSON object to the payload you need to stringify that object.

You could then fetch this API request by passing the Request object in as a parameter to a fetch() call, for example and get the response:
jsfetch(request)
  .then((response) => {
    if (response.status === 200) {
      return response.json();
    } else {
      throw new Error("Something went wrong on API server!");
    }
  })
  .then((response) => {
    console.debug(response);
    // …
  })
  .catch((error) => {
    console.error(error);
  });
SpecificationsSpecificationFetch # request-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nRequestInitThe RequestInit dictionary of the Fetch API represents the set of options that can be used to configure a fetch request.
You can pass a RequestInit object into the Request() constructor, or directly into the fetch() function call.
You can also construct a Request with a RequestInit, and pass the Request to a fetch() call along with another RequestInit. If you do this, and the same option is set in both places, then the value passed directly into fetch() is used.Instance properties
attributionReporting Optional 
Experimental


Indicates that you want the request's response to be able to register a JavaScript-based attribution source or attribution trigger. attributionReporting is an object containing the following properties:

eventSourceEligible

A boolean. If set to true, the request's response is eligible to register an attribution source. If set to false, it isn't.

triggerEligible

A boolean. If set to true, the request's response is eligible to register an attribution trigger. If set to false, it isn't.


See the Attribution Reporting API for more details.

body Optional

The request body contains content to send to the server, for example in a POST or PUT request. It is specified as an instance of any of the following types:

a string
ArrayBuffer
Blob
DataView
File
FormData
TypedArray
URLSearchParams
ReadableStream

See Setting a body for more details.

browsingTopics Optional 
Experimental


A boolean specifying that the selected topics for the current user should be sent in a Sec-Browsing-Topics header with the associated request.
See Using the Topics API for more details.

cache Optional

The cache mode you want to use for the request. This may be any one of the following values:

default

The browser looks in its HTTP cache for a response matching the request.

If there is a match and it is fresh, it will be returned from the cache.
If there is a match but it is stale, the browser will make a conditional request to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


no-store

The browser fetches the resource from the remote server without first looking in the cache, and will not update the cache with the downloaded resource.

reload

The browser fetches the resource from the remote server without first looking in the cache, but then will update the cache with the downloaded resource.

no-cache

The browser looks in its HTTP cache for a response matching the request.

If there is a match, fresh or stale, the browser will make a conditional request to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


force-cache

The browser looks in its HTTP cache for a response matching the request.

If there is a match, fresh or stale, it will be returned from the cache.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


only-if-cached

The browser looks in its HTTP cache for a response matching the request. 
Experimental


If there is a match, fresh or stale, it will be returned from the cache.
If there is no match, a network error is returned.



The "only-if-cached" mode can only be used if the request's mode is "same-origin". Cached redirects will be followed if the request's redirect property is "follow" and the redirects do not violate the "same-origin" mode.

credentials Optional

Controls whether or not the browser sends credentials with the request, as well as whether any Set-Cookie response headers are respected. Credentials are cookies, TLS client certificates, or authentication headers containing a username and password. This option may be any one of the following values:

omit

Never send credentials in the request or include credentials in the response.

same-origin

Only send and include credentials for same-origin requests.

include

Always include credentials, even for cross-origin requests.


Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if credentials is set to include, the server must also agree to their inclusion by including the Access-Control-Allow-Credentials in its response. Additionally, in this situation the server must explicitly specify the client's origin in the Access-Control-Allow-Origin response header (that is, * is not allowed).
See Including credentials for more details.
Defaults to same-origin.

headers Optional

Any headers you want to add to your request, contained
within a Headers object or an object literal whose keys are the names of headers and whose values are the header values.
Many headers are set automatically by the browser and can't be set by a script: these are called Forbidden request headers.
If the mode option is set to no-cors, you can only set CORS-safelisted request headers.
See Setting headers for more details.

integrity Optional

Contains the subresource integrity
value of the request.
This will be checked when the resource is fetched, just as it would be when the integrity attribute is set on a <script> element. The browser will compute the hash of the fetched resource using the specified algorithm, and if the result does not match the value specified, the browser will reject the fetch request with a network error.
The format of this option is <hash-algo>-<hash-source> where:

<hash-algo> is one of the following values: sha256, sha384, or sha512
<hash-source> is the Base64-encoding of the result of hashing the resource with the specified hash algorithm.

Defaults to an empty string.

keepalive Optional

A boolean.
When set to true, the browser will not abort the associated request if the page that initiated it is unloaded before the request is complete.
This enables a fetch() request to send analytics at the end of a session even if the user navigates away from or closes the page.
This has some advantages over using Navigator.sendBeacon() for the same purpose.
For example, you can use HTTP methods other than POST, customize request properties, and access the server response via the fetch Promise fulfillment.
It is also available in service workers.
The body size for keepalive requests is limited to 64 kibibytes.
Defaults to false.

method Optional

The request method.
Defaults to GET.

mode Optional

Sets cross-origin behavior for the request. One of the following values:

same-origin

Disallows cross-origin requests. If a same-origin request is sent to a different origin, the result is a network error.

cors

If the request is cross-origin then it will use the Cross-Origin Resource Sharing (CORS) mechanism. Only CORS-safelisted response headers are exposed in the response.

no-cors

Disables CORS for cross-origin requests. This option comes with the following restrictions:

The method may only be one of HEAD, GET or POST.
The headers may only be CORS-safelisted request headers, with the additional restriction that the Range header is also not allowed. This also applies to any headers added by service workers.
The response is opaque, meaning that its headers and body are not available to JavaScript, and its status code is always 0.

The main application for no-cors is for a service worker: although the response to a no-cors request can't be read by JavaScript, it can be cached by a service worker and then used as a response to an intercepted fetch request. Note that in this situation you don't know whether the request succeeded or not, so you should adopt a caching strategy which enables the cached response to be updated from the network (such as cache first with cache refresh).

navigate

Used only by HTML navigation. A navigate request is created only while navigating between documents.


See Making cross-origin requests for more details.
Defaults to cors.

priority Optional

Specifies the priority of the fetch request relative to other requests of the same type. Must be one of the following:

high

A high priority fetch request relative to other requests of the same type.

low

A low priority fetch request relative to other requests of the same type.

auto

No user preference for the fetch priority.
It is used if no value is set or if an invalid value is set.


Defaults to auto.

redirect Optional

Determines the browser's behavior in case the server replies with a redirect status. One of the following values:

follow

Automatically follow redirects.

error

Reject the promise with a network error when a redirect status is returned.

manual

Return a response with almost all fields filtered out, to enable a service worker to store the response and later replay it.


Defaults to follow.

referrer Optional

A string specifying the value to use for the request's Referer header. One of the following:

A same-origin relative or absolute URL

Set the Referer header to the given value. Relative URLs are resolved relative to the URL of the page that made the request.

An empty string

Omit the Referer header.

about:client

Set the Referer header to the default value for the context of the request (for example, the URL of the page that made the request).


Defaults to about:client.

referrerPolicy Optional

A string that sets a policy for the Referer header. The syntax and semantics of this option are exactly the same as for the Referrer-Policy header.

signal Optional

An AbortSignal. If this option is set, the request can be canceled by calling abort() on the corresponding AbortController.

ExamplesPassing options into fetch()In this example we pass the method, body, and headers options directly into the fetch() method call:
jsasync function post() {
  const response = await fetch("https://example.org/post", {
    method: "POST",
    body: JSON.stringify({ username: "example" }),
    headers: {
      "Content-Type": "application/json",
    },
  });

  console.log(response.status);
}
Passing options into the Request() constructorIn this example we create a Request, passing the same set of options into its constructor, and then pass the request into fetch():
jsasync function post() {
  const request = new Request("https://example.org/post", {
    method: "POST",
    body: JSON.stringify({ username: "example" }),
    headers: {
      "Content-Type": "application/json",
    },
  });

  const response = await fetch(request);

  console.log(response.status);
}
Passing options into both Request() and fetch()In this example we create a Request, passing the method, headers, and body options into its constructor. We then pass the request into fetch() along with body and referrer options:
jsasync function post() {
  const request = new Request("https://example.org/post", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ username: "example1" }),
  });

  const response = await fetch(request, {
    body: JSON.stringify({ username: "example2" }),
    referrer: "",
  });

  console.log(response.status);
}

In this case the request will be sent with the following options:

method: "POST"
headers: {"Content-Type": "application/json"}
body: '{"username":"example2"}'
referrer: ""
SpecificationsSpecificationFetch # requestinitSee also
Using Fetch
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nRequestInitThe RequestInit dictionary of the Fetch API represents the set of options that can be used to configure a fetch request.
You can pass a RequestInit object into the Request() constructor, or directly into the fetch() function call.
You can also construct a Request with a RequestInit, and pass the Request to a fetch() call along with another RequestInit. If you do this, and the same option is set in both places, then the value passed directly into fetch() is used.Instance properties
attributionReporting Optional 
Experimental


Indicates that you want the request's response to be able to register a JavaScript-based attribution source or attribution trigger. attributionReporting is an object containing the following properties:

eventSourceEligible

A boolean. If set to true, the request's response is eligible to register an attribution source. If set to false, it isn't.

triggerEligible

A boolean. If set to true, the request's response is eligible to register an attribution trigger. If set to false, it isn't.


See the Attribution Reporting API for more details.

body Optional

The request body contains content to send to the server, for example in a POST or PUT request. It is specified as an instance of any of the following types:

a string
ArrayBuffer
Blob
DataView
File
FormData
TypedArray
URLSearchParams
ReadableStream

See Setting a body for more details.

browsingTopics Optional 
Experimental


A boolean specifying that the selected topics for the current user should be sent in a Sec-Browsing-Topics header with the associated request.
See Using the Topics API for more details.

cache Optional

The cache mode you want to use for the request. This may be any one of the following values:

default

The browser looks in its HTTP cache for a response matching the request.

If there is a match and it is fresh, it will be returned from the cache.
If there is a match but it is stale, the browser will make a conditional request to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


no-store

The browser fetches the resource from the remote server without first looking in the cache, and will not update the cache with the downloaded resource.

reload

The browser fetches the resource from the remote server without first looking in the cache, but then will update the cache with the downloaded resource.

no-cache

The browser looks in its HTTP cache for a response matching the request.

If there is a match, fresh or stale, the browser will make a conditional request to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


force-cache

The browser looks in its HTTP cache for a response matching the request.

If there is a match, fresh or stale, it will be returned from the cache.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


only-if-cached

The browser looks in its HTTP cache for a response matching the request. 
Experimental


If there is a match, fresh or stale, it will be returned from the cache.
If there is no match, a network error is returned.



The "only-if-cached" mode can only be used if the request's mode is "same-origin". Cached redirects will be followed if the request's redirect property is "follow" and the redirects do not violate the "same-origin" mode.

credentials Optional

Controls whether or not the browser sends credentials with the request, as well as whether any Set-Cookie response headers are respected. Credentials are cookies, TLS client certificates, or authentication headers containing a username and password. This option may be any one of the following values:

omit

Never send credentials in the request or include credentials in the response.

same-origin

Only send and include credentials for same-origin requests.

include

Always include credentials, even for cross-origin requests.


Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if credentials is set to include, the server must also agree to their inclusion by including the Access-Control-Allow-Credentials in its response. Additionally, in this situation the server must explicitly specify the client's origin in the Access-Control-Allow-Origin response header (that is, * is not allowed).
See Including credentials for more details.
Defaults to same-origin.

headers Optional

Any headers you want to add to your request, contained
within a Headers object or an object literal whose keys are the names of headers and whose values are the header values.
Many headers are set automatically by the browser and can't be set by a script: these are called Forbidden request headers.
If the mode option is set to no-cors, you can only set CORS-safelisted request headers.
See Setting headers for more details.

integrity Optional

Contains the subresource integrity
value of the request.
This will be checked when the resource is fetched, just as it would be when the integrity attribute is set on a <script> element. The browser will compute the hash of the fetched resource using the specified algorithm, and if the result does not match the value specified, the browser will reject the fetch request with a network error.
The format of this option is <hash-algo>-<hash-source> where:

<hash-algo> is one of the following values: sha256, sha384, or sha512
<hash-source> is the Base64-encoding of the result of hashing the resource with the specified hash algorithm.

Defaults to an empty string.

keepalive Optional

A boolean.
When set to true, the browser will not abort the associated request if the page that initiated it is unloaded before the request is complete.
This enables a fetch() request to send analytics at the end of a session even if the user navigates away from or closes the page.
This has some advantages over using Navigator.sendBeacon() for the same purpose.
For example, you can use HTTP methods other than POST, customize request properties, and access the server response via the fetch Promise fulfillment.
It is also available in service workers.
The body size for keepalive requests is limited to 64 kibibytes.
Defaults to false.

method Optional

The request method.
Defaults to GET.

mode Optional

Sets cross-origin behavior for the request. One of the following values:

same-origin

Disallows cross-origin requests. If a same-origin request is sent to a different origin, the result is a network error.

cors

If the request is cross-origin then it will use the Cross-Origin Resource Sharing (CORS) mechanism. Only CORS-safelisted response headers are exposed in the response.

no-cors

Disables CORS for cross-origin requests. This option comes with the following restrictions:

The method may only be one of HEAD, GET or POST.
The headers may only be CORS-safelisted request headers, with the additional restriction that the Range header is also not allowed. This also applies to any headers added by service workers.
The response is opaque, meaning that its headers and body are not available to JavaScript, and its status code is always 0.

The main application for no-cors is for a service worker: although the response to a no-cors request can't be read by JavaScript, it can be cached by a service worker and then used as a response to an intercepted fetch request. Note that in this situation you don't know whether the request succeeded or not, so you should adopt a caching strategy which enables the cached response to be updated from the network (such as cache first with cache refresh).

navigate

Used only by HTML navigation. A navigate request is created only while navigating between documents.


See Making cross-origin requests for more details.
Defaults to cors.

priority Optional

Specifies the priority of the fetch request relative to other requests of the same type. Must be one of the following:

high

A high priority fetch request relative to other requests of the same type.

low

A low priority fetch request relative to other requests of the same type.

auto

No user preference for the fetch priority.
It is used if no value is set or if an invalid value is set.


Defaults to auto.

redirect Optional

Determines the browser's behavior in case the server replies with a redirect status. One of the following values:

follow

Automatically follow redirects.

error

Reject the promise with a network error when a redirect status is returned.

manual

Return a response with almost all fields filtered out, to enable a service worker to store the response and later replay it.


Defaults to follow.

referrer Optional

A string specifying the value to use for the request's Referer header. One of the following:

A same-origin relative or absolute URL

Set the Referer header to the given value. Relative URLs are resolved relative to the URL of the page that made the request.

An empty string

Omit the Referer header.

about:client

Set the Referer header to the default value for the context of the request (for example, the URL of the page that made the request).


Defaults to about:client.

referrerPolicy Optional

A string that sets a policy for the Referer header. The syntax and semantics of this option are exactly the same as for the Referrer-Policy header.

signal Optional

An AbortSignal. If this option is set, the request can be canceled by calling abort() on the corresponding AbortController.

ExamplesPassing options into fetch()In this example we pass the method, body, and headers options directly into the fetch() method call:
jsasync function post() {
  const response = await fetch("https://example.org/post", {
    method: "POST",
    body: JSON.stringify({ username: "example" }),
    headers: {
      "Content-Type": "application/json",
    },
  });

  console.log(response.status);
}
Passing options into the Request() constructorIn this example we create a Request, passing the same set of options into its constructor, and then pass the request into fetch():
jsasync function post() {
  const request = new Request("https://example.org/post", {
    method: "POST",
    body: JSON.stringify({ username: "example" }),
    headers: {
      "Content-Type": "application/json",
    },
  });

  const response = await fetch(request);

  console.log(response.status);
}
Passing options into both Request() and fetch()In this example we create a Request, passing the method, headers, and body options into its constructor. We then pass the request into fetch() along with body and referrer options:
jsasync function post() {
  const request = new Request("https://example.org/post", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ username: "example1" }),
  });

  const response = await fetch(request, {
    body: JSON.stringify({ username: "example2" }),
    referrer: "",
  });

  console.log(response.status);
}

In this case the request will be sent with the following options:

method: "POST"
headers: {"Content-Type": "application/json"}
body: '{"username":"example2"}'
referrer: ""
SpecificationsSpecificationFetch # requestinitSee also
Using Fetch
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nRequestInitThe RequestInit dictionary of the Fetch API represents the set of options that can be used to configure a fetch request.
You can pass a RequestInit object into the Request() constructor, or directly into the fetch() function call.
You can also construct a Request with a RequestInit, and pass the Request to a fetch() call along with another RequestInit. If you do this, and the same option is set in both places, then the value passed directly into fetch() is used.Instance properties
attributionReporting Optional 
Experimental


Indicates that you want the request's response to be able to register a JavaScript-based attribution source or attribution trigger. attributionReporting is an object containing the following properties:

eventSourceEligible

A boolean. If set to true, the request's response is eligible to register an attribution source. If set to false, it isn't.

triggerEligible

A boolean. If set to true, the request's response is eligible to register an attribution trigger. If set to false, it isn't.


See the Attribution Reporting API for more details.

body Optional

The request body contains content to send to the server, for example in a POST or PUT request. It is specified as an instance of any of the following types:

a string
ArrayBuffer
Blob
DataView
File
FormData
TypedArray
URLSearchParams
ReadableStream

See Setting a body for more details.

browsingTopics Optional 
Experimental


A boolean specifying that the selected topics for the current user should be sent in a Sec-Browsing-Topics header with the associated request.
See Using the Topics API for more details.

cache Optional

The cache mode you want to use for the request. This may be any one of the following values:

default

The browser looks in its HTTP cache for a response matching the request.

If there is a match and it is fresh, it will be returned from the cache.
If there is a match but it is stale, the browser will make a conditional request to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


no-store

The browser fetches the resource from the remote server without first looking in the cache, and will not update the cache with the downloaded resource.

reload

The browser fetches the resource from the remote server without first looking in the cache, but then will update the cache with the downloaded resource.

no-cache

The browser looks in its HTTP cache for a response matching the request.

If there is a match, fresh or stale, the browser will make a conditional request to the remote server. If the server indicates that the resource has not changed, it will be returned from the cache. Otherwise the resource will be downloaded from the server and the cache will be updated.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


force-cache

The browser looks in its HTTP cache for a response matching the request.

If there is a match, fresh or stale, it will be returned from the cache.
If there is no match, the browser will make a normal request, and will update the cache with the downloaded resource.


only-if-cached

The browser looks in its HTTP cache for a response matching the request. 
Experimental


If there is a match, fresh or stale, it will be returned from the cache.
If there is no match, a network error is returned.



The "only-if-cached" mode can only be used if the request's mode is "same-origin". Cached redirects will be followed if the request's redirect property is "follow" and the redirects do not violate the "same-origin" mode.

credentials Optional

Controls whether or not the browser sends credentials with the request, as well as whether any Set-Cookie response headers are respected. Credentials are cookies, TLS client certificates, or authentication headers containing a username and password. This option may be any one of the following values:

omit

Never send credentials in the request or include credentials in the response.

same-origin

Only send and include credentials for same-origin requests.

include

Always include credentials, even for cross-origin requests.


Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if credentials is set to include, the server must also agree to their inclusion by including the Access-Control-Allow-Credentials in its response. Additionally, in this situation the server must explicitly specify the client's origin in the Access-Control-Allow-Origin response header (that is, * is not allowed).
See Including credentials for more details.
Defaults to same-origin.

headers Optional

Any headers you want to add to your request, contained
within a Headers object or an object literal whose keys are the names of headers and whose values are the header values.
Many headers are set automatically by the browser and can't be set by a script: these are called Forbidden request headers.
If the mode option is set to no-cors, you can only set CORS-safelisted request headers.
See Setting headers for more details.

integrity Optional

Contains the subresource integrity
value of the request.
This will be checked when the resource is fetched, just as it would be when the integrity attribute is set on a <script> element. The browser will compute the hash of the fetched resource using the specified algorithm, and if the result does not match the value specified, the browser will reject the fetch request with a network error.
The format of this option is <hash-algo>-<hash-source> where:

<hash-algo> is one of the following values: sha256, sha384, or sha512
<hash-source> is the Base64-encoding of the result of hashing the resource with the specified hash algorithm.

Defaults to an empty string.

keepalive Optional

A boolean.
When set to true, the browser will not abort the associated request if the page that initiated it is unloaded before the request is complete.
This enables a fetch() request to send analytics at the end of a session even if the user navigates away from or closes the page.
This has some advantages over using Navigator.sendBeacon() for the same purpose.
For example, you can use HTTP methods other than POST, customize request properties, and access the server response via the fetch Promise fulfillment.
It is also available in service workers.
The body size for keepalive requests is limited to 64 kibibytes.
Defaults to false.

method Optional

The request method.
Defaults to GET.

mode Optional

Sets cross-origin behavior for the request. One of the following values:

same-origin

Disallows cross-origin requests. If a same-origin request is sent to a different origin, the result is a network error.

cors

If the request is cross-origin then it will use the Cross-Origin Resource Sharing (CORS) mechanism. Only CORS-safelisted response headers are exposed in the response.

no-cors

Disables CORS for cross-origin requests. This option comes with the following restrictions:

The method may only be one of HEAD, GET or POST.
The headers may only be CORS-safelisted request headers, with the additional restriction that the Range header is also not allowed. This also applies to any headers added by service workers.
The response is opaque, meaning that its headers and body are not available to JavaScript, and its status code is always 0.

The main application for no-cors is for a service worker: although the response to a no-cors request can't be read by JavaScript, it can be cached by a service worker and then used as a response to an intercepted fetch request. Note that in this situation you don't know whether the request succeeded or not, so you should adopt a caching strategy which enables the cached response to be updated from the network (such as cache first with cache refresh).

navigate

Used only by HTML navigation. A navigate request is created only while navigating between documents.


See Making cross-origin requests for more details.
Defaults to cors.

priority Optional

Specifies the priority of the fetch request relative to other requests of the same type. Must be one of the following:

high

A high priority fetch request relative to other requests of the same type.

low

A low priority fetch request relative to other requests of the same type.

auto

No user preference for the fetch priority.
It is used if no value is set or if an invalid value is set.


Defaults to auto.

redirect Optional

Determines the browser's behavior in case the server replies with a redirect status. One of the following values:

follow

Automatically follow redirects.

error

Reject the promise with a network error when a redirect status is returned.

manual

Return a response with almost all fields filtered out, to enable a service worker to store the response and later replay it.


Defaults to follow.

referrer Optional

A string specifying the value to use for the request's Referer header. One of the following:

A same-origin relative or absolute URL

Set the Referer header to the given value. Relative URLs are resolved relative to the URL of the page that made the request.

An empty string

Omit the Referer header.

about:client

Set the Referer header to the default value for the context of the request (for example, the URL of the page that made the request).


Defaults to about:client.

referrerPolicy Optional

A string that sets a policy for the Referer header. The syntax and semantics of this option are exactly the same as for the Referrer-Policy header.

signal Optional

An AbortSignal. If this option is set, the request can be canceled by calling abort() on the corresponding AbortController.

ExamplesPassing options into fetch()In this example we pass the method, body, and headers options directly into the fetch() method call:
jsasync function post() {
  const response = await fetch("https://example.org/post", {
    method: "POST",
    body: JSON.stringify({ username: "example" }),
    headers: {
      "Content-Type": "application/json",
    },
  });

  console.log(response.status);
}
Passing options into the Request() constructorIn this example we create a Request, passing the same set of options into its constructor, and then pass the request into fetch():
jsasync function post() {
  const request = new Request("https://example.org/post", {
    method: "POST",
    body: JSON.stringify({ username: "example" }),
    headers: {
      "Content-Type": "application/json",
    },
  });

  const response = await fetch(request);

  console.log(response.status);
}
Passing options into both Request() and fetch()In this example we create a Request, passing the method, headers, and body options into its constructor. We then pass the request into fetch() along with body and referrer options:
jsasync function post() {
  const request = new Request("https://example.org/post", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ username: "example1" }),
  });

  const response = await fetch(request, {
    body: JSON.stringify({ username: "example2" }),
    referrer: "",
  });

  console.log(response.status);
}

In this case the request will be sent with the following options:

method: "POST"
headers: {"Content-Type": "application/json"}
body: '{"username":"example2"}'
referrer: ""
SpecificationsSpecificationFetch # requestinitSee also
Using Fetch
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResponseBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Response interface of the Fetch API represents the response to a request.
You can create a new Response object using the Response() constructor, but you are more likely to encounter a Response object being returned as the result of another API operation—for example, a service worker FetchEvent.respondWith, or a simple fetch().Constructor
Response()

Creates a new Response object.

Instance properties
Response.body Read only

A ReadableStream of the body contents.

Response.bodyUsed Read only

Stores a boolean value that declares whether the body has been used in a response yet.

Response.headers Read only

The Headers object associated with the response.

Response.ok Read only

A boolean indicating whether the response was successful (status in the range 200 – 299) or not.

Response.redirected Read only

Indicates whether or not the response is the result of a redirect (that is, its URL list has more than one entry).

Response.status Read only

The status code of the response. (This will be 200 for a success).

Response.statusText Read only

The status message corresponding to the status code. (e.g., OK for 200).

Response.type Read only

The type of the response (e.g., basic, cors).

Response.url Read only

The URL of the response.

Static methods
Response.error()

Returns a new Response object associated with a network error.

Response.redirect()

Returns a new response with a different URL.

Response.json()

Returns a new Response object for returning the provided JSON encoded data.

Instance methods
Response.arrayBuffer()

Returns a promise that resolves with an ArrayBuffer representation of the response body.

Response.blob()

Returns a promise that resolves with a Blob representation of the response body.

Response.bytes()

Returns a promise that resolves with a Uint8Array representation of the response body.

Response.clone()

Creates a clone of a Response object.

Response.formData()

Returns a promise that resolves with a FormData representation of the response body.

Response.json()

Returns a promise that resolves with the result of parsing the response body text as JSON.

Response.text()

Returns a promise that resolves with a text representation of the response body.

ExamplesFetching an imageIn our basic fetch example (run example live) we use a simple fetch() call to grab an image and display it in an <img> element.
The fetch() call returns a promise, which resolves to the Response object associated with the resource fetch operation.
You'll notice that since we are requesting an image, we need to run Response.blob to give the response its correct MIME type.
jsconst image = document.querySelector(".my-image");
fetch("flowers.jpg")
  .then((response) => response.blob())
  .then((blob) => {
    const objectURL = URL.createObjectURL(blob);
    image.src = objectURL;
  });

You can also use the Response() constructor to create your own custom Response object:
jsconst response = new Response();
A PHP CallHere we call a PHP program file that generates a JSON string, displaying the result as a JSON value.
js// Function to fetch JSON using PHP
const getJSON = async () => {
  // Generate the Response object
  const response = await fetch("getJSON.php");
  if (response.ok) {
    // Get JSON value from the response body
    return response.json();
  }
  throw new Error("*** PHP file not found");
};

// Call the function and output value or error message to console
getJSON()
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
SpecificationsSpecificationFetch # response-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nResponseBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Response interface of the Fetch API represents the response to a request.
You can create a new Response object using the Response() constructor, but you are more likely to encounter a Response object being returned as the result of another API operation—for example, a service worker FetchEvent.respondWith, or a simple fetch().Constructor
Response()

Creates a new Response object.

Instance properties
Response.body Read only

A ReadableStream of the body contents.

Response.bodyUsed Read only

Stores a boolean value that declares whether the body has been used in a response yet.

Response.headers Read only

The Headers object associated with the response.

Response.ok Read only

A boolean indicating whether the response was successful (status in the range 200 – 299) or not.

Response.redirected Read only

Indicates whether or not the response is the result of a redirect (that is, its URL list has more than one entry).

Response.status Read only

The status code of the response. (This will be 200 for a success).

Response.statusText Read only

The status message corresponding to the status code. (e.g., OK for 200).

Response.type Read only

The type of the response (e.g., basic, cors).

Response.url Read only

The URL of the response.

Static methods
Response.error()

Returns a new Response object associated with a network error.

Response.redirect()

Returns a new response with a different URL.

Response.json()

Returns a new Response object for returning the provided JSON encoded data.

Instance methods
Response.arrayBuffer()

Returns a promise that resolves with an ArrayBuffer representation of the response body.

Response.blob()

Returns a promise that resolves with a Blob representation of the response body.

Response.bytes()

Returns a promise that resolves with a Uint8Array representation of the response body.

Response.clone()

Creates a clone of a Response object.

Response.formData()

Returns a promise that resolves with a FormData representation of the response body.

Response.json()

Returns a promise that resolves with the result of parsing the response body text as JSON.

Response.text()

Returns a promise that resolves with a text representation of the response body.

ExamplesFetching an imageIn our basic fetch example (run example live) we use a simple fetch() call to grab an image and display it in an <img> element.
The fetch() call returns a promise, which resolves to the Response object associated with the resource fetch operation.
You'll notice that since we are requesting an image, we need to run Response.blob to give the response its correct MIME type.
jsconst image = document.querySelector(".my-image");
fetch("flowers.jpg")
  .then((response) => response.blob())
  .then((blob) => {
    const objectURL = URL.createObjectURL(blob);
    image.src = objectURL;
  });

You can also use the Response() constructor to create your own custom Response object:
jsconst response = new Response();
A PHP CallHere we call a PHP program file that generates a JSON string, displaying the result as a JSON value.
js// Function to fetch JSON using PHP
const getJSON = async () => {
  // Generate the Response object
  const response = await fetch("getJSON.php");
  if (response.ok) {
    // Get JSON value from the response body
    return response.json();
  }
  throw new Error("*** PHP file not found");
};

// Call the function and output value or error message to console
getJSON()
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
SpecificationsSpecificationFetch # response-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nResponseBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Response interface of the Fetch API represents the response to a request.
You can create a new Response object using the Response() constructor, but you are more likely to encounter a Response object being returned as the result of another API operation—for example, a service worker FetchEvent.respondWith, or a simple fetch().Constructor
Response()

Creates a new Response object.

Instance properties
Response.body Read only

A ReadableStream of the body contents.

Response.bodyUsed Read only

Stores a boolean value that declares whether the body has been used in a response yet.

Response.headers Read only

The Headers object associated with the response.

Response.ok Read only

A boolean indicating whether the response was successful (status in the range 200 – 299) or not.

Response.redirected Read only

Indicates whether or not the response is the result of a redirect (that is, its URL list has more than one entry).

Response.status Read only

The status code of the response. (This will be 200 for a success).

Response.statusText Read only

The status message corresponding to the status code. (e.g., OK for 200).

Response.type Read only

The type of the response (e.g., basic, cors).

Response.url Read only

The URL of the response.

Static methods
Response.error()

Returns a new Response object associated with a network error.

Response.redirect()

Returns a new response with a different URL.

Response.json()

Returns a new Response object for returning the provided JSON encoded data.

Instance methods
Response.arrayBuffer()

Returns a promise that resolves with an ArrayBuffer representation of the response body.

Response.blob()

Returns a promise that resolves with a Blob representation of the response body.

Response.bytes()

Returns a promise that resolves with a Uint8Array representation of the response body.

Response.clone()

Creates a clone of a Response object.

Response.formData()

Returns a promise that resolves with a FormData representation of the response body.

Response.json()

Returns a promise that resolves with the result of parsing the response body text as JSON.

Response.text()

Returns a promise that resolves with a text representation of the response body.

ExamplesFetching an imageIn our basic fetch example (run example live) we use a simple fetch() call to grab an image and display it in an <img> element.
The fetch() call returns a promise, which resolves to the Response object associated with the resource fetch operation.
You'll notice that since we are requesting an image, we need to run Response.blob to give the response its correct MIME type.
jsconst image = document.querySelector(".my-image");
fetch("flowers.jpg")
  .then((response) => response.blob())
  .then((blob) => {
    const objectURL = URL.createObjectURL(blob);
    image.src = objectURL;
  });

You can also use the Response() constructor to create your own custom Response object:
jsconst response = new Response();
A PHP CallHere we call a PHP program file that generates a JSON string, displaying the result as a JSON value.
js// Function to fetch JSON using PHP
const getJSON = async () => {
  // Generate the Response object
  const response = await fetch("getJSON.php");
  if (response.ok) {
    // Get JSON value from the response body
    return response.json();
  }
  throw new Error("*** PHP file not found");
};

// Call the function and output value or error message to console
getJSON()
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
SpecificationsSpecificationFetch # response-classBrowser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWindow: fetch() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe fetch() method of the Window interface starts the process of fetching a resource from the network, returning a promise that is fulfilled once the response is available.
The promise resolves to the Response object representing the response to your request.
A fetch() promise only rejects when the request fails, for example, because of a badly-formed request URL or a network error.
A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.).
Instead, a then() handler must check the Response.ok and/or Response.status properties.
The fetch() method is controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.

Note:
The fetch() method's parameters are identical to those of the Request() constructor.
Syntaxjsfetch(resource)
fetch(resource, options)
Parameters
resource

This defines the resource that you wish to fetch. This can either be:

A string or any other object with a stringifier — including a URL object — that provides the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.
A Request object.


options Optional

A RequestInit object containing any custom settings that you want to apply to the request.

Return valueA Promise that resolves to a Response object.Exceptions
AbortError DOMException

The request was aborted due to a call to the AbortController
abort() method.

NotAllowedError DOMException

Thrown if use of the Topics API is specifically disallowed by a browsing-topics Permissions Policy, and a fetch() request was made with browsingTopics: true.

TypeError

Can occur for the following reasons:



  
    
      Reason
      Failing examples
    
  
  
    
      Blocked by a permissions policy
      Use of the Attribution Reporting API is blocked by a attribution-reporting Permissions-Policy, and a fetch() request was made with attributionReporting specified.
    
    
      Invalid header name.
      
        
        js// space in "C ontent-Type"
const headers = {
  "C ontent-Type": "text/xml",
  "Breaking-Bad": "<3",
};
fetch("https://example.com/", { headers });
        
      
    
    
      
        Invalid header value. The header object must contain exactly two elements.
      
      
        jsconst headers = [
  ["Content-Type", "text/html", "extra"],
  ["Accept"],
];
fetch("https://example.com/", { headers });
        
      
    
    
      
        Invalid URL or scheme, or using a scheme that fetch does not support, or using a scheme that is not supported for a particular request mode.
      
      
        jsfetch("blob://example.com/", { mode: "cors" });
        
      
    
      URL includes credentials.
      
        jsfetch("https://user:password@example.com/");
        
      
    
      Invalid referrer URL.
      
        jsfetch("https://example.com/", { referrer: "./abc\u0000df" });
        
      
    
    
      Invalid modes (navigate and websocket).
      
        jsfetch("https://example.com/", { mode: "navigate" });
        
      
    
    
      
        If the request cache mode is "only-if-cached" and the request mode is other than "same-origin".
      
      
        jsfetch("https://example.com/", {
  cache: "only-if-cached",
  mode: "no-cors",
});
        
      
    
    
      
        If the request method is an invalid name token or one of the forbidden headers
        (CONNECT, TRACE or TRACK).
      
      
        jsfetch("https://example.com/", { method: "CONNECT" });
        
      
    
    
      
        If the request mode is "no-cors" and the request method is not a CORS-safe-listed method
        (GET, HEAD, or POST).
      
      
        jsfetch("https://example.com/", {
  method: "CONNECT",
  mode: "no-cors",
});
        
      
    
    
      
        If the request method is GET or HEAD and the body is non-null or not undefined.
      
      
        jsfetch("https://example.com/", {
  method: "GET",
  body: new FormData(),
});
        
      
    
    
      If fetch throws a network error.
      
    
  
ExamplesIn our Fetch Request example (see Fetch Request live) we
create a new Request object using the relevant constructor, then fetch it
using a fetch() call. Since we are fetching an image, we run
Response.blob() on the response to give it the proper MIME type so it will be
handled properly, then create an Object URL of it and display it in an
<img> element.
jsconst myImage = document.querySelector("img");

const myRequest = new Request("flowers.jpg");

window
  .fetch(myRequest)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    return response.blob();
  })
  .then((response) => {
    myImage.src = URL.createObjectURL(response);
  });

In our Fetch Request with init example (see Fetch Request init live) we do the same thing except that we pass in an options object when we invoke fetch().
In this case, we can set a Cache-Control value to indicate what kind of cached responses we're okay with:
jsconst myImage = document.querySelector("img");
const reqHeaders = new Headers();

// A cached response is okay unless it's more than a week old
reqHeaders.set("Cache-Control", "max-age=604800");

const options = {
  headers: reqHeaders,
};

// Pass init as an "options" object with our headers.
const req = new Request("flowers.jpg", options);

fetch(req).then((response) => {
  // ...
});

You could also pass the init object in with the Request constructor to get the same effect:
jsconst req = new Request("flowers.jpg", options);

You can also use an object literal as headers in init:
jsconst options = {
  headers: {
    "Cache-Control": "max-age=60480",
  },
};

const req = new Request("flowers.jpg", options);

The Using fetch article provides more examples of using fetch().SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
WorkerGlobalScope.fetch()
Fetch API
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nWindow: fetch() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe fetch() method of the Window interface starts the process of fetching a resource from the network, returning a promise that is fulfilled once the response is available.
The promise resolves to the Response object representing the response to your request.
A fetch() promise only rejects when the request fails, for example, because of a badly-formed request URL or a network error.
A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.).
Instead, a then() handler must check the Response.ok and/or Response.status properties.
The fetch() method is controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.

Note:
The fetch() method's parameters are identical to those of the Request() constructor.
Syntaxjsfetch(resource)
fetch(resource, options)
Parameters
resource

This defines the resource that you wish to fetch. This can either be:

A string or any other object with a stringifier — including a URL object — that provides the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.
A Request object.


options Optional

A RequestInit object containing any custom settings that you want to apply to the request.

Return valueA Promise that resolves to a Response object.Exceptions
AbortError DOMException

The request was aborted due to a call to the AbortController
abort() method.

NotAllowedError DOMException

Thrown if use of the Topics API is specifically disallowed by a browsing-topics Permissions Policy, and a fetch() request was made with browsingTopics: true.

TypeError

Can occur for the following reasons:



  
    
      Reason
      Failing examples
    
  
  
    
      Blocked by a permissions policy
      Use of the Attribution Reporting API is blocked by a attribution-reporting Permissions-Policy, and a fetch() request was made with attributionReporting specified.
    
    
      Invalid header name.
      
        
        js// space in "C ontent-Type"
const headers = {
  "C ontent-Type": "text/xml",
  "Breaking-Bad": "<3",
};
fetch("https://example.com/", { headers });
        
      
    
    
      
        Invalid header value. The header object must contain exactly two elements.
      
      
        jsconst headers = [
  ["Content-Type", "text/html", "extra"],
  ["Accept"],
];
fetch("https://example.com/", { headers });
        
      
    
    
      
        Invalid URL or scheme, or using a scheme that fetch does not support, or using a scheme that is not supported for a particular request mode.
      
      
        jsfetch("blob://example.com/", { mode: "cors" });
        
      
    
      URL includes credentials.
      
        jsfetch("https://user:password@example.com/");
        
      
    
      Invalid referrer URL.
      
        jsfetch("https://example.com/", { referrer: "./abc\u0000df" });
        
      
    
    
      Invalid modes (navigate and websocket).
      
        jsfetch("https://example.com/", { mode: "navigate" });
        
      
    
    
      
        If the request cache mode is "only-if-cached" and the request mode is other than "same-origin".
      
      
        jsfetch("https://example.com/", {
  cache: "only-if-cached",
  mode: "no-cors",
});
        
      
    
    
      
        If the request method is an invalid name token or one of the forbidden headers
        (CONNECT, TRACE or TRACK).
      
      
        jsfetch("https://example.com/", { method: "CONNECT" });
        
      
    
    
      
        If the request mode is "no-cors" and the request method is not a CORS-safe-listed method
        (GET, HEAD, or POST).
      
      
        jsfetch("https://example.com/", {
  method: "CONNECT",
  mode: "no-cors",
});
        
      
    
    
      
        If the request method is GET or HEAD and the body is non-null or not undefined.
      
      
        jsfetch("https://example.com/", {
  method: "GET",
  body: new FormData(),
});
        
      
    
    
      If fetch throws a network error.
      
    
  
ExamplesIn our Fetch Request example (see Fetch Request live) we
create a new Request object using the relevant constructor, then fetch it
using a fetch() call. Since we are fetching an image, we run
Response.blob() on the response to give it the proper MIME type so it will be
handled properly, then create an Object URL of it and display it in an
<img> element.
jsconst myImage = document.querySelector("img");

const myRequest = new Request("flowers.jpg");

window
  .fetch(myRequest)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    return response.blob();
  })
  .then((response) => {
    myImage.src = URL.createObjectURL(response);
  });

In our Fetch Request with init example (see Fetch Request init live) we do the same thing except that we pass in an options object when we invoke fetch().
In this case, we can set a Cache-Control value to indicate what kind of cached responses we're okay with:
jsconst myImage = document.querySelector("img");
const reqHeaders = new Headers();

// A cached response is okay unless it's more than a week old
reqHeaders.set("Cache-Control", "max-age=604800");

const options = {
  headers: reqHeaders,
};

// Pass init as an "options" object with our headers.
const req = new Request("flowers.jpg", options);

fetch(req).then((response) => {
  // ...
});

You could also pass the init object in with the Request constructor to get the same effect:
jsconst req = new Request("flowers.jpg", options);

You can also use an object literal as headers in init:
jsconst options = {
  headers: {
    "Cache-Control": "max-age=60480",
  },
};

const req = new Request("flowers.jpg", options);

The Using fetch article provides more examples of using fetch().SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
WorkerGlobalScope.fetch()
Fetch API
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWindow: fetch() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe fetch() method of the Window interface starts the process of fetching a resource from the network, returning a promise that is fulfilled once the response is available.
The promise resolves to the Response object representing the response to your request.
A fetch() promise only rejects when the request fails, for example, because of a badly-formed request URL or a network error.
A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.).
Instead, a then() handler must check the Response.ok and/or Response.status properties.
The fetch() method is controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.

Note:
The fetch() method's parameters are identical to those of the Request() constructor.
Syntaxjsfetch(resource)
fetch(resource, options)
Parameters
resource

This defines the resource that you wish to fetch. This can either be:

A string or any other object with a stringifier — including a URL object — that provides the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.
A Request object.


options Optional

A RequestInit object containing any custom settings that you want to apply to the request.

Return valueA Promise that resolves to a Response object.Exceptions
AbortError DOMException

The request was aborted due to a call to the AbortController
abort() method.

NotAllowedError DOMException

Thrown if use of the Topics API is specifically disallowed by a browsing-topics Permissions Policy, and a fetch() request was made with browsingTopics: true.

TypeError

Can occur for the following reasons:



  
    
      Reason
      Failing examples
    
  
  
    
      Blocked by a permissions policy
      Use of the Attribution Reporting API is blocked by a attribution-reporting Permissions-Policy, and a fetch() request was made with attributionReporting specified.
    
    
      Invalid header name.
      
        
        js// space in "C ontent-Type"
const headers = {
  "C ontent-Type": "text/xml",
  "Breaking-Bad": "<3",
};
fetch("https://example.com/", { headers });
        
      
    
    
      
        Invalid header value. The header object must contain exactly two elements.
      
      
        jsconst headers = [
  ["Content-Type", "text/html", "extra"],
  ["Accept"],
];
fetch("https://example.com/", { headers });
        
      
    
    
      
        Invalid URL or scheme, or using a scheme that fetch does not support, or using a scheme that is not supported for a particular request mode.
      
      
        jsfetch("blob://example.com/", { mode: "cors" });
        
      
    
      URL includes credentials.
      
        jsfetch("https://user:password@example.com/");
        
      
    
      Invalid referrer URL.
      
        jsfetch("https://example.com/", { referrer: "./abc\u0000df" });
        
      
    
    
      Invalid modes (navigate and websocket).
      
        jsfetch("https://example.com/", { mode: "navigate" });
        
      
    
    
      
        If the request cache mode is "only-if-cached" and the request mode is other than "same-origin".
      
      
        jsfetch("https://example.com/", {
  cache: "only-if-cached",
  mode: "no-cors",
});
        
      
    
    
      
        If the request method is an invalid name token or one of the forbidden headers
        (CONNECT, TRACE or TRACK).
      
      
        jsfetch("https://example.com/", { method: "CONNECT" });
        
      
    
    
      
        If the request mode is "no-cors" and the request method is not a CORS-safe-listed method
        (GET, HEAD, or POST).
      
      
        jsfetch("https://example.com/", {
  method: "CONNECT",
  mode: "no-cors",
});
        
      
    
    
      
        If the request method is GET or HEAD and the body is non-null or not undefined.
      
      
        jsfetch("https://example.com/", {
  method: "GET",
  body: new FormData(),
});
        
      
    
    
      If fetch throws a network error.
      
    
  
ExamplesIn our Fetch Request example (see Fetch Request live) we
create a new Request object using the relevant constructor, then fetch it
using a fetch() call. Since we are fetching an image, we run
Response.blob() on the response to give it the proper MIME type so it will be
handled properly, then create an Object URL of it and display it in an
<img> element.
jsconst myImage = document.querySelector("img");

const myRequest = new Request("flowers.jpg");

window
  .fetch(myRequest)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    return response.blob();
  })
  .then((response) => {
    myImage.src = URL.createObjectURL(response);
  });

In our Fetch Request with init example (see Fetch Request init live) we do the same thing except that we pass in an options object when we invoke fetch().
In this case, we can set a Cache-Control value to indicate what kind of cached responses we're okay with:
jsconst myImage = document.querySelector("img");
const reqHeaders = new Headers();

// A cached response is okay unless it's more than a week old
reqHeaders.set("Cache-Control", "max-age=604800");

const options = {
  headers: reqHeaders,
};

// Pass init as an "options" object with our headers.
const req = new Request("flowers.jpg", options);

fetch(req).then((response) => {
  // ...
});

You could also pass the init object in with the Request constructor to get the same effect:
jsconst req = new Request("flowers.jpg", options);

You can also use an object literal as headers in init:
jsconst options = {
  headers: {
    "Cache-Control": "max-age=60480",
  },
};

const req = new Request("flowers.jpg", options);

The Using fetch article provides more examples of using fetch().SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
WorkerGlobalScope.fetch()
Fetch API
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWorkerGlobalScope: fetch() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Web Workers.
The fetch() method of the WorkerGlobalScope interface starts the process of fetching a resource from the network, returning a promise that is fulfilled once the response is available.
The promise resolves to the Response object representing the response to your request.
A fetch() promise only rejects when the request fails, for example, because of a badly-formed request URL or a network error.
A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.).
Instead, a then() handler must check the Response.ok and/or Response.status properties.
The fetch() method is controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.

Note:
The fetch() method's parameters are identical to those of the Request() constructor.
Syntaxjsfetch(resource)
fetch(resource, options)
Parameters
resource

This defines the resource that you wish to fetch. This can either be:

A string or any other object with a stringifier — including a URL object — that provides the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.
A Request object.


options Optional

A RequestInit object containing any custom settings that you want to apply to the request.

Return valueA Promise that resolves to a Response object.Exceptions
AbortError DOMException

The request was aborted due to a call to the AbortController abort() method.

NotAllowedError DOMException

Thrown if use of the Topics API is specifically disallowed by a browsing-topics Permissions Policy, and a fetch() request was made with browsingTopics: true.

TypeError

An error when the fetch operation could not be performed.
See Window.fetch() exceptions for a list of reasons why this error can occur.

ExamplesSee fetch() for examples.SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Window.fetch()
Fetch API
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nWorkerGlobalScope: fetch() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Web Workers.
The fetch() method of the WorkerGlobalScope interface starts the process of fetching a resource from the network, returning a promise that is fulfilled once the response is available.
The promise resolves to the Response object representing the response to your request.
A fetch() promise only rejects when the request fails, for example, because of a badly-formed request URL or a network error.
A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.).
Instead, a then() handler must check the Response.ok and/or Response.status properties.
The fetch() method is controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.

Note:
The fetch() method's parameters are identical to those of the Request() constructor.
Syntaxjsfetch(resource)
fetch(resource, options)
Parameters
resource

This defines the resource that you wish to fetch. This can either be:

A string or any other object with a stringifier — including a URL object — that provides the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.
A Request object.


options Optional

A RequestInit object containing any custom settings that you want to apply to the request.

Return valueA Promise that resolves to a Response object.Exceptions
AbortError DOMException

The request was aborted due to a call to the AbortController abort() method.

NotAllowedError DOMException

Thrown if use of the Topics API is specifically disallowed by a browsing-topics Permissions Policy, and a fetch() request was made with browsingTopics: true.

TypeError

An error when the fetch operation could not be performed.
See Window.fetch() exceptions for a list of reasons why this error can occur.

ExamplesSee fetch() for examples.SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Window.fetch()
Fetch API
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWorkerGlobalScope: fetch() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Web Workers.
The fetch() method of the WorkerGlobalScope interface starts the process of fetching a resource from the network, returning a promise that is fulfilled once the response is available.
The promise resolves to the Response object representing the response to your request.
A fetch() promise only rejects when the request fails, for example, because of a badly-formed request URL or a network error.
A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.).
Instead, a then() handler must check the Response.ok and/or Response.status properties.
The fetch() method is controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.

Note:
The fetch() method's parameters are identical to those of the Request() constructor.
Syntaxjsfetch(resource)
fetch(resource, options)
Parameters
resource

This defines the resource that you wish to fetch. This can either be:

A string or any other object with a stringifier — including a URL object — that provides the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.
A Request object.


options Optional

A RequestInit object containing any custom settings that you want to apply to the request.

Return valueA Promise that resolves to a Response object.Exceptions
AbortError DOMException

The request was aborted due to a call to the AbortController abort() method.

NotAllowedError DOMException

Thrown if use of the Topics API is specifically disallowed by a browsing-topics Permissions Policy, and a fetch() request was made with browsingTopics: true.

TypeError

An error when the fetch operation could not be performed.
See Window.fetch() exceptions for a list of reasons why this error can occur.

ExamplesSee fetch() for examples.SpecificationsSpecificationFetch # fetch-methodBrowser compatibilitySee also
Window.fetch()
Fetch API
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nBaseline (compatibility)Baseline identifies the availability of web platform features across popular browsers, including APIs, CSS properties, and JavaScript syntax. Baseline describes web features as being either widely available or newly available. Features that do not meet the Baseline criteria are said to have limited availability.
Baseline considers support in the following browsers:

Apple Safari (iOS)
Apple Safari (macOS)
Google Chrome (Android)
Google Chrome (desktop)
Microsoft Edge (desktop)
Mozilla Firefox (Android)
Mozilla Firefox (desktop)

Baseline is a summary of browser support. It is not a substitute for accessibility, usability, performance, security, or other testing. Baseline may not tell you if a feature works with:

Older devices and browser releases
Browsers not covered by the Baseline definition, such as operating system web views
Assistive technology, such as screen readers.
Baseline badges
Features listed as widely available have a consistent history of support in each of the Baseline browsers for at least 2.5 years.

Features listed as newly available work in at least the latest stable version of each of the Baseline browsers, but may not work with older browsers and devices.

Features listed with limited availability are not yet available in all browsers.See also
Testing
web-platform-dx/web-features repository
W3C WebDX Community Group
mdn/browser-compat-data repository
caniuse.com
a11ysupport.io
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 19, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb Workers APIWeb Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down.Concepts and usageA worker is an object created using a constructor (e.g., Worker()) that runs a named JavaScript file — this file contains the code that will run in the worker thread.
In addition to the standard JavaScript set of functions (such as String, Array, Object, JSON, etc.), you can run almost any code you like inside a worker thread. There are some exceptions: for example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the Window object. For information about the code that you can run see supported functions, and supported Web APIs.
Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data property). The data is copied rather than shared.
Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page.
In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null).Worker typesThere are a number of different types of workers:

Dedicated workers are workers that are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
Shared workers are workers that can be utilized by multiple scripts running in different windows, IFrames, etc., as long as they are in the same domain as the worker. They are a little more complex than dedicated workers — scripts must communicate via an active port.
Service Workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.
Worker contextsWhile Window is not directly available to workers, many of the same methods are defined in a shared mixin (WindowOrWorkerGlobalScope), and made available to workers through their own WorkerGlobalScope-derived contexts:

DedicatedWorkerGlobalScope for dedicated workers
SharedWorkerGlobalScope for shared workers
ServiceWorkerGlobalScope for service workers
Interfaces
Worker

Represents a running worker thread, allowing you to pass messages to the running worker code.

WorkerLocation

Defines the absolute location of the script executed by the Worker.

SharedWorker

Represents a specific kind of worker that can be accessed from several browsing contexts (i.e., windows, tabs, or iframes) or even other workers.

WorkerGlobalScope

Represents the generic scope of any worker (doing the same job as Window does for normal web content). Different types of worker have scope objects that inherit from this interface and add more specific features.

DedicatedWorkerGlobalScope

Represents the scope of a dedicated worker, inheriting from WorkerGlobalScope and adding some dedicated features.

SharedWorkerGlobalScope

Represents the scope of a shared worker, inheriting from WorkerGlobalScope and adding some dedicated features.

WorkerNavigator

Represents the identity and state of the user agent (the client).

ExamplesWe have created a couple of demos to show web worker usage:

Basic dedicated worker example (run dedicated worker).
Basic shared worker example (run shared worker).
OffscreenCanvas worker example (run OffscreenCanvas worker).

You can find out more information on how these demos work in Using Web Workers.SpecificationsSpecificationHTML # workersSee also
Using Web Workers
Worker interface
SharedWorker interface
Service Worker API\n\nWeb Workers APIWeb Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down.Concepts and usageA worker is an object created using a constructor (e.g., Worker()) that runs a named JavaScript file — this file contains the code that will run in the worker thread.
In addition to the standard JavaScript set of functions (such as String, Array, Object, JSON, etc.), you can run almost any code you like inside a worker thread. There are some exceptions: for example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the Window object. For information about the code that you can run see supported functions, and supported Web APIs.
Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data property). The data is copied rather than shared.
Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page.
In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null).Worker typesThere are a number of different types of workers:

Dedicated workers are workers that are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
Shared workers are workers that can be utilized by multiple scripts running in different windows, IFrames, etc., as long as they are in the same domain as the worker. They are a little more complex than dedicated workers — scripts must communicate via an active port.
Service Workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.
Worker contextsWhile Window is not directly available to workers, many of the same methods are defined in a shared mixin (WindowOrWorkerGlobalScope), and made available to workers through their own WorkerGlobalScope-derived contexts:

DedicatedWorkerGlobalScope for dedicated workers
SharedWorkerGlobalScope for shared workers
ServiceWorkerGlobalScope for service workers
Interfaces
Worker

Represents a running worker thread, allowing you to pass messages to the running worker code.

WorkerLocation

Defines the absolute location of the script executed by the Worker.

SharedWorker

Represents a specific kind of worker that can be accessed from several browsing contexts (i.e., windows, tabs, or iframes) or even other workers.

WorkerGlobalScope

Represents the generic scope of any worker (doing the same job as Window does for normal web content). Different types of worker have scope objects that inherit from this interface and add more specific features.

DedicatedWorkerGlobalScope

Represents the scope of a dedicated worker, inheriting from WorkerGlobalScope and adding some dedicated features.

SharedWorkerGlobalScope

Represents the scope of a shared worker, inheriting from WorkerGlobalScope and adding some dedicated features.

WorkerNavigator

Represents the identity and state of the user agent (the client).

ExamplesWe have created a couple of demos to show web worker usage:

Basic dedicated worker example (run dedicated worker).
Basic shared worker example (run shared worker).
OffscreenCanvas worker example (run OffscreenCanvas worker).

You can find out more information on how these demos work in Using Web Workers.SpecificationsSpecificationHTML # workersSee also
Using Web Workers
Worker interface
SharedWorker interface
Service Worker API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb Workers APIWeb Workers makes it possible to run a script operation in a background thread separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, allowing the main (usually the UI) thread to run without being blocked/slowed down.Concepts and usageA worker is an object created using a constructor (e.g., Worker()) that runs a named JavaScript file — this file contains the code that will run in the worker thread.
In addition to the standard JavaScript set of functions (such as String, Array, Object, JSON, etc.), you can run almost any code you like inside a worker thread. There are some exceptions: for example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the Window object. For information about the code that you can run see supported functions, and supported Web APIs.
Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data property). The data is copied rather than shared.
Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page.
In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null).Worker typesThere are a number of different types of workers:

Dedicated workers are workers that are utilized by a single script. This context is represented by a DedicatedWorkerGlobalScope object.
Shared workers are workers that can be utilized by multiple scripts running in different windows, IFrames, etc., as long as they are in the same domain as the worker. They are a little more complex than dedicated workers — scripts must communicate via an active port.
Service Workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.
Worker contextsWhile Window is not directly available to workers, many of the same methods are defined in a shared mixin (WindowOrWorkerGlobalScope), and made available to workers through their own WorkerGlobalScope-derived contexts:

DedicatedWorkerGlobalScope for dedicated workers
SharedWorkerGlobalScope for shared workers
ServiceWorkerGlobalScope for service workers
Interfaces
Worker

Represents a running worker thread, allowing you to pass messages to the running worker code.

WorkerLocation

Defines the absolute location of the script executed by the Worker.

SharedWorker

Represents a specific kind of worker that can be accessed from several browsing contexts (i.e., windows, tabs, or iframes) or even other workers.

WorkerGlobalScope

Represents the generic scope of any worker (doing the same job as Window does for normal web content). Different types of worker have scope objects that inherit from this interface and add more specific features.

DedicatedWorkerGlobalScope

Represents the scope of a dedicated worker, inheriting from WorkerGlobalScope and adding some dedicated features.

SharedWorkerGlobalScope

Represents the scope of a shared worker, inheriting from WorkerGlobalScope and adding some dedicated features.

WorkerNavigator

Represents the identity and state of the user agent (the client).

ExamplesWe have created a couple of demos to show web worker usage:

Basic dedicated worker example (run dedicated worker).
Basic shared worker example (run shared worker).
OffscreenCanvas worker example (run OffscreenCanvas worker).

You can find out more information on how these demos work in Using Web Workers.SpecificationsSpecificationHTML # workersSee also
Using Web Workers
Worker interface
SharedWorker interface
Service Worker API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXMLHttpRequestBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers, except for Service Workers.
XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing.

Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML.
If your communication needs to involve receiving event data or message data from a server, consider using server-sent events through the EventSource interface. For full-duplex communication, WebSockets may be a better choice.Constructor
XMLHttpRequest()

The constructor initializes an XMLHttpRequest. It must be called before any other method calls.

Instance propertiesThis interface also inherits properties of XMLHttpRequestEventTarget and of EventTarget.

XMLHttpRequest.readyState Read only

Returns a number representing the state of the request.

XMLHttpRequest.response Read only

Returns an ArrayBuffer, a Blob, a Document, a JavaScript object, or a string, depending on the value of XMLHttpRequest.responseType, that contains the response entity body.

XMLHttpRequest.responseText Read only

Returns a string that contains the response to the request as text, or null if the request was unsuccessful or has not yet been sent.

XMLHttpRequest.responseType

Specifies the type of the response.

XMLHttpRequest.responseURL Read only

Returns the serialized URL of the response or the empty string if the URL is null.

XMLHttpRequest.responseXML Read only

Returns a Document containing the response to the request, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML. Not available in Web Workers.

XMLHttpRequest.status Read only

Returns the HTTP response status code of the request.

XMLHttpRequest.statusText Read only

Returns a string containing the response string returned by the HTTP server. Unlike XMLHttpRequest.status, this includes the entire text of the response message ("OK", for example).

Note:
According to the HTTP/2 specification RFC 7540, section 8.1.2.4: Response Pseudo-Header Fields, HTTP/2 does not define a way to carry the version or reason phrase that is included in an HTTP/1.1 status line.


XMLHttpRequest.timeout

The time in milliseconds a request can take before automatically being terminated.

XMLHttpRequest.upload Read only

A XMLHttpRequestUpload representing the upload process.

XMLHttpRequest.withCredentials

Returns true if cross-site Access-Control requests should be made using credentials such as cookies or authorization headers; otherwise false.

Non-standard properties
XMLHttpRequest.mozAnon Read only 
Non-standard


A boolean. If true, the request will be sent without cookie and authentication headers.

XMLHttpRequest.mozSystem Read only 
Non-standard


A boolean. If true, the same origin policy will not be enforced on the request.

Instance methods
XMLHttpRequest.abort()

Aborts the request if it has already been sent.

XMLHttpRequest.getAllResponseHeaders()

Returns all the response headers, separated by CRLF, as a string, or null if no response has been received.

XMLHttpRequest.getResponseHeader()

Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response.

XMLHttpRequest.open()

Initializes a request.

XMLHttpRequest.overrideMimeType()

Overrides the MIME type returned by the server.

XMLHttpRequest.send()

Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent.

XMLHttpRequest.setAttributionReporting() Secure context 
Experimental


Indicates that you want the request's response to be able to register an attribution source or trigger event.

XMLHttpRequest.setRequestHeader()

Sets the value of an HTTP request header. You must call setRequestHeader() after open(), but before send().

Events
abort

Fired when a request has been aborted, for example because the program called XMLHttpRequest.abort().
Also available via the onabort event handler property.

error

Fired when the request encountered an error.
Also available via the onerror event handler property.

load

Fired when an XMLHttpRequest transaction completes successfully.
Also available via the onload event handler property.

loadend

Fired when a request has completed, whether successfully (after load) or unsuccessfully (after abort or error).
Also available via the onloadend event handler property.

loadstart

Fired when a request has started to load data.
Also available via the onloadstart event handler property.

progress

Fired periodically when a request receives more data.
Also available via the onprogress event handler property.

readystatechange

Fired whenever the readyState property changes.
Also available via the onreadystatechange event handler property.

timeout

Fired when progress is terminated due to preset time expiring.
Also available via the ontimeout event handler property.

SpecificationsSpecificationXMLHttpRequest # interface-xmlhttprequestBrowser compatibilitySee also
XMLSerializer: Serializing a DOM tree into XML
Using XMLHttpRequest
Fetch API\n\nXMLHttpRequestBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers, except for Service Workers.
XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing.

Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML.
If your communication needs to involve receiving event data or message data from a server, consider using server-sent events through the EventSource interface. For full-duplex communication, WebSockets may be a better choice.Constructor
XMLHttpRequest()

The constructor initializes an XMLHttpRequest. It must be called before any other method calls.

Instance propertiesThis interface also inherits properties of XMLHttpRequestEventTarget and of EventTarget.

XMLHttpRequest.readyState Read only

Returns a number representing the state of the request.

XMLHttpRequest.response Read only

Returns an ArrayBuffer, a Blob, a Document, a JavaScript object, or a string, depending on the value of XMLHttpRequest.responseType, that contains the response entity body.

XMLHttpRequest.responseText Read only

Returns a string that contains the response to the request as text, or null if the request was unsuccessful or has not yet been sent.

XMLHttpRequest.responseType

Specifies the type of the response.

XMLHttpRequest.responseURL Read only

Returns the serialized URL of the response or the empty string if the URL is null.

XMLHttpRequest.responseXML Read only

Returns a Document containing the response to the request, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML. Not available in Web Workers.

XMLHttpRequest.status Read only

Returns the HTTP response status code of the request.

XMLHttpRequest.statusText Read only

Returns a string containing the response string returned by the HTTP server. Unlike XMLHttpRequest.status, this includes the entire text of the response message ("OK", for example).

Note:
According to the HTTP/2 specification RFC 7540, section 8.1.2.4: Response Pseudo-Header Fields, HTTP/2 does not define a way to carry the version or reason phrase that is included in an HTTP/1.1 status line.


XMLHttpRequest.timeout

The time in milliseconds a request can take before automatically being terminated.

XMLHttpRequest.upload Read only

A XMLHttpRequestUpload representing the upload process.

XMLHttpRequest.withCredentials

Returns true if cross-site Access-Control requests should be made using credentials such as cookies or authorization headers; otherwise false.

Non-standard properties
XMLHttpRequest.mozAnon Read only 
Non-standard


A boolean. If true, the request will be sent without cookie and authentication headers.

XMLHttpRequest.mozSystem Read only 
Non-standard


A boolean. If true, the same origin policy will not be enforced on the request.

Instance methods
XMLHttpRequest.abort()

Aborts the request if it has already been sent.

XMLHttpRequest.getAllResponseHeaders()

Returns all the response headers, separated by CRLF, as a string, or null if no response has been received.

XMLHttpRequest.getResponseHeader()

Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response.

XMLHttpRequest.open()

Initializes a request.

XMLHttpRequest.overrideMimeType()

Overrides the MIME type returned by the server.

XMLHttpRequest.send()

Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent.

XMLHttpRequest.setAttributionReporting() Secure context 
Experimental


Indicates that you want the request's response to be able to register an attribution source or trigger event.

XMLHttpRequest.setRequestHeader()

Sets the value of an HTTP request header. You must call setRequestHeader() after open(), but before send().

Events
abort

Fired when a request has been aborted, for example because the program called XMLHttpRequest.abort().
Also available via the onabort event handler property.

error

Fired when the request encountered an error.
Also available via the onerror event handler property.

load

Fired when an XMLHttpRequest transaction completes successfully.
Also available via the onload event handler property.

loadend

Fired when a request has completed, whether successfully (after load) or unsuccessfully (after abort or error).
Also available via the onloadend event handler property.

loadstart

Fired when a request has started to load data.
Also available via the onloadstart event handler property.

progress

Fired periodically when a request receives more data.
Also available via the onprogress event handler property.

readystatechange

Fired whenever the readyState property changes.
Also available via the onreadystatechange event handler property.

timeout

Fired when progress is terminated due to preset time expiring.
Also available via the ontimeout event handler property.

SpecificationsSpecificationXMLHttpRequest # interface-xmlhttprequestBrowser compatibilitySee also
XMLSerializer: Serializing a DOM tree into XML
Using XMLHttpRequest
Fetch API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXMLHttpRequestBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedback 
Note: This feature is available in Web Workers, except for Service Workers.
XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing.

Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML.
If your communication needs to involve receiving event data or message data from a server, consider using server-sent events through the EventSource interface. For full-duplex communication, WebSockets may be a better choice.Constructor
XMLHttpRequest()

The constructor initializes an XMLHttpRequest. It must be called before any other method calls.

Instance propertiesThis interface also inherits properties of XMLHttpRequestEventTarget and of EventTarget.

XMLHttpRequest.readyState Read only

Returns a number representing the state of the request.

XMLHttpRequest.response Read only

Returns an ArrayBuffer, a Blob, a Document, a JavaScript object, or a string, depending on the value of XMLHttpRequest.responseType, that contains the response entity body.

XMLHttpRequest.responseText Read only

Returns a string that contains the response to the request as text, or null if the request was unsuccessful or has not yet been sent.

XMLHttpRequest.responseType

Specifies the type of the response.

XMLHttpRequest.responseURL Read only

Returns the serialized URL of the response or the empty string if the URL is null.

XMLHttpRequest.responseXML Read only

Returns a Document containing the response to the request, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML. Not available in Web Workers.

XMLHttpRequest.status Read only

Returns the HTTP response status code of the request.

XMLHttpRequest.statusText Read only

Returns a string containing the response string returned by the HTTP server. Unlike XMLHttpRequest.status, this includes the entire text of the response message ("OK", for example).

Note:
According to the HTTP/2 specification RFC 7540, section 8.1.2.4: Response Pseudo-Header Fields, HTTP/2 does not define a way to carry the version or reason phrase that is included in an HTTP/1.1 status line.


XMLHttpRequest.timeout

The time in milliseconds a request can take before automatically being terminated.

XMLHttpRequest.upload Read only

A XMLHttpRequestUpload representing the upload process.

XMLHttpRequest.withCredentials

Returns true if cross-site Access-Control requests should be made using credentials such as cookies or authorization headers; otherwise false.

Non-standard properties
XMLHttpRequest.mozAnon Read only 
Non-standard


A boolean. If true, the request will be sent without cookie and authentication headers.

XMLHttpRequest.mozSystem Read only 
Non-standard


A boolean. If true, the same origin policy will not be enforced on the request.

Instance methods
XMLHttpRequest.abort()

Aborts the request if it has already been sent.

XMLHttpRequest.getAllResponseHeaders()

Returns all the response headers, separated by CRLF, as a string, or null if no response has been received.

XMLHttpRequest.getResponseHeader()

Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response.

XMLHttpRequest.open()

Initializes a request.

XMLHttpRequest.overrideMimeType()

Overrides the MIME type returned by the server.

XMLHttpRequest.send()

Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent.

XMLHttpRequest.setAttributionReporting() Secure context 
Experimental


Indicates that you want the request's response to be able to register an attribution source or trigger event.

XMLHttpRequest.setRequestHeader()

Sets the value of an HTTP request header. You must call setRequestHeader() after open(), but before send().

Events
abort

Fired when a request has been aborted, for example because the program called XMLHttpRequest.abort().
Also available via the onabort event handler property.

error

Fired when the request encountered an error.
Also available via the onerror event handler property.

load

Fired when an XMLHttpRequest transaction completes successfully.
Also available via the onload event handler property.

loadend

Fired when a request has completed, whether successfully (after load) or unsuccessfully (after abort or error).
Also available via the onloadend event handler property.

loadstart

Fired when a request has started to load data.
Also available via the onloadstart event handler property.

progress

Fired periodically when a request receives more data.
Also available via the onprogress event handler property.

readystatechange

Fired whenever the readyState property changes.
Also available via the onreadystatechange event handler property.

timeout

Fired when progress is terminated due to preset time expiring.
Also available via the ontimeout event handler property.

SpecificationsSpecificationXMLHttpRequest # interface-xmlhttprequestBrowser compatibilitySee also
XMLSerializer: Serializing a DOM tree into XML
Using XMLHttpRequest
Fetch API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWindowBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Window interface represents a window containing a DOM document; the document property points to the DOM document loaded in that window.
A window for a given document can be obtained using the document.defaultView property.
A global variable, window, representing the window in which the script is running, is exposed to JavaScript code.
The Window interface is home to a variety of functions, namespaces, objects, and constructors which are not necessarily directly associated with the concept of a user interface window. However, the Window interface is a suitable place to include these items that need to be globally available. Many of these are documented in the JavaScript Reference and the DOM Reference.
In a tabbed browser, each tab is represented by its own Window object; the global window seen by JavaScript code running within a given tab always represents the tab in which the code is running. That said, even in a tabbed browser, some properties and methods still apply to the overall window that contains the tab, such as resizeTo() and innerHeight. Generally, anything that can't reasonably pertain to a tab pertains to the window instead.
Instance propertiesThis interface inherits properties from the EventTarget interface.
Note that properties which are objects (e.g., for overriding the prototype of built-in elements) are listed in a separate section below.

Window.caches Read only Secure context

Returns the CacheStorage object associated with the current context. This object enables functionality such as storing assets for offline use, and generating custom responses to requests.

Window.clientInformation Read only

An alias for Window.navigator.

Window.closed Read only

This property indicates whether the current window is closed or not.

Window.cookieStore Read only Secure context

Returns a reference to the CookieStore object for the current document context.

Window.credentialless Read only 
Experimental


Returns a boolean that indicates whether the current document was loaded inside a credentialless <iframe>. See IFrame credentialless for more details.

Window.crossOriginIsolated Read only

Returns a boolean value that indicates whether the website is in a cross-origin isolation state.

Window.crypto Read only

Returns the Crypto object associated to the global object.

Window.customElements Read only

Returns a reference to the CustomElementRegistry object, which can be used to register new custom elements and get information about previously registered custom elements.

Window.devicePixelRatio Read only

Returns the ratio between physical pixels and device independent pixels in the current display.

Window.document Read only

Returns a reference to the document that the window contains.

Window.documentPictureInPicture Read only 
Experimental
 Secure context

Returns a reference to the document Picture-in-Picture window for the current document context.

Window.fence Read only 
Experimental


Returns a Fence object instance for the current document context. Available only to documents embedded inside a <fencedframe>.

Window.frameElement Read only

Returns the element in which the window is embedded, or null if the window is not embedded.

Window.frames Read only

Returns an array of the subframes in the current window.

Window.fullScreen 
Non-standard


This property indicates whether the window is displayed in full screen or not.

Window.history Read only

Returns a reference to the history object.

Window.indexedDB Read only

Provides a mechanism for applications to asynchronously access capabilities of indexed databases; returns an IDBFactory object.

Window.innerHeight Read only

Gets the height of the content area of the browser window including, if rendered, the horizontal scrollbar.

Window.innerWidth Read only

Gets the width of the content area of the browser window including, if rendered, the vertical scrollbar.

Window.isSecureContext Read only

Returns a boolean indicating whether the current context is secure (true) or not (false).

Window.launchQueue Read only 
Experimental


When a progressive web app (PWA) is launched with a launch_handler client_mode value of focus-existing, navigate-new, or navigate-existing, the launchQueue provides access to the LaunchQueue class, which allows custom launch navigation handling to be implemented for the PWA.

Window.length Read only

Returns the number of frames in the window. See also window.frames.

Window.localStorage Read only

Returns a reference to the local storage object used to store data that may only be accessed by the origin that created it.

Window.location

Gets/sets the location, or current URL, of the window object.

Window.locationbar Read only

Returns the locationbar object.

Window.menubar Read only

Returns the menubar object.

Window.mozInnerScreenX Read only 
Non-standard


Returns the horizontal (X) coordinate of the top-left corner of the window's viewport, in screen coordinates. This value is reported in CSS pixels. See mozScreenPixelsPerCSSPixel in nsIDOMWindowUtils for a conversion factor to adapt to screen pixels if needed.

Window.mozInnerScreenY Read only 
Non-standard


Returns the vertical (Y) coordinate of the top-left corner of the window's viewport, in screen coordinates. This value is reported in CSS pixels. See mozScreenPixelsPerCSSPixel for a conversion factor to adapt to screen pixels if needed.

Window.name

Gets/sets the name of the window.

Window.navigation Read only 
Experimental


Returns the current window's associated Navigation object. The entry point for the Navigation API.

Window.navigator Read only

Returns a reference to the navigator object.

Window.opener

Returns a reference to the window that opened this current window.

Window.origin Read only

Returns the global object's origin, serialized as a string.

Window.originAgentCluster Read only

Returns true if this window belongs to an origin-keyed agent cluster.

Window.outerHeight Read only

Gets the height of the outside of the browser window.

Window.outerWidth Read only

Gets the width of the outside of the browser window.

Window.pageXOffset Read only

An alias for window.scrollX.

Window.pageYOffset Read only

An alias for window.scrollY.

Window.parent Read only

Returns a reference to the parent of the current window or subframe.

Window.performance Read only

Returns a Performance object, which includes the timing and navigation attributes, each of which is an object providing performance-related data. See also Using Navigation Timing for additional information and examples.

Window.personalbar Read only

Returns the personalbar object.

Window.scheduler Read only

Returns the Scheduler object associated with the current context. This is the entry point for using the Prioritized Task Scheduling API.

Window.screen Read only

Returns a reference to the screen object associated with the window.

Window.screenX and Window.screenLeft Read only

Both properties return the horizontal distance from the left border of the user's browser viewport to the left side of the screen.

Window.screenY and Window.screenTop Read only

Both properties return the vertical distance from the top border of the user's browser viewport to the top side of the screen.

Window.scrollbars Read only

Returns the scrollbars object.

Window.scrollMaxX 
Non-standard
 Read only

The maximum offset that the window can be scrolled to horizontally, that is the document width minus the viewport width.

Window.scrollMaxY 
Non-standard
 Read only

The maximum offset that the window can be scrolled to vertically (i.e., the document height minus the viewport height).

Window.scrollX Read only

Returns the number of pixels that the document has already been scrolled horizontally.

Window.scrollY Read only

Returns the number of pixels that the document has already been scrolled vertically.

Window.self Read only

Returns an object reference to the window object itself.

Window.sessionStorage

Returns a reference to the session storage object used to store data that may only be accessed by the origin that created it.

Window.sharedStorage Read only 
Experimental
 Secure context

Returns the WindowSharedStorage object for the current origin. This is the main entry point for writing data to shared storage using the Shared Storage API.

Window.speechSynthesis Read only

Returns a SpeechSynthesis object, which is the entry point into using Web Speech API speech synthesis functionality.

Window.statusbar Read only

Returns the statusbar object.

Window.toolbar Read only

Returns the toolbar object.

Window.top Read only

Returns a reference to the topmost window in the window hierarchy. This property is read only.

Window.trustedTypes Read only

Returns the TrustedTypePolicyFactory object associated with the global object, providing the entry point for using the Trusted Types API.

Window.visualViewport Read only

Returns a VisualViewport object which represents the visual viewport for a given window.

Window.window Read only

Returns a reference to the current window.

window[0], window[1], etc.

Returns a reference to the window object in the frames. See Window.frames for more details.

Deprecated properties
Window.event 
Deprecated
 Read only

Returns the current event, which is the event currently being handled by the JavaScript code's context, or undefined if no event is currently being handled. The Event object passed directly to event handlers should be used instead whenever possible.

Window.external 
Deprecated
 Read only

Returns an object with functions for adding external search providers to the browser.

Window.orientation 
Deprecated
 Read only

Returns the orientation in degrees (in 90 degree increments) of the viewport relative to the device's natural orientation.

Window.status 
Deprecated


Gets/sets the text in the statusbar at the bottom of the browser.

Instance methodsThis interface inherits methods from the EventTarget interface.

Window.atob()

Decodes a string of data which has been encoded using base-64 encoding.

Window.alert()

Displays an alert dialog.

Window.blur() 
Deprecated


Sets focus away from the window.

Window.btoa()

Creates a base-64 encoded ASCII string from a string of binary data.

Window.cancelAnimationFrame()

Enables you to cancel a callback previously scheduled with Window.requestAnimationFrame.

Window.cancelIdleCallback()

Enables you to cancel a callback previously scheduled with Window.requestIdleCallback.

Window.clearInterval()

Cancels the repeated execution set using Window.setInterval().

Window.clearTimeout()

Cancels the delayed execution set using Window.setTimeout().

Window.close()

Closes the current window.

Window.confirm()

Displays a dialog with a message that the user needs to respond to.

Window.createImageBitmap()

Accepts a variety of different image sources, and returns a Promise which resolves to an ImageBitmap. Optionally the source is cropped to the rectangle of pixels originating at (sx, sy) with width sw, and height sh.

Window.dump() 
Non-standard


Writes a message to the console.

Window.fetch()

Starts the process of fetching a resource from the network.

Window.fetchLater() 
Experimental


Creates a deferred fetch, which is sent once the page is navigated away from (it is destroyed or enters the bfcache), or after a provided activateAfter timeout — whichever comes first.

Window.find() 
Non-standard


Searches for a given string in a window.

Window.focus()

Sets focus on the current window.

Window.getComputedStyle()

Gets computed style for the specified element. Computed style indicates the computed values of all CSS properties of the element.

Window.getDefaultComputedStyle() 
Non-standard


Gets default computed style for the specified element, ignoring author stylesheets.

Window.getScreenDetails() 
Experimental
 Secure context

Returns a Promise that fulfills with a ScreenDetails object instance representing the details of all the screens available to the user's device.

Window.getSelection()

Returns the selection object representing the selected item(s).

Window.matchMedia()

Returns a MediaQueryList object representing the specified media query string.

Window.moveBy()

Moves the current window by a specified amount.

Window.moveTo()

Moves the window to the specified coordinates.

Window.open()

Opens a new window.

Window.postMessage()

Provides a secure means for one window to send a string of data to another window, which need not be within the same domain as the first.

Window.print()

Opens the Print Dialog to print the current document.

Window.prompt()

Returns the text entered by the user in a prompt dialog.

Window.queryLocalFonts() 
Experimental
 Secure context

Returns a Promise that fulfills with an array of FontData objects representing the font faces available locally.

Window.queueMicrotask()

Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.

Window.reportError()

Reports an error in a script, emulating an unhandled exception.

Window.requestAnimationFrame()

Tells the browser that an animation is in progress, requesting that the browser schedule a repaint of the window for the next animation frame.

Window.requestIdleCallback()

Enables the scheduling of tasks during a browser's idle periods.

Window.resizeBy()

Resizes the current window by a certain amount.

Window.resizeTo()

Dynamically resizes window.

Window.scroll()

Scrolls the window to a particular place in the document.

Window.scrollBy()

Scrolls the document in the window by the given amount.

Window.scrollByLines() 
Non-standard


Scrolls the document by the given number of lines.

Window.scrollByPages() 
Non-standard


Scrolls the current document by the specified number of pages.

Window.scrollTo()

Scrolls to a particular set of coordinates in the document.

Window.setInterval()

Schedules a function to execute every time a given number of milliseconds elapses.

Window.setTimeout()

Schedules a function to execute in a given amount of time.

Window.showDirectoryPicker() 
Experimental
 Secure context

Displays a directory picker which allows the user to select a directory.

Window.showOpenFilePicker() 
Experimental
 Secure context

Shows a file picker that allows a user to select a file or multiple files.

Window.showSaveFilePicker() 
Experimental
 Secure context

Shows a file picker that allows a user to save a file.

Window.sizeToContent() 
Non-standard


Sizes the window according to its content.

Window.stop()

This method stops window loading.

Window.structuredClone()

Creates a deep clone of a given value using the structured clone algorithm.

Deprecated methods
Window.captureEvents() 
Deprecated


Registers the window to capture all events of the specified type.

Window.clearImmediate() 
Non-standard
 
Deprecated


Cancels the repeated execution set using setImmediate().

Window.releaseEvents() 
Deprecated


Releases the window from trapping events of a specific type.

Window.requestFileSystem() 
Non-standard
 
Deprecated


Lets a website or app gain access to a sandboxed file system for its own use.

Window.setImmediate() 
Non-standard
 
Deprecated


Executes a function after the browser has finished other heavy tasks.

Window.setResizable() 
Non-standard
 
Deprecated


Does nothing (no-op). Kept for backward compatibility with Netscape 4.x.

Window.showModalDialog() 
Non-standard
 
Deprecated


Displays a modal dialog.

Window.webkitConvertPointFromNodeToPage() 
Non-standard
 
Deprecated


Transforms a WebKitPoint from the node's coordinate system to the page's coordinate system.

Window.webkitConvertPointFromPageToNode() 
Non-standard
 
Deprecated


Transforms a WebKitPoint from the page's coordinate system to the node's coordinate system.

EventsListen to these events using addEventListener() or by assigning an event listener to the oneventname property of this interface. In addition to the events listed below, many events can bubble from the Document contained in the window object.

error

Fired when a resource failed to load, or can't be used. For example, if a script has an execution error or an image can't be found or is invalid.

languagechange

Fired at the global scope object when the user's preferred language changes.

resize

Fired when the window has been resized.

storage

Fired when a storage area (localStorage or sessionStorage) has been modified in the context of another document.

Clipboard events
copy

Fired when the user initiates a copy action through the browser's user interface.
Also available via the oncopy property.

cut

Fired when the user initiates a cut action through the browser's user interface.
Also available via the oncut property.

paste

Fired when the user initiates a paste action through the browser's user interface.
Also available via the onpaste property.

Connection events
offline

Fired when the browser has lost access to the network and the value of navigator.onLine has switched to false.

online

Fired when the browser has gained access to the network and the value of navigator.onLine has switched to true.

Device orientation events
devicemotion Secure context

Fired at a regular interval, indicating the amount of physical force of acceleration the device is receiving and the rate of rotation, if available.

deviceorientation Secure context

Fired when fresh data is available from the magnetometer orientation sensor about the current orientation of the device as compared to the Earth coordinate frame.

deviceorientationabsolute Secure context

Fired when fresh data is available from the magnetometer orientation sensor about the current absolute orientation of the device as compared to the Earth coordinate frame.

Focus events
blur

Fired when an element has lost focus.

focus

Fired when an element has gained focus.

Gamepad events
gamepadconnected

Fired when the browser detects that a gamepad has been connected or the first time a button/axis of the gamepad is used.

gamepaddisconnected

Fired when the browser detects that a gamepad has been disconnected.

History events
hashchange

Fired when the fragment identifier of the URL has changed (the part of the URL beginning with and following the # symbol).

pagehide

Sent when the browser hides the current document while in the process of switching to displaying in its place a different document from the session's history. This happens, for example, when the user clicks the Back button or when they click the Forward button to move ahead in session history.

pagereveal

Fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender).

pageshow

Sent when the browser makes the document visible due to navigation tasks, including not only when the page is first loaded, but also situations such as the user navigating back to the page after having navigated to another within the same tab.

pageswap

Fired when a document is about to be unloaded due to a navigation.

popstate

Fired when the active history entry changes.

Load & unload events
beforeunload

Fired when the window, the document and its resources are about to be unloaded.

load

Fired when the whole page has loaded, including all dependent resources such as stylesheets images.

unload 
Deprecated


Fired when the document or a child resource is being unloaded.

Manifest events
appinstalled

Fired when the browser has successfully installed a page as an application.

beforeinstallprompt

Fired when a user is about to be prompted to install a web application.

Messaging events
message

Fired when the window receives a message, for example from a call to Window.postMessage() from another browsing context.

messageerror

Fired when a Window object receives a message that can't be deserialized.

Print events
afterprint

Fired after the associated document has started printing or the print preview has been closed.

beforeprint

Fired when the associated document is about to be printed or previewed for printing.

Promise rejection events
rejectionhandled

Sent every time a JavaScript Promise is rejected, regardless of whether or not there is a handler in place to catch the rejection.

unhandledrejection

Sent when a JavaScript Promise is rejected but there is no handler in place to catch the rejection.

Scroll events
scrollsnapchange 
Experimental


Fired on the scroll container at the end of a scrolling operation when a new scroll snap target has been selected.

scrollsnapchanging 
Experimental


Fired on the scroll container when the browser determines a new scroll snap target is pending, i.e., it will be selected when the current scroll gesture ends.

Deprecated events
orientationchange 
Deprecated


Fired when the orientation of the device has changed.

vrdisplayactivate 
Deprecated
 
Non-standard


Fired when a display is able to be presented to.

vrdisplayconnect 
Deprecated
 
Non-standard


Fired when a compatible VR device has been connected to the computer.

vrdisplaydisconnect 
Deprecated
 
Non-standard


Fired when a compatible VR device has been disconnected from the computer.

vrdisplaydeactivate 
Deprecated
 
Non-standard


Fired when a display can no longer be presented to.

vrdisplaypresentchange 
Deprecated
 
Non-standard


Fired when the presenting state of a VR device changes — i.e., goes from presenting to not presenting, or vice versa.

Bubbled eventsNot all events that bubble can reach the Window object. Only the following do and can be listened for on the Window object:

abort
auxclick
beforeinput
beforematch
beforetoggle
cancel
canplay
canplaythrough
change
click
close
contextlost
contextmenu
contextrestored
copy
cuechange
cut
dblclick
drag
dragend
dragenter
dragleave
dragover
dragstart
drop
durationchange
emptied
ended
formdata
input
invalid
keydown
keypress
keyup
loadeddata
loadedmetadata
loadstart
mousedown
mouseenter
mouseleave
mousemove
mouseout
mouseover
mouseup
paste
pause
play
playing
progress
ratechange
reset
scrollend
securitypolicyviolation
seeked
seeking
select
slotchange
stalled
submit
suspend
timeupdate
toggle
volumechange
waiting
wheel
InterfacesSee DOM Reference.Listening for events on WindowHTML elements have three ways to listen for events:

Add an event listener to the element using the EventTarget.addEventListener method.
Assign an event handler to the element's oneventname property in JavaScript.
Add an on-prefixed attribute to the element in the HTML.

To listen for events on Window objects, in general, you can only use the first two methods, because Window has no corresponding HTML element. However, there's a specific group of events whose listeners can be added to the <body> (or the deprecated <frameset>) element that's owned by the Window's document, using the second or third methods. These events are:

afterprint
beforeprint
beforeunload
blur
error
focus
hashchange
languagechange
load
message
messageerror
offline
online
pagehide
pagereveal
pageshow
pageswap
popstate
rejectionhandled
resize
scroll
storage
unhandledrejection
unload

This means the following are strictly equivalent:
jswindow.onresize = (e) => console.log(e.currentTarget);
document.body.onresize = (e) => console.log(e.currentTarget);

html<body onresize="console.log(event.currentTarget)"></body>

In all three cases, you see the Window object logged as currentTarget.SpecificationsSpecificationHTML # the-window-objectBrowser compatibility\n\nWindowBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Window interface represents a window containing a DOM document; the document property points to the DOM document loaded in that window.
A window for a given document can be obtained using the document.defaultView property.
A global variable, window, representing the window in which the script is running, is exposed to JavaScript code.
The Window interface is home to a variety of functions, namespaces, objects, and constructors which are not necessarily directly associated with the concept of a user interface window. However, the Window interface is a suitable place to include these items that need to be globally available. Many of these are documented in the JavaScript Reference and the DOM Reference.
In a tabbed browser, each tab is represented by its own Window object; the global window seen by JavaScript code running within a given tab always represents the tab in which the code is running. That said, even in a tabbed browser, some properties and methods still apply to the overall window that contains the tab, such as resizeTo() and innerHeight. Generally, anything that can't reasonably pertain to a tab pertains to the window instead.
Instance propertiesThis interface inherits properties from the EventTarget interface.
Note that properties which are objects (e.g., for overriding the prototype of built-in elements) are listed in a separate section below.

Window.caches Read only Secure context

Returns the CacheStorage object associated with the current context. This object enables functionality such as storing assets for offline use, and generating custom responses to requests.

Window.clientInformation Read only

An alias for Window.navigator.

Window.closed Read only

This property indicates whether the current window is closed or not.

Window.cookieStore Read only Secure context

Returns a reference to the CookieStore object for the current document context.

Window.credentialless Read only 
Experimental


Returns a boolean that indicates whether the current document was loaded inside a credentialless <iframe>. See IFrame credentialless for more details.

Window.crossOriginIsolated Read only

Returns a boolean value that indicates whether the website is in a cross-origin isolation state.

Window.crypto Read only

Returns the Crypto object associated to the global object.

Window.customElements Read only

Returns a reference to the CustomElementRegistry object, which can be used to register new custom elements and get information about previously registered custom elements.

Window.devicePixelRatio Read only

Returns the ratio between physical pixels and device independent pixels in the current display.

Window.document Read only

Returns a reference to the document that the window contains.

Window.documentPictureInPicture Read only 
Experimental
 Secure context

Returns a reference to the document Picture-in-Picture window for the current document context.

Window.fence Read only 
Experimental


Returns a Fence object instance for the current document context. Available only to documents embedded inside a <fencedframe>.

Window.frameElement Read only

Returns the element in which the window is embedded, or null if the window is not embedded.

Window.frames Read only

Returns an array of the subframes in the current window.

Window.fullScreen 
Non-standard


This property indicates whether the window is displayed in full screen or not.

Window.history Read only

Returns a reference to the history object.

Window.indexedDB Read only

Provides a mechanism for applications to asynchronously access capabilities of indexed databases; returns an IDBFactory object.

Window.innerHeight Read only

Gets the height of the content area of the browser window including, if rendered, the horizontal scrollbar.

Window.innerWidth Read only

Gets the width of the content area of the browser window including, if rendered, the vertical scrollbar.

Window.isSecureContext Read only

Returns a boolean indicating whether the current context is secure (true) or not (false).

Window.launchQueue Read only 
Experimental


When a progressive web app (PWA) is launched with a launch_handler client_mode value of focus-existing, navigate-new, or navigate-existing, the launchQueue provides access to the LaunchQueue class, which allows custom launch navigation handling to be implemented for the PWA.

Window.length Read only

Returns the number of frames in the window. See also window.frames.

Window.localStorage Read only

Returns a reference to the local storage object used to store data that may only be accessed by the origin that created it.

Window.location

Gets/sets the location, or current URL, of the window object.

Window.locationbar Read only

Returns the locationbar object.

Window.menubar Read only

Returns the menubar object.

Window.mozInnerScreenX Read only 
Non-standard


Returns the horizontal (X) coordinate of the top-left corner of the window's viewport, in screen coordinates. This value is reported in CSS pixels. See mozScreenPixelsPerCSSPixel in nsIDOMWindowUtils for a conversion factor to adapt to screen pixels if needed.

Window.mozInnerScreenY Read only 
Non-standard


Returns the vertical (Y) coordinate of the top-left corner of the window's viewport, in screen coordinates. This value is reported in CSS pixels. See mozScreenPixelsPerCSSPixel for a conversion factor to adapt to screen pixels if needed.

Window.name

Gets/sets the name of the window.

Window.navigation Read only 
Experimental


Returns the current window's associated Navigation object. The entry point for the Navigation API.

Window.navigator Read only

Returns a reference to the navigator object.

Window.opener

Returns a reference to the window that opened this current window.

Window.origin Read only

Returns the global object's origin, serialized as a string.

Window.originAgentCluster Read only

Returns true if this window belongs to an origin-keyed agent cluster.

Window.outerHeight Read only

Gets the height of the outside of the browser window.

Window.outerWidth Read only

Gets the width of the outside of the browser window.

Window.pageXOffset Read only

An alias for window.scrollX.

Window.pageYOffset Read only

An alias for window.scrollY.

Window.parent Read only

Returns a reference to the parent of the current window or subframe.

Window.performance Read only

Returns a Performance object, which includes the timing and navigation attributes, each of which is an object providing performance-related data. See also Using Navigation Timing for additional information and examples.

Window.personalbar Read only

Returns the personalbar object.

Window.scheduler Read only

Returns the Scheduler object associated with the current context. This is the entry point for using the Prioritized Task Scheduling API.

Window.screen Read only

Returns a reference to the screen object associated with the window.

Window.screenX and Window.screenLeft Read only

Both properties return the horizontal distance from the left border of the user's browser viewport to the left side of the screen.

Window.screenY and Window.screenTop Read only

Both properties return the vertical distance from the top border of the user's browser viewport to the top side of the screen.

Window.scrollbars Read only

Returns the scrollbars object.

Window.scrollMaxX 
Non-standard
 Read only

The maximum offset that the window can be scrolled to horizontally, that is the document width minus the viewport width.

Window.scrollMaxY 
Non-standard
 Read only

The maximum offset that the window can be scrolled to vertically (i.e., the document height minus the viewport height).

Window.scrollX Read only

Returns the number of pixels that the document has already been scrolled horizontally.

Window.scrollY Read only

Returns the number of pixels that the document has already been scrolled vertically.

Window.self Read only

Returns an object reference to the window object itself.

Window.sessionStorage

Returns a reference to the session storage object used to store data that may only be accessed by the origin that created it.

Window.sharedStorage Read only 
Experimental
 Secure context

Returns the WindowSharedStorage object for the current origin. This is the main entry point for writing data to shared storage using the Shared Storage API.

Window.speechSynthesis Read only

Returns a SpeechSynthesis object, which is the entry point into using Web Speech API speech synthesis functionality.

Window.statusbar Read only

Returns the statusbar object.

Window.toolbar Read only

Returns the toolbar object.

Window.top Read only

Returns a reference to the topmost window in the window hierarchy. This property is read only.

Window.trustedTypes Read only

Returns the TrustedTypePolicyFactory object associated with the global object, providing the entry point for using the Trusted Types API.

Window.visualViewport Read only

Returns a VisualViewport object which represents the visual viewport for a given window.

Window.window Read only

Returns a reference to the current window.

window[0], window[1], etc.

Returns a reference to the window object in the frames. See Window.frames for more details.

Deprecated properties
Window.event 
Deprecated
 Read only

Returns the current event, which is the event currently being handled by the JavaScript code's context, or undefined if no event is currently being handled. The Event object passed directly to event handlers should be used instead whenever possible.

Window.external 
Deprecated
 Read only

Returns an object with functions for adding external search providers to the browser.

Window.orientation 
Deprecated
 Read only

Returns the orientation in degrees (in 90 degree increments) of the viewport relative to the device's natural orientation.

Window.status 
Deprecated


Gets/sets the text in the statusbar at the bottom of the browser.

Instance methodsThis interface inherits methods from the EventTarget interface.

Window.atob()

Decodes a string of data which has been encoded using base-64 encoding.

Window.alert()

Displays an alert dialog.

Window.blur() 
Deprecated


Sets focus away from the window.

Window.btoa()

Creates a base-64 encoded ASCII string from a string of binary data.

Window.cancelAnimationFrame()

Enables you to cancel a callback previously scheduled with Window.requestAnimationFrame.

Window.cancelIdleCallback()

Enables you to cancel a callback previously scheduled with Window.requestIdleCallback.

Window.clearInterval()

Cancels the repeated execution set using Window.setInterval().

Window.clearTimeout()

Cancels the delayed execution set using Window.setTimeout().

Window.close()

Closes the current window.

Window.confirm()

Displays a dialog with a message that the user needs to respond to.

Window.createImageBitmap()

Accepts a variety of different image sources, and returns a Promise which resolves to an ImageBitmap. Optionally the source is cropped to the rectangle of pixels originating at (sx, sy) with width sw, and height sh.

Window.dump() 
Non-standard


Writes a message to the console.

Window.fetch()

Starts the process of fetching a resource from the network.

Window.fetchLater() 
Experimental


Creates a deferred fetch, which is sent once the page is navigated away from (it is destroyed or enters the bfcache), or after a provided activateAfter timeout — whichever comes first.

Window.find() 
Non-standard


Searches for a given string in a window.

Window.focus()

Sets focus on the current window.

Window.getComputedStyle()

Gets computed style for the specified element. Computed style indicates the computed values of all CSS properties of the element.

Window.getDefaultComputedStyle() 
Non-standard


Gets default computed style for the specified element, ignoring author stylesheets.

Window.getScreenDetails() 
Experimental
 Secure context

Returns a Promise that fulfills with a ScreenDetails object instance representing the details of all the screens available to the user's device.

Window.getSelection()

Returns the selection object representing the selected item(s).

Window.matchMedia()

Returns a MediaQueryList object representing the specified media query string.

Window.moveBy()

Moves the current window by a specified amount.

Window.moveTo()

Moves the window to the specified coordinates.

Window.open()

Opens a new window.

Window.postMessage()

Provides a secure means for one window to send a string of data to another window, which need not be within the same domain as the first.

Window.print()

Opens the Print Dialog to print the current document.

Window.prompt()

Returns the text entered by the user in a prompt dialog.

Window.queryLocalFonts() 
Experimental
 Secure context

Returns a Promise that fulfills with an array of FontData objects representing the font faces available locally.

Window.queueMicrotask()

Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.

Window.reportError()

Reports an error in a script, emulating an unhandled exception.

Window.requestAnimationFrame()

Tells the browser that an animation is in progress, requesting that the browser schedule a repaint of the window for the next animation frame.

Window.requestIdleCallback()

Enables the scheduling of tasks during a browser's idle periods.

Window.resizeBy()

Resizes the current window by a certain amount.

Window.resizeTo()

Dynamically resizes window.

Window.scroll()

Scrolls the window to a particular place in the document.

Window.scrollBy()

Scrolls the document in the window by the given amount.

Window.scrollByLines() 
Non-standard


Scrolls the document by the given number of lines.

Window.scrollByPages() 
Non-standard


Scrolls the current document by the specified number of pages.

Window.scrollTo()

Scrolls to a particular set of coordinates in the document.

Window.setInterval()

Schedules a function to execute every time a given number of milliseconds elapses.

Window.setTimeout()

Schedules a function to execute in a given amount of time.

Window.showDirectoryPicker() 
Experimental
 Secure context

Displays a directory picker which allows the user to select a directory.

Window.showOpenFilePicker() 
Experimental
 Secure context

Shows a file picker that allows a user to select a file or multiple files.

Window.showSaveFilePicker() 
Experimental
 Secure context

Shows a file picker that allows a user to save a file.

Window.sizeToContent() 
Non-standard


Sizes the window according to its content.

Window.stop()

This method stops window loading.

Window.structuredClone()

Creates a deep clone of a given value using the structured clone algorithm.

Deprecated methods
Window.captureEvents() 
Deprecated


Registers the window to capture all events of the specified type.

Window.clearImmediate() 
Non-standard
 
Deprecated


Cancels the repeated execution set using setImmediate().

Window.releaseEvents() 
Deprecated


Releases the window from trapping events of a specific type.

Window.requestFileSystem() 
Non-standard
 
Deprecated


Lets a website or app gain access to a sandboxed file system for its own use.

Window.setImmediate() 
Non-standard
 
Deprecated


Executes a function after the browser has finished other heavy tasks.

Window.setResizable() 
Non-standard
 
Deprecated


Does nothing (no-op). Kept for backward compatibility with Netscape 4.x.

Window.showModalDialog() 
Non-standard
 
Deprecated


Displays a modal dialog.

Window.webkitConvertPointFromNodeToPage() 
Non-standard
 
Deprecated


Transforms a WebKitPoint from the node's coordinate system to the page's coordinate system.

Window.webkitConvertPointFromPageToNode() 
Non-standard
 
Deprecated


Transforms a WebKitPoint from the page's coordinate system to the node's coordinate system.

EventsListen to these events using addEventListener() or by assigning an event listener to the oneventname property of this interface. In addition to the events listed below, many events can bubble from the Document contained in the window object.

error

Fired when a resource failed to load, or can't be used. For example, if a script has an execution error or an image can't be found or is invalid.

languagechange

Fired at the global scope object when the user's preferred language changes.

resize

Fired when the window has been resized.

storage

Fired when a storage area (localStorage or sessionStorage) has been modified in the context of another document.

Clipboard events
copy

Fired when the user initiates a copy action through the browser's user interface.
Also available via the oncopy property.

cut

Fired when the user initiates a cut action through the browser's user interface.
Also available via the oncut property.

paste

Fired when the user initiates a paste action through the browser's user interface.
Also available via the onpaste property.

Connection events
offline

Fired when the browser has lost access to the network and the value of navigator.onLine has switched to false.

online

Fired when the browser has gained access to the network and the value of navigator.onLine has switched to true.

Device orientation events
devicemotion Secure context

Fired at a regular interval, indicating the amount of physical force of acceleration the device is receiving and the rate of rotation, if available.

deviceorientation Secure context

Fired when fresh data is available from the magnetometer orientation sensor about the current orientation of the device as compared to the Earth coordinate frame.

deviceorientationabsolute Secure context

Fired when fresh data is available from the magnetometer orientation sensor about the current absolute orientation of the device as compared to the Earth coordinate frame.

Focus events
blur

Fired when an element has lost focus.

focus

Fired when an element has gained focus.

Gamepad events
gamepadconnected

Fired when the browser detects that a gamepad has been connected or the first time a button/axis of the gamepad is used.

gamepaddisconnected

Fired when the browser detects that a gamepad has been disconnected.

History events
hashchange

Fired when the fragment identifier of the URL has changed (the part of the URL beginning with and following the # symbol).

pagehide

Sent when the browser hides the current document while in the process of switching to displaying in its place a different document from the session's history. This happens, for example, when the user clicks the Back button or when they click the Forward button to move ahead in session history.

pagereveal

Fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender).

pageshow

Sent when the browser makes the document visible due to navigation tasks, including not only when the page is first loaded, but also situations such as the user navigating back to the page after having navigated to another within the same tab.

pageswap

Fired when a document is about to be unloaded due to a navigation.

popstate

Fired when the active history entry changes.

Load & unload events
beforeunload

Fired when the window, the document and its resources are about to be unloaded.

load

Fired when the whole page has loaded, including all dependent resources such as stylesheets images.

unload 
Deprecated


Fired when the document or a child resource is being unloaded.

Manifest events
appinstalled

Fired when the browser has successfully installed a page as an application.

beforeinstallprompt

Fired when a user is about to be prompted to install a web application.

Messaging events
message

Fired when the window receives a message, for example from a call to Window.postMessage() from another browsing context.

messageerror

Fired when a Window object receives a message that can't be deserialized.

Print events
afterprint

Fired after the associated document has started printing or the print preview has been closed.

beforeprint

Fired when the associated document is about to be printed or previewed for printing.

Promise rejection events
rejectionhandled

Sent every time a JavaScript Promise is rejected, regardless of whether or not there is a handler in place to catch the rejection.

unhandledrejection

Sent when a JavaScript Promise is rejected but there is no handler in place to catch the rejection.

Scroll events
scrollsnapchange 
Experimental


Fired on the scroll container at the end of a scrolling operation when a new scroll snap target has been selected.

scrollsnapchanging 
Experimental


Fired on the scroll container when the browser determines a new scroll snap target is pending, i.e., it will be selected when the current scroll gesture ends.

Deprecated events
orientationchange 
Deprecated


Fired when the orientation of the device has changed.

vrdisplayactivate 
Deprecated
 
Non-standard


Fired when a display is able to be presented to.

vrdisplayconnect 
Deprecated
 
Non-standard


Fired when a compatible VR device has been connected to the computer.

vrdisplaydisconnect 
Deprecated
 
Non-standard


Fired when a compatible VR device has been disconnected from the computer.

vrdisplaydeactivate 
Deprecated
 
Non-standard


Fired when a display can no longer be presented to.

vrdisplaypresentchange 
Deprecated
 
Non-standard


Fired when the presenting state of a VR device changes — i.e., goes from presenting to not presenting, or vice versa.

Bubbled eventsNot all events that bubble can reach the Window object. Only the following do and can be listened for on the Window object:

abort
auxclick
beforeinput
beforematch
beforetoggle
cancel
canplay
canplaythrough
change
click
close
contextlost
contextmenu
contextrestored
copy
cuechange
cut
dblclick
drag
dragend
dragenter
dragleave
dragover
dragstart
drop
durationchange
emptied
ended
formdata
input
invalid
keydown
keypress
keyup
loadeddata
loadedmetadata
loadstart
mousedown
mouseenter
mouseleave
mousemove
mouseout
mouseover
mouseup
paste
pause
play
playing
progress
ratechange
reset
scrollend
securitypolicyviolation
seeked
seeking
select
slotchange
stalled
submit
suspend
timeupdate
toggle
volumechange
waiting
wheel
InterfacesSee DOM Reference.Listening for events on WindowHTML elements have three ways to listen for events:

Add an event listener to the element using the EventTarget.addEventListener method.
Assign an event handler to the element's oneventname property in JavaScript.
Add an on-prefixed attribute to the element in the HTML.

To listen for events on Window objects, in general, you can only use the first two methods, because Window has no corresponding HTML element. However, there's a specific group of events whose listeners can be added to the <body> (or the deprecated <frameset>) element that's owned by the Window's document, using the second or third methods. These events are:

afterprint
beforeprint
beforeunload
blur
error
focus
hashchange
languagechange
load
message
messageerror
offline
online
pagehide
pagereveal
pageshow
pageswap
popstate
rejectionhandled
resize
scroll
storage
unhandledrejection
unload

This means the following are strictly equivalent:
jswindow.onresize = (e) => console.log(e.currentTarget);
document.body.onresize = (e) => console.log(e.currentTarget);

html<body onresize="console.log(event.currentTarget)"></body>

In all three cases, you see the Window object logged as currentTarget.SpecificationsSpecificationHTML # the-window-objectBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWindowBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Window interface represents a window containing a DOM document; the document property points to the DOM document loaded in that window.
A window for a given document can be obtained using the document.defaultView property.
A global variable, window, representing the window in which the script is running, is exposed to JavaScript code.
The Window interface is home to a variety of functions, namespaces, objects, and constructors which are not necessarily directly associated with the concept of a user interface window. However, the Window interface is a suitable place to include these items that need to be globally available. Many of these are documented in the JavaScript Reference and the DOM Reference.
In a tabbed browser, each tab is represented by its own Window object; the global window seen by JavaScript code running within a given tab always represents the tab in which the code is running. That said, even in a tabbed browser, some properties and methods still apply to the overall window that contains the tab, such as resizeTo() and innerHeight. Generally, anything that can't reasonably pertain to a tab pertains to the window instead.
Instance propertiesThis interface inherits properties from the EventTarget interface.
Note that properties which are objects (e.g., for overriding the prototype of built-in elements) are listed in a separate section below.

Window.caches Read only Secure context

Returns the CacheStorage object associated with the current context. This object enables functionality such as storing assets for offline use, and generating custom responses to requests.

Window.clientInformation Read only

An alias for Window.navigator.

Window.closed Read only

This property indicates whether the current window is closed or not.

Window.cookieStore Read only Secure context

Returns a reference to the CookieStore object for the current document context.

Window.credentialless Read only 
Experimental


Returns a boolean that indicates whether the current document was loaded inside a credentialless <iframe>. See IFrame credentialless for more details.

Window.crossOriginIsolated Read only

Returns a boolean value that indicates whether the website is in a cross-origin isolation state.

Window.crypto Read only

Returns the Crypto object associated to the global object.

Window.customElements Read only

Returns a reference to the CustomElementRegistry object, which can be used to register new custom elements and get information about previously registered custom elements.

Window.devicePixelRatio Read only

Returns the ratio between physical pixels and device independent pixels in the current display.

Window.document Read only

Returns a reference to the document that the window contains.

Window.documentPictureInPicture Read only 
Experimental
 Secure context

Returns a reference to the document Picture-in-Picture window for the current document context.

Window.fence Read only 
Experimental


Returns a Fence object instance for the current document context. Available only to documents embedded inside a <fencedframe>.

Window.frameElement Read only

Returns the element in which the window is embedded, or null if the window is not embedded.

Window.frames Read only

Returns an array of the subframes in the current window.

Window.fullScreen 
Non-standard


This property indicates whether the window is displayed in full screen or not.

Window.history Read only

Returns a reference to the history object.

Window.indexedDB Read only

Provides a mechanism for applications to asynchronously access capabilities of indexed databases; returns an IDBFactory object.

Window.innerHeight Read only

Gets the height of the content area of the browser window including, if rendered, the horizontal scrollbar.

Window.innerWidth Read only

Gets the width of the content area of the browser window including, if rendered, the vertical scrollbar.

Window.isSecureContext Read only

Returns a boolean indicating whether the current context is secure (true) or not (false).

Window.launchQueue Read only 
Experimental


When a progressive web app (PWA) is launched with a launch_handler client_mode value of focus-existing, navigate-new, or navigate-existing, the launchQueue provides access to the LaunchQueue class, which allows custom launch navigation handling to be implemented for the PWA.

Window.length Read only

Returns the number of frames in the window. See also window.frames.

Window.localStorage Read only

Returns a reference to the local storage object used to store data that may only be accessed by the origin that created it.

Window.location

Gets/sets the location, or current URL, of the window object.

Window.locationbar Read only

Returns the locationbar object.

Window.menubar Read only

Returns the menubar object.

Window.mozInnerScreenX Read only 
Non-standard


Returns the horizontal (X) coordinate of the top-left corner of the window's viewport, in screen coordinates. This value is reported in CSS pixels. See mozScreenPixelsPerCSSPixel in nsIDOMWindowUtils for a conversion factor to adapt to screen pixels if needed.

Window.mozInnerScreenY Read only 
Non-standard


Returns the vertical (Y) coordinate of the top-left corner of the window's viewport, in screen coordinates. This value is reported in CSS pixels. See mozScreenPixelsPerCSSPixel for a conversion factor to adapt to screen pixels if needed.

Window.name

Gets/sets the name of the window.

Window.navigation Read only 
Experimental


Returns the current window's associated Navigation object. The entry point for the Navigation API.

Window.navigator Read only

Returns a reference to the navigator object.

Window.opener

Returns a reference to the window that opened this current window.

Window.origin Read only

Returns the global object's origin, serialized as a string.

Window.originAgentCluster Read only

Returns true if this window belongs to an origin-keyed agent cluster.

Window.outerHeight Read only

Gets the height of the outside of the browser window.

Window.outerWidth Read only

Gets the width of the outside of the browser window.

Window.pageXOffset Read only

An alias for window.scrollX.

Window.pageYOffset Read only

An alias for window.scrollY.

Window.parent Read only

Returns a reference to the parent of the current window or subframe.

Window.performance Read only

Returns a Performance object, which includes the timing and navigation attributes, each of which is an object providing performance-related data. See also Using Navigation Timing for additional information and examples.

Window.personalbar Read only

Returns the personalbar object.

Window.scheduler Read only

Returns the Scheduler object associated with the current context. This is the entry point for using the Prioritized Task Scheduling API.

Window.screen Read only

Returns a reference to the screen object associated with the window.

Window.screenX and Window.screenLeft Read only

Both properties return the horizontal distance from the left border of the user's browser viewport to the left side of the screen.

Window.screenY and Window.screenTop Read only

Both properties return the vertical distance from the top border of the user's browser viewport to the top side of the screen.

Window.scrollbars Read only

Returns the scrollbars object.

Window.scrollMaxX 
Non-standard
 Read only

The maximum offset that the window can be scrolled to horizontally, that is the document width minus the viewport width.

Window.scrollMaxY 
Non-standard
 Read only

The maximum offset that the window can be scrolled to vertically (i.e., the document height minus the viewport height).

Window.scrollX Read only

Returns the number of pixels that the document has already been scrolled horizontally.

Window.scrollY Read only

Returns the number of pixels that the document has already been scrolled vertically.

Window.self Read only

Returns an object reference to the window object itself.

Window.sessionStorage

Returns a reference to the session storage object used to store data that may only be accessed by the origin that created it.

Window.sharedStorage Read only 
Experimental
 Secure context

Returns the WindowSharedStorage object for the current origin. This is the main entry point for writing data to shared storage using the Shared Storage API.

Window.speechSynthesis Read only

Returns a SpeechSynthesis object, which is the entry point into using Web Speech API speech synthesis functionality.

Window.statusbar Read only

Returns the statusbar object.

Window.toolbar Read only

Returns the toolbar object.

Window.top Read only

Returns a reference to the topmost window in the window hierarchy. This property is read only.

Window.trustedTypes Read only

Returns the TrustedTypePolicyFactory object associated with the global object, providing the entry point for using the Trusted Types API.

Window.visualViewport Read only

Returns a VisualViewport object which represents the visual viewport for a given window.

Window.window Read only

Returns a reference to the current window.

window[0], window[1], etc.

Returns a reference to the window object in the frames. See Window.frames for more details.

Deprecated properties
Window.event 
Deprecated
 Read only

Returns the current event, which is the event currently being handled by the JavaScript code's context, or undefined if no event is currently being handled. The Event object passed directly to event handlers should be used instead whenever possible.

Window.external 
Deprecated
 Read only

Returns an object with functions for adding external search providers to the browser.

Window.orientation 
Deprecated
 Read only

Returns the orientation in degrees (in 90 degree increments) of the viewport relative to the device's natural orientation.

Window.status 
Deprecated


Gets/sets the text in the statusbar at the bottom of the browser.

Instance methodsThis interface inherits methods from the EventTarget interface.

Window.atob()

Decodes a string of data which has been encoded using base-64 encoding.

Window.alert()

Displays an alert dialog.

Window.blur() 
Deprecated


Sets focus away from the window.

Window.btoa()

Creates a base-64 encoded ASCII string from a string of binary data.

Window.cancelAnimationFrame()

Enables you to cancel a callback previously scheduled with Window.requestAnimationFrame.

Window.cancelIdleCallback()

Enables you to cancel a callback previously scheduled with Window.requestIdleCallback.

Window.clearInterval()

Cancels the repeated execution set using Window.setInterval().

Window.clearTimeout()

Cancels the delayed execution set using Window.setTimeout().

Window.close()

Closes the current window.

Window.confirm()

Displays a dialog with a message that the user needs to respond to.

Window.createImageBitmap()

Accepts a variety of different image sources, and returns a Promise which resolves to an ImageBitmap. Optionally the source is cropped to the rectangle of pixels originating at (sx, sy) with width sw, and height sh.

Window.dump() 
Non-standard


Writes a message to the console.

Window.fetch()

Starts the process of fetching a resource from the network.

Window.fetchLater() 
Experimental


Creates a deferred fetch, which is sent once the page is navigated away from (it is destroyed or enters the bfcache), or after a provided activateAfter timeout — whichever comes first.

Window.find() 
Non-standard


Searches for a given string in a window.

Window.focus()

Sets focus on the current window.

Window.getComputedStyle()

Gets computed style for the specified element. Computed style indicates the computed values of all CSS properties of the element.

Window.getDefaultComputedStyle() 
Non-standard


Gets default computed style for the specified element, ignoring author stylesheets.

Window.getScreenDetails() 
Experimental
 Secure context

Returns a Promise that fulfills with a ScreenDetails object instance representing the details of all the screens available to the user's device.

Window.getSelection()

Returns the selection object representing the selected item(s).

Window.matchMedia()

Returns a MediaQueryList object representing the specified media query string.

Window.moveBy()

Moves the current window by a specified amount.

Window.moveTo()

Moves the window to the specified coordinates.

Window.open()

Opens a new window.

Window.postMessage()

Provides a secure means for one window to send a string of data to another window, which need not be within the same domain as the first.

Window.print()

Opens the Print Dialog to print the current document.

Window.prompt()

Returns the text entered by the user in a prompt dialog.

Window.queryLocalFonts() 
Experimental
 Secure context

Returns a Promise that fulfills with an array of FontData objects representing the font faces available locally.

Window.queueMicrotask()

Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.

Window.reportError()

Reports an error in a script, emulating an unhandled exception.

Window.requestAnimationFrame()

Tells the browser that an animation is in progress, requesting that the browser schedule a repaint of the window for the next animation frame.

Window.requestIdleCallback()

Enables the scheduling of tasks during a browser's idle periods.

Window.resizeBy()

Resizes the current window by a certain amount.

Window.resizeTo()

Dynamically resizes window.

Window.scroll()

Scrolls the window to a particular place in the document.

Window.scrollBy()

Scrolls the document in the window by the given amount.

Window.scrollByLines() 
Non-standard


Scrolls the document by the given number of lines.

Window.scrollByPages() 
Non-standard


Scrolls the current document by the specified number of pages.

Window.scrollTo()

Scrolls to a particular set of coordinates in the document.

Window.setInterval()

Schedules a function to execute every time a given number of milliseconds elapses.

Window.setTimeout()

Schedules a function to execute in a given amount of time.

Window.showDirectoryPicker() 
Experimental
 Secure context

Displays a directory picker which allows the user to select a directory.

Window.showOpenFilePicker() 
Experimental
 Secure context

Shows a file picker that allows a user to select a file or multiple files.

Window.showSaveFilePicker() 
Experimental
 Secure context

Shows a file picker that allows a user to save a file.

Window.sizeToContent() 
Non-standard


Sizes the window according to its content.

Window.stop()

This method stops window loading.

Window.structuredClone()

Creates a deep clone of a given value using the structured clone algorithm.

Deprecated methods
Window.captureEvents() 
Deprecated


Registers the window to capture all events of the specified type.

Window.clearImmediate() 
Non-standard
 
Deprecated


Cancels the repeated execution set using setImmediate().

Window.releaseEvents() 
Deprecated


Releases the window from trapping events of a specific type.

Window.requestFileSystem() 
Non-standard
 
Deprecated


Lets a website or app gain access to a sandboxed file system for its own use.

Window.setImmediate() 
Non-standard
 
Deprecated


Executes a function after the browser has finished other heavy tasks.

Window.setResizable() 
Non-standard
 
Deprecated


Does nothing (no-op). Kept for backward compatibility with Netscape 4.x.

Window.showModalDialog() 
Non-standard
 
Deprecated


Displays a modal dialog.

Window.webkitConvertPointFromNodeToPage() 
Non-standard
 
Deprecated


Transforms a WebKitPoint from the node's coordinate system to the page's coordinate system.

Window.webkitConvertPointFromPageToNode() 
Non-standard
 
Deprecated


Transforms a WebKitPoint from the page's coordinate system to the node's coordinate system.

EventsListen to these events using addEventListener() or by assigning an event listener to the oneventname property of this interface. In addition to the events listed below, many events can bubble from the Document contained in the window object.

error

Fired when a resource failed to load, or can't be used. For example, if a script has an execution error or an image can't be found or is invalid.

languagechange

Fired at the global scope object when the user's preferred language changes.

resize

Fired when the window has been resized.

storage

Fired when a storage area (localStorage or sessionStorage) has been modified in the context of another document.

Clipboard events
copy

Fired when the user initiates a copy action through the browser's user interface.
Also available via the oncopy property.

cut

Fired when the user initiates a cut action through the browser's user interface.
Also available via the oncut property.

paste

Fired when the user initiates a paste action through the browser's user interface.
Also available via the onpaste property.

Connection events
offline

Fired when the browser has lost access to the network and the value of navigator.onLine has switched to false.

online

Fired when the browser has gained access to the network and the value of navigator.onLine has switched to true.

Device orientation events
devicemotion Secure context

Fired at a regular interval, indicating the amount of physical force of acceleration the device is receiving and the rate of rotation, if available.

deviceorientation Secure context

Fired when fresh data is available from the magnetometer orientation sensor about the current orientation of the device as compared to the Earth coordinate frame.

deviceorientationabsolute Secure context

Fired when fresh data is available from the magnetometer orientation sensor about the current absolute orientation of the device as compared to the Earth coordinate frame.

Focus events
blur

Fired when an element has lost focus.

focus

Fired when an element has gained focus.

Gamepad events
gamepadconnected

Fired when the browser detects that a gamepad has been connected or the first time a button/axis of the gamepad is used.

gamepaddisconnected

Fired when the browser detects that a gamepad has been disconnected.

History events
hashchange

Fired when the fragment identifier of the URL has changed (the part of the URL beginning with and following the # symbol).

pagehide

Sent when the browser hides the current document while in the process of switching to displaying in its place a different document from the session's history. This happens, for example, when the user clicks the Back button or when they click the Forward button to move ahead in session history.

pagereveal

Fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender).

pageshow

Sent when the browser makes the document visible due to navigation tasks, including not only when the page is first loaded, but also situations such as the user navigating back to the page after having navigated to another within the same tab.

pageswap

Fired when a document is about to be unloaded due to a navigation.

popstate

Fired when the active history entry changes.

Load & unload events
beforeunload

Fired when the window, the document and its resources are about to be unloaded.

load

Fired when the whole page has loaded, including all dependent resources such as stylesheets images.

unload 
Deprecated


Fired when the document or a child resource is being unloaded.

Manifest events
appinstalled

Fired when the browser has successfully installed a page as an application.

beforeinstallprompt

Fired when a user is about to be prompted to install a web application.

Messaging events
message

Fired when the window receives a message, for example from a call to Window.postMessage() from another browsing context.

messageerror

Fired when a Window object receives a message that can't be deserialized.

Print events
afterprint

Fired after the associated document has started printing or the print preview has been closed.

beforeprint

Fired when the associated document is about to be printed or previewed for printing.

Promise rejection events
rejectionhandled

Sent every time a JavaScript Promise is rejected, regardless of whether or not there is a handler in place to catch the rejection.

unhandledrejection

Sent when a JavaScript Promise is rejected but there is no handler in place to catch the rejection.

Scroll events
scrollsnapchange 
Experimental


Fired on the scroll container at the end of a scrolling operation when a new scroll snap target has been selected.

scrollsnapchanging 
Experimental


Fired on the scroll container when the browser determines a new scroll snap target is pending, i.e., it will be selected when the current scroll gesture ends.

Deprecated events
orientationchange 
Deprecated


Fired when the orientation of the device has changed.

vrdisplayactivate 
Deprecated
 
Non-standard


Fired when a display is able to be presented to.

vrdisplayconnect 
Deprecated
 
Non-standard


Fired when a compatible VR device has been connected to the computer.

vrdisplaydisconnect 
Deprecated
 
Non-standard


Fired when a compatible VR device has been disconnected from the computer.

vrdisplaydeactivate 
Deprecated
 
Non-standard


Fired when a display can no longer be presented to.

vrdisplaypresentchange 
Deprecated
 
Non-standard


Fired when the presenting state of a VR device changes — i.e., goes from presenting to not presenting, or vice versa.

Bubbled eventsNot all events that bubble can reach the Window object. Only the following do and can be listened for on the Window object:

abort
auxclick
beforeinput
beforematch
beforetoggle
cancel
canplay
canplaythrough
change
click
close
contextlost
contextmenu
contextrestored
copy
cuechange
cut
dblclick
drag
dragend
dragenter
dragleave
dragover
dragstart
drop
durationchange
emptied
ended
formdata
input
invalid
keydown
keypress
keyup
loadeddata
loadedmetadata
loadstart
mousedown
mouseenter
mouseleave
mousemove
mouseout
mouseover
mouseup
paste
pause
play
playing
progress
ratechange
reset
scrollend
securitypolicyviolation
seeked
seeking
select
slotchange
stalled
submit
suspend
timeupdate
toggle
volumechange
waiting
wheel
InterfacesSee DOM Reference.Listening for events on WindowHTML elements have three ways to listen for events:

Add an event listener to the element using the EventTarget.addEventListener method.
Assign an event handler to the element's oneventname property in JavaScript.
Add an on-prefixed attribute to the element in the HTML.

To listen for events on Window objects, in general, you can only use the first two methods, because Window has no corresponding HTML element. However, there's a specific group of events whose listeners can be added to the <body> (or the deprecated <frameset>) element that's owned by the Window's document, using the second or third methods. These events are:

afterprint
beforeprint
beforeunload
blur
error
focus
hashchange
languagechange
load
message
messageerror
offline
online
pagehide
pagereveal
pageshow
pageswap
popstate
rejectionhandled
resize
scroll
storage
unhandledrejection
unload

This means the following are strictly equivalent:
jswindow.onresize = (e) => console.log(e.currentTarget);
document.body.onresize = (e) => console.log(e.currentTarget);

html<body onresize="console.log(event.currentTarget)"></body>

In all three cases, you see the Window object logged as currentTarget.SpecificationsSpecificationHTML # the-window-objectBrowser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWorkerGlobalScopeBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Web Workers.
The WorkerGlobalScope interface of the Web Workers API is an interface representing the scope of any worker. Workers have no browsing context; this scope contains the information usually conveyed by Window objects — in this case event handlers, the console or the associated WorkerNavigator object. Each WorkerGlobalScope has its own event loop.
This interface is usually specialized by each worker type: DedicatedWorkerGlobalScope for dedicated workers, SharedWorkerGlobalScope for shared workers, and ServiceWorkerGlobalScope for ServiceWorker. The self property returns the specialized scope for each context.
Instance propertiesThis interface inherits properties from the EventTarget interface.

WorkerGlobalScope.caches Read only Secure context

Returns the CacheStorage object associated with the current context. This object enables functionality such as storing assets for offline use, and generating custom responses to requests.

WorkerGlobalScope.crossOriginIsolated Read only

Returns a boolean value that indicates whether the website is in a cross-origin isolation state.

WorkerGlobalScope.crypto Read only

Returns the Crypto object associated to the global object.

WorkerGlobalScope.fonts Read only

Returns the FontFaceSet associated with the worker.

WorkerGlobalScope.indexedDB Read only

Provides a mechanism for workers to asynchronously access capabilities of indexed databases; returns an IDBFactory object.

WorkerGlobalScope.isSecureContext Read only

Returns a boolean indicating whether the current context is secure (true) or not (false).

WorkerGlobalScope.location Read only

Returns the WorkerLocation associated with the worker. It is a specific location object, mostly a subset of the Location for browsing scopes, but adapted to workers.

WorkerGlobalScope.navigator Read only

Returns the WorkerNavigator associated with the worker. It is a specific navigator object, mostly a subset of the Navigator for browsing scopes, but adapted to workers.

WorkerGlobalScope.origin Read only

Returns the global object's origin, serialized as a string.

WorkerGlobalScope.performance Read only

Returns the Performance associated with the worker. Only a subset of the properties and methods of the Performance interface are available to workers.

WorkerGlobalScope.scheduler Read only

Returns the Scheduler object associated with the current context. This is the entry point for using the Prioritized Task Scheduling API.

WorkerGlobalScope.trustedTypes Read only

Returns the TrustedTypePolicyFactory object associated with the global object, providing the entry point for using the Trusted Types API.

WorkerGlobalScope.self Read only

Returns a reference to the WorkerGlobalScope itself. Most of the time it is a specific scope like DedicatedWorkerGlobalScope, SharedWorkerGlobalScope or ServiceWorkerGlobalScope.

Instance methodsThis interface inherits methods from the EventTarget interface.

WorkerGlobalScope.atob()

Decodes a string of data which has been encoded using base-64 encoding.

WorkerGlobalScope.btoa()

Creates a base-64 encoded ASCII string from a string of binary data.

WorkerGlobalScope.clearInterval()

Cancels the repeated execution set using WorkerGlobalScope.setInterval().

WorkerGlobalScope.clearTimeout()

Cancels the delayed execution set using WorkerGlobalScope.setTimeout().

WorkerGlobalScope.createImageBitmap()

Accepts a variety of different image sources, and returns a Promise which resolves to an ImageBitmap. Optionally the source is cropped to the rectangle of pixels originating at (sx, sy) with width sw, and height sh.

WorkerGlobalScope.dump() 
Deprecated
 
Non-standard


Allows you to write a message to stdout — i.e., in your terminal. This is the same as Firefox's window.dump, but for workers.

WorkerGlobalScope.fetch()

Starts the process of fetching a resource from the network.

WorkerGlobalScope.importScripts()

Imports one or more scripts into the worker's scope. You can specify as many as you'd like, separated by commas. For example: importScripts('foo.js', 'bar.js');.

WorkerGlobalScope.queueMicrotask()

Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.

WorkerGlobalScope.setInterval()

Schedules a function to execute every time a given number of milliseconds elapses.

WorkerGlobalScope.setTimeout()

Schedules a function to execute in a given amount of time.

WorkerGlobalScope.structuredClone()

Creates a deep clone of a given value using the structured clone algorithm.

WorkerGlobalScope.reportError()

Reports an error in a script, emulating an unhandled exception.

Events
error

Fired when an error occurred.

languagechange

Fired at the global/worker scope object when the user's preferred languages change.

offline

Fired when the browser has lost access to the network and the value of navigator.onLine switched to false.

online

Fired when the browser has gained access to the network and the value of navigator.onLine switched to true.

rejectionhandled

Fired on handled Promise rejection events.

securitypolicyviolation

Fired when a Content Security Policy is violated.

unhandledrejection

Fired on unhandled Promise rejection events.

ExampleYou won't access WorkerGlobalScope directly in your code; however, its properties and methods are inherited by more specific global scopes such as DedicatedWorkerGlobalScope and SharedWorkerGlobalScope. For example, you could import another script into the worker and print out the contents of the worker scope's navigator object using the following two lines:
jsimportScripts("foo.js");
console.log(navigator);


Note:
Since the global scope of the worker script is effectively the global scope of the worker you are running (DedicatedWorkerGlobalScope or whatever) and all worker global scopes inherit methods, properties, etc. from WorkerGlobalScope, you can run lines such as those above without specifying a parent object.
SpecificationsSpecificationHTML # the-workerglobalscope-common-interfaceBrowser compatibilitySee also
Other global object interface: Window, DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, ServiceWorkerGlobalScope
Other Worker-related interfaces: Worker, WorkerLocation and WorkerNavigator
Using web workers\n\nWorkerGlobalScopeBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Web Workers.
The WorkerGlobalScope interface of the Web Workers API is an interface representing the scope of any worker. Workers have no browsing context; this scope contains the information usually conveyed by Window objects — in this case event handlers, the console or the associated WorkerNavigator object. Each WorkerGlobalScope has its own event loop.
This interface is usually specialized by each worker type: DedicatedWorkerGlobalScope for dedicated workers, SharedWorkerGlobalScope for shared workers, and ServiceWorkerGlobalScope for ServiceWorker. The self property returns the specialized scope for each context.
Instance propertiesThis interface inherits properties from the EventTarget interface.

WorkerGlobalScope.caches Read only Secure context

Returns the CacheStorage object associated with the current context. This object enables functionality such as storing assets for offline use, and generating custom responses to requests.

WorkerGlobalScope.crossOriginIsolated Read only

Returns a boolean value that indicates whether the website is in a cross-origin isolation state.

WorkerGlobalScope.crypto Read only

Returns the Crypto object associated to the global object.

WorkerGlobalScope.fonts Read only

Returns the FontFaceSet associated with the worker.

WorkerGlobalScope.indexedDB Read only

Provides a mechanism for workers to asynchronously access capabilities of indexed databases; returns an IDBFactory object.

WorkerGlobalScope.isSecureContext Read only

Returns a boolean indicating whether the current context is secure (true) or not (false).

WorkerGlobalScope.location Read only

Returns the WorkerLocation associated with the worker. It is a specific location object, mostly a subset of the Location for browsing scopes, but adapted to workers.

WorkerGlobalScope.navigator Read only

Returns the WorkerNavigator associated with the worker. It is a specific navigator object, mostly a subset of the Navigator for browsing scopes, but adapted to workers.

WorkerGlobalScope.origin Read only

Returns the global object's origin, serialized as a string.

WorkerGlobalScope.performance Read only

Returns the Performance associated with the worker. Only a subset of the properties and methods of the Performance interface are available to workers.

WorkerGlobalScope.scheduler Read only

Returns the Scheduler object associated with the current context. This is the entry point for using the Prioritized Task Scheduling API.

WorkerGlobalScope.trustedTypes Read only

Returns the TrustedTypePolicyFactory object associated with the global object, providing the entry point for using the Trusted Types API.

WorkerGlobalScope.self Read only

Returns a reference to the WorkerGlobalScope itself. Most of the time it is a specific scope like DedicatedWorkerGlobalScope, SharedWorkerGlobalScope or ServiceWorkerGlobalScope.

Instance methodsThis interface inherits methods from the EventTarget interface.

WorkerGlobalScope.atob()

Decodes a string of data which has been encoded using base-64 encoding.

WorkerGlobalScope.btoa()

Creates a base-64 encoded ASCII string from a string of binary data.

WorkerGlobalScope.clearInterval()

Cancels the repeated execution set using WorkerGlobalScope.setInterval().

WorkerGlobalScope.clearTimeout()

Cancels the delayed execution set using WorkerGlobalScope.setTimeout().

WorkerGlobalScope.createImageBitmap()

Accepts a variety of different image sources, and returns a Promise which resolves to an ImageBitmap. Optionally the source is cropped to the rectangle of pixels originating at (sx, sy) with width sw, and height sh.

WorkerGlobalScope.dump() 
Deprecated
 
Non-standard


Allows you to write a message to stdout — i.e., in your terminal. This is the same as Firefox's window.dump, but for workers.

WorkerGlobalScope.fetch()

Starts the process of fetching a resource from the network.

WorkerGlobalScope.importScripts()

Imports one or more scripts into the worker's scope. You can specify as many as you'd like, separated by commas. For example: importScripts('foo.js', 'bar.js');.

WorkerGlobalScope.queueMicrotask()

Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.

WorkerGlobalScope.setInterval()

Schedules a function to execute every time a given number of milliseconds elapses.

WorkerGlobalScope.setTimeout()

Schedules a function to execute in a given amount of time.

WorkerGlobalScope.structuredClone()

Creates a deep clone of a given value using the structured clone algorithm.

WorkerGlobalScope.reportError()

Reports an error in a script, emulating an unhandled exception.

Events
error

Fired when an error occurred.

languagechange

Fired at the global/worker scope object when the user's preferred languages change.

offline

Fired when the browser has lost access to the network and the value of navigator.onLine switched to false.

online

Fired when the browser has gained access to the network and the value of navigator.onLine switched to true.

rejectionhandled

Fired on handled Promise rejection events.

securitypolicyviolation

Fired when a Content Security Policy is violated.

unhandledrejection

Fired on unhandled Promise rejection events.

ExampleYou won't access WorkerGlobalScope directly in your code; however, its properties and methods are inherited by more specific global scopes such as DedicatedWorkerGlobalScope and SharedWorkerGlobalScope. For example, you could import another script into the worker and print out the contents of the worker scope's navigator object using the following two lines:
jsimportScripts("foo.js");
console.log(navigator);


Note:
Since the global scope of the worker script is effectively the global scope of the worker you are running (DedicatedWorkerGlobalScope or whatever) and all worker global scopes inherit methods, properties, etc. from WorkerGlobalScope, you can run lines such as those above without specifying a parent object.
SpecificationsSpecificationHTML # the-workerglobalscope-common-interfaceBrowser compatibilitySee also
Other global object interface: Window, DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, ServiceWorkerGlobalScope
Other Worker-related interfaces: Worker, WorkerLocation and WorkerNavigator
Using web workers
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWorkerGlobalScopeBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Web Workers.
The WorkerGlobalScope interface of the Web Workers API is an interface representing the scope of any worker. Workers have no browsing context; this scope contains the information usually conveyed by Window objects — in this case event handlers, the console or the associated WorkerNavigator object. Each WorkerGlobalScope has its own event loop.
This interface is usually specialized by each worker type: DedicatedWorkerGlobalScope for dedicated workers, SharedWorkerGlobalScope for shared workers, and ServiceWorkerGlobalScope for ServiceWorker. The self property returns the specialized scope for each context.
Instance propertiesThis interface inherits properties from the EventTarget interface.

WorkerGlobalScope.caches Read only Secure context

Returns the CacheStorage object associated with the current context. This object enables functionality such as storing assets for offline use, and generating custom responses to requests.

WorkerGlobalScope.crossOriginIsolated Read only

Returns a boolean value that indicates whether the website is in a cross-origin isolation state.

WorkerGlobalScope.crypto Read only

Returns the Crypto object associated to the global object.

WorkerGlobalScope.fonts Read only

Returns the FontFaceSet associated with the worker.

WorkerGlobalScope.indexedDB Read only

Provides a mechanism for workers to asynchronously access capabilities of indexed databases; returns an IDBFactory object.

WorkerGlobalScope.isSecureContext Read only

Returns a boolean indicating whether the current context is secure (true) or not (false).

WorkerGlobalScope.location Read only

Returns the WorkerLocation associated with the worker. It is a specific location object, mostly a subset of the Location for browsing scopes, but adapted to workers.

WorkerGlobalScope.navigator Read only

Returns the WorkerNavigator associated with the worker. It is a specific navigator object, mostly a subset of the Navigator for browsing scopes, but adapted to workers.

WorkerGlobalScope.origin Read only

Returns the global object's origin, serialized as a string.

WorkerGlobalScope.performance Read only

Returns the Performance associated with the worker. Only a subset of the properties and methods of the Performance interface are available to workers.

WorkerGlobalScope.scheduler Read only

Returns the Scheduler object associated with the current context. This is the entry point for using the Prioritized Task Scheduling API.

WorkerGlobalScope.trustedTypes Read only

Returns the TrustedTypePolicyFactory object associated with the global object, providing the entry point for using the Trusted Types API.

WorkerGlobalScope.self Read only

Returns a reference to the WorkerGlobalScope itself. Most of the time it is a specific scope like DedicatedWorkerGlobalScope, SharedWorkerGlobalScope or ServiceWorkerGlobalScope.

Instance methodsThis interface inherits methods from the EventTarget interface.

WorkerGlobalScope.atob()

Decodes a string of data which has been encoded using base-64 encoding.

WorkerGlobalScope.btoa()

Creates a base-64 encoded ASCII string from a string of binary data.

WorkerGlobalScope.clearInterval()

Cancels the repeated execution set using WorkerGlobalScope.setInterval().

WorkerGlobalScope.clearTimeout()

Cancels the delayed execution set using WorkerGlobalScope.setTimeout().

WorkerGlobalScope.createImageBitmap()

Accepts a variety of different image sources, and returns a Promise which resolves to an ImageBitmap. Optionally the source is cropped to the rectangle of pixels originating at (sx, sy) with width sw, and height sh.

WorkerGlobalScope.dump() 
Deprecated
 
Non-standard


Allows you to write a message to stdout — i.e., in your terminal. This is the same as Firefox's window.dump, but for workers.

WorkerGlobalScope.fetch()

Starts the process of fetching a resource from the network.

WorkerGlobalScope.importScripts()

Imports one or more scripts into the worker's scope. You can specify as many as you'd like, separated by commas. For example: importScripts('foo.js', 'bar.js');.

WorkerGlobalScope.queueMicrotask()

Queues a microtask to be executed at a safe time prior to control returning to the browser's event loop.

WorkerGlobalScope.setInterval()

Schedules a function to execute every time a given number of milliseconds elapses.

WorkerGlobalScope.setTimeout()

Schedules a function to execute in a given amount of time.

WorkerGlobalScope.structuredClone()

Creates a deep clone of a given value using the structured clone algorithm.

WorkerGlobalScope.reportError()

Reports an error in a script, emulating an unhandled exception.

Events
error

Fired when an error occurred.

languagechange

Fired at the global/worker scope object when the user's preferred languages change.

offline

Fired when the browser has lost access to the network and the value of navigator.onLine switched to false.

online

Fired when the browser has gained access to the network and the value of navigator.onLine switched to true.

rejectionhandled

Fired on handled Promise rejection events.

securitypolicyviolation

Fired when a Content Security Policy is violated.

unhandledrejection

Fired on unhandled Promise rejection events.

ExampleYou won't access WorkerGlobalScope directly in your code; however, its properties and methods are inherited by more specific global scopes such as DedicatedWorkerGlobalScope and SharedWorkerGlobalScope. For example, you could import another script into the worker and print out the contents of the worker scope's navigator object using the following two lines:
jsimportScripts("foo.js");
console.log(navigator);


Note:
Since the global scope of the worker script is effectively the global scope of the worker you are running (DedicatedWorkerGlobalScope or whatever) and all worker global scopes inherit methods, properties, etc. from WorkerGlobalScope, you can run lines such as those above without specifying a parent object.
SpecificationsSpecificationHTML # the-workerglobalscope-common-interfaceBrowser compatibilitySee also
Other global object interface: Window, DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, ServiceWorkerGlobalScope
Other Worker-related interfaces: Worker, WorkerLocation and WorkerNavigator
Using web workers
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nPromiseBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
To learn about the way promises work and how you can use them, we advise you to read Using promises first.DescriptionA Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.
A Promise is in one of these states:

pending: initial state, neither fulfilled nor rejected.
fulfilled: meaning that the operation was completed successfully.
rejected: meaning that the operation failed.

The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error).
When either of these options occur, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.
A promise is said to be settled if it is either fulfilled or rejected, but not pending.

You will also hear the term resolved used with promises — this means that the promise is settled or "locked-in" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, "resolved" promises are often equivalent to "fulfilled" promises, but as illustrated in "States and fates", resolved promises can be pending or rejected as well. For example:
jsnew Promise((resolveOuter) => {
  resolveOuter(
    new Promise((resolveInner) => {
      setTimeout(resolveInner, 1000);
    }),
  );
});

This promise is already resolved at the time when it's created (because the resolveOuter is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the "resolution" is often done behind the scenes and not observable, and only its fulfillment or rejection are.

Note:
Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call "promises", e.g., Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g., f = () => expression to create the lazily-evaluated expression, and f() to evaluate the expression immediately.

Promise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController.Chained PromisesThe promise methods then(), catch(), and finally() are used to associate further action with a promise that becomes settled. The then() method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The catch() and finally() methods call then() internally and make error handling less verbose. For example, a catch() is really just a then() without passing the fulfillment handler. As these methods return promises, they can be chained. For example:
jsconst myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);

We will use the following terminology: initial promise is the promise on which then is called; new promise is the promise returned by then. The two callbacks passed to then are called fulfillment handler and rejection handler, respectively.
The settled state of the initial promise determines which handler to execute.

If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value.
If the initial promise is rejected, the rejection handler is called with the rejection reason.

The completion of the handler determines the settled state of the new promise.

If the handler returns a thenable value, the new promise settles in the same state as the returned value.
If the handler returns a non-thenable value, the new promise is fulfilled with the returned value.
If the handler throws an error, the new promise is rejected with the thrown error.
If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise — that is, without a rejection handler, a rejected promise stays rejected with the same reason.

For example, in the code above, if myPromise rejects, handleRejectedA will be called, and if handleRejectedA completes normally (without throwing or returning a rejected promise), the promise returned by the first then will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final catch() handler.
jsmyPromise
  .then(handleFulfilledA)
  .then(handleFulfilledB)
  .then(handleFulfilledC)
  .catch(handleRejectedAny);

Using arrow functions for the callback functions, implementation of the promise chain might look something like this:
jsmyPromise
  .then((value) => `${value} and bar`)
  .then((value) => `${value} and bar again`)
  .then((value) => `${value} and again`)
  .then((value) => `${value} and again`)
  .then((value) => {
    console.log(value);
  })
  .catch((err) => {
    console.error(err);
  });


Note:
For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence.

JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the Promise() constructor, the handlers passed to then, or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue.
A promise can participate in more than one chain. For the following code, the fulfillment of promiseA will cause both handleFulfilled1 and handleFulfilled2 to be added to the job queue. Because handleFulfilled1 is registered first, it will be invoked first.
jsconst promiseA = new Promise(myExecutorFunc);
const promiseB = promiseA.then(handleFulfilled1, handleRejected1);
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);

An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already "settled" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous.
jsconst promiseA = new Promise((resolve, reject) => {
  resolve(777);
});
// At this point, "promiseA" is already settled.
promiseA.then((val) => console.log("asynchronous logging has val:", val));
console.log("immediate logging");

// produces output in this order:
// immediate logging
// asynchronous logging has val: 777
ThenablesThe JavaScript ecosystem had made multiple Promise implementations long before it became part of the language. Despite being represented differently internally, at the minimum, all Promise-like objects implement the Thenable interface. A thenable implements the .then() method, which is called with two callbacks: one for when the promise is fulfilled, one for when it's rejected. Promises are thenables as well.
To interoperate with the existing Promise implementations, the language allows using thenables in place of promises. For example, Promise.resolve will not only resolve promises, but also trace thenables.
jsconst aThenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      // The thenable is fulfilled with another thenable
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};

Promise.resolve(aThenable); // A promise fulfilled with 42
Promise concurrencyThe Promise class offers four static methods to facilitate async task concurrency:

Promise.all()

Fulfills when all of the promises fulfill; rejects when any of the promises rejects.

Promise.allSettled()

Fulfills when all promises settle.

Promise.any()

Fulfills when any of the promises fulfills; rejects when all of the promises reject.

Promise.race()

Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects.


All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor — accepting a single executor function that can be called with the resolve and reject callbacks as parameters. The subclass must also have a resolve static method that can be called like Promise.resolve() to resolve values to promises.
Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads.Constructor
Promise()

Creates a new Promise object. The constructor is primarily used to wrap functions that do not already support promises.

Static properties
Promise[Symbol.species]

Returns the constructor used to construct return values from promise methods.

Static methods
Promise.all()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises reject, with this first rejection reason.

Promise.allSettled()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises settle (including when an empty iterable is passed), with an array of objects that describe the outcome of each promise.

Promise.any()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when any of the input's promises fulfill, with this first fulfillment value. It rejects when all of the input's promises reject (including when an empty iterable is passed), with an AggregateError containing an array of rejection reasons.

Promise.race()

Takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.

Promise.reject()

Returns a new Promise object that is rejected with the given reason.

Promise.resolve()

Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e., has a then method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value.

Promise.try()

Takes a callback of any kind (returns or throws, synchronously or asynchronously) and wraps its result in a Promise.

Promise.withResolvers()

Returns an object containing a new Promise object and two functions to resolve or reject it, corresponding to the two parameters passed to the executor of the Promise() constructor.

Instance propertiesThese properties are defined on Promise.prototype and shared by all Promise instances.

Promise.prototype.constructor

The constructor function that created the instance object. For Promise instances, the initial value is the Promise constructor.

Promise.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Promise". This property is used in Object.prototype.toString().

Instance methods
Promise.prototype.catch()

Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.

Promise.prototype.finally()

Appends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected.

Promise.prototype.then()

Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e., if the relevant handler onFulfilled or onRejected is not a function).

ExamplesBasic ExampleIn this example, we use setTimeout(...) to simulate async code.
In reality, you will probably be using something like XHR or an HTML API.
jsconst myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously
  // was successful, and reject(...) when it failed.
  setTimeout(() => {
    resolve("Success!"); // Yay! Everything went well!
  }, 250);
});

myFirstPromise.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log(`Yay! ${successMessage}`);
});
Example with diverse situationsThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of .then() calls, and typically (but not necessarily) has a single .catch() at the end, optionally followed by .finally(). In this example, the promise chain is initiated by a custom-written new Promise() construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise.
The example function tetheredGetNumber() shows that a promise generator will utilize reject() while setting up an asynchronous call, or within the call-back, or both. The function promiseGetWord() illustrates how an API function might generate and return a promise in a self-contained manner.
Note that the function troubleWithGetNumber() ends with a throw. That is forced because a promise chain goes through all the .then() promises, even after an error, and without the throw, the error would seem "fixed". This is a hassle, and for this reason, it is common to omit onRejected throughout the chain of .then() promises, and just have a single onRejected in the final catch().
This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the threshold values.
js// To experiment with error handling, "threshold" values cause errors randomly
const THRESHOLD_A = 8; // can use zero 0 to guarantee error

function tetheredGetNumber(resolve, reject) {
  setTimeout(() => {
    const randomInt = Date.now();
    const value = randomInt % 10;
    if (value < THRESHOLD_A) {
      resolve(value);
    } else {
      reject(`Too large: ${value}`);
    }
  }, 500);
}

function determineParity(value) {
  const isOdd = value % 2 === 1;
  return { value, isOdd };
}

function troubleWithGetNumber(reason) {
  const err = new Error("Trouble getting number", { cause: reason });
  console.error(err);
  throw err;
}

function promiseGetWord(parityInfo) {
  return new Promise((resolve, reject) => {
    const { value, isOdd } = parityInfo;
    if (value >= THRESHOLD_A - 1) {
      reject(`Still too large: ${value}`);
    } else {
      parityInfo.wordEvenOdd = isOdd ? "odd" : "even";
      resolve(parityInfo);
    }
  });
}

new Promise(tetheredGetNumber)
  .then(determineParity, troubleWithGetNumber)
  .then(promiseGetWord)
  .then((info) => {
    console.log(`Got: ${info.value}, ${info.wordEvenOdd}`);
    return info;
  })
  .catch((reason) => {
    if (reason.cause) {
      console.error("Had previously handled error");
    } else {
      console.error(`Trouble with promiseGetWord(): ${reason}`);
    }
  })
  .finally((info) => console.log("All done"));
Advanced ExampleThis small example shows the mechanism of a Promise. The testPromise() method is called each time the <button> is clicked. It creates a promise that will be fulfilled, using setTimeout(), to the promise count (number starting from 1) every 1-3 seconds, at random. The Promise() constructor is used to create the promise.
The fulfillment of the promise is logged, via a fulfill callback set using p1.then(). A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise.
By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another.
HTML
html<button id="make-promise">Make a promise!</button>
<div id="log"></div>

JavaScript
js"use strict";

let promiseCount = 0;

function testPromise() {
  const thisPromiseCount = ++promiseCount;
  const log = document.getElementById("log");
  // begin
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Started<br>`);
  // We make a new promise: we promise a numeric count of this promise,
  // starting from 1 (after waiting 3s)
  const p1 = new Promise((resolve, reject) => {
    // The executor function is called with the ability
    // to resolve or reject the promise
    log.insertAdjacentHTML(
      "beforeend",
      `${thisPromiseCount}) Promise constructor<br>`,
    );
    // This is only an example to create asynchronism
    setTimeout(
      () => {
        // We fulfill the promise
        resolve(thisPromiseCount);
      },
      Math.random() * 2000 + 1000,
    );
  });

  // We define what to do when the promise is resolved with the then() call,
  // and what to do when the promise is rejected with the catch() call
  p1.then((val) => {
    // Log the fulfillment value
    log.insertAdjacentHTML("beforeend", `${val}) Promise fulfilled<br>`);
  }).catch((reason) => {
    // Log the rejection reason
    console.log(`Handle rejected promise (${reason}) here.`);
  });
  // end
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Promise made<br>`);
}

const btn = document.getElementById("make-promise");
btn.addEventListener("click", testPromise);

Result
Loading an image with XHRAnother example using Promise and XMLHttpRequest to load an image is shown below.
Each step is commented on and allows you to follow the Promise and XHR architecture closely.
<h1>Promise example</h1>

jsfunction imgLoad(url) {
  // Create new promise with the Promise() constructor;
  // This has as its argument a function with two parameters, resolve and reject
  return new Promise((resolve, reject) => {
    // XHR to load an image
    const request = new XMLHttpRequest();
    request.open("GET", url);
    request.responseType = "blob";
    // When the request loads, check whether it was successful
    request.onload = () => {
      if (request.status === 200) {
        // If successful, resolve the promise by passing back the request response
        resolve(request.response);
      } else {
        // If it fails, reject the promise with an error message
        reject(
          Error(
            `Image didn't load successfully; error code: + ${request.statusText}`,
          ),
        );
      }
    };
    // Handle network errors
    request.onerror = () => reject(new Error("There was a network error."));
    // Send the request
    request.send();
  });
}

// Get a reference to the body element, and create a new image object
const body = document.querySelector("body");
const myImage = new Image();
const imgUrl =
  "https://mdn.github.io/shared-assets/images/examples/round-balloon.png";

// Call the function with the URL we want to load, then chain the
// promise then() method with two callbacks
imgLoad(imgUrl).then(
  (response) => {
    // The first runs when the promise resolves, with the request.response
    // specified within the resolve() method.
    const imageURL = URL.createObjectURL(response);
    myImage.src = imageURL;
    body.appendChild(myImage);
  },
  (error) => {
    // The second runs when the promise
    // is rejected, and logs the Error specified with the reject() method.
    console.log(error);
  },
);

Incumbent settings object trackingA settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code.
To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like Array and Error. Each settings object has its own "copy" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call.
To illustrate this a bit further we can take a look at how an <iframe> embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built-in function — there is no user
  // code on the stack, so which realm do we use?
  setTimeout(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

The same concept applies to promises. If we modify the above example a little bit, we get this:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built in function — there is no user
  // code on the stack — which realm do we use?
  Promise.resolve(undefined).then(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

If we change this so that the <iframe> in the document is listening to post messages, we can observe the effect of the incumbent settings object:
html<!-- y.html -->
<!doctype html>
<iframe src="x.html"></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  Promise.resolve(undefined).then(bound);
</script>

html<!-- x.html -->
<!doctype html>
<script>
  window.addEventListener(
    "message",
    (event) => {
      document.querySelector("#text").textContent = "hello";
      // this code will only run in browsers that track the incumbent settings object
      console.log(event);
    },
    false,
  );
</script>

In the above example, the inner text of the <iframe> will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message.

Note:
Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-promise-objectsBrowser compatibilitySee also
Polyfill of Promise in core-js
Using promises guide
Promises/A+ specification
JavaScript Promises: an introduction on web.dev (2013)
Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript slide show by Domenic Denicola (2011)\n\nPromiseBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
To learn about the way promises work and how you can use them, we advise you to read Using promises first.DescriptionA Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.
A Promise is in one of these states:

pending: initial state, neither fulfilled nor rejected.
fulfilled: meaning that the operation was completed successfully.
rejected: meaning that the operation failed.

The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error).
When either of these options occur, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.
A promise is said to be settled if it is either fulfilled or rejected, but not pending.

You will also hear the term resolved used with promises — this means that the promise is settled or "locked-in" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, "resolved" promises are often equivalent to "fulfilled" promises, but as illustrated in "States and fates", resolved promises can be pending or rejected as well. For example:
jsnew Promise((resolveOuter) => {
  resolveOuter(
    new Promise((resolveInner) => {
      setTimeout(resolveInner, 1000);
    }),
  );
});

This promise is already resolved at the time when it's created (because the resolveOuter is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the "resolution" is often done behind the scenes and not observable, and only its fulfillment or rejection are.

Note:
Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call "promises", e.g., Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g., f = () => expression to create the lazily-evaluated expression, and f() to evaluate the expression immediately.

Promise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController.Chained PromisesThe promise methods then(), catch(), and finally() are used to associate further action with a promise that becomes settled. The then() method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The catch() and finally() methods call then() internally and make error handling less verbose. For example, a catch() is really just a then() without passing the fulfillment handler. As these methods return promises, they can be chained. For example:
jsconst myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);

We will use the following terminology: initial promise is the promise on which then is called; new promise is the promise returned by then. The two callbacks passed to then are called fulfillment handler and rejection handler, respectively.
The settled state of the initial promise determines which handler to execute.

If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value.
If the initial promise is rejected, the rejection handler is called with the rejection reason.

The completion of the handler determines the settled state of the new promise.

If the handler returns a thenable value, the new promise settles in the same state as the returned value.
If the handler returns a non-thenable value, the new promise is fulfilled with the returned value.
If the handler throws an error, the new promise is rejected with the thrown error.
If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise — that is, without a rejection handler, a rejected promise stays rejected with the same reason.

For example, in the code above, if myPromise rejects, handleRejectedA will be called, and if handleRejectedA completes normally (without throwing or returning a rejected promise), the promise returned by the first then will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final catch() handler.
jsmyPromise
  .then(handleFulfilledA)
  .then(handleFulfilledB)
  .then(handleFulfilledC)
  .catch(handleRejectedAny);

Using arrow functions for the callback functions, implementation of the promise chain might look something like this:
jsmyPromise
  .then((value) => `${value} and bar`)
  .then((value) => `${value} and bar again`)
  .then((value) => `${value} and again`)
  .then((value) => `${value} and again`)
  .then((value) => {
    console.log(value);
  })
  .catch((err) => {
    console.error(err);
  });


Note:
For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence.

JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the Promise() constructor, the handlers passed to then, or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue.
A promise can participate in more than one chain. For the following code, the fulfillment of promiseA will cause both handleFulfilled1 and handleFulfilled2 to be added to the job queue. Because handleFulfilled1 is registered first, it will be invoked first.
jsconst promiseA = new Promise(myExecutorFunc);
const promiseB = promiseA.then(handleFulfilled1, handleRejected1);
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);

An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already "settled" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous.
jsconst promiseA = new Promise((resolve, reject) => {
  resolve(777);
});
// At this point, "promiseA" is already settled.
promiseA.then((val) => console.log("asynchronous logging has val:", val));
console.log("immediate logging");

// produces output in this order:
// immediate logging
// asynchronous logging has val: 777
ThenablesThe JavaScript ecosystem had made multiple Promise implementations long before it became part of the language. Despite being represented differently internally, at the minimum, all Promise-like objects implement the Thenable interface. A thenable implements the .then() method, which is called with two callbacks: one for when the promise is fulfilled, one for when it's rejected. Promises are thenables as well.
To interoperate with the existing Promise implementations, the language allows using thenables in place of promises. For example, Promise.resolve will not only resolve promises, but also trace thenables.
jsconst aThenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      // The thenable is fulfilled with another thenable
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};

Promise.resolve(aThenable); // A promise fulfilled with 42
Promise concurrencyThe Promise class offers four static methods to facilitate async task concurrency:

Promise.all()

Fulfills when all of the promises fulfill; rejects when any of the promises rejects.

Promise.allSettled()

Fulfills when all promises settle.

Promise.any()

Fulfills when any of the promises fulfills; rejects when all of the promises reject.

Promise.race()

Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects.


All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor — accepting a single executor function that can be called with the resolve and reject callbacks as parameters. The subclass must also have a resolve static method that can be called like Promise.resolve() to resolve values to promises.
Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads.Constructor
Promise()

Creates a new Promise object. The constructor is primarily used to wrap functions that do not already support promises.

Static properties
Promise[Symbol.species]

Returns the constructor used to construct return values from promise methods.

Static methods
Promise.all()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises reject, with this first rejection reason.

Promise.allSettled()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises settle (including when an empty iterable is passed), with an array of objects that describe the outcome of each promise.

Promise.any()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when any of the input's promises fulfill, with this first fulfillment value. It rejects when all of the input's promises reject (including when an empty iterable is passed), with an AggregateError containing an array of rejection reasons.

Promise.race()

Takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.

Promise.reject()

Returns a new Promise object that is rejected with the given reason.

Promise.resolve()

Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e., has a then method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value.

Promise.try()

Takes a callback of any kind (returns or throws, synchronously or asynchronously) and wraps its result in a Promise.

Promise.withResolvers()

Returns an object containing a new Promise object and two functions to resolve or reject it, corresponding to the two parameters passed to the executor of the Promise() constructor.

Instance propertiesThese properties are defined on Promise.prototype and shared by all Promise instances.

Promise.prototype.constructor

The constructor function that created the instance object. For Promise instances, the initial value is the Promise constructor.

Promise.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Promise". This property is used in Object.prototype.toString().

Instance methods
Promise.prototype.catch()

Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.

Promise.prototype.finally()

Appends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected.

Promise.prototype.then()

Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e., if the relevant handler onFulfilled or onRejected is not a function).

ExamplesBasic ExampleIn this example, we use setTimeout(...) to simulate async code.
In reality, you will probably be using something like XHR or an HTML API.
jsconst myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously
  // was successful, and reject(...) when it failed.
  setTimeout(() => {
    resolve("Success!"); // Yay! Everything went well!
  }, 250);
});

myFirstPromise.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log(`Yay! ${successMessage}`);
});
Example with diverse situationsThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of .then() calls, and typically (but not necessarily) has a single .catch() at the end, optionally followed by .finally(). In this example, the promise chain is initiated by a custom-written new Promise() construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise.
The example function tetheredGetNumber() shows that a promise generator will utilize reject() while setting up an asynchronous call, or within the call-back, or both. The function promiseGetWord() illustrates how an API function might generate and return a promise in a self-contained manner.
Note that the function troubleWithGetNumber() ends with a throw. That is forced because a promise chain goes through all the .then() promises, even after an error, and without the throw, the error would seem "fixed". This is a hassle, and for this reason, it is common to omit onRejected throughout the chain of .then() promises, and just have a single onRejected in the final catch().
This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the threshold values.
js// To experiment with error handling, "threshold" values cause errors randomly
const THRESHOLD_A = 8; // can use zero 0 to guarantee error

function tetheredGetNumber(resolve, reject) {
  setTimeout(() => {
    const randomInt = Date.now();
    const value = randomInt % 10;
    if (value < THRESHOLD_A) {
      resolve(value);
    } else {
      reject(`Too large: ${value}`);
    }
  }, 500);
}

function determineParity(value) {
  const isOdd = value % 2 === 1;
  return { value, isOdd };
}

function troubleWithGetNumber(reason) {
  const err = new Error("Trouble getting number", { cause: reason });
  console.error(err);
  throw err;
}

function promiseGetWord(parityInfo) {
  return new Promise((resolve, reject) => {
    const { value, isOdd } = parityInfo;
    if (value >= THRESHOLD_A - 1) {
      reject(`Still too large: ${value}`);
    } else {
      parityInfo.wordEvenOdd = isOdd ? "odd" : "even";
      resolve(parityInfo);
    }
  });
}

new Promise(tetheredGetNumber)
  .then(determineParity, troubleWithGetNumber)
  .then(promiseGetWord)
  .then((info) => {
    console.log(`Got: ${info.value}, ${info.wordEvenOdd}`);
    return info;
  })
  .catch((reason) => {
    if (reason.cause) {
      console.error("Had previously handled error");
    } else {
      console.error(`Trouble with promiseGetWord(): ${reason}`);
    }
  })
  .finally((info) => console.log("All done"));
Advanced ExampleThis small example shows the mechanism of a Promise. The testPromise() method is called each time the <button> is clicked. It creates a promise that will be fulfilled, using setTimeout(), to the promise count (number starting from 1) every 1-3 seconds, at random. The Promise() constructor is used to create the promise.
The fulfillment of the promise is logged, via a fulfill callback set using p1.then(). A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise.
By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another.
HTML
html<button id="make-promise">Make a promise!</button>
<div id="log"></div>

JavaScript
js"use strict";

let promiseCount = 0;

function testPromise() {
  const thisPromiseCount = ++promiseCount;
  const log = document.getElementById("log");
  // begin
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Started<br>`);
  // We make a new promise: we promise a numeric count of this promise,
  // starting from 1 (after waiting 3s)
  const p1 = new Promise((resolve, reject) => {
    // The executor function is called with the ability
    // to resolve or reject the promise
    log.insertAdjacentHTML(
      "beforeend",
      `${thisPromiseCount}) Promise constructor<br>`,
    );
    // This is only an example to create asynchronism
    setTimeout(
      () => {
        // We fulfill the promise
        resolve(thisPromiseCount);
      },
      Math.random() * 2000 + 1000,
    );
  });

  // We define what to do when the promise is resolved with the then() call,
  // and what to do when the promise is rejected with the catch() call
  p1.then((val) => {
    // Log the fulfillment value
    log.insertAdjacentHTML("beforeend", `${val}) Promise fulfilled<br>`);
  }).catch((reason) => {
    // Log the rejection reason
    console.log(`Handle rejected promise (${reason}) here.`);
  });
  // end
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Promise made<br>`);
}

const btn = document.getElementById("make-promise");
btn.addEventListener("click", testPromise);

Result
Loading an image with XHRAnother example using Promise and XMLHttpRequest to load an image is shown below.
Each step is commented on and allows you to follow the Promise and XHR architecture closely.
<h1>Promise example</h1>

jsfunction imgLoad(url) {
  // Create new promise with the Promise() constructor;
  // This has as its argument a function with two parameters, resolve and reject
  return new Promise((resolve, reject) => {
    // XHR to load an image
    const request = new XMLHttpRequest();
    request.open("GET", url);
    request.responseType = "blob";
    // When the request loads, check whether it was successful
    request.onload = () => {
      if (request.status === 200) {
        // If successful, resolve the promise by passing back the request response
        resolve(request.response);
      } else {
        // If it fails, reject the promise with an error message
        reject(
          Error(
            `Image didn't load successfully; error code: + ${request.statusText}`,
          ),
        );
      }
    };
    // Handle network errors
    request.onerror = () => reject(new Error("There was a network error."));
    // Send the request
    request.send();
  });
}

// Get a reference to the body element, and create a new image object
const body = document.querySelector("body");
const myImage = new Image();
const imgUrl =
  "https://mdn.github.io/shared-assets/images/examples/round-balloon.png";

// Call the function with the URL we want to load, then chain the
// promise then() method with two callbacks
imgLoad(imgUrl).then(
  (response) => {
    // The first runs when the promise resolves, with the request.response
    // specified within the resolve() method.
    const imageURL = URL.createObjectURL(response);
    myImage.src = imageURL;
    body.appendChild(myImage);
  },
  (error) => {
    // The second runs when the promise
    // is rejected, and logs the Error specified with the reject() method.
    console.log(error);
  },
);

Incumbent settings object trackingA settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code.
To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like Array and Error. Each settings object has its own "copy" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call.
To illustrate this a bit further we can take a look at how an <iframe> embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built-in function — there is no user
  // code on the stack, so which realm do we use?
  setTimeout(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

The same concept applies to promises. If we modify the above example a little bit, we get this:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built in function — there is no user
  // code on the stack — which realm do we use?
  Promise.resolve(undefined).then(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

If we change this so that the <iframe> in the document is listening to post messages, we can observe the effect of the incumbent settings object:
html<!-- y.html -->
<!doctype html>
<iframe src="x.html"></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  Promise.resolve(undefined).then(bound);
</script>

html<!-- x.html -->
<!doctype html>
<script>
  window.addEventListener(
    "message",
    (event) => {
      document.querySelector("#text").textContent = "hello";
      // this code will only run in browsers that track the incumbent settings object
      console.log(event);
    },
    false,
  );
</script>

In the above example, the inner text of the <iframe> will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message.

Note:
Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-promise-objectsBrowser compatibilitySee also
Polyfill of Promise in core-js
Using promises guide
Promises/A+ specification
JavaScript Promises: an introduction on web.dev (2013)
Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript slide show by Domenic Denicola (2011)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nPromiseBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackThe Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
To learn about the way promises work and how you can use them, we advise you to read Using promises first.DescriptionA Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.
A Promise is in one of these states:

pending: initial state, neither fulfilled nor rejected.
fulfilled: meaning that the operation was completed successfully.
rejected: meaning that the operation failed.

The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error).
When either of these options occur, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.
A promise is said to be settled if it is either fulfilled or rejected, but not pending.

You will also hear the term resolved used with promises — this means that the promise is settled or "locked-in" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, "resolved" promises are often equivalent to "fulfilled" promises, but as illustrated in "States and fates", resolved promises can be pending or rejected as well. For example:
jsnew Promise((resolveOuter) => {
  resolveOuter(
    new Promise((resolveInner) => {
      setTimeout(resolveInner, 1000);
    }),
  );
});

This promise is already resolved at the time when it's created (because the resolveOuter is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the "resolution" is often done behind the scenes and not observable, and only its fulfillment or rejection are.

Note:
Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call "promises", e.g., Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g., f = () => expression to create the lazily-evaluated expression, and f() to evaluate the expression immediately.

Promise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController.Chained PromisesThe promise methods then(), catch(), and finally() are used to associate further action with a promise that becomes settled. The then() method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The catch() and finally() methods call then() internally and make error handling less verbose. For example, a catch() is really just a then() without passing the fulfillment handler. As these methods return promises, they can be chained. For example:
jsconst myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);

We will use the following terminology: initial promise is the promise on which then is called; new promise is the promise returned by then. The two callbacks passed to then are called fulfillment handler and rejection handler, respectively.
The settled state of the initial promise determines which handler to execute.

If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value.
If the initial promise is rejected, the rejection handler is called with the rejection reason.

The completion of the handler determines the settled state of the new promise.

If the handler returns a thenable value, the new promise settles in the same state as the returned value.
If the handler returns a non-thenable value, the new promise is fulfilled with the returned value.
If the handler throws an error, the new promise is rejected with the thrown error.
If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise — that is, without a rejection handler, a rejected promise stays rejected with the same reason.

For example, in the code above, if myPromise rejects, handleRejectedA will be called, and if handleRejectedA completes normally (without throwing or returning a rejected promise), the promise returned by the first then will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final catch() handler.
jsmyPromise
  .then(handleFulfilledA)
  .then(handleFulfilledB)
  .then(handleFulfilledC)
  .catch(handleRejectedAny);

Using arrow functions for the callback functions, implementation of the promise chain might look something like this:
jsmyPromise
  .then((value) => `${value} and bar`)
  .then((value) => `${value} and bar again`)
  .then((value) => `${value} and again`)
  .then((value) => `${value} and again`)
  .then((value) => {
    console.log(value);
  })
  .catch((err) => {
    console.error(err);
  });


Note:
For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence.

JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the Promise() constructor, the handlers passed to then, or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue.
A promise can participate in more than one chain. For the following code, the fulfillment of promiseA will cause both handleFulfilled1 and handleFulfilled2 to be added to the job queue. Because handleFulfilled1 is registered first, it will be invoked first.
jsconst promiseA = new Promise(myExecutorFunc);
const promiseB = promiseA.then(handleFulfilled1, handleRejected1);
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);

An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already "settled" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous.
jsconst promiseA = new Promise((resolve, reject) => {
  resolve(777);
});
// At this point, "promiseA" is already settled.
promiseA.then((val) => console.log("asynchronous logging has val:", val));
console.log("immediate logging");

// produces output in this order:
// immediate logging
// asynchronous logging has val: 777
ThenablesThe JavaScript ecosystem had made multiple Promise implementations long before it became part of the language. Despite being represented differently internally, at the minimum, all Promise-like objects implement the Thenable interface. A thenable implements the .then() method, which is called with two callbacks: one for when the promise is fulfilled, one for when it's rejected. Promises are thenables as well.
To interoperate with the existing Promise implementations, the language allows using thenables in place of promises. For example, Promise.resolve will not only resolve promises, but also trace thenables.
jsconst aThenable = {
  then(onFulfilled, onRejected) {
    onFulfilled({
      // The thenable is fulfilled with another thenable
      then(onFulfilled, onRejected) {
        onFulfilled(42);
      },
    });
  },
};

Promise.resolve(aThenable); // A promise fulfilled with 42
Promise concurrencyThe Promise class offers four static methods to facilitate async task concurrency:

Promise.all()

Fulfills when all of the promises fulfill; rejects when any of the promises rejects.

Promise.allSettled()

Fulfills when all promises settle.

Promise.any()

Fulfills when any of the promises fulfills; rejects when all of the promises reject.

Promise.race()

Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects.


All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor — accepting a single executor function that can be called with the resolve and reject callbacks as parameters. The subclass must also have a resolve static method that can be called like Promise.resolve() to resolve values to promises.
Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads.Constructor
Promise()

Creates a new Promise object. The constructor is primarily used to wrap functions that do not already support promises.

Static properties
Promise[Symbol.species]

Returns the constructor used to construct return values from promise methods.

Static methods
Promise.all()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises reject, with this first rejection reason.

Promise.allSettled()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises settle (including when an empty iterable is passed), with an array of objects that describe the outcome of each promise.

Promise.any()

Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when any of the input's promises fulfill, with this first fulfillment value. It rejects when all of the input's promises reject (including when an empty iterable is passed), with an AggregateError containing an array of rejection reasons.

Promise.race()

Takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.

Promise.reject()

Returns a new Promise object that is rejected with the given reason.

Promise.resolve()

Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e., has a then method), the returned promise will "follow" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value.

Promise.try()

Takes a callback of any kind (returns or throws, synchronously or asynchronously) and wraps its result in a Promise.

Promise.withResolvers()

Returns an object containing a new Promise object and two functions to resolve or reject it, corresponding to the two parameters passed to the executor of the Promise() constructor.

Instance propertiesThese properties are defined on Promise.prototype and shared by all Promise instances.

Promise.prototype.constructor

The constructor function that created the instance object. For Promise instances, the initial value is the Promise constructor.

Promise.prototype[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Promise". This property is used in Object.prototype.toString().

Instance methods
Promise.prototype.catch()

Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.

Promise.prototype.finally()

Appends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected.

Promise.prototype.then()

Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e., if the relevant handler onFulfilled or onRejected is not a function).

ExamplesBasic ExampleIn this example, we use setTimeout(...) to simulate async code.
In reality, you will probably be using something like XHR or an HTML API.
jsconst myFirstPromise = new Promise((resolve, reject) => {
  // We call resolve(...) when what we were doing asynchronously
  // was successful, and reject(...) when it failed.
  setTimeout(() => {
    resolve("Success!"); // Yay! Everything went well!
  }, 250);
});

myFirstPromise.then((successMessage) => {
  // successMessage is whatever we passed in the resolve(...) function above.
  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.
  console.log(`Yay! ${successMessage}`);
});
Example with diverse situationsThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of .then() calls, and typically (but not necessarily) has a single .catch() at the end, optionally followed by .finally(). In this example, the promise chain is initiated by a custom-written new Promise() construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise.
The example function tetheredGetNumber() shows that a promise generator will utilize reject() while setting up an asynchronous call, or within the call-back, or both. The function promiseGetWord() illustrates how an API function might generate and return a promise in a self-contained manner.
Note that the function troubleWithGetNumber() ends with a throw. That is forced because a promise chain goes through all the .then() promises, even after an error, and without the throw, the error would seem "fixed". This is a hassle, and for this reason, it is common to omit onRejected throughout the chain of .then() promises, and just have a single onRejected in the final catch().
This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the threshold values.
js// To experiment with error handling, "threshold" values cause errors randomly
const THRESHOLD_A = 8; // can use zero 0 to guarantee error

function tetheredGetNumber(resolve, reject) {
  setTimeout(() => {
    const randomInt = Date.now();
    const value = randomInt % 10;
    if (value < THRESHOLD_A) {
      resolve(value);
    } else {
      reject(`Too large: ${value}`);
    }
  }, 500);
}

function determineParity(value) {
  const isOdd = value % 2 === 1;
  return { value, isOdd };
}

function troubleWithGetNumber(reason) {
  const err = new Error("Trouble getting number", { cause: reason });
  console.error(err);
  throw err;
}

function promiseGetWord(parityInfo) {
  return new Promise((resolve, reject) => {
    const { value, isOdd } = parityInfo;
    if (value >= THRESHOLD_A - 1) {
      reject(`Still too large: ${value}`);
    } else {
      parityInfo.wordEvenOdd = isOdd ? "odd" : "even";
      resolve(parityInfo);
    }
  });
}

new Promise(tetheredGetNumber)
  .then(determineParity, troubleWithGetNumber)
  .then(promiseGetWord)
  .then((info) => {
    console.log(`Got: ${info.value}, ${info.wordEvenOdd}`);
    return info;
  })
  .catch((reason) => {
    if (reason.cause) {
      console.error("Had previously handled error");
    } else {
      console.error(`Trouble with promiseGetWord(): ${reason}`);
    }
  })
  .finally((info) => console.log("All done"));
Advanced ExampleThis small example shows the mechanism of a Promise. The testPromise() method is called each time the <button> is clicked. It creates a promise that will be fulfilled, using setTimeout(), to the promise count (number starting from 1) every 1-3 seconds, at random. The Promise() constructor is used to create the promise.
The fulfillment of the promise is logged, via a fulfill callback set using p1.then(). A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise.
By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another.
HTML
html<button id="make-promise">Make a promise!</button>
<div id="log"></div>

JavaScript
js"use strict";

let promiseCount = 0;

function testPromise() {
  const thisPromiseCount = ++promiseCount;
  const log = document.getElementById("log");
  // begin
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Started<br>`);
  // We make a new promise: we promise a numeric count of this promise,
  // starting from 1 (after waiting 3s)
  const p1 = new Promise((resolve, reject) => {
    // The executor function is called with the ability
    // to resolve or reject the promise
    log.insertAdjacentHTML(
      "beforeend",
      `${thisPromiseCount}) Promise constructor<br>`,
    );
    // This is only an example to create asynchronism
    setTimeout(
      () => {
        // We fulfill the promise
        resolve(thisPromiseCount);
      },
      Math.random() * 2000 + 1000,
    );
  });

  // We define what to do when the promise is resolved with the then() call,
  // and what to do when the promise is rejected with the catch() call
  p1.then((val) => {
    // Log the fulfillment value
    log.insertAdjacentHTML("beforeend", `${val}) Promise fulfilled<br>`);
  }).catch((reason) => {
    // Log the rejection reason
    console.log(`Handle rejected promise (${reason}) here.`);
  });
  // end
  log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Promise made<br>`);
}

const btn = document.getElementById("make-promise");
btn.addEventListener("click", testPromise);

Result
Loading an image with XHRAnother example using Promise and XMLHttpRequest to load an image is shown below.
Each step is commented on and allows you to follow the Promise and XHR architecture closely.
<h1>Promise example</h1>

jsfunction imgLoad(url) {
  // Create new promise with the Promise() constructor;
  // This has as its argument a function with two parameters, resolve and reject
  return new Promise((resolve, reject) => {
    // XHR to load an image
    const request = new XMLHttpRequest();
    request.open("GET", url);
    request.responseType = "blob";
    // When the request loads, check whether it was successful
    request.onload = () => {
      if (request.status === 200) {
        // If successful, resolve the promise by passing back the request response
        resolve(request.response);
      } else {
        // If it fails, reject the promise with an error message
        reject(
          Error(
            `Image didn't load successfully; error code: + ${request.statusText}`,
          ),
        );
      }
    };
    // Handle network errors
    request.onerror = () => reject(new Error("There was a network error."));
    // Send the request
    request.send();
  });
}

// Get a reference to the body element, and create a new image object
const body = document.querySelector("body");
const myImage = new Image();
const imgUrl =
  "https://mdn.github.io/shared-assets/images/examples/round-balloon.png";

// Call the function with the URL we want to load, then chain the
// promise then() method with two callbacks
imgLoad(imgUrl).then(
  (response) => {
    // The first runs when the promise resolves, with the request.response
    // specified within the resolve() method.
    const imageURL = URL.createObjectURL(response);
    myImage.src = imageURL;
    body.appendChild(myImage);
  },
  (error) => {
    // The second runs when the promise
    // is rejected, and logs the Error specified with the reject() method.
    console.log(error);
  },
);

Incumbent settings object trackingA settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code.
To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like Array and Error. Each settings object has its own "copy" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call.
To illustrate this a bit further we can take a look at how an <iframe> embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built-in function — there is no user
  // code on the stack, so which realm do we use?
  setTimeout(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

The same concept applies to promises. If we modify the above example a little bit, we get this:
html<!doctype html> <iframe></iframe>
<!-- we have a realm here -->
<script>
  // we have a realm here as well
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // bound is a built in function — there is no user
  // code on the stack — which realm do we use?
  Promise.resolve(undefined).then(bound);
  // this still works, because we use the youngest
  // realm (the incumbent) on the stack
</script>

If we change this so that the <iframe> in the document is listening to post messages, we can observe the effect of the incumbent settings object:
html<!-- y.html -->
<!doctype html>
<iframe src="x.html"></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  Promise.resolve(undefined).then(bound);
</script>

html<!-- x.html -->
<!doctype html>
<script>
  window.addEventListener(
    "message",
    (event) => {
      document.querySelector("#text").textContent = "hello";
      // this code will only run in browsers that track the incumbent settings object
      console.log(event);
    },
    false,
  );
</script>

In the above example, the inner text of the <iframe> will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message.

Note:
Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari.
SpecificationsSpecificationECMAScript® 2026 Language Specification # sec-promise-objectsBrowser compatibilitySee also
Polyfill of Promise in core-js
Using promises guide
Promises/A+ specification
JavaScript Promises: an introduction on web.dev (2013)
Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript slide show by Domenic Denicola (2011)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nRequest: Request() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Request() constructor creates a new
Request object.Syntaxjsnew Request(input)
new Request(input, options)
Parameters
input

Defines the resource that you wish to fetch. This can either be:


A string containing the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.


A Request object, effectively creating a copy. Note the following
behavioral updates to retain security while making the constructor less likely to
throw exceptions:

If this object exists on another origin to the constructor call, the
Request.referrer is stripped out.
If this object has a Request.mode of navigate,
the mode value is converted to same-origin.




options Optional

A RequestInit object containing any custom settings that you want to apply to the request.
If you construct a new Request from an existing Request, any options you set in an options argument for the new request replace any corresponding options set in the original Request. For example:
jsconst oldRequest = new Request(
  "https://github.com/mdn/content/issues/12959",
  { headers: { From: "webmaster@example.org" } },
);
oldRequest.headers.get("From"); // "webmaster@example.org"
const newRequest = new Request(oldRequest, {
  headers: { From: "developer@example.org" },
});
newRequest.headers.get("From"); // "developer@example.org"


Exceptions
TypeError

The URL has credentials, such as http://user:password@example.com, or cannot be parsed.

ExamplesIn our Fetch Request example (see Fetch Request live) we create a new Request object using the constructor, then fetch it using a fetch() call.
Since we are fetching an image, we run Response.blob on the response to give it the proper MIME type so it will be handled properly, then create an Object URL of it and display it in an <img> element.
jsconst myImage = document.querySelector("img");
const myRequest = new Request("flowers.jpg");

fetch(myRequest)
  .then((response) => response.blob())
  .then((response) => {
    const objectURL = URL.createObjectURL(response);
    myImage.src = objectURL;
  });

In our Fetch Request with init example (see Fetch Request init live) we do the same thing except that we pass in an options object when we invoke fetch().
In this case, we can set a Cache-Control value to indicate what kind of cached responses we're okay with:
jsconst myImage = document.querySelector("img");
const reqHeaders = new Headers();

// A cached response is okay unless it's more than a week old.
reqHeaders.set("Cache-Control", "max-age=604800");

const options = {
  headers: reqHeaders,
};

// pass init as an "options" object with our headers
const req = new Request("flowers.jpg", options);

fetch(req).then((response) => {
  // ...
});

Note that you could also pass options into the fetch call to get the same effect, e.g.:
jsfetch(req, options).then((response) => {
  // ...
});

You can also use an object literal as headers in options.
jsconst options = {
  headers: {
    "Cache-Control": "max-age=60480",
  },
};

const req = new Request("flowers.jpg", options);

You may also pass a Request object to the Request()
constructor to create a copy of the Request (This is similar to calling the
clone() method.)
jsconst copy = new Request(req);


Note:
This last usage is probably only useful in ServiceWorkers.
SpecificationsSpecificationFetch # ref-for-dom-request①Browser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nRequest: Request() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Request() constructor creates a new
Request object.Syntaxjsnew Request(input)
new Request(input, options)
Parameters
input

Defines the resource that you wish to fetch. This can either be:


A string containing the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.


A Request object, effectively creating a copy. Note the following
behavioral updates to retain security while making the constructor less likely to
throw exceptions:

If this object exists on another origin to the constructor call, the
Request.referrer is stripped out.
If this object has a Request.mode of navigate,
the mode value is converted to same-origin.




options Optional

A RequestInit object containing any custom settings that you want to apply to the request.
If you construct a new Request from an existing Request, any options you set in an options argument for the new request replace any corresponding options set in the original Request. For example:
jsconst oldRequest = new Request(
  "https://github.com/mdn/content/issues/12959",
  { headers: { From: "webmaster@example.org" } },
);
oldRequest.headers.get("From"); // "webmaster@example.org"
const newRequest = new Request(oldRequest, {
  headers: { From: "developer@example.org" },
});
newRequest.headers.get("From"); // "developer@example.org"


Exceptions
TypeError

The URL has credentials, such as http://user:password@example.com, or cannot be parsed.

ExamplesIn our Fetch Request example (see Fetch Request live) we create a new Request object using the constructor, then fetch it using a fetch() call.
Since we are fetching an image, we run Response.blob on the response to give it the proper MIME type so it will be handled properly, then create an Object URL of it and display it in an <img> element.
jsconst myImage = document.querySelector("img");
const myRequest = new Request("flowers.jpg");

fetch(myRequest)
  .then((response) => response.blob())
  .then((response) => {
    const objectURL = URL.createObjectURL(response);
    myImage.src = objectURL;
  });

In our Fetch Request with init example (see Fetch Request init live) we do the same thing except that we pass in an options object when we invoke fetch().
In this case, we can set a Cache-Control value to indicate what kind of cached responses we're okay with:
jsconst myImage = document.querySelector("img");
const reqHeaders = new Headers();

// A cached response is okay unless it's more than a week old.
reqHeaders.set("Cache-Control", "max-age=604800");

const options = {
  headers: reqHeaders,
};

// pass init as an "options" object with our headers
const req = new Request("flowers.jpg", options);

fetch(req).then((response) => {
  // ...
});

Note that you could also pass options into the fetch call to get the same effect, e.g.:
jsfetch(req, options).then((response) => {
  // ...
});

You can also use an object literal as headers in options.
jsconst options = {
  headers: {
    "Cache-Control": "max-age=60480",
  },
};

const req = new Request("flowers.jpg", options);

You may also pass a Request object to the Request()
constructor to create a copy of the Request (This is similar to calling the
clone() method.)
jsconst copy = new Request(req);


Note:
This last usage is probably only useful in ServiceWorkers.
SpecificationsSpecificationFetch # ref-for-dom-request①Browser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nRequest: Request() constructorBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Request() constructor creates a new
Request object.Syntaxjsnew Request(input)
new Request(input, options)
Parameters
input

Defines the resource that you wish to fetch. This can either be:


A string containing the URL of the resource you want to fetch. The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context.


A Request object, effectively creating a copy. Note the following
behavioral updates to retain security while making the constructor less likely to
throw exceptions:

If this object exists on another origin to the constructor call, the
Request.referrer is stripped out.
If this object has a Request.mode of navigate,
the mode value is converted to same-origin.




options Optional

A RequestInit object containing any custom settings that you want to apply to the request.
If you construct a new Request from an existing Request, any options you set in an options argument for the new request replace any corresponding options set in the original Request. For example:
jsconst oldRequest = new Request(
  "https://github.com/mdn/content/issues/12959",
  { headers: { From: "webmaster@example.org" } },
);
oldRequest.headers.get("From"); // "webmaster@example.org"
const newRequest = new Request(oldRequest, {
  headers: { From: "developer@example.org" },
});
newRequest.headers.get("From"); // "developer@example.org"


Exceptions
TypeError

The URL has credentials, such as http://user:password@example.com, or cannot be parsed.

ExamplesIn our Fetch Request example (see Fetch Request live) we create a new Request object using the constructor, then fetch it using a fetch() call.
Since we are fetching an image, we run Response.blob on the response to give it the proper MIME type so it will be handled properly, then create an Object URL of it and display it in an <img> element.
jsconst myImage = document.querySelector("img");
const myRequest = new Request("flowers.jpg");

fetch(myRequest)
  .then((response) => response.blob())
  .then((response) => {
    const objectURL = URL.createObjectURL(response);
    myImage.src = objectURL;
  });

In our Fetch Request with init example (see Fetch Request init live) we do the same thing except that we pass in an options object when we invoke fetch().
In this case, we can set a Cache-Control value to indicate what kind of cached responses we're okay with:
jsconst myImage = document.querySelector("img");
const reqHeaders = new Headers();

// A cached response is okay unless it's more than a week old.
reqHeaders.set("Cache-Control", "max-age=604800");

const options = {
  headers: reqHeaders,
};

// pass init as an "options" object with our headers
const req = new Request("flowers.jpg", options);

fetch(req).then((response) => {
  // ...
});

Note that you could also pass options into the fetch call to get the same effect, e.g.:
jsfetch(req, options).then((response) => {
  // ...
});

You can also use an object literal as headers in options.
jsconst options = {
  headers: {
    "Cache-Control": "max-age=60480",
  },
};

const req = new Request("flowers.jpg", options);

You may also pass a Request object to the Request()
constructor to create a copy of the Request (This is similar to calling the
clone() method.)
jsconst copy = new Request(req);


Note:
This last usage is probably only useful in ServiceWorkers.
SpecificationsSpecificationFetch # ref-for-dom-request①Browser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResponse: Response() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Response() constructor creates a new Response object.Syntaxjsnew Response()
new Response(body)
new Response(body, options)
Parameters
body Optional

An object defining a body for the response. This can be null (which is
the default value), or one of:

Blob
ArrayBuffer
TypedArray
DataView
FormData
ReadableStream
URLSearchParams
String
string literal


options Optional

An options object containing any custom settings that you want to apply to the response, or an empty object (which is the default value). The possible options are:

status

The status code for the response.
The default value is 200.

statusText

The status message associated with the status code, such as "OK".
The default value is "".

headers

Any headers you want to add to your response, contained within a Headers object or object literal of String key/value pairs (see HTTP headers for a reference).
By default this is empty.



ExamplesIn our Fetch Response example (see Fetch Response live)
we create a new Response object using the constructor, passing it a new Blob as a body, and an init object containing a custom status and statusText:
jsconst myBlob = new Blob();
const myOptions = { status: 200, statusText: "SuperSmashingGreat!" };
const myResponse = new Response(myBlob, myOptions);
SpecificationsSpecificationFetch # ref-for-dom-response①Browser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP\n\nResponse: Response() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Response() constructor creates a new Response object.Syntaxjsnew Response()
new Response(body)
new Response(body, options)
Parameters
body Optional

An object defining a body for the response. This can be null (which is
the default value), or one of:

Blob
ArrayBuffer
TypedArray
DataView
FormData
ReadableStream
URLSearchParams
String
string literal


options Optional

An options object containing any custom settings that you want to apply to the response, or an empty object (which is the default value). The possible options are:

status

The status code for the response.
The default value is 200.

statusText

The status message associated with the status code, such as "OK".
The default value is "".

headers

Any headers you want to add to your response, contained within a Headers object or object literal of String key/value pairs (see HTTP headers for a reference).
By default this is empty.



ExamplesIn our Fetch Response example (see Fetch Response live)
we create a new Response object using the constructor, passing it a new Blob as a body, and an init object containing a custom status and statusText:
jsconst myBlob = new Blob();
const myOptions = { status: 200, statusText: "SuperSmashingGreat!" };
const myResponse = new Response(myBlob, myOptions);
SpecificationsSpecificationFetch # ref-for-dom-response①Browser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nResponse: Response() constructorBaseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since March 2017.Learn moreSee full compatibilityReport feedbackNote: This feature is available in Web Workers.
The Response() constructor creates a new Response object.Syntaxjsnew Response()
new Response(body)
new Response(body, options)
Parameters
body Optional

An object defining a body for the response. This can be null (which is
the default value), or one of:

Blob
ArrayBuffer
TypedArray
DataView
FormData
ReadableStream
URLSearchParams
String
string literal


options Optional

An options object containing any custom settings that you want to apply to the response, or an empty object (which is the default value). The possible options are:

status

The status code for the response.
The default value is 200.

statusText

The status message associated with the status code, such as "OK".
The default value is "".

headers

Any headers you want to add to your response, contained within a Headers object or object literal of String key/value pairs (see HTTP headers for a reference).
By default this is empty.



ExamplesIn our Fetch Response example (see Fetch Response live)
we create a new Response object using the constructor, passing it a new Blob as a body, and an init object containing a custom status and statusText:
jsconst myBlob = new Blob();
const myOptions = { status: 200, statusText: "SuperSmashingGreat!" };
const myResponse = new Response(myBlob, myOptions);
SpecificationsSpecificationFetch # ref-for-dom-response①Browser compatibilitySee also
ServiceWorker API
HTTP access control (CORS)
HTTP
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 13, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nFetchEvent: respondWith() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Service Workers.
The respondWith() method of
FetchEvent prevents the browser's default fetch handling, and
allows you to provide a promise for a Response yourself.
In most cases you can provide any response that the receiver understands. For example,
if an <img> initiates the request, the response body needs to be
image data. For security reasons, there are a few global rules:

You can only return Response objects of type
"opaque" if the fetchEvent.request object's
mode is "no-cors". This prevents the
leaking of private data.
You can only return Response objects of type
"opaqueredirect" if the fetchEvent.request
object's mode is "manual".
You cannot return Response objects of type
"cors" if the fetchEvent.request object's
mode is "same-origin".
Specifying the final URL of a resourceFrom Firefox 59 onwards, when a service worker provides a Response to
FetchEvent.respondWith(), the Response.url value will be
propagated to the intercepted network request as the final resolved URL. If the
Response.url value is the empty string, then the
FetchEvent.request.url is used as the final URL.
In the past the FetchEvent.request.url was used as the
final URL in all cases. The provided Response.url was effectively
ignored.
This means, for example, if a service worker intercepts a stylesheet or worker script,
then the provided Response.url will be used to resolve any relative
@import or
importScripts() subresource loads
(Firefox bug 1222008).
For most types of network request this change has no impact because you can't observe
the final URL. There are a few, though, where it does matter:

If a fetch() is intercepted,
then you can observe the final URL on the result's Response.url.
If a worker script is
intercepted, then the final URL is used to set
self.location
and used as the base URL for relative URLs in the worker script.
If a stylesheet is intercepted, then the final URL is used as the base URL for
resolving relative @import loads.

Note that navigation requests for Windows and
iframes do NOT use the final URL. The way the HTML
specification handles redirects for navigations ends up using the request URL for the
resulting Window.location. This means sites can still provide an
"alternate" view of a web page when offline without changing the user-visible URL.SyntaxjsrespondWith(response)
Parameters
response

A Response or a Promise that resolves to a
Response. Otherwise, a network error is returned to Fetch.

Return valueNone (undefined).Exceptions
NetworkError DOMException

Returned if a network error is triggered on certain combinations of
FetchEvent.request.mode and
Response.type values, as hinted at in the "global rules"
listed above.

InvalidStateError DOMException

Returned if the event has not been dispatched or respondWith() has
already been invoked.

ExamplesThis fetch event tries to return a response from the cache API, falling back to the
network otherwise.
jsaddEventListener("fetch", (event) => {
  // Prevent the default, and handle the request ourselves.
  event.respondWith(
    (async () => {
      // Try to get the response from a cache.
      const cachedResponse = await caches.match(event.request);
      // Return it if we found one.
      if (cachedResponse) return cachedResponse;
      // If we didn't find a match in the cache, use the network.
      return fetch(event.request);
    })(),
  );
});


Note: caches.match() is a
convenience method. Equivalent functionality is to call
cache.match() on each cache (in the order returned by
caches.keys()) until a
Response is returned.
SpecificationsSpecificationService Workers # fetch-event-respondwithBrowser compatibilitySee also
Using Service Workers
Fetch API\n\nFetchEvent: respondWith() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Service Workers.
The respondWith() method of
FetchEvent prevents the browser's default fetch handling, and
allows you to provide a promise for a Response yourself.
In most cases you can provide any response that the receiver understands. For example,
if an <img> initiates the request, the response body needs to be
image data. For security reasons, there are a few global rules:

You can only return Response objects of type
"opaque" if the fetchEvent.request object's
mode is "no-cors". This prevents the
leaking of private data.
You can only return Response objects of type
"opaqueredirect" if the fetchEvent.request
object's mode is "manual".
You cannot return Response objects of type
"cors" if the fetchEvent.request object's
mode is "same-origin".
Specifying the final URL of a resourceFrom Firefox 59 onwards, when a service worker provides a Response to
FetchEvent.respondWith(), the Response.url value will be
propagated to the intercepted network request as the final resolved URL. If the
Response.url value is the empty string, then the
FetchEvent.request.url is used as the final URL.
In the past the FetchEvent.request.url was used as the
final URL in all cases. The provided Response.url was effectively
ignored.
This means, for example, if a service worker intercepts a stylesheet or worker script,
then the provided Response.url will be used to resolve any relative
@import or
importScripts() subresource loads
(Firefox bug 1222008).
For most types of network request this change has no impact because you can't observe
the final URL. There are a few, though, where it does matter:

If a fetch() is intercepted,
then you can observe the final URL on the result's Response.url.
If a worker script is
intercepted, then the final URL is used to set
self.location
and used as the base URL for relative URLs in the worker script.
If a stylesheet is intercepted, then the final URL is used as the base URL for
resolving relative @import loads.

Note that navigation requests for Windows and
iframes do NOT use the final URL. The way the HTML
specification handles redirects for navigations ends up using the request URL for the
resulting Window.location. This means sites can still provide an
"alternate" view of a web page when offline without changing the user-visible URL.SyntaxjsrespondWith(response)
Parameters
response

A Response or a Promise that resolves to a
Response. Otherwise, a network error is returned to Fetch.

Return valueNone (undefined).Exceptions
NetworkError DOMException

Returned if a network error is triggered on certain combinations of
FetchEvent.request.mode and
Response.type values, as hinted at in the "global rules"
listed above.

InvalidStateError DOMException

Returned if the event has not been dispatched or respondWith() has
already been invoked.

ExamplesThis fetch event tries to return a response from the cache API, falling back to the
network otherwise.
jsaddEventListener("fetch", (event) => {
  // Prevent the default, and handle the request ourselves.
  event.respondWith(
    (async () => {
      // Try to get the response from a cache.
      const cachedResponse = await caches.match(event.request);
      // Return it if we found one.
      if (cachedResponse) return cachedResponse;
      // If we didn't find a match in the cache, use the network.
      return fetch(event.request);
    })(),
  );
});


Note: caches.match() is a
convenience method. Equivalent functionality is to call
cache.match() on each cache (in the order returned by
caches.keys()) until a
Response is returned.
SpecificationsSpecificationService Workers # fetch-event-respondwithBrowser compatibilitySee also
Using Service Workers
Fetch API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 24, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nFetchEvent: respondWith() methodBaseline Widely available *This feature is well established and works across many devices and browser versions. It’s been available across browsers since April 2018.* Some parts of this feature may have varying levels of support.Learn moreSee full compatibilityReport feedbackNote: This feature is only available in Service Workers.
The respondWith() method of
FetchEvent prevents the browser's default fetch handling, and
allows you to provide a promise for a Response yourself.
In most cases you can provide any response that the receiver understands. For example,
if an <img> initiates the request, the response body needs to be
image data. For security reasons, there are a few global rules:

You can only return Response objects of type
"opaque" if the fetchEvent.request object's
mode is "no-cors". This prevents the
leaking of private data.
You can only return Response objects of type
"opaqueredirect" if the fetchEvent.request
object's mode is "manual".
You cannot return Response objects of type
"cors" if the fetchEvent.request object's
mode is "same-origin".
Specifying the final URL of a resourceFrom Firefox 59 onwards, when a service worker provides a Response to
FetchEvent.respondWith(), the Response.url value will be
propagated to the intercepted network request as the final resolved URL. If the
Response.url value is the empty string, then the
FetchEvent.request.url is used as the final URL.
In the past the FetchEvent.request.url was used as the
final URL in all cases. The provided Response.url was effectively
ignored.
This means, for example, if a service worker intercepts a stylesheet or worker script,
then the provided Response.url will be used to resolve any relative
@import or
importScripts() subresource loads
(Firefox bug 1222008).
For most types of network request this change has no impact because you can't observe
the final URL. There are a few, though, where it does matter:

If a fetch() is intercepted,
then you can observe the final URL on the result's Response.url.
If a worker script is
intercepted, then the final URL is used to set
self.location
and used as the base URL for relative URLs in the worker script.
If a stylesheet is intercepted, then the final URL is used as the base URL for
resolving relative @import loads.

Note that navigation requests for Windows and
iframes do NOT use the final URL. The way the HTML
specification handles redirects for navigations ends up using the request URL for the
resulting Window.location. This means sites can still provide an
"alternate" view of a web page when offline without changing the user-visible URL.SyntaxjsrespondWith(response)
Parameters
response

A Response or a Promise that resolves to a
Response. Otherwise, a network error is returned to Fetch.

Return valueNone (undefined).Exceptions
NetworkError DOMException

Returned if a network error is triggered on certain combinations of
FetchEvent.request.mode and
Response.type values, as hinted at in the "global rules"
listed above.

InvalidStateError DOMException

Returned if the event has not been dispatched or respondWith() has
already been invoked.

ExamplesThis fetch event tries to return a response from the cache API, falling back to the
network otherwise.
jsaddEventListener("fetch", (event) => {
  // Prevent the default, and handle the request ourselves.
  event.respondWith(
    (async () => {
      // Try to get the response from a cache.
      const cachedResponse = await caches.match(event.request);
      // Return it if we found one.
      if (cachedResponse) return cachedResponse;
      // If we didn't find a match in the cache, use the network.
      return fetch(event.request);
    })(),
  );
});


Note: caches.match() is a
convenience method. Equivalent functionality is to call
cache.match() on each cache (in the order returned by
caches.keys()) until a
Response is returned.
SpecificationsSpecificationService Workers # fetch-event-respondwithBrowser compatibilitySee also
Using Service Workers
Fetch API
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Sep 24, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nService Worker APINote: This feature is available in Web Workers.
Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests, and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.Service worker concepts and usageA service worker is an event-driven worker registered against an origin and a path. It takes the form of a JavaScript file that can control the web page/site that it is associated with, intercepting and modifying navigation and resource requests, and caching resources in a very granular fashion to give you complete control over how your app behaves in certain situations (the most obvious one being when the network is not available).
Service workers run in a worker context: they therefore have no DOM access and run on a different thread to the main JavaScript that powers your app. They are non-blocking and designed to be fully asynchronous. As a consequence, APIs such as synchronous XHR and Web Storage can't be used inside a service worker.
Service workers can't import JavaScript modules dynamically, and import() will throw if it is called in a service worker global scope. Static imports using the import statement are allowed.
Service workers only run over HTTPS, for security reasons. Most significantly, HTTP connections are susceptible to malicious code injection by man in the middle attacks, and such attacks could be worse if allowed access to these powerful APIs. In Firefox, service worker APIs are also hidden and cannot be used when the user is in private browsing mode.

Note:
On Firefox, for testing you can run service workers over HTTP (insecurely); simply check the Enable Service Workers over HTTP (when toolbox is open) option in the Firefox DevTools options/gear menu.


Note:
Unlike previous attempts in this area such as AppCache, service workers don't make assumptions about what you are trying to do, but then break when those assumptions are not exactly right. Instead, service workers give you much more granular control.


Note:
Service workers make heavy use of promises, as generally they will wait for responses to come through, after which they will respond with a success or failure action. The promises architecture is ideal for this.
RegistrationA service worker is first registered using the ServiceWorkerContainer.register() method. If successful, your service worker will be downloaded to the client and attempt installation/activation (see below) for URLs accessed by the user inside the whole origin, or a subset specified by you.Download, install and activateAt this point, your service worker will observe the following lifecycle:

Download
Install
Activate

The service worker is immediately downloaded when a user first accesses a service worker–controlled site/page.
After that, it is updated when:

A navigation to an in-scope page occurs.
An event is fired on the service worker and it hasn't been downloaded in the last 24 hours.

Installation is attempted when the downloaded file is found to be new — either different to an existing service worker (byte-wise compared), or the first service worker encountered for this page/site.
If this is the first time a service worker has been made available, installation is attempted, then after a successful installation, it is activated.
If there is an existing service worker available, the new version is installed in the background, but not yet activated — at this point it is called the worker in waiting. It is only activated when there are no longer any pages loaded that are still using the old service worker. As soon as there are no more pages to be loaded, the new service worker activates (becoming the active worker). Activation can happen sooner using ServiceWorkerGlobalScope.skipWaiting() and existing pages can be claimed by the active worker using Clients.claim().
You can listen for the install event; a standard action is to prepare your service worker for usage when this fires, for example by creating a cache using the built-in storage API, and placing assets inside it that you'll want for running your app offline.
There is also an activate event. The point where this event fires is generally a good time to clean up old caches and other things associated with the previous version of your service worker.
Your service worker can respond to requests using the FetchEvent event. You can modify the response to these requests in any way you want, using the FetchEvent.respondWith() method.

Note:
Because install/activate events could take a while to complete, the service worker spec provides a waitUntil() method. Once it is called on install or activate events with a promise, functional events such as fetch and push will wait until the promise is successfully resolved.

For a complete tutorial to show how to build up your first basic example, read Using Service Workers.Using static routing to control how resources are fetchedService workers can incur an unnecessary performance cost — when a page is loaded for the first time in a while, the browser has to wait for the service worker to start up and run to know what content to load and whether it should come from a cache or the network.
If you already know ahead of time where certain content should be fetched from, you can bypass the service worker altogether and fetch resources immediately. The InstallEvent.addRoutes() method can be used to implement this use case and more.Other use case ideasService workers are also intended to be used for such things as:

Background data synchronization.
Responding to resource requests from other origins.
Receiving centralized updates to expensive-to-calculate data such as geolocation or gyroscope, so multiple pages can make use of one set of data.
Client-side compiling and dependency management of CoffeeScript, less, CJS/AMD modules, etc. for development purposes.
Hooks for background services.
Custom templating based on certain URL patterns.
Performance enhancements, for example, pre-fetching resources that the user is likely to need soon, such as the next few pictures in a photo album.
API mocking.

In the future, service workers will be able to do several other useful things for the web platform that will bring it closer to native app viability. Interestingly, other specifications can and will start to make use of the service worker context, for example:

Background synchronization: Start up a service worker even when no users are at the site, so caches can be updated, etc.
Reacting to push messages: Start up a service worker to send users a message to tell them new content is available.
Reacting to a particular time & date.
Entering a geo-fence.
Interfaces
Cache

Represents the storage for Request / Response object pairs that are cached as part of the ServiceWorker life cycle.

CacheStorage

Represents the storage for Cache objects. It provides a master directory of all the named caches that a ServiceWorker can access, and maintains a mapping of string names to corresponding Cache objects.

Client

Represents the scope of a service worker client. A service worker client is either a document in a browser context or a SharedWorker, which is controlled by an active worker.

Clients

Represents a container for a list of Client objects; the main way to access the active service worker clients at the current origin.

ExtendableEvent

Extends the lifetime of the install and activate events dispatched on the ServiceWorkerGlobalScope, as part of the service worker lifecycle. This ensures that any functional events (like FetchEvent) are not dispatched to the ServiceWorker, until it upgrades database schemas, and deletes outdated cache entries, etc.

ExtendableMessageEvent

The event object of a message event fired on a service worker (when a channel message is received on the ServiceWorkerGlobalScope from another context) — extends the lifetime of such events.

FetchEvent

The parameter passed into the onfetch handler, FetchEvent represents a fetch action that is dispatched on the ServiceWorkerGlobalScope of a ServiceWorker. It contains information about the request and resulting response, and provides the FetchEvent.respondWith() method, which allows us to provide an arbitrary response back to the controlled page.

InstallEvent

The parameter passed into an install event handler function, the InstallEvent interface represents an install action that is dispatched on the ServiceWorkerGlobalScope of a ServiceWorker. As a child of ExtendableEvent, it ensures that functional events such as FetchEvent are not dispatched during installation.

NavigationPreloadManager

Provides methods for managing the preloading of resources with a service worker.

ServiceWorker

Represents a service worker. Multiple browsing contexts (e.g., pages, workers, etc.) can be associated with the same ServiceWorker object.

ServiceWorkerContainer

Provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister, and update service workers, and access the state of service workers and their registrations.

ServiceWorkerGlobalScope

Represents the global execution context of a service worker.

ServiceWorkerRegistration

Represents a service worker registration.

WindowClient

Represents the scope of a service worker client that is a document in a browser context, controlled by an active worker. This is a special type of Client object, with some additional methods and properties available.

Extensions to other interfaces
Window.caches and WorkerGlobalScope.caches

Returns the CacheStorage object associated with the current context.

Navigator.serviceWorker and WorkerNavigator.serviceWorker

Returns a ServiceWorkerContainer object, which provides access to registration, removal, upgrade, and communication with the ServiceWorker objects for the associated document.

SpecificationsSpecificationService Workers See also
Using Service Workers
Service Worker Lifecycle
Service workers basic code example
Web APIs that are related to the Service Worker API:

Background Fetch API
Background Synchronization API
Content Index API
Cookie Store API
Notifications API
Payment Handler API
Push API
Web Periodic Background Synchronization API\n\nService Worker APINote: This feature is available in Web Workers.
Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests, and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.Service worker concepts and usageA service worker is an event-driven worker registered against an origin and a path. It takes the form of a JavaScript file that can control the web page/site that it is associated with, intercepting and modifying navigation and resource requests, and caching resources in a very granular fashion to give you complete control over how your app behaves in certain situations (the most obvious one being when the network is not available).
Service workers run in a worker context: they therefore have no DOM access and run on a different thread to the main JavaScript that powers your app. They are non-blocking and designed to be fully asynchronous. As a consequence, APIs such as synchronous XHR and Web Storage can't be used inside a service worker.
Service workers can't import JavaScript modules dynamically, and import() will throw if it is called in a service worker global scope. Static imports using the import statement are allowed.
Service workers only run over HTTPS, for security reasons. Most significantly, HTTP connections are susceptible to malicious code injection by man in the middle attacks, and such attacks could be worse if allowed access to these powerful APIs. In Firefox, service worker APIs are also hidden and cannot be used when the user is in private browsing mode.

Note:
On Firefox, for testing you can run service workers over HTTP (insecurely); simply check the Enable Service Workers over HTTP (when toolbox is open) option in the Firefox DevTools options/gear menu.


Note:
Unlike previous attempts in this area such as AppCache, service workers don't make assumptions about what you are trying to do, but then break when those assumptions are not exactly right. Instead, service workers give you much more granular control.


Note:
Service workers make heavy use of promises, as generally they will wait for responses to come through, after which they will respond with a success or failure action. The promises architecture is ideal for this.
RegistrationA service worker is first registered using the ServiceWorkerContainer.register() method. If successful, your service worker will be downloaded to the client and attempt installation/activation (see below) for URLs accessed by the user inside the whole origin, or a subset specified by you.Download, install and activateAt this point, your service worker will observe the following lifecycle:

Download
Install
Activate

The service worker is immediately downloaded when a user first accesses a service worker–controlled site/page.
After that, it is updated when:

A navigation to an in-scope page occurs.
An event is fired on the service worker and it hasn't been downloaded in the last 24 hours.

Installation is attempted when the downloaded file is found to be new — either different to an existing service worker (byte-wise compared), or the first service worker encountered for this page/site.
If this is the first time a service worker has been made available, installation is attempted, then after a successful installation, it is activated.
If there is an existing service worker available, the new version is installed in the background, but not yet activated — at this point it is called the worker in waiting. It is only activated when there are no longer any pages loaded that are still using the old service worker. As soon as there are no more pages to be loaded, the new service worker activates (becoming the active worker). Activation can happen sooner using ServiceWorkerGlobalScope.skipWaiting() and existing pages can be claimed by the active worker using Clients.claim().
You can listen for the install event; a standard action is to prepare your service worker for usage when this fires, for example by creating a cache using the built-in storage API, and placing assets inside it that you'll want for running your app offline.
There is also an activate event. The point where this event fires is generally a good time to clean up old caches and other things associated with the previous version of your service worker.
Your service worker can respond to requests using the FetchEvent event. You can modify the response to these requests in any way you want, using the FetchEvent.respondWith() method.

Note:
Because install/activate events could take a while to complete, the service worker spec provides a waitUntil() method. Once it is called on install or activate events with a promise, functional events such as fetch and push will wait until the promise is successfully resolved.

For a complete tutorial to show how to build up your first basic example, read Using Service Workers.Using static routing to control how resources are fetchedService workers can incur an unnecessary performance cost — when a page is loaded for the first time in a while, the browser has to wait for the service worker to start up and run to know what content to load and whether it should come from a cache or the network.
If you already know ahead of time where certain content should be fetched from, you can bypass the service worker altogether and fetch resources immediately. The InstallEvent.addRoutes() method can be used to implement this use case and more.Other use case ideasService workers are also intended to be used for such things as:

Background data synchronization.
Responding to resource requests from other origins.
Receiving centralized updates to expensive-to-calculate data such as geolocation or gyroscope, so multiple pages can make use of one set of data.
Client-side compiling and dependency management of CoffeeScript, less, CJS/AMD modules, etc. for development purposes.
Hooks for background services.
Custom templating based on certain URL patterns.
Performance enhancements, for example, pre-fetching resources that the user is likely to need soon, such as the next few pictures in a photo album.
API mocking.

In the future, service workers will be able to do several other useful things for the web platform that will bring it closer to native app viability. Interestingly, other specifications can and will start to make use of the service worker context, for example:

Background synchronization: Start up a service worker even when no users are at the site, so caches can be updated, etc.
Reacting to push messages: Start up a service worker to send users a message to tell them new content is available.
Reacting to a particular time & date.
Entering a geo-fence.
Interfaces
Cache

Represents the storage for Request / Response object pairs that are cached as part of the ServiceWorker life cycle.

CacheStorage

Represents the storage for Cache objects. It provides a master directory of all the named caches that a ServiceWorker can access, and maintains a mapping of string names to corresponding Cache objects.

Client

Represents the scope of a service worker client. A service worker client is either a document in a browser context or a SharedWorker, which is controlled by an active worker.

Clients

Represents a container for a list of Client objects; the main way to access the active service worker clients at the current origin.

ExtendableEvent

Extends the lifetime of the install and activate events dispatched on the ServiceWorkerGlobalScope, as part of the service worker lifecycle. This ensures that any functional events (like FetchEvent) are not dispatched to the ServiceWorker, until it upgrades database schemas, and deletes outdated cache entries, etc.

ExtendableMessageEvent

The event object of a message event fired on a service worker (when a channel message is received on the ServiceWorkerGlobalScope from another context) — extends the lifetime of such events.

FetchEvent

The parameter passed into the onfetch handler, FetchEvent represents a fetch action that is dispatched on the ServiceWorkerGlobalScope of a ServiceWorker. It contains information about the request and resulting response, and provides the FetchEvent.respondWith() method, which allows us to provide an arbitrary response back to the controlled page.

InstallEvent

The parameter passed into an install event handler function, the InstallEvent interface represents an install action that is dispatched on the ServiceWorkerGlobalScope of a ServiceWorker. As a child of ExtendableEvent, it ensures that functional events such as FetchEvent are not dispatched during installation.

NavigationPreloadManager

Provides methods for managing the preloading of resources with a service worker.

ServiceWorker

Represents a service worker. Multiple browsing contexts (e.g., pages, workers, etc.) can be associated with the same ServiceWorker object.

ServiceWorkerContainer

Provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister, and update service workers, and access the state of service workers and their registrations.

ServiceWorkerGlobalScope

Represents the global execution context of a service worker.

ServiceWorkerRegistration

Represents a service worker registration.

WindowClient

Represents the scope of a service worker client that is a document in a browser context, controlled by an active worker. This is a special type of Client object, with some additional methods and properties available.

Extensions to other interfaces
Window.caches and WorkerGlobalScope.caches

Returns the CacheStorage object associated with the current context.

Navigator.serviceWorker and WorkerNavigator.serviceWorker

Returns a ServiceWorkerContainer object, which provides access to registration, removal, upgrade, and communication with the ServiceWorker objects for the associated document.

SpecificationsSpecificationService Workers See also
Using Service Workers
Service Worker Lifecycle
Service workers basic code example
Web APIs that are related to the Service Worker API:

Background Fetch API
Background Synchronization API
Content Index API
Cookie Store API
Notifications API
Payment Handler API
Push API
Web Periodic Background Synchronization API


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nService Worker APINote: This feature is available in Web Workers.
Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests, and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.Service worker concepts and usageA service worker is an event-driven worker registered against an origin and a path. It takes the form of a JavaScript file that can control the web page/site that it is associated with, intercepting and modifying navigation and resource requests, and caching resources in a very granular fashion to give you complete control over how your app behaves in certain situations (the most obvious one being when the network is not available).
Service workers run in a worker context: they therefore have no DOM access and run on a different thread to the main JavaScript that powers your app. They are non-blocking and designed to be fully asynchronous. As a consequence, APIs such as synchronous XHR and Web Storage can't be used inside a service worker.
Service workers can't import JavaScript modules dynamically, and import() will throw if it is called in a service worker global scope. Static imports using the import statement are allowed.
Service workers only run over HTTPS, for security reasons. Most significantly, HTTP connections are susceptible to malicious code injection by man in the middle attacks, and such attacks could be worse if allowed access to these powerful APIs. In Firefox, service worker APIs are also hidden and cannot be used when the user is in private browsing mode.

Note:
On Firefox, for testing you can run service workers over HTTP (insecurely); simply check the Enable Service Workers over HTTP (when toolbox is open) option in the Firefox DevTools options/gear menu.


Note:
Unlike previous attempts in this area such as AppCache, service workers don't make assumptions about what you are trying to do, but then break when those assumptions are not exactly right. Instead, service workers give you much more granular control.


Note:
Service workers make heavy use of promises, as generally they will wait for responses to come through, after which they will respond with a success or failure action. The promises architecture is ideal for this.
RegistrationA service worker is first registered using the ServiceWorkerContainer.register() method. If successful, your service worker will be downloaded to the client and attempt installation/activation (see below) for URLs accessed by the user inside the whole origin, or a subset specified by you.Download, install and activateAt this point, your service worker will observe the following lifecycle:

Download
Install
Activate

The service worker is immediately downloaded when a user first accesses a service worker–controlled site/page.
After that, it is updated when:

A navigation to an in-scope page occurs.
An event is fired on the service worker and it hasn't been downloaded in the last 24 hours.

Installation is attempted when the downloaded file is found to be new — either different to an existing service worker (byte-wise compared), or the first service worker encountered for this page/site.
If this is the first time a service worker has been made available, installation is attempted, then after a successful installation, it is activated.
If there is an existing service worker available, the new version is installed in the background, but not yet activated — at this point it is called the worker in waiting. It is only activated when there are no longer any pages loaded that are still using the old service worker. As soon as there are no more pages to be loaded, the new service worker activates (becoming the active worker). Activation can happen sooner using ServiceWorkerGlobalScope.skipWaiting() and existing pages can be claimed by the active worker using Clients.claim().
You can listen for the install event; a standard action is to prepare your service worker for usage when this fires, for example by creating a cache using the built-in storage API, and placing assets inside it that you'll want for running your app offline.
There is also an activate event. The point where this event fires is generally a good time to clean up old caches and other things associated with the previous version of your service worker.
Your service worker can respond to requests using the FetchEvent event. You can modify the response to these requests in any way you want, using the FetchEvent.respondWith() method.

Note:
Because install/activate events could take a while to complete, the service worker spec provides a waitUntil() method. Once it is called on install or activate events with a promise, functional events such as fetch and push will wait until the promise is successfully resolved.

For a complete tutorial to show how to build up your first basic example, read Using Service Workers.Using static routing to control how resources are fetchedService workers can incur an unnecessary performance cost — when a page is loaded for the first time in a while, the browser has to wait for the service worker to start up and run to know what content to load and whether it should come from a cache or the network.
If you already know ahead of time where certain content should be fetched from, you can bypass the service worker altogether and fetch resources immediately. The InstallEvent.addRoutes() method can be used to implement this use case and more.Other use case ideasService workers are also intended to be used for such things as:

Background data synchronization.
Responding to resource requests from other origins.
Receiving centralized updates to expensive-to-calculate data such as geolocation or gyroscope, so multiple pages can make use of one set of data.
Client-side compiling and dependency management of CoffeeScript, less, CJS/AMD modules, etc. for development purposes.
Hooks for background services.
Custom templating based on certain URL patterns.
Performance enhancements, for example, pre-fetching resources that the user is likely to need soon, such as the next few pictures in a photo album.
API mocking.

In the future, service workers will be able to do several other useful things for the web platform that will bring it closer to native app viability. Interestingly, other specifications can and will start to make use of the service worker context, for example:

Background synchronization: Start up a service worker even when no users are at the site, so caches can be updated, etc.
Reacting to push messages: Start up a service worker to send users a message to tell them new content is available.
Reacting to a particular time & date.
Entering a geo-fence.
Interfaces
Cache

Represents the storage for Request / Response object pairs that are cached as part of the ServiceWorker life cycle.

CacheStorage

Represents the storage for Cache objects. It provides a master directory of all the named caches that a ServiceWorker can access, and maintains a mapping of string names to corresponding Cache objects.

Client

Represents the scope of a service worker client. A service worker client is either a document in a browser context or a SharedWorker, which is controlled by an active worker.

Clients

Represents a container for a list of Client objects; the main way to access the active service worker clients at the current origin.

ExtendableEvent

Extends the lifetime of the install and activate events dispatched on the ServiceWorkerGlobalScope, as part of the service worker lifecycle. This ensures that any functional events (like FetchEvent) are not dispatched to the ServiceWorker, until it upgrades database schemas, and deletes outdated cache entries, etc.

ExtendableMessageEvent

The event object of a message event fired on a service worker (when a channel message is received on the ServiceWorkerGlobalScope from another context) — extends the lifetime of such events.

FetchEvent

The parameter passed into the onfetch handler, FetchEvent represents a fetch action that is dispatched on the ServiceWorkerGlobalScope of a ServiceWorker. It contains information about the request and resulting response, and provides the FetchEvent.respondWith() method, which allows us to provide an arbitrary response back to the controlled page.

InstallEvent

The parameter passed into an install event handler function, the InstallEvent interface represents an install action that is dispatched on the ServiceWorkerGlobalScope of a ServiceWorker. As a child of ExtendableEvent, it ensures that functional events such as FetchEvent are not dispatched during installation.

NavigationPreloadManager

Provides methods for managing the preloading of resources with a service worker.

ServiceWorker

Represents a service worker. Multiple browsing contexts (e.g., pages, workers, etc.) can be associated with the same ServiceWorker object.

ServiceWorkerContainer

Provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister, and update service workers, and access the state of service workers and their registrations.

ServiceWorkerGlobalScope

Represents the global execution context of a service worker.

ServiceWorkerRegistration

Represents a service worker registration.

WindowClient

Represents the scope of a service worker client that is a document in a browser context, controlled by an active worker. This is a special type of Client object, with some additional methods and properties available.

Extensions to other interfaces
Window.caches and WorkerGlobalScope.caches

Returns the CacheStorage object associated with the current context.

Navigator.serviceWorker and WorkerNavigator.serviceWorker

Returns a ServiceWorkerContainer object, which provides access to registration, removal, upgrade, and communication with the ServiceWorker objects for the associated document.

SpecificationsSpecificationService Workers See also
Using Service Workers
Service Worker Lifecycle
Service workers basic code example
Web APIs that are related to the Service Worker API:

Background Fetch API
Background Synchronization API
Content Index API
Cookie Store API
Notifications API
Payment Handler API
Push API
Web Periodic Background Synchronization API


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 3, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nCross-Origin Resource Sharing (CORS)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackCross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources. CORS also relies on a mechanism by which browsers make a "preflight" request to the server hosting the cross-origin resource, in order to check that the server will permit the actual request. In that preflight, the browser sends headers that indicate the HTTP method and headers that will be used in the actual request.
An example of a cross-origin request: the front-end JavaScript code served from https://domain-a.com uses fetch() to make a request for https://domain-b.com/data.json.
For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. For example, fetch() and XMLHttpRequest follow the same-origin policy. This means that a web application using those APIs can only request resources from the same origin the application was loaded from unless the response from other origins includes the right CORS headers.

The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Browsers use CORS in APIs such as fetch() or XMLHttpRequest to mitigate the risks of cross-origin HTTP requests.What requests use CORS?This cross-origin sharing standard can enable cross-origin HTTP requests for:

Invocations of fetch() or XMLHttpRequest, as discussed above.
Web Fonts (for cross-domain font usage in @font-face within CSS), so that servers can deploy TrueType fonts that can only be loaded cross-origin and used by websites that are permitted to do so.
WebGL textures.
Images/video frames drawn to a canvas using drawImage().
CSS Shapes from images.

This is a general article about Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.Functional overviewThe Cross-Origin Resource Sharing standard works by adding new HTTP headers that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than GET, or POST with certain MIME types), the specification mandates that browsers "preflight" the request, soliciting supported methods from the server with the HTTP OPTIONS request method, and then, upon "approval" from the server, sending the actual request. Servers can also inform clients whether "credentials" (such as Cookies and HTTP Authentication) should be sent with requests.
CORS failures result in errors but for security reasons, specifics about the error are not available to JavaScript. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.
Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.Examples of access control scenariosWe present three scenarios that demonstrate how Cross-Origin Resource Sharing works. All these examples use fetch(), which can make cross-origin requests in any supporting browser.Simple requestsSome requests don't trigger a CORS preflight. Those are called simple requests from the obsolete CORS spec, though the Fetch spec (which now defines CORS) doesn't use that term.
The motivation is that the <form> element from HTML 4.0 (which predates cross-site fetch() and XMLHttpRequest) can submit simple requests to any origin, so anyone writing a server must already be protecting against cross-site request forgery (CSRF). Under this assumption, the server doesn't have to opt-in (by responding to a preflight request) to receive any request that looks like a form submission, since the threat of CSRF is no worse than that of form submission. However, the server still must opt-in using Access-Control-Allow-Origin to share the response with the script.
A simple request is one that meets all the following conditions:


One of the allowed methods:

GET
HEAD
POST



Apart from the headers automatically set by the user agent (for example, Connection, User-Agent, or the forbidden request headers), the only headers which are allowed to be manually set are the CORS-safelisted request-headers, which are:

Accept
Accept-Language
Content-Language
Content-Type (please note the additional requirements below)
Range (only with a single range header value; e.g., bytes=256- or bytes=127-255)



The only type/subtype combinations allowed for the media type specified in the Content-Type header are:

application/x-www-form-urlencoded
multipart/form-data
text/plain



If the request is made using an XMLHttpRequest object, no event listeners are registered on the object returned by the XMLHttpRequest.upload property used in the request; that is, given an XMLHttpRequest instance xhr, no code has called xhr.upload.addEventListener() to add an event listener to monitor the upload.


No ReadableStream object is used in the request.



Note:
WebKit Nightly and Safari Technology Preview place additional restrictions on the values allowed in the Accept, Accept-Language, and Content-Language headers. If any of those headers have "nonstandard" values, WebKit/Safari does not consider the request to be a "simple request". What values WebKit/Safari consider "nonstandard" is not documented, except in the following WebKit bugs:

Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-Language
Allow commas in Accept, Accept-Language, and Content-Language request headers for simple CORS
Switch to a blacklist model for restricted Accept headers in simple CORS requests

No other browsers implement these extra restrictions because they're not part of the spec.

For example, suppose web content at https://foo.example wishes to fetch JSON content from domain https://bar.other. Code of this sort might be used in JavaScript deployed on foo.example:
jsconst fetchPromise = fetch("https://bar.other");

fetchPromise
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
  });

This operation performs a simple exchange between the client and the server, using CORS headers to handle the privileges:

Let's look at what the browser will send to the server in this case:
httpGET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://foo.example

The request header of note is Origin, which shows that the invocation is coming from https://foo.example.
Now let's see how the server responds:
httpHTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml

[…XML Data…]

In response, the server returns a Access-Control-Allow-Origin header with Access-Control-Allow-Origin: *, which means that the resource can be accessed by any origin.
httpAccess-Control-Allow-Origin: *

This pattern of the Origin and Access-Control-Allow-Origin headers is the simplest use of the access control protocol. If the resource owners at https://bar.other wished to restrict access to the resource to requests only from https://foo.example (i.e., no domain other than https://foo.example can access the resource in a cross-origin manner), they would send:
httpAccess-Control-Allow-Origin: https://foo.example


Note:
When responding to a credentialed requests request, the server must specify an origin in the value of the Access-Control-Allow-Origin header, instead of specifying the * wildcard.
Preflighted requestsUnlike simple requests, for "preflighted" requests the browser first sends an HTTP request using the OPTIONS method to the resource on the other origin, in order to determine if the actual request is safe to send. Such cross-origin requests are preflighted since they may have implications for user data.
The following is an example of a request that will be preflighted:
jsconst fetchPromise = fetch("https://bar.other/doc", {
  method: "POST",
  mode: "cors",
  headers: {
    "Content-Type": "text/xml",
    "X-PINGOTHER": "pingpong",
  },
  body: "<person><name>Arun</name></person>",
});

fetchPromise.then((response) => {
  console.log(response.status);
});

The example above creates an XML body to send with the POST request. Also, a non-standard HTTP X-PINGOTHER request header is set. Such headers are not part of HTTP/1.1, but are generally useful to web applications. Since the request uses a Content-Type of text/xml, and since a custom header is set, this request is preflighted.


Note:
As described below, the actual POST request does not include the Access-Control-Request-* headers; they are needed only for the OPTIONS request.

Let's look at the full exchange between client and server. The first exchange is the preflight request/response:
httpOPTIONS /doc HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: content-type,x-pingother

HTTP/1.1 204 No Content
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive

The first block above represents the preflight request with the OPTIONS method. The browser determines that it needs to send this based on the request parameters that the JavaScript code snippet above was using, so that the server can respond whether it is acceptable to send the request with the actual request parameters. OPTIONS is an HTTP/1.1 method that is used to determine further information from servers, and is a safe method, meaning that it can't be used to change the resource. Note that along with the OPTIONS request, two other request headers are sent:
httpAccess-Control-Request-Method: POST
Access-Control-Request-Headers: content-type,x-pingother

The Access-Control-Request-Method header notifies the server as part of a preflight request that when the actual request is sent, it will do so with a POST request method. The Access-Control-Request-Headers header notifies the server that when the actual request is sent, it will do so with X-PINGOTHER and Content-Type custom headers. Now the server has an opportunity to determine whether it can accept a request under these conditions.
The second block above is the response that the server returns, which indicate that the request method (POST) and request headers (X-PINGOTHER) are acceptable. Let's have a closer look at the following lines:
httpAccess-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400

The server responds with Access-Control-Allow-Origin: https://foo.example, restricting access to the requesting origin domain only. It also responds with Access-Control-Allow-Methods, which says that POST and GET are valid methods to query the resource in question (this header is similar to the Allow response header, but used strictly within the context of access control).
The server also sends Access-Control-Allow-Headers with a value of X-PINGOTHER, Content-Type, confirming that these are permitted headers to be used with the actual request. Like Access-Control-Allow-Methods, Access-Control-Allow-Headers is a comma-separated list of acceptable headers.
Finally, Access-Control-Max-Age gives the value in seconds for how long the response to the preflight request can be cached without sending another preflight request. The default value is 5 seconds. In the present case, the max age is 86400 seconds (= 24 hours). Note that each browser has a maximum internal value that takes precedence when the Access-Control-Max-Age exceeds it.
Once the preflight request is complete, the real request is sent:
httpPOST /doc HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Referer: https://foo.example/examples/preflightInvocation.html
Content-Length: 55
Origin: https://foo.example
Pragma: no-cache
Cache-Control: no-cache

<person><name>Arun</name></person>

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 235
Keep-Alive: timeout=2, max=99
Connection: Keep-Alive
Content-Type: text/plain

[Some XML content]

Preflighted requests and redirects
Not all browsers currently support following redirects after a preflighted request. If a redirect occurs after such a request, some browsers currently will report an error message such as the following:

The request was redirected to https://example.com/foo, which is disallowed for cross-origin requests that require preflight.
Request requires preflight, which is disallowed to follow cross-origin redirects.

The CORS protocol originally required that behavior but was subsequently changed to no longer require it. However, not all browsers have implemented the change, and thus still exhibit the originally required behavior.
Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:

Change the server-side behavior to avoid the preflight and/or to avoid the redirect
Change the request such that it is a simple request that doesn't cause a preflight

If that's not possible, then another way is to:

Make a simple request (using Response.url for the Fetch API, or XMLHttpRequest.responseURL) to determine what URL the real preflighted request would end up at.
Make another request (the real request) using the URL you obtained from Response.url or XMLHttpRequest.responseURL in the first step.

However, if the request is one that triggers a preflight due to the presence of the Authorization header in the request, you won't be able to work around the limitation using the steps above. And you won't be able to work around it at all unless you have control over the server the request is being made to.Requests with credentials
Note:
When making credentialed requests to a different domain, third-party cookie policies will still apply. The policy is always enforced regardless of any setup on the server and the client as described in this chapter.

The most interesting capability exposed by both fetch() or XMLHttpRequest and CORS is the ability to make "credentialed" requests that are aware of HTTP cookies and HTTP Authentication information. By default, in cross-origin fetch() or XMLHttpRequest calls, browsers will not send credentials.
To ask for a fetch() request to include credentials, set the credentials option to "include".
To ask for an XMLHttpRequest request to include credentials, set the XMLHttpRequest.withCredentials property to true.
In this example, content originally loaded from https://foo.example makes a GET request to a resource on https://bar.other which sets Cookies. Content on foo.example might contain JavaScript like this:
jsconst url = "https://bar.other/resources/credentialed-content/";

const request = new Request(url, { credentials: "include" });

const fetchPromise = fetch(request);
fetchPromise.then((response) => console.log(response));

This code creates a Request object, setting the credentials option to "include" in the constructor, then passes this request into fetch(). Since this is a simple GET request, it is not preflighted but the browser will reject any response that does not have the Access-Control-Allow-Credentials: true header, and not make the response available to the invoking web content.

Here is a sample exchange between client and server:
httpGET /resources/credentialed-content/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Referer: https://foo.example/examples/credential.html
Origin: https://foo.example
Cookie: pageAccess=2

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain

[text/plain content]

Although the request's Cookie header contains the cookie destined for the content on https://bar.other, if bar.other did not respond with an Access-Control-Allow-Credentials with value true, as demonstrated in this example, the response would be ignored and not made available to the web content.
Preflight requests and credentials
CORS-preflight requests must never include credentials. The response to a preflight request must specify Access-Control-Allow-Credentials: true to indicate that the actual request can be made with credentials.

Note:
Some enterprise authentication services require that TLS client certificates be sent in preflight requests, in contravention of the Fetch specification.
Firefox 87 allows this non-compliant behavior to be enabled by setting the preference: network.cors_preflight.allow_client_cert to true (Firefox bug 1511151). Chromium-based browsers currently always send TLS client certificates in CORS preflight requests (Chrome bug 775438).

Credentialed requests and wildcards
When responding to a credentialed request:

The server must not specify the * wildcard for the Access-Control-Allow-Origin response-header value, but must instead specify an explicit origin; for example: Access-Control-Allow-Origin: https://example.com
The server must not specify the * wildcard for the Access-Control-Allow-Headers response-header value, but must instead specify an explicit list of header names; for example, Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
The server must not specify the * wildcard for the Access-Control-Allow-Methods response-header value, but must instead specify an explicit list of method names; for example, Access-Control-Allow-Methods: POST, GET
The server must not specify the * wildcard for the Access-Control-Expose-Headers response-header value, but must instead specify an explicit list of header names; for example, Access-Control-Expose-Headers: Content-Encoding, Kuma-Revision

If a request includes a credential (most commonly a Cookie header) and the response includes an Access-Control-Allow-Origin: * header (that is, with the wildcard), the browser will block access to the response, and report a CORS error in the devtools console.
But if a request does include a credential (like the Cookie header) and the response includes an actual origin rather than the wildcard (like, for example, Access-Control-Allow-Origin: https://example.com), then the browser will allow access to the response from the specified origin.
Also note that any Set-Cookie response header in a response would not set a cookie if the Access-Control-Allow-Origin value in that response is the * wildcard rather an actual origin.
Third-party cookies
Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from foo.example but the Cookie header in the response is sent by bar.other, and would thus not be saved if the user's browser is configured to reject all third-party cookies.
Cookie in the request may also be suppressed in normal third-party cookie policies. The enforced cookie policy may therefore nullify the capability described in this chapter, effectively preventing you from making credentialed requests whatsoever.
Cookie policy around the SameSite attribute would apply.The HTTP response headersThis section lists the HTTP response headers that servers return for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.Access-Control-Allow-OriginA returned resource may have one Access-Control-Allow-Origin header with the following syntax:
httpAccess-Control-Allow-Origin: <origin> | *

Access-Control-Allow-Origin specifies either a single origin which tells browsers to allow that origin to access the resource; or else — for requests without credentials — the * wildcard tells browsers to allow any origin to access the resource.
For example, to allow code from the origin https://mozilla.org to access the resource, you can specify:
httpAccess-Control-Allow-Origin: https://mozilla.org
Vary: Origin

If the server specifies a single origin (that may dynamically change based on the requesting origin as part of an allowlist) rather than the * wildcard, then the server should also include Origin in the Vary response header to indicate to clients that server responses will differ based on the value of the Origin request header.Access-Control-Expose-HeadersThe Access-Control-Expose-Headers header adds the specified headers to the allowlist that JavaScript (such as Response.headers) in browsers is allowed to access.
httpAccess-Control-Expose-Headers: <header-name>[, <header-name>]*

For example, the following:
httpAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header

…would allow the X-My-Custom-Header and X-Another-Custom-Header headers to be exposed to the browser.Access-Control-Max-AgeThe Access-Control-Max-Age header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.
httpAccess-Control-Max-Age: <delta-seconds>

The delta-seconds parameter indicates the number of seconds the results can be cached.Access-Control-Allow-CredentialsThe Access-Control-Allow-Credentials header indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple GET requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.
httpAccess-Control-Allow-Credentials: true

Credentialed requests are discussed above.Access-Control-Allow-MethodsThe Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.
httpAccess-Control-Allow-Methods: <method>[, <method>]*

An example of a preflight request is given above, including an example which sends this header to the browser.Access-Control-Allow-HeadersThe Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. This header is the server side response to the browser's Access-Control-Request-Headers header.
httpAccess-Control-Allow-Headers: <header-name>[, <header-name>]*
The HTTP request headersThis section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers making cross-origin requests do not have to set any cross-origin sharing request headers programmatically.OriginThe Origin header indicates the origin of the cross-origin access request or preflight request.
httpOrigin: <origin>

The origin is a URL indicating the server from which the request is initiated. It does not include any path information, only the server name.

Note:
The origin value can be null.

Note that in any access control request, the Origin header is always sent.Access-Control-Request-MethodThe Access-Control-Request-Method is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.
httpAccess-Control-Request-Method: <method>

Examples of this usage can be found above.Access-Control-Request-HeadersThe Access-Control-Request-Headers header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made (for example, by passing them as the headers option). This browser-side header will be answered by the complementary server-side header of Access-Control-Allow-Headers.
httpAccess-Control-Request-Headers: <field-name>[,<field-name>]*

Examples of this usage can be found above.SpecificationsSpecificationFetch # http-access-control-allow-originBrowser compatibilitySee also

CORS errors


Enable CORS: I want to add CORS support to my server


Fetch API

XMLHttpRequest

Will it CORS? - an interactive CORS explainer & generator


How to run Chrome browser without CORS


Using CORS with All (Modern) Browsers


Stack Overflow answer with "how to" info for dealing with common problems:

How to avoid the CORS preflight
How to use a CORS proxy to get around "No Access-Control-Allow-Origin header"
How to fix "Access-Control-Allow-Origin header must not be the wildcard"\n\nCross-Origin Resource Sharing (CORS)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackCross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources. CORS also relies on a mechanism by which browsers make a "preflight" request to the server hosting the cross-origin resource, in order to check that the server will permit the actual request. In that preflight, the browser sends headers that indicate the HTTP method and headers that will be used in the actual request.
An example of a cross-origin request: the front-end JavaScript code served from https://domain-a.com uses fetch() to make a request for https://domain-b.com/data.json.
For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. For example, fetch() and XMLHttpRequest follow the same-origin policy. This means that a web application using those APIs can only request resources from the same origin the application was loaded from unless the response from other origins includes the right CORS headers.

The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Browsers use CORS in APIs such as fetch() or XMLHttpRequest to mitigate the risks of cross-origin HTTP requests.What requests use CORS?This cross-origin sharing standard can enable cross-origin HTTP requests for:

Invocations of fetch() or XMLHttpRequest, as discussed above.
Web Fonts (for cross-domain font usage in @font-face within CSS), so that servers can deploy TrueType fonts that can only be loaded cross-origin and used by websites that are permitted to do so.
WebGL textures.
Images/video frames drawn to a canvas using drawImage().
CSS Shapes from images.

This is a general article about Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.Functional overviewThe Cross-Origin Resource Sharing standard works by adding new HTTP headers that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than GET, or POST with certain MIME types), the specification mandates that browsers "preflight" the request, soliciting supported methods from the server with the HTTP OPTIONS request method, and then, upon "approval" from the server, sending the actual request. Servers can also inform clients whether "credentials" (such as Cookies and HTTP Authentication) should be sent with requests.
CORS failures result in errors but for security reasons, specifics about the error are not available to JavaScript. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.
Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.Examples of access control scenariosWe present three scenarios that demonstrate how Cross-Origin Resource Sharing works. All these examples use fetch(), which can make cross-origin requests in any supporting browser.Simple requestsSome requests don't trigger a CORS preflight. Those are called simple requests from the obsolete CORS spec, though the Fetch spec (which now defines CORS) doesn't use that term.
The motivation is that the <form> element from HTML 4.0 (which predates cross-site fetch() and XMLHttpRequest) can submit simple requests to any origin, so anyone writing a server must already be protecting against cross-site request forgery (CSRF). Under this assumption, the server doesn't have to opt-in (by responding to a preflight request) to receive any request that looks like a form submission, since the threat of CSRF is no worse than that of form submission. However, the server still must opt-in using Access-Control-Allow-Origin to share the response with the script.
A simple request is one that meets all the following conditions:


One of the allowed methods:

GET
HEAD
POST



Apart from the headers automatically set by the user agent (for example, Connection, User-Agent, or the forbidden request headers), the only headers which are allowed to be manually set are the CORS-safelisted request-headers, which are:

Accept
Accept-Language
Content-Language
Content-Type (please note the additional requirements below)
Range (only with a single range header value; e.g., bytes=256- or bytes=127-255)



The only type/subtype combinations allowed for the media type specified in the Content-Type header are:

application/x-www-form-urlencoded
multipart/form-data
text/plain



If the request is made using an XMLHttpRequest object, no event listeners are registered on the object returned by the XMLHttpRequest.upload property used in the request; that is, given an XMLHttpRequest instance xhr, no code has called xhr.upload.addEventListener() to add an event listener to monitor the upload.


No ReadableStream object is used in the request.



Note:
WebKit Nightly and Safari Technology Preview place additional restrictions on the values allowed in the Accept, Accept-Language, and Content-Language headers. If any of those headers have "nonstandard" values, WebKit/Safari does not consider the request to be a "simple request". What values WebKit/Safari consider "nonstandard" is not documented, except in the following WebKit bugs:

Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-Language
Allow commas in Accept, Accept-Language, and Content-Language request headers for simple CORS
Switch to a blacklist model for restricted Accept headers in simple CORS requests

No other browsers implement these extra restrictions because they're not part of the spec.

For example, suppose web content at https://foo.example wishes to fetch JSON content from domain https://bar.other. Code of this sort might be used in JavaScript deployed on foo.example:
jsconst fetchPromise = fetch("https://bar.other");

fetchPromise
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
  });

This operation performs a simple exchange between the client and the server, using CORS headers to handle the privileges:

Let's look at what the browser will send to the server in this case:
httpGET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://foo.example

The request header of note is Origin, which shows that the invocation is coming from https://foo.example.
Now let's see how the server responds:
httpHTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml

[…XML Data…]

In response, the server returns a Access-Control-Allow-Origin header with Access-Control-Allow-Origin: *, which means that the resource can be accessed by any origin.
httpAccess-Control-Allow-Origin: *

This pattern of the Origin and Access-Control-Allow-Origin headers is the simplest use of the access control protocol. If the resource owners at https://bar.other wished to restrict access to the resource to requests only from https://foo.example (i.e., no domain other than https://foo.example can access the resource in a cross-origin manner), they would send:
httpAccess-Control-Allow-Origin: https://foo.example


Note:
When responding to a credentialed requests request, the server must specify an origin in the value of the Access-Control-Allow-Origin header, instead of specifying the * wildcard.
Preflighted requestsUnlike simple requests, for "preflighted" requests the browser first sends an HTTP request using the OPTIONS method to the resource on the other origin, in order to determine if the actual request is safe to send. Such cross-origin requests are preflighted since they may have implications for user data.
The following is an example of a request that will be preflighted:
jsconst fetchPromise = fetch("https://bar.other/doc", {
  method: "POST",
  mode: "cors",
  headers: {
    "Content-Type": "text/xml",
    "X-PINGOTHER": "pingpong",
  },
  body: "<person><name>Arun</name></person>",
});

fetchPromise.then((response) => {
  console.log(response.status);
});

The example above creates an XML body to send with the POST request. Also, a non-standard HTTP X-PINGOTHER request header is set. Such headers are not part of HTTP/1.1, but are generally useful to web applications. Since the request uses a Content-Type of text/xml, and since a custom header is set, this request is preflighted.


Note:
As described below, the actual POST request does not include the Access-Control-Request-* headers; they are needed only for the OPTIONS request.

Let's look at the full exchange between client and server. The first exchange is the preflight request/response:
httpOPTIONS /doc HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: content-type,x-pingother

HTTP/1.1 204 No Content
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive

The first block above represents the preflight request with the OPTIONS method. The browser determines that it needs to send this based on the request parameters that the JavaScript code snippet above was using, so that the server can respond whether it is acceptable to send the request with the actual request parameters. OPTIONS is an HTTP/1.1 method that is used to determine further information from servers, and is a safe method, meaning that it can't be used to change the resource. Note that along with the OPTIONS request, two other request headers are sent:
httpAccess-Control-Request-Method: POST
Access-Control-Request-Headers: content-type,x-pingother

The Access-Control-Request-Method header notifies the server as part of a preflight request that when the actual request is sent, it will do so with a POST request method. The Access-Control-Request-Headers header notifies the server that when the actual request is sent, it will do so with X-PINGOTHER and Content-Type custom headers. Now the server has an opportunity to determine whether it can accept a request under these conditions.
The second block above is the response that the server returns, which indicate that the request method (POST) and request headers (X-PINGOTHER) are acceptable. Let's have a closer look at the following lines:
httpAccess-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400

The server responds with Access-Control-Allow-Origin: https://foo.example, restricting access to the requesting origin domain only. It also responds with Access-Control-Allow-Methods, which says that POST and GET are valid methods to query the resource in question (this header is similar to the Allow response header, but used strictly within the context of access control).
The server also sends Access-Control-Allow-Headers with a value of X-PINGOTHER, Content-Type, confirming that these are permitted headers to be used with the actual request. Like Access-Control-Allow-Methods, Access-Control-Allow-Headers is a comma-separated list of acceptable headers.
Finally, Access-Control-Max-Age gives the value in seconds for how long the response to the preflight request can be cached without sending another preflight request. The default value is 5 seconds. In the present case, the max age is 86400 seconds (= 24 hours). Note that each browser has a maximum internal value that takes precedence when the Access-Control-Max-Age exceeds it.
Once the preflight request is complete, the real request is sent:
httpPOST /doc HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Referer: https://foo.example/examples/preflightInvocation.html
Content-Length: 55
Origin: https://foo.example
Pragma: no-cache
Cache-Control: no-cache

<person><name>Arun</name></person>

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 235
Keep-Alive: timeout=2, max=99
Connection: Keep-Alive
Content-Type: text/plain

[Some XML content]

Preflighted requests and redirects
Not all browsers currently support following redirects after a preflighted request. If a redirect occurs after such a request, some browsers currently will report an error message such as the following:

The request was redirected to https://example.com/foo, which is disallowed for cross-origin requests that require preflight.
Request requires preflight, which is disallowed to follow cross-origin redirects.

The CORS protocol originally required that behavior but was subsequently changed to no longer require it. However, not all browsers have implemented the change, and thus still exhibit the originally required behavior.
Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:

Change the server-side behavior to avoid the preflight and/or to avoid the redirect
Change the request such that it is a simple request that doesn't cause a preflight

If that's not possible, then another way is to:

Make a simple request (using Response.url for the Fetch API, or XMLHttpRequest.responseURL) to determine what URL the real preflighted request would end up at.
Make another request (the real request) using the URL you obtained from Response.url or XMLHttpRequest.responseURL in the first step.

However, if the request is one that triggers a preflight due to the presence of the Authorization header in the request, you won't be able to work around the limitation using the steps above. And you won't be able to work around it at all unless you have control over the server the request is being made to.Requests with credentials
Note:
When making credentialed requests to a different domain, third-party cookie policies will still apply. The policy is always enforced regardless of any setup on the server and the client as described in this chapter.

The most interesting capability exposed by both fetch() or XMLHttpRequest and CORS is the ability to make "credentialed" requests that are aware of HTTP cookies and HTTP Authentication information. By default, in cross-origin fetch() or XMLHttpRequest calls, browsers will not send credentials.
To ask for a fetch() request to include credentials, set the credentials option to "include".
To ask for an XMLHttpRequest request to include credentials, set the XMLHttpRequest.withCredentials property to true.
In this example, content originally loaded from https://foo.example makes a GET request to a resource on https://bar.other which sets Cookies. Content on foo.example might contain JavaScript like this:
jsconst url = "https://bar.other/resources/credentialed-content/";

const request = new Request(url, { credentials: "include" });

const fetchPromise = fetch(request);
fetchPromise.then((response) => console.log(response));

This code creates a Request object, setting the credentials option to "include" in the constructor, then passes this request into fetch(). Since this is a simple GET request, it is not preflighted but the browser will reject any response that does not have the Access-Control-Allow-Credentials: true header, and not make the response available to the invoking web content.

Here is a sample exchange between client and server:
httpGET /resources/credentialed-content/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Referer: https://foo.example/examples/credential.html
Origin: https://foo.example
Cookie: pageAccess=2

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain

[text/plain content]

Although the request's Cookie header contains the cookie destined for the content on https://bar.other, if bar.other did not respond with an Access-Control-Allow-Credentials with value true, as demonstrated in this example, the response would be ignored and not made available to the web content.
Preflight requests and credentials
CORS-preflight requests must never include credentials. The response to a preflight request must specify Access-Control-Allow-Credentials: true to indicate that the actual request can be made with credentials.

Note:
Some enterprise authentication services require that TLS client certificates be sent in preflight requests, in contravention of the Fetch specification.
Firefox 87 allows this non-compliant behavior to be enabled by setting the preference: network.cors_preflight.allow_client_cert to true (Firefox bug 1511151). Chromium-based browsers currently always send TLS client certificates in CORS preflight requests (Chrome bug 775438).

Credentialed requests and wildcards
When responding to a credentialed request:

The server must not specify the * wildcard for the Access-Control-Allow-Origin response-header value, but must instead specify an explicit origin; for example: Access-Control-Allow-Origin: https://example.com
The server must not specify the * wildcard for the Access-Control-Allow-Headers response-header value, but must instead specify an explicit list of header names; for example, Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
The server must not specify the * wildcard for the Access-Control-Allow-Methods response-header value, but must instead specify an explicit list of method names; for example, Access-Control-Allow-Methods: POST, GET
The server must not specify the * wildcard for the Access-Control-Expose-Headers response-header value, but must instead specify an explicit list of header names; for example, Access-Control-Expose-Headers: Content-Encoding, Kuma-Revision

If a request includes a credential (most commonly a Cookie header) and the response includes an Access-Control-Allow-Origin: * header (that is, with the wildcard), the browser will block access to the response, and report a CORS error in the devtools console.
But if a request does include a credential (like the Cookie header) and the response includes an actual origin rather than the wildcard (like, for example, Access-Control-Allow-Origin: https://example.com), then the browser will allow access to the response from the specified origin.
Also note that any Set-Cookie response header in a response would not set a cookie if the Access-Control-Allow-Origin value in that response is the * wildcard rather an actual origin.
Third-party cookies
Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from foo.example but the Cookie header in the response is sent by bar.other, and would thus not be saved if the user's browser is configured to reject all third-party cookies.
Cookie in the request may also be suppressed in normal third-party cookie policies. The enforced cookie policy may therefore nullify the capability described in this chapter, effectively preventing you from making credentialed requests whatsoever.
Cookie policy around the SameSite attribute would apply.The HTTP response headersThis section lists the HTTP response headers that servers return for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.Access-Control-Allow-OriginA returned resource may have one Access-Control-Allow-Origin header with the following syntax:
httpAccess-Control-Allow-Origin: <origin> | *

Access-Control-Allow-Origin specifies either a single origin which tells browsers to allow that origin to access the resource; or else — for requests without credentials — the * wildcard tells browsers to allow any origin to access the resource.
For example, to allow code from the origin https://mozilla.org to access the resource, you can specify:
httpAccess-Control-Allow-Origin: https://mozilla.org
Vary: Origin

If the server specifies a single origin (that may dynamically change based on the requesting origin as part of an allowlist) rather than the * wildcard, then the server should also include Origin in the Vary response header to indicate to clients that server responses will differ based on the value of the Origin request header.Access-Control-Expose-HeadersThe Access-Control-Expose-Headers header adds the specified headers to the allowlist that JavaScript (such as Response.headers) in browsers is allowed to access.
httpAccess-Control-Expose-Headers: <header-name>[, <header-name>]*

For example, the following:
httpAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header

…would allow the X-My-Custom-Header and X-Another-Custom-Header headers to be exposed to the browser.Access-Control-Max-AgeThe Access-Control-Max-Age header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.
httpAccess-Control-Max-Age: <delta-seconds>

The delta-seconds parameter indicates the number of seconds the results can be cached.Access-Control-Allow-CredentialsThe Access-Control-Allow-Credentials header indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple GET requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.
httpAccess-Control-Allow-Credentials: true

Credentialed requests are discussed above.Access-Control-Allow-MethodsThe Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.
httpAccess-Control-Allow-Methods: <method>[, <method>]*

An example of a preflight request is given above, including an example which sends this header to the browser.Access-Control-Allow-HeadersThe Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. This header is the server side response to the browser's Access-Control-Request-Headers header.
httpAccess-Control-Allow-Headers: <header-name>[, <header-name>]*
The HTTP request headersThis section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers making cross-origin requests do not have to set any cross-origin sharing request headers programmatically.OriginThe Origin header indicates the origin of the cross-origin access request or preflight request.
httpOrigin: <origin>

The origin is a URL indicating the server from which the request is initiated. It does not include any path information, only the server name.

Note:
The origin value can be null.

Note that in any access control request, the Origin header is always sent.Access-Control-Request-MethodThe Access-Control-Request-Method is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.
httpAccess-Control-Request-Method: <method>

Examples of this usage can be found above.Access-Control-Request-HeadersThe Access-Control-Request-Headers header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made (for example, by passing them as the headers option). This browser-side header will be answered by the complementary server-side header of Access-Control-Allow-Headers.
httpAccess-Control-Request-Headers: <field-name>[,<field-name>]*

Examples of this usage can be found above.SpecificationsSpecificationFetch # http-access-control-allow-originBrowser compatibilitySee also

CORS errors


Enable CORS: I want to add CORS support to my server


Fetch API

XMLHttpRequest

Will it CORS? - an interactive CORS explainer & generator


How to run Chrome browser without CORS


Using CORS with All (Modern) Browsers


Stack Overflow answer with "how to" info for dealing with common problems:

How to avoid the CORS preflight
How to use a CORS proxy to get around "No Access-Control-Allow-Origin header"
How to fix "Access-Control-Allow-Origin header must not be the wildcard"


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCross-Origin Resource Sharing (CORS)Baseline Widely availableThis feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015.Learn moreSee full compatibilityReport feedbackCross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources. CORS also relies on a mechanism by which browsers make a "preflight" request to the server hosting the cross-origin resource, in order to check that the server will permit the actual request. In that preflight, the browser sends headers that indicate the HTTP method and headers that will be used in the actual request.
An example of a cross-origin request: the front-end JavaScript code served from https://domain-a.com uses fetch() to make a request for https://domain-b.com/data.json.
For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. For example, fetch() and XMLHttpRequest follow the same-origin policy. This means that a web application using those APIs can only request resources from the same origin the application was loaded from unless the response from other origins includes the right CORS headers.

The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Browsers use CORS in APIs such as fetch() or XMLHttpRequest to mitigate the risks of cross-origin HTTP requests.What requests use CORS?This cross-origin sharing standard can enable cross-origin HTTP requests for:

Invocations of fetch() or XMLHttpRequest, as discussed above.
Web Fonts (for cross-domain font usage in @font-face within CSS), so that servers can deploy TrueType fonts that can only be loaded cross-origin and used by websites that are permitted to do so.
WebGL textures.
Images/video frames drawn to a canvas using drawImage().
CSS Shapes from images.

This is a general article about Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.Functional overviewThe Cross-Origin Resource Sharing standard works by adding new HTTP headers that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than GET, or POST with certain MIME types), the specification mandates that browsers "preflight" the request, soliciting supported methods from the server with the HTTP OPTIONS request method, and then, upon "approval" from the server, sending the actual request. Servers can also inform clients whether "credentials" (such as Cookies and HTTP Authentication) should be sent with requests.
CORS failures result in errors but for security reasons, specifics about the error are not available to JavaScript. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.
Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.Examples of access control scenariosWe present three scenarios that demonstrate how Cross-Origin Resource Sharing works. All these examples use fetch(), which can make cross-origin requests in any supporting browser.Simple requestsSome requests don't trigger a CORS preflight. Those are called simple requests from the obsolete CORS spec, though the Fetch spec (which now defines CORS) doesn't use that term.
The motivation is that the <form> element from HTML 4.0 (which predates cross-site fetch() and XMLHttpRequest) can submit simple requests to any origin, so anyone writing a server must already be protecting against cross-site request forgery (CSRF). Under this assumption, the server doesn't have to opt-in (by responding to a preflight request) to receive any request that looks like a form submission, since the threat of CSRF is no worse than that of form submission. However, the server still must opt-in using Access-Control-Allow-Origin to share the response with the script.
A simple request is one that meets all the following conditions:


One of the allowed methods:

GET
HEAD
POST



Apart from the headers automatically set by the user agent (for example, Connection, User-Agent, or the forbidden request headers), the only headers which are allowed to be manually set are the CORS-safelisted request-headers, which are:

Accept
Accept-Language
Content-Language
Content-Type (please note the additional requirements below)
Range (only with a single range header value; e.g., bytes=256- or bytes=127-255)



The only type/subtype combinations allowed for the media type specified in the Content-Type header are:

application/x-www-form-urlencoded
multipart/form-data
text/plain



If the request is made using an XMLHttpRequest object, no event listeners are registered on the object returned by the XMLHttpRequest.upload property used in the request; that is, given an XMLHttpRequest instance xhr, no code has called xhr.upload.addEventListener() to add an event listener to monitor the upload.


No ReadableStream object is used in the request.



Note:
WebKit Nightly and Safari Technology Preview place additional restrictions on the values allowed in the Accept, Accept-Language, and Content-Language headers. If any of those headers have "nonstandard" values, WebKit/Safari does not consider the request to be a "simple request". What values WebKit/Safari consider "nonstandard" is not documented, except in the following WebKit bugs:

Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-Language
Allow commas in Accept, Accept-Language, and Content-Language request headers for simple CORS
Switch to a blacklist model for restricted Accept headers in simple CORS requests

No other browsers implement these extra restrictions because they're not part of the spec.

For example, suppose web content at https://foo.example wishes to fetch JSON content from domain https://bar.other. Code of this sort might be used in JavaScript deployed on foo.example:
jsconst fetchPromise = fetch("https://bar.other");

fetchPromise
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
  });

This operation performs a simple exchange between the client and the server, using CORS headers to handle the privileges:

Let's look at what the browser will send to the server in this case:
httpGET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://foo.example

The request header of note is Origin, which shows that the invocation is coming from https://foo.example.
Now let's see how the server responds:
httpHTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml

[…XML Data…]

In response, the server returns a Access-Control-Allow-Origin header with Access-Control-Allow-Origin: *, which means that the resource can be accessed by any origin.
httpAccess-Control-Allow-Origin: *

This pattern of the Origin and Access-Control-Allow-Origin headers is the simplest use of the access control protocol. If the resource owners at https://bar.other wished to restrict access to the resource to requests only from https://foo.example (i.e., no domain other than https://foo.example can access the resource in a cross-origin manner), they would send:
httpAccess-Control-Allow-Origin: https://foo.example


Note:
When responding to a credentialed requests request, the server must specify an origin in the value of the Access-Control-Allow-Origin header, instead of specifying the * wildcard.
Preflighted requestsUnlike simple requests, for "preflighted" requests the browser first sends an HTTP request using the OPTIONS method to the resource on the other origin, in order to determine if the actual request is safe to send. Such cross-origin requests are preflighted since they may have implications for user data.
The following is an example of a request that will be preflighted:
jsconst fetchPromise = fetch("https://bar.other/doc", {
  method: "POST",
  mode: "cors",
  headers: {
    "Content-Type": "text/xml",
    "X-PINGOTHER": "pingpong",
  },
  body: "<person><name>Arun</name></person>",
});

fetchPromise.then((response) => {
  console.log(response.status);
});

The example above creates an XML body to send with the POST request. Also, a non-standard HTTP X-PINGOTHER request header is set. Such headers are not part of HTTP/1.1, but are generally useful to web applications. Since the request uses a Content-Type of text/xml, and since a custom header is set, this request is preflighted.


Note:
As described below, the actual POST request does not include the Access-Control-Request-* headers; they are needed only for the OPTIONS request.

Let's look at the full exchange between client and server. The first exchange is the preflight request/response:
httpOPTIONS /doc HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: content-type,x-pingother

HTTP/1.1 204 No Content
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive

The first block above represents the preflight request with the OPTIONS method. The browser determines that it needs to send this based on the request parameters that the JavaScript code snippet above was using, so that the server can respond whether it is acceptable to send the request with the actual request parameters. OPTIONS is an HTTP/1.1 method that is used to determine further information from servers, and is a safe method, meaning that it can't be used to change the resource. Note that along with the OPTIONS request, two other request headers are sent:
httpAccess-Control-Request-Method: POST
Access-Control-Request-Headers: content-type,x-pingother

The Access-Control-Request-Method header notifies the server as part of a preflight request that when the actual request is sent, it will do so with a POST request method. The Access-Control-Request-Headers header notifies the server that when the actual request is sent, it will do so with X-PINGOTHER and Content-Type custom headers. Now the server has an opportunity to determine whether it can accept a request under these conditions.
The second block above is the response that the server returns, which indicate that the request method (POST) and request headers (X-PINGOTHER) are acceptable. Let's have a closer look at the following lines:
httpAccess-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400

The server responds with Access-Control-Allow-Origin: https://foo.example, restricting access to the requesting origin domain only. It also responds with Access-Control-Allow-Methods, which says that POST and GET are valid methods to query the resource in question (this header is similar to the Allow response header, but used strictly within the context of access control).
The server also sends Access-Control-Allow-Headers with a value of X-PINGOTHER, Content-Type, confirming that these are permitted headers to be used with the actual request. Like Access-Control-Allow-Methods, Access-Control-Allow-Headers is a comma-separated list of acceptable headers.
Finally, Access-Control-Max-Age gives the value in seconds for how long the response to the preflight request can be cached without sending another preflight request. The default value is 5 seconds. In the present case, the max age is 86400 seconds (= 24 hours). Note that each browser has a maximum internal value that takes precedence when the Access-Control-Max-Age exceeds it.
Once the preflight request is complete, the real request is sent:
httpPOST /doc HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Referer: https://foo.example/examples/preflightInvocation.html
Content-Length: 55
Origin: https://foo.example
Pragma: no-cache
Cache-Control: no-cache

<person><name>Arun</name></person>

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 235
Keep-Alive: timeout=2, max=99
Connection: Keep-Alive
Content-Type: text/plain

[Some XML content]

Preflighted requests and redirects
Not all browsers currently support following redirects after a preflighted request. If a redirect occurs after such a request, some browsers currently will report an error message such as the following:

The request was redirected to https://example.com/foo, which is disallowed for cross-origin requests that require preflight.
Request requires preflight, which is disallowed to follow cross-origin redirects.

The CORS protocol originally required that behavior but was subsequently changed to no longer require it. However, not all browsers have implemented the change, and thus still exhibit the originally required behavior.
Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:

Change the server-side behavior to avoid the preflight and/or to avoid the redirect
Change the request such that it is a simple request that doesn't cause a preflight

If that's not possible, then another way is to:

Make a simple request (using Response.url for the Fetch API, or XMLHttpRequest.responseURL) to determine what URL the real preflighted request would end up at.
Make another request (the real request) using the URL you obtained from Response.url or XMLHttpRequest.responseURL in the first step.

However, if the request is one that triggers a preflight due to the presence of the Authorization header in the request, you won't be able to work around the limitation using the steps above. And you won't be able to work around it at all unless you have control over the server the request is being made to.Requests with credentials
Note:
When making credentialed requests to a different domain, third-party cookie policies will still apply. The policy is always enforced regardless of any setup on the server and the client as described in this chapter.

The most interesting capability exposed by both fetch() or XMLHttpRequest and CORS is the ability to make "credentialed" requests that are aware of HTTP cookies and HTTP Authentication information. By default, in cross-origin fetch() or XMLHttpRequest calls, browsers will not send credentials.
To ask for a fetch() request to include credentials, set the credentials option to "include".
To ask for an XMLHttpRequest request to include credentials, set the XMLHttpRequest.withCredentials property to true.
In this example, content originally loaded from https://foo.example makes a GET request to a resource on https://bar.other which sets Cookies. Content on foo.example might contain JavaScript like this:
jsconst url = "https://bar.other/resources/credentialed-content/";

const request = new Request(url, { credentials: "include" });

const fetchPromise = fetch(request);
fetchPromise.then((response) => console.log(response));

This code creates a Request object, setting the credentials option to "include" in the constructor, then passes this request into fetch(). Since this is a simple GET request, it is not preflighted but the browser will reject any response that does not have the Access-Control-Allow-Credentials: true header, and not make the response available to the invoking web content.

Here is a sample exchange between client and server:
httpGET /resources/credentialed-content/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Referer: https://foo.example/examples/credential.html
Origin: https://foo.example
Cookie: pageAccess=2

HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain

[text/plain content]

Although the request's Cookie header contains the cookie destined for the content on https://bar.other, if bar.other did not respond with an Access-Control-Allow-Credentials with value true, as demonstrated in this example, the response would be ignored and not made available to the web content.
Preflight requests and credentials
CORS-preflight requests must never include credentials. The response to a preflight request must specify Access-Control-Allow-Credentials: true to indicate that the actual request can be made with credentials.

Note:
Some enterprise authentication services require that TLS client certificates be sent in preflight requests, in contravention of the Fetch specification.
Firefox 87 allows this non-compliant behavior to be enabled by setting the preference: network.cors_preflight.allow_client_cert to true (Firefox bug 1511151). Chromium-based browsers currently always send TLS client certificates in CORS preflight requests (Chrome bug 775438).

Credentialed requests and wildcards
When responding to a credentialed request:

The server must not specify the * wildcard for the Access-Control-Allow-Origin response-header value, but must instead specify an explicit origin; for example: Access-Control-Allow-Origin: https://example.com
The server must not specify the * wildcard for the Access-Control-Allow-Headers response-header value, but must instead specify an explicit list of header names; for example, Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
The server must not specify the * wildcard for the Access-Control-Allow-Methods response-header value, but must instead specify an explicit list of method names; for example, Access-Control-Allow-Methods: POST, GET
The server must not specify the * wildcard for the Access-Control-Expose-Headers response-header value, but must instead specify an explicit list of header names; for example, Access-Control-Expose-Headers: Content-Encoding, Kuma-Revision

If a request includes a credential (most commonly a Cookie header) and the response includes an Access-Control-Allow-Origin: * header (that is, with the wildcard), the browser will block access to the response, and report a CORS error in the devtools console.
But if a request does include a credential (like the Cookie header) and the response includes an actual origin rather than the wildcard (like, for example, Access-Control-Allow-Origin: https://example.com), then the browser will allow access to the response from the specified origin.
Also note that any Set-Cookie response header in a response would not set a cookie if the Access-Control-Allow-Origin value in that response is the * wildcard rather an actual origin.
Third-party cookies
Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from foo.example but the Cookie header in the response is sent by bar.other, and would thus not be saved if the user's browser is configured to reject all third-party cookies.
Cookie in the request may also be suppressed in normal third-party cookie policies. The enforced cookie policy may therefore nullify the capability described in this chapter, effectively preventing you from making credentialed requests whatsoever.
Cookie policy around the SameSite attribute would apply.The HTTP response headersThis section lists the HTTP response headers that servers return for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.Access-Control-Allow-OriginA returned resource may have one Access-Control-Allow-Origin header with the following syntax:
httpAccess-Control-Allow-Origin: <origin> | *

Access-Control-Allow-Origin specifies either a single origin which tells browsers to allow that origin to access the resource; or else — for requests without credentials — the * wildcard tells browsers to allow any origin to access the resource.
For example, to allow code from the origin https://mozilla.org to access the resource, you can specify:
httpAccess-Control-Allow-Origin: https://mozilla.org
Vary: Origin

If the server specifies a single origin (that may dynamically change based on the requesting origin as part of an allowlist) rather than the * wildcard, then the server should also include Origin in the Vary response header to indicate to clients that server responses will differ based on the value of the Origin request header.Access-Control-Expose-HeadersThe Access-Control-Expose-Headers header adds the specified headers to the allowlist that JavaScript (such as Response.headers) in browsers is allowed to access.
httpAccess-Control-Expose-Headers: <header-name>[, <header-name>]*

For example, the following:
httpAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header

…would allow the X-My-Custom-Header and X-Another-Custom-Header headers to be exposed to the browser.Access-Control-Max-AgeThe Access-Control-Max-Age header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.
httpAccess-Control-Max-Age: <delta-seconds>

The delta-seconds parameter indicates the number of seconds the results can be cached.Access-Control-Allow-CredentialsThe Access-Control-Allow-Credentials header indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple GET requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.
httpAccess-Control-Allow-Credentials: true

Credentialed requests are discussed above.Access-Control-Allow-MethodsThe Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.
httpAccess-Control-Allow-Methods: <method>[, <method>]*

An example of a preflight request is given above, including an example which sends this header to the browser.Access-Control-Allow-HeadersThe Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. This header is the server side response to the browser's Access-Control-Request-Headers header.
httpAccess-Control-Allow-Headers: <header-name>[, <header-name>]*
The HTTP request headersThis section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers making cross-origin requests do not have to set any cross-origin sharing request headers programmatically.OriginThe Origin header indicates the origin of the cross-origin access request or preflight request.
httpOrigin: <origin>

The origin is a URL indicating the server from which the request is initiated. It does not include any path information, only the server name.

Note:
The origin value can be null.

Note that in any access control request, the Origin header is always sent.Access-Control-Request-MethodThe Access-Control-Request-Method is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.
httpAccess-Control-Request-Method: <method>

Examples of this usage can be found above.Access-Control-Request-HeadersThe Access-Control-Request-Headers header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made (for example, by passing them as the headers option). This browser-side header will be answered by the complementary server-side header of Access-Control-Allow-Headers.
httpAccess-Control-Request-Headers: <field-name>[,<field-name>]*

Examples of this usage can be found above.SpecificationsSpecificationFetch # http-access-control-allow-originBrowser compatibilitySee also

CORS errors


Enable CORS: I want to add CORS support to my server


Fetch API

XMLHttpRequest

Will it CORS? - an interactive CORS explainer & generator


How to run Chrome browser without CORS


Using CORS with All (Modern) Browsers


Stack Overflow answer with "how to" info for dealing with common problems:

How to avoid the CORS preflight
How to use a CORS proxy to get around "No Access-Control-Allow-Origin header"
How to fix "Access-Control-Allow-Origin header must not be the wildcard"


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 14, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\nAbout MDN
Empowering developers worldwide to build a better, open web

45K Pages of content
7 Languages
46M Monthly pageviews
Who we areMDN is an open-source, collaborative project owned by Mozilla Corporation and
developed by Mozilla, in partnership with a global community of volunteers and
partners. Mozilla’s MDN team leads the platform’s development, content strategy,
and overall direction, while the community actively
contributes to content creation, translations, and browser compatibility
improvements, ensuring MDN remains a vital and evolving resource for all.What we offerOur journeyOur core valuesOur teamOur partners

MDN Web Docs
Your comprehensive resource for web development documentation, covering
everything from CSS, HTML,
JavaScript, Web APIs, and
other web technologies.


MDN Learn
Ideal for beginners, MDN Learn offers guides and a
structured curriculum to kickstart your web development
journey. Enhance your learning with interactive courses from our partner,
Scrimba.


MDN Blog
Stay updated with the latest in web development. Our blog
features updates, tips, tutorials from web experts, MDN announcements, and
curated sponsored content.


MDN Plus
Experience a personalized MDN with our premium subscription service. Enjoy
features like AI-powered assistance and
Collections to streamline your workflow.


MDN Tools
Experiment and learn with tools like Playground for live coding
and HTTP Observatory for analyzing website security,
designed to enhance your development experience.

From our beginnings to becoming the go-to resource for web developers worldwide,
here's how we've evolved:


2005
Launched as
DevMo by Mozilla,
a community-driven wiki dedicated to documenting open web standards.



2010
Rebranded as
Mozilla Developer Network (MDN),
reinforcing our commitment to the developer community.



2017
Achieved a milestone when major tech companies began contributing and
supporting web documentation on our platform, solidifying MDN as the central
hub for web development knowledge.


2020
Transitioned from its wiki-based origins to a modern,
GitHub-hosted project with the launch of Yari,
modernizing our infrastructure and workflows.



2022
Unveiled a
major redesign and
introduced
MDN Plus,
offering personalized features for an enhanced user experience.



2023/2024
Launched new tools, including Playground for coding experiments, AI Help for
easier content discovery, and HTTP Observatory for website security scans. We
also introduced a Blog to cover interesting topics beyond MDN’s core focus,
and a Curriculum to provide a structured approach to learning web development.


Discover more
We had fun exploring the
internet archives
and putting together a fast-forward trip through our transformation!























Accurate and reliable
MDN is built on the fundamental principle of accuracy, which has established
it as the trusted source of web documentation globally. We are committed to
providing expertly curated and rigorously reviewed content to maintain the
highest standards of quality and accuracy. Our dedication is backed by the
best developer community in the world—a passionate group of contributors who
help us enhance and refine our documentation. We welcome the knowledge and
experience of our diverse developer community to ensure that millions of users
can rely on MDN daily for up-to-date and accurate information.


Collaborative and community-driven
MDN is a Mozilla project that is powered by its global community. We are a
diverse group of developers, writers, and technologists working together to
build resources for a better web. Our open-source approach welcomes
contributions from anyone. Each of the individuals who have
contributed over the past decades has strengthened MDN. Through our GitHub
repository, contributors can make changes and get their work reviewed and
integrated into MDN’s content.


Inclusive and dynamic
MDN is committed to providing documentation for a wide range of web
technologies while continuously adapting to the changing landscape of web
development. We strive to create content that’s relevant and valuable to
developers working across different browsers and platforms. We are dedicated
to regularly updating our resources to reflect the latest standards and best
practices, helping developers stay current in a rapidly changing field.


Our mission
At MDN, our mission is to provide developers with the resources they need to
create innovative and accessible web experiences. We offer a free,
high-quality, and comprehensive platform that includes documentation on
essential web technologies like CSS,
HTML, JavaScript, and
Web APIs. Our learning materials
are tailored for a diverse audience—from beginners and students to professors
teaching web development.

From technical writers and engineers to product and community managers, we are a
diverse group dedicated to driving MDN’s mission, growth, and success. Get to
know the people behind MDN and discover what motivates us to keep you at the
forefront of web development!

Joe Walker

Senior Director

@joewalker
Joe is based in London and has been at Mozilla since 2009. He got interested in Mozilla after suddenly being anointed as the maintainer of Venkman, a precursor to Firebug. He later worked on and managed Firebug and Firefox DevTools. Since 2020, he's managed various teams across Firefox Web Platform, including looking after the core parts of Firefox that you don't usually see—like JavaScript and the DOM. In 2025, he took on the leadership of MDN as well. Joe sometimes works from his office at the bottom of a disused canal, with three chickens and a few newts for company.



Ruth John

Senior Manager

@Rumyra
Based in the UK, Ruth has been working on MDN since 2017. Starting out as a
contracting technical writer documenting fun Web APIs, she joined the team
full-time in 2021 and now heads up the content and community teams. She has
always been a big supporter of the web platform due to her long experience as
a front-end developer and cares deeply about the accuracy and usefulness of
MDN for its developer audience. In her spare time, you can find her walking
her dog Yoshi or in her studio, where she enjoys sewing, sculpting, painting,
and anything else that takes her away from a screen.



Florian Dieminger

Senior Engineering Manager

@fiji-flo
A Berlin resident and a long-time Mozilian, Florian was an active community
member before he joined the Mozilla staff in 2018. His passion for the web
spans across front-end, back-end, browser-engine and anything in-between. He
is a nerd outside of work too and is rediscovering online gaming. He loves
spending time with his family.



Dipika Bhattacharya

Staff Technical Writer

@dipikabh
Dipika works out of Toronto. She joined the MDN team in 2022, bringing her
background in instructional design to the role. She is passionate about
delivering clear and concise documentation to make complex concepts easy to
understand, paying special attention to how information is organized and
presented. She cares about improving the clarity, usability, and
discoverability of MDN’s documentation. Outside of work, she loves exploring
the city, discovering unique coffee shops, and trying different cuisines.



Vadim Makeev

Staff Technical Writer

@pepelsbey
Based in Berlin, Vadim has been working on MDN since 2023. He combines his
previous experience as a front-end developer with a deep passion for browsers
and the web platform. Before joining Mozilla, he worked as a DevRel for the
Opera browser, authored front-end courses, and was also involved in organizing
conferences and meetups. In his spare time, he goes on bikepacking trips,
hangs out on punk gigs, and records podcasts and videos in his home studio.



Brian Smith

Staff Technical Writer

@bsmth
Brian has been with MDN since 2022. He lives in Berlin. With around 20 years
of experience hacking on web technologies and working full-time as a technical
writer since 2016, Brian is passionate about open-source software and writing
docs that make complex concepts fun and easy to grasp for people of all
levels. Before joining Mozilla, Brian worked on a TypeScript-like language
specification, a time series database, and REST API documentation for cloud
services. Outside of work, he enjoys exploring new European destinations with
family, discovering local coffee shops, and using music gear as long as it
doesn't have a screen.



Dave Letorey


Technical Writer





@dletorey


Based in London, UK, Dave has been with MDN since 2022 where he's been focused
on Firefox release documentation, particularly HTML, CSS and SVG updates. He's
passionate about web standards, accessibility, performance and digital
inclusion. He is constantly learning about new web technologies and standards.
Outside of work he loves live music and tries to attend as many gigs and music
festivals as he can. He particularly loves post-punk, indie, house and techno.
He also attends many conferences and meetups and is an organizer of
London Web Standards &
State of the Browser. He also has a large
collection of red hats, so is easy to spot in the wild. He is never happier
than when in a field with his friends.




Chris Mills

Technical Writer and Product Strategist

@chrisdavidmills
Based in Greenfield, UK, Chris has been part of MDN since 2013, initially as a
technical writer and then as the writers' team lead until 2021. He came back
on board as a contractor in 2022 to document new technologies and contribute
to various MDN products and initiatives. Chris loves tinkering with CSS and
JavaScript and is passionate about accessibility and semantics. Outside work,
he is obsessed with loud, heavy music, and plays drums and guitar. He enjoys
cycling, country walks, and spending time with his wife and three awesome
kids.



Hamish Willee

Technical Writer

@hamishwillee
Based in Melbourne, Australia, Hamish has been with MDN since 2014, initially
on short-term contracts for various projects. From 2020, he’s been focused on
Firefox release documentation, particularly Web API and HTTP updates, while
also contributing to other aspects of the open-source project. He’s passionate
about efficient processes that maximize time for creating clear, concise, and
maintainable documentation. Hamish values that his writing reaches thousands
of developers and enjoys working with the diverse community to make expert
knowledge accessible to everyone in a clear format. Outside work, he brews
beer, reads science fiction and fantasy, enjoys running, and likes drones.



Andi Pieper

Staff Software Engineer

@argl
Andi lives in Berlin. He joined the MDN team in 2023. He is focused on keeping
up the high quality of MDN and ensuring that it remains an accessible,
competent, and friendly help for anyone concerned with the web, regardless of
their level of expertise. Growing up with the internet of the 90s, Andi has
worked on a multitude of projects on the web over the years, occasionally
veering off into desktop and mobile development. Apart from his daytime
obligations, he enjoys creating organized noise.



Claas Augner

Senior Software Engineer

@caugner
Based in Paris, Claas has been working as a Software Engineer in the MDN team
since 2022. He is passionate about clean code and continuous improvement. He
enjoys entertaining (the team), and maintaining (the platform). Outside of
work, he loves baking rye sourdough breads and playing cooperative board
games.



Leo McArdle

Senior Software Engineer

@LeoMcA
A London-based long-term Mozilla contributor, Leo has been working on MDN
since 2022 and volunteering for Mozilla since around 2008. As a self-taught
developer, largely through MDN, he cares about making the website discoverable
and functional for everyone. In his free time, he can be found cycling around
the city, photographing panoramas, or watching almost every sport imaginable,
from cricket to karting.



Pranshu Khanna

Staff Community Manager

@pransh15
Pranshu has been a long-term contributor to Mozilla as a Rep. Based in Berlin,
he joined the MDN team in 2024. He works on moderating, growing and managing
MDN’s awesome community. Pranshu is passionate about building a healthy and
inclusive community for developers and helping them build better. Before
working at Mozilla, Pranshu gained extensive experience in growing developer
communities for startups, organizing conferences like GraphQL Conf. 2021 &
2022, and running global programs for devs and students around AI, Web, and
DevOps. In his free time, he likes to play football in any form - physical,
digital, and fantasy.



Anuja Rajput

Senior User Experience Designer

@AnujaRajput727
Located in London, Anuja has been a part of the MDN team since 2023. With over
8 years of experience, she has passionately contributed to various phases of
product development, including design, business analysis, and testing. She is
empathetic and deeply cares about understanding users' perspectives and pain
points. She combines her work experience with her creative skills to enhance
her UX designs. In her free time, she enjoys painting, sketching, and travel
sketching.



Sonal Sood

Senior Product Manager

@s-sood
Sonal lives in Berlin. She has been with MDN since 2022. As a product manager,
she is adept at identifying and prioritizing features that truly meet users'
needs. With a strong background in data analysis and product management, she
is always focused on delivering valuable and impactful products that make a
difference. In her free time, Sonal enjoys cycling, running, and practicing
yoga.



Miruna Curtean

Quality Assurance

@mirunacurtean
Miruna calls Cluj-Napoca, Romania home. Contracting with Mozilla since 2019,
she worked on Firefox Add-ons and Mozilla Support before switching to MDN
in 2022. She focuses on analyzing requirements and community issues, building
comprehensive test bases, and ensuring delivered features meet requirements.
Before Mozilla, she worked in game development and e-commerce but found
greater joy in website development, particularly inspired by its community
aspect. Outside of work, Miruna enjoys story-based entertainment including
books, movies, shows, anime, and podcasts.


Product Advisory Board

Rachel Andrew

Content Lead at Google

Rachel has been working on the web as a developer since 1996 and writing about web development for almost as long. She now works for Google as Content Lead for Chrome Developer Relations, owning the content strategy of web.dev and developer.chrome.com, and is also a lead on the Baseline project. Rachel is a CSS Working Group member and specification editor, and in the past has been a contributor to MDN as a contractor for Mozilla and for Google.
Photo © Drew McLellan.



Robert Nyman

Web Developer Relations at Google

Robert wants to make the web the best platform for developers and has always been heavily invested in the community and helping developers succeed. Prior to Google, Robert was a technical evangelist at Mozilla, focused on the Open Web and the company's various products and initiatives. He's a co-founder of Open Web Docs, lives in Stockholm, has a passion for traveling and meeting people, and has given presentations in 42 countries.



Patrick Brosset

Senior Product Manager, Microsoft Edge

Patrick Brosset is a senior Product Manager on the Microsoft Edge web platform team, where he drives efforts around developer advocacy, documentation, and evangelism for the web platform. Patrick has worked with the web for more than 20 years, and on web browsers at Mozilla and Microsoft, including on developer tools, web apps, and the rendering engine for over a decade. He is a member of the Governing Committee at Open Web Docs, and a co-chair of the W3C WebDX Community Group.



Dominique Hazael-Massieux

Web Technology Expert including Web, W3C

Dominique Hazael-Massieux is part of the W3C staff, leading W3C
efforts in developer relations. Dom has been working for W3C since 2000,
and in addition to dev rel, is currently involved in the standardization
of WebRTC, WebNN and looking over the systemic impact of AI on the Web.
Dom also sits on the W3C Board of Directors and on the Open Web Docs
Governing Committee.



Carmen Cañas

Technical Project Manager, Bocoup

Carmen Cañas is part of the worker-owner team at Bocoup where she manages web platform projects and product development projects with a special focus on accessibility and privacy. Before joining Bocoup, she spent over 10 years building open source projects in Latin America and Africa, with a focus on implementing open data standards for publishing government data.  Carmen lives between Cuzcatlán (El Salvador) and Tkaronto (Toronto).



Laura Morinigo

Web Developer Advocate

Laura is a software developer, advocate, and mentor, passionate about sharing her knowledge and connecting with tech communities worldwide. She has been recognized as a Google Developer Expert and a Woman Techmakers Ambassador for her contributions. As a mentor, she has supported startups in accelerator programs like Google Launchpad and the United Nations’ World Food Programme. Currently, Laura contributes to web standards and advocates for advanced web features, helping developers build more inclusive and impactful web applications.




Open Web Docs
Open Web Docs (OWD), an independent open source organization, is one of the most productive contributors to MDN Web Docs. OWD contributes as part of their mission to support “web platform documentation for the benefit of web developers & designers worldwide.” The team at OWD has led or contributed to many projects to improve documentation on MDN. They're an invaluable partner in the day-to-day work of making MDN. Read more about OWD’s activities in their 2024 Impact and Transparency Report and get continuous updates on their Mastodon account.

Florian Scholz

Director

@Elchi3
Florian Scholz is the Director of Open Web Docs. He began volunteer editing MDN as a teen in 2009 and previously worked at Mozilla as MDN's Lead Content Strategist, Technical Writer & Documentation Engineer from 2013 until 2020. He's one of the creators of the browser compatibility data (BCD) project and it makes him happy when open source projects collaborate. He lives in Bremen, Germany; not Berlin. Other than submitting and reviewing PRs on GitHub, he enjoys listening to wave and post-punk music.



Will Bamberg

Sr. Technical Writer and Documentation Engineer

@wbamberg
Will Bamberg is a perfectionist and professional pedant who has been writing about the web for a long time, mostly on MDN. He enjoys learning about new aspects of the web platform and then turning that knowledge into accessible documentation. He believes that writing good documentation depends on understanding what it's like for someone who is learning something new or looking for the answer to their question.



Estelle Weyl

Sr. Technical Writer and Developer Advocate

@estelle
Estelle Weyl is a Sr. Technical Writer and Developer Advocate on the Open Web Docs team. She is a frontend engineer, writing CSS, JS and HTML since 1999. Estelle has always been a web standardista, advocating for a free, accessible, and performant web. Estelle has been documenting and teaching web standards since 2007, writing numerous books, blogs, and tutorials. She’s typing with her cat (who thinks he's a dog) and dog (who thinks she's a cat) in San Francisco.



Queen Vinyl Da.i'gyu-Kazotetsu

Compat Data Engineer

@queengooborg
Vinyl works for Open Web Docs leading the browser compatibility data (BCD) project that millions of developers around the world rely on. Previously a contractor at Google and Mozilla and a long-time BCD community member, Vinyl has a lot of experience with compatibility on the open web. She was already the number #1 contributor to the BCD repository before officially joining our team! When she's not submitting pull requests to BCD, she's usually slicing blocks to the music in Beat Saber or staffing at various conventions across the globe.


Global impactServing over 15 million users monthly from around the globe, MDN connects
developers with the tools and information they need to easily build projects on
the open web.


Educational influence: Our resources are integral to many coding bootcamps and
university courses worldwide.


Trusted reference: Platforms like freeCodeCamp and Codecademy frequently link
to MDN articles as authoritative references.


Industry standard: Tools like Can I use leverage
MDN’s browser compatibility data
for up-to-date information on web feature support across browsers.


Collaborative partnerships: We work closely with partners such as
Open Web Docs,
Microsoft,
Google, Igalia,
W3C, and others to drive web innovation and serve the
common good.

Join us in building a better webBe a part of our mission to foster innovation and inclusivity on the web.
Start contributing today and make a lasting impact
on the global developer community.\n\n\n\n\n\n\n\n\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCreating and working on issuesAs a contributor, you can report and work on issues.
After you report an issue, the issue gets triaged. Issue triaging is typically done by people assigned the role of a maintainer or an owner.General guidelines for participationWhile reporting an issue or participating in a conversation in an issue, always ensure that your inputs are contributing to the overall progress of the project. Consider whether the issues you open and your comments in an issue are constructive and on topic and are not just adding noise.
Do the following:

Before filing an issue, consider if you need to discuss it with the staff/community. Use discussions to gain different viewpoints and to converge on an agreed-upon course of action. This helps to keep issues focused and productive.
After filing an issue, try to fix the problem yourself. Read our contribution guide to learn more.
If you have a question, you can ask it in the MDN Web Docs chat rooms instead of filing an issue.

Avoid doing the following:

Complicating issues by trying to discuss multiple topics or by making off-topic comments.
Opening lots of issues asking vague questions.
Asking questions without trying to solve the problem yourself first.
Guidelines for reporting an issueIssues are used to track bugs. An issue must be a single actionable task or a collection of related actionable tasks and must have a clear outcome.Before filing an issueIf you think you've found a bug with the content on MDN Web Docs or with the look and feel of the website, search the current open issues in the relevant repository and make sure nobody else has reported the issue.Reporting an issueDepending on the type of problem you've discovered, you can report it by filing an issue on one of the main MDN GitHub repositories.
If the information you provide in the issue is incomplete, you might be asked to provide more details during the issue triaging process.
Here are some hints for opening issues:

Choose the appropriate category to report the issue. For example, to report a content bug, use the Content issue template in the mdn/content repository.
Provide sufficient information while reporting the issue:

Issue title must convey succinctly the required action.
Issue description must clearly describe the bug and the action required to resolve the issue. It must also list the task or sub-tasks to be completed to resolve the issue. Some other guidelines include:

Use the description field to indicate the status of the task or sub-tasks by using checklists.
Update the status of a task in the issue description instead of commenting on the issue. Use task lists in the description if an issue has multiple parts. This helps others who may otherwise need to scroll through comments on the issue to determine the status of various tasks.
Comments in an issue should be limited to details or context that help resolve the issue.




If you find yourself in one of the following situations, move the conversation to MDN's discussion on GitHub:

A discussion needs to take place to clarify an issue.
A discussion begins after opening the issue.
The issue has no clear consensus on its resolution.
The requirements for completing the task expand while it's being resolved or the work is unclear.


For minor bugs, you can make the changes yourself and submit a pull request.
Creating a task list issueIf the issue you're opening is not to report a bug but to perform a series of tasks, you can create the issue as a task list.
Explain the context or reason for performing the tasks in the description.
Ensure that you list all the actionable tasks as a checklist.
For example:
md// Issue title
Ensure sections follow the order defined in the CSS property template

### Description

The CSS property page template is defined [here](/en-US/docs/MDN/Writing_guidelines/Page_structures/Page_types/CSS_property_page_template).
The task list in this issue will be used to compare the documented CSS properties with the template and track changes to the property pages for compliance.

### List of pages checked

- [x] [accent-color](/en-US/docs/Web/CSS/accent-color) - checked, okay
- [ ] [backdrop-filter](/en-US/docs/Web/CSS/backdrop-filter)
- [ ] [letter-spacing](/en-US/docs/Web/CSS/letter-spacing) - open pull request to move `Accessibility concerns` and `Internationalization concerns` sections before the `Specifications` section.
Guidelines for working on an issueRemember that if you take on an issue, the expectation is for the work to be completed in a timely manner. If you're not able to make any progress for a week after being assigned or can no longer complete the required task, leave a comment and unassign yourself from the issue.
These are the general steps for working on an issue:


Find an issue: If you're looking to contribute, search for issues with good first issue, help wanted or p3 label. Most repositories have issues with these labels. You are welcome to browse and pick an issue that is suitable for your skill set. Another useful place to look for issues to work on is the MDN Contributors Task Board. This project view lists open issues from multiple repositories. You can filter the list based on the topics (Labels column) you're interested in. See the description of some of the labels that get applied during the issue triage process.

Note:
An issue with the needs triage label indicates that the MDN Web Docs core team has not reviewed the issue yet, and you shouldn't begin work on it.



Assign the issue to yourself: After finding an issue you'd like to work on, make sure that the issue is not assigned to anybody else. Add a comment saying you would like to work on the issue, and if you are able to, assign the issue to yourself.


Do the research: Most issues need some investigation before work can start.

Scope out the work that needs to be done. If you need to ask questions, ask them in the MDN Web Docs chat rooms.
If the issue is well-described, and the work is pretty obvious, go ahead and do it.
If the issue is not well-described, and/or you are not sure what is needed, feel free to @mention the poster and ask for more information.



Make the changes: Fork and branch the repository. Do your work and open a pull request in the repository. Reference the issue in the pull request description. Depending on the files you've updated in the pull request, a reviewer will be assigned to your pull request automatically. (Teams per topic area are defined in the CODEOWNERS file).
After opening the pull request, if you find you no longer have the time to make changes or incorporate review feedback, let the team know as soon as possible in a comment in the pull request. This will help the team assign another interested contributor to complete the work on the pull request and close the linked issue.


After your pull request has been reviewed and merged, you can mark the linked issue as closed. If you opened the pull request with Fixes #<issue> verbiage, the issue will be closed automatically when the pull request is merged.

Fixing issues yourselfIf you spot a bug — whether it's a problem with the website's look and feel or an error in documentation — you can try to fix it yourself. Learn how you can contribute by going through our contribution guide.
If the bug is small, such as a typo or a minor sentence improvement, or involves an uncontroversial fix, submit a pull request with the changes.
For all other type of bugs, begin by opening the issue. Add a comment about your intent to work on the issue and if possible, describe your proposed solution or steps to fix the issue.
Wait for the issue to be triaged, so that the MDN Web Docs team can verify that the issue is legit and approves your proposed solution.

Note:
If you open a pull request before the issue has been triaged, your time and effort might go waste if the linked issue is deemed invalid or the solution does not match the one expected by the MDN Web Docs team.
After the issue is triaged, assign the issue to yourself.

Using the guidelines on working on an issue, try to fix the problem by updating the appropriate source, such as:

The MDN Web Docs content (in English) in the mdn/content repository
The MDN Web Docs translated content in the mdn/translated-content repository
The MDN Web Docs frontend in the mdn/yari repository

Each repository includes useful information to guide you on how to contribute.
For more information, see our main GitHub repositories.Guidelines for triaging issuesIf you are a maintainer or an owner in the MDN Web Docs GitHub organization, you are responsible for triaging issues in one or more MDN Web Docs repository.
The overall process for triaging includes some general and some issue-specific tasks.General triaging tasks

When an issue is opened, the needs triage label is set on the issue automatically. You can search for this label to look for issues that need to be triaged. Contributors or anybody else should not work on the issue until the issue has been triaged. (Triagers should remember to remove the needs triage label after triaging the issue.)


In the mdn/content repository, an additional Content: label, such as Content:CSS or Content:WebAPI, is set on the issue automatically. This gets set based on the MDN URL mentioned in the issue. You can use the content-specific label to look for issues to be triaged in your specific topic area.


If an issue concerns an active, non-en-US locale, set the appropriate label, such as l10n-fr, l10n-zh, or l10n-ja. The teams for those locales will pick these issues up and triage them.


You don't need to actively triage issues all the time. Set aside time, say 30 minutes every week, to triage issues on a regular basis in your area of responsibility. Triaging doesn't have to be done as part of a synchronous meeting or even at the same time as everyone else, but it should be done regularly to make sure that the backlog of untriaged bugs doesn't get too high.


Apart from triaging incoming issues every week, review the list of old bugs to see if there are any that are stalled, need closing, or are no longer relevant. The idle label is automatically set on issues that have had no activity for 30 days.

Check assigned issues that are still open to see if the assignee is making progress. If there is no progress after a week of being assigned, ask them if they still have time to work on the issue. If another week passes by without any progress, unassign them and leave a comment indicating that you're making the issue available for other interested contributors.
If a pull request has been opened to fix the issue but has not been reviewed for a week, give the reviewer a gentle ping to ask if they can get to it.
If a pull request to fix the issue is waiting on review comments to be addressed after a week, then ask the author if they can respond to their review. If another week goes by, either fix the review comments yourself if you have time, or close the pull request and unassign the related issue.


Issue-specific triaging tasksThese are the guidelines to follow while triaging each issue.
Review if the issue is valid
These are some of the things to keep in mind while reviewing the validity of an issue:

Check if the issue raised is valid and if the fix will improve the content for the readers and the website.
Evaluate if the impact of the fix will be small or site-wide.
Evaluate if the fix for the issue will need a discussion first, in which case, point the author to open a discussion instead.
Check if the issue complies with our writing guidelines and templates.
Check whether suggestions for adding links comply with our external links policy.

Review the issue for completeness of information
Review each issue against the following checklist to ensure that the issue contains the described information for someone to start working on the bug:

URL of the MDN Web Docs page with the problem or URL of an example MDN Web Docs page if the problem exists on multiple pages
The specific heading or section on the MDN Web Docs page where the problem was found
A clear description of the incorrect, unhelpful, incomplete, or missing information

If any of the above information is not present, then you should ask the author of the issue to provide these details, and add the needs info label to the issue. Resume triaging the issue only after those details have been provided (after which, you can remove the needs info label). It is okay to wait for up to a week to get a response from the author.
Set a priority label
For each bug, set a priority label based on the severity of the issue to help people who want to work on the most important issues or areas.


Critical issue: This type of issue needs to be fixed as soon as possible, regardless of where it appears on the site. This type of issue could damage MDN's reputation severely and/or harm users. Examples of this issue include an incorrect code snippet, which if used in production, could create a severe security problem and undesirable content such as malware, profanity, pornography, hate speech, or links to such content.

Label: p0 (will be addressed immediately)



Major issue: This type of issue could severely affect a page's usefulness. For example, a significant amount of out-of-date information, a complex and important code example that doesn't work, a significant amount of prose that is badly written and hard to understand, or a large number of broken links.

Labels: p1 (will be addressed soon) and p2 (will be addressed soon, but higher priority items will take precedence)



Minor issue: This is a type of improvement issue that can make the existing content better but does not affect learning or only has a minor effect on learning. Since these types of issues are not actively planned for, help from contributors to fix these issues is welcome and much appreciated. Fixing some of these issues can also provide the necessary practice to beginner contributors who are starting to get familiar with the contribution process. Examples include typos, bad grammar, a broken link, a small amount of out-of-date information or badly-written prose, or a code snippet that doesn't work.

Labels: p3 (no visibility when the issue will be addressed)



In general, critical issues should be fixed immediately and are most likely handled by MDN Web Docs staff and peers.
Add helpful information
If possible, add information that can help contributors to fix the issue. The information can be in the form of steps, general approach, links to other similar fixed issues, or reading resources. A well-laid out plan or steps is especially required in issues that are labeled good first issue and can help ramp up new contributors quickly. You can time-box this task to 5-10 minutes.
For example, as a triager, you can add the following information to the issue you are triaging:
mdTo whoever fixes this issue, it looks like the following is needed:

- Update the first paragraph below heading X to correct the problem with Y
- Add a description of X
- Update the compatibility data at Link-X

Set other labels
Next, set the following labels as appropriate:


effort: small, effort: medium, effort: large: Some contributors like to search for bugs based on the time and effort that will be needed to fix the bug. So where possible, you should try to provide an estimate of the required effort.


good first issue: Set this label on the issue if the fix for the issue is really simple and if fixing the issue would provide good practice for a newcomer who is getting used to the process.


help wanted: Set this label if the issue requires help from someone who knows about or is familiar with the topic. This is a popular label and some contributors use it to search for issues to work on in open source projects in their areas of familiarity or expertise.


broken link external: Set this label if the issue involves a broken link to an external page.


document not written: Set this label if the issue involves a necessary document that has not been written yet, usually because a link points to it.


needs content update: Set this label if the issue fix in another repository will need an equivalent fix in the mdn/content repository.

Note:
After the triage process is complete, remove the needs triage label.


Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 7, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\nMDN Community
Where web enthusiasts learn, collaborate, and create

Start contributing
Join MDN Discord



45K+ Total contributors
200+ Weekly commits
7 Language communities
MDN's community powers the webMDN’s strength comes from the passion and dedication of our global community.
Since our founding in 2005, we’ve grown into a thriving network. Together, we’ve
created a comprehensive, open, and free resource that serves web developers
across the globe. With volunteers leading translation efforts in
7 languages, we’re
truly international.Meet our contributorsWe are an open-source community dedicated to building resources for a better
web. Our diverse contributors, including developers, technical writers,
students, educators, designers, and more, come from various backgrounds and
platforms. Anyone can contribute, and each contribution strengthens our
community, driving innovation and improving this vital resource for developers
worldwide.

Join us
View all contributors



Jason Lam, 林家祥 https://github.com/JasonLamv-t Grantit
Nicolò Ribaudo https://github.com/nicolo-ribaudo Igalia
Joshua Chen https://github.com/Josh-Cena
Kimchanmin https://github.com/c17an SK Planet
Gibbeum Yoon https://github.com/givvemee
Jongha Kim https://github.com/wisedog
Qizhe ZHANG https://github.com/PassionPenguin
Artem Shibakov https://github.com/saionaro Bright Data
HoChan Lee https://github.com/hochan222 11STREET
Sangchul Lee https://github.com/1ilsang WoowaBros
Park Sunhee https://github.com/sunhpark42 WoowaBros
FU CHUNHUI https://github.com/fuchunhui Baidu
Estelle Weyl https://github.com/estelle Open Web Docs
Yitao Yin https://github.com/yin1999 Northwestern Polytechnical University
Florian Scholz https://github.com/Elchi3 Open Web Docs

Contributor spotlight


There are many other things I like about MDN: the openness of its
governance, the respect for contributors' work, the professional
conversations, and the always timely reviews. MDN has consistently
demonstrated the ideal form of an open-source project.

Joshua Chen (MDN contributor)



MDN Web Docs has the most up-to-date and accurate information and the
content is presented in an easy-to-understand manner. I also like that it's
available in many languages (very important!).

Yuji (MDN contributor)



There are millions of web developers in China, and many of them begin their
developer journey at MDN Web Docs. Contributing to MDN Web Docs is an
excellent way to help people who are starting out.

YiTao Yin (MDN contributor)


If you wish to be a part of the featured contributors here,
let us know. If you’re featured here
and would like to opt-out,
please file an issue on GitHub.Learn how to get startedWe collaborate on GitHub, our project's home, on
various tasks such as writing and improving documentation, fixing bugs, and
providing review feedback. It starts here, with you. Want to start right away,
but not sure how? Follow
our guide
to make your first contribution.
Watch this video on
how to get started with contributing to MDN.
Video from the community team on contributing to MDNJoin us in shaping a better webBecome part of this globally cherished group that’s dedicated to documenting web
technologies. Whether you’re an expert or a beginner, there’s a place for you in
our inclusive community. Check out some of the ways you can contribute and
engage.


Fix issues
Submit pull requests to fix reported issues.
Squash bugs


Improve content
Fix inaccuracies and fill in missing information.
Start writing


Localize content
Participate in translating content into one of our supported languages.
Find your locale


Answer questions
Share your knowledge and expertise and guide fellow learners.
Help on Discord

Help us fix open issuesNew to MDN or open-source projects? Tackle our beginner-friendly issues to help
improve MDN.TitleRepositoryJoin the conversation

Chat with us on Discord
Connect with the community. Engage with domain experts. Help others learn.
Join MDN Discord


Join our Community Call
Every month, get exclusive updates from the MDN team. Share your ideas and
contributions.
RSVP to the next community call


While working in Mozilla spaces and communities, please adhere to the
Mozilla Community Participation Guidelines,
which promote respect, inclusion, and a harassment-free environment for all
community members.Licensing and reuseMDN's resources are freely available under various open-source licenses. For
detailed information on reusing MDN content, check out our
Attribution and Copyright Licensing
page.\n\n\n\n\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nLearn web developmentThe essential skillset for new front-end developersWelcome to MDN Learning Web Development (also known as Learn). This resource provides a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer, along with challenges and further recommended resources.About Learn web development

Teaches the essential skills and knowledge every front-end developer needs for career success and industry relevance, as defined in the MDN Curriculum.


Created by the MDN community and refined with insights from students, educators, and developers from the broader web community.


Designed to take you from "beginner" to "comfortable" (not "beginner" to "expert"), giving you enough knowledge to use more advanced resources (such as the rest of MDN).



Note:
Last updated: December 2024 (see changelog).
Don't know where to get started?
Never coded before?

Our Getting started modules provide setup tutorials and essential concepts and background information for complete beginners. You should start here if you are a complete beginner (i.e., you've not installed a code editor or written any code yet).

Want to master the essentials?

Our Core modules provide a structured set of tutorials teaching the essential skills and practices for being a successful front-end developer.

Beyond the basics?

Our Extension modules cover useful additional skills to learn as you start to expand your knowledge and develop specialisms. Go onto these after you finish our Core.

Working at a school?

Use our modules to guide your teaching, check out our Educators page for more ideas, or enroll your students in Scrimba's Frontend Developer Career PathMDN learning partner.

Getting our code examplesThe code examples you'll encounter in the Learning Area are all available on GitHub:

The easiest way to get them is to download a ZIP of the latest main code branch.
If you are familiar with Git and GitHub, you could also choose to clone the repository.
Contact usIf you want to get in touch with us about anything, use the communication channels. We'd love to hear from you about anything you think is wrong or missing on the site, requests for new learning topics, requests for help with items you don't understand, or any other questions or concerns.
If you're interested in helping develop/improve the content, take a look at how you can help and get in touch! We are more than happy to talk to you, whether you are a learner, teacher, experienced web developer, or someone else interested in helping to improve the learning experience.See also
The Frontend Developer Career Path MDN learning partner

Scrimba's Frontend Developer Career Path teaches all you need to know to be a competent front-end web developer, with fun interactive lessons and challenges, knowledgeable teachers, and a supportive community. Go from zero to landing your first front-end job! Many of the course components are available as standalone free versions.

Codecademy

A great interactive site for learning programming languages from scratch.

freeCodeCamp.org

Interactive site with tutorials and projects to learn web development.

Learn JavaScript

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nAttribution and copyright licensingMDN Web Docs content is available free of charge and is available under various open-source licenses.Using MDN Web Docs contentThis section covers the types of content we provide and the copyrights and licenses that are in effect for each type if you choose to reuse any of it.Documentation
Note:
The content on MDN Web Docs has been prepared with the contributions of authors from both inside and outside Mozilla. Unless otherwise indicated, the content is available under the terms of the Creative Commons Attribution-ShareAlike license (CC-BY-SA), v2.5 or any later version.

Your reuse of the content here is published under the same license as the original content – CC-BY-SA v2.5 or any later version.
When reusing the content on MDN Web Docs, you need to ensure that attribution is given to the material as well as to "Mozilla Contributors".
Good attribution is the title of the document, with a hyperlink (online) or URL (in print) to the specific page of the content being sourced, and any modifications you've made briefly described.
For example, to provide attribution for this page, you can write:

"Attributions and copyright licensing" by Mozilla Contributors, licensed under CC-BY-SA 2.5.

You may also want to link "Mozilla Contributors" to a contributors.txt file linked in the page footer you're referencing for a list of authors, if reasonable.
See Recommended practices for attribution for more details.Code samplesCode samples added on or after August 20, 2010 are in the public domain CC0. No licensing notice is necessary but if you need one, you can use: Any copyright is dedicated to the Public Domain: https://creativecommons.org/publicdomain/zero/1.0/
Code samples added before August 20, 2010 are available under the MIT license; you should insert the following attribution information into the MIT template: "© <date of last wiki page revision> <name of person who put it in the wiki>".
Since the launch of the new Yari MDN platform on December 14 2020, there is currently no way to determine which one you need. We are working on this and will update this content soon. Your contributionsIf you wish to contribute to MDN Web Docs, you agree that your documentation is available under the Attribution-ShareAlike license (or occasionally an alternative license already specified by the page you are editing) and that your code samples are available under Creative Commons CC-0 (a Public Domain dedication).

Warning:
No new pages may be created using alternate licenses.

Copyright for contributed materials remains with the author unless the author assigns it to someone else.
If you have any questions or concerns about anything discussed here, please contact the MDN Web Docs team.Logos, trademarks, service marks, and wordmarksThe rights in the logos, trademarks, and service marks of the Mozilla Foundation, as well as the look and feel of this website, are not licensed under the Creative Commons license, and to the extent they are works of authorship (like logos and graphic design), they are not included in the work that is licensed under those terms. If you use the text of documents and wish to also use any of these rights, or if you have any other questions about complying with our licensing terms for this collection, you should contact the Mozilla Foundation here: licensing@mozilla.org.Using content from elsewhere on MDN Web DocsIn general, we do not approve of copying content from other sources and putting it on MDN.
MDN should be made up of original content wherever possible.
If we receive a pull request and discover that it contains plagiarized content, we will close it and request that the submitter resubmit the change with the content rewritten into their own words.Reusing or republishing your content on MDN
Note:
Unless there is a good reason to republish the content, we will probably say "no".
The MDN writing team's decision is final.

If someone wants to donate an article to MDN that they previously published on their blog or it makes sense to copy a complex reference sheet to MDN, there may be justification for republishing it. For these cases, discuss your plan with the MDN team beforehand:

Create a GitHub issue that explains your intention.

Describe what you would like to copy or republish.
Provide a URL to the resource.
Explain why you think it's appropriate.



If the content is published under a closed license:

If you hold the rights to the content, state this and your express agreement to republish it on MDN.
If you do not hold the rights to the content, include the author/publisher on the issue if possible, or include details of how they could be contacted so we can ask them for permission to republish the content.

If the content is published under an open license:

Say what it is, and link to the license so we can check whether it is compatible with MDN's license.
Linking to MDN Web Docs articlesWe regularly get users asking us questions about how to link to MDN Web Docs and whether or not it is even allowed. The short answer is: yes, you can link to MDN Web Docs! Not only is the hypertext link the essence of the web, it is both a way to point your users to valuable resources as well as a show of trust toward the work our community does.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 19, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\nResources for Developers, by DevelopersDocumenting web technologies, including CSS, HTML, and JavaScript, since 2005.Search MDNClear search inputSearchFeatured articlesBlogJavaScript Temporal is comingA new way to handle dates and times is being added to JavaScript. Let's take a look at Temporal, what problems it solves, the current state, and what you'll find in the new documentation about it on MDN.
CSSCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
Web APIsUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).
JavaScriptTemporalThe Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.
Latest newsMDN 2024 content projectsdeveloper.mozilla.org4 months agoA new learning experience on MDNdeveloper.mozilla.org4 months agoIntroducing the new MDN Community pagedeveloper.mozilla.org6 months agoRecent contributionsElementInternals.aria* examplesmdn/content2 days agofix: replaces "a" in "an"mdn/contenta day agoAdd space after // in commentmdn/content6 hours agoFix case of `Document.styleSheets` reference in DOM scripting introductionmdn/content6 hours agoCorrect an article overviewmdn/content4 hours ago訳語の修正: 実現方法→手引mdn/translated-contentan hour agoContributor SpotlightYash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.Get involved →\n\n\n\n\n\nJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy ControlPrevious Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\nIn this articleWhat is JavaScript Temporal?Core conceptsTemporal examplesTrying Temporal and browser supportAcknowledgementsSee alsoJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\nJavaScript Temporal is comingBrian SmithJanuary 24, 20255 minute readImplementations of the new JavaScript Temporal object are starting to be shipped in experimental releases of browsers.
This is big news for web developers because working with dates and times in JavaScript will be hugely simplified and modernized.
Applications that rely on scheduling, internationalization, or time-sensitive data will be able to use built-ins for efficient, precise and consistent dates, times, durations, and calendars.
We're a long way away from stable, cross-browser support, and there may be changes as implementations develop, but we can already take a look at Temporal as it stands now, why it's exciting, and what problems it solves.
To help you get up to speed, there are over 270 pages of Temporal docs on MDN added this week, with detailed explanations and examples.What is JavaScript Temporal?To understand Temporal, we can look at JavaScript's Date object.
When JavaScript was created in 1995, the Date object was copied from Java's early, flawed java.util.Date implementation.
Java replaced this implementation in 1997, but JavaScript is stuck with the same API for almost 30 years, despite known problems.
The major issues with JavaScript's Date object are that it only supports the user's local time and UTC, and there's no time zone support.
Additionally, its parsing behavior is very unreliable, and Date itself is mutable, which can introduce hard-to-trace bugs.
There are other problems like calculations across Daylight Saving Time (DST) and historical calendar changes, which are notoriously difficult to work with.
All of these issues make working with dates and times in JavaScript complex and prone to bugs, which can have serious consequences for some systems.
Most developers rely on dedicated libraries like Moment.js and date-fns for better handling of dates and times in their applications.
Temporal is designed as a full replacement for the Date object, making date and time management reliable and predictable.
Temporal adds support for time zone and calendar representations, many built-in methods for conversions, comparisons and computations, formatting, and more.
The API surface has over 200 utility methods, and you can find information about all of them in the Temporal docs on MDN.Core conceptsIn Temporal, the key concepts are that it has instants (unique points in history), wall-clock times (regional time), and durations.
The APIs have this overall structure to handle these concepts:

Duration: Temporal.Duration the difference between two points in time
Points in time:

Unique points in time:

As a timestamp: Temporal.Instant
A date-time with a time zone: Temporal.ZonedDateTime


Time-zone-unaware date/time ("Plain"):

Full date and time: Temporal.PlainDateTime

Just the date: Temporal.PlainDate

Year and month: Temporal.PlainYearMonth
Month and day: Temporal.PlainMonthDay


Just the time: Temporal.PlainTime






Now: using Temporal.now to get the current time as various class instances, or in a specific format
Temporal examplesSome of the most basic usages of Temporal include getting current dates and times as an ISO string, but we can see from the example below, that we can now provide time zones with many methods, which takes care of complex calculations you may be doing yourself:
js// The current date in the system's time zone
const dateTime = Temporal.Now.plainDateTimeISO();
console.log(dateTime); // e.g.: 2025-01-22T11:46:36.144

// The current date in the "America/New_York" time zone
const dateTimeInNewYork = Temporal.Now.plainDateTimeISO("America/New_York");
console.log(dateTimeInNewYork);
// e.g.: 2025-01-22T05:47:02.555

Working with different calendars is also simplified, as it's possible to create dates in calendar systems other than Gregorian, such as Hebrew, Chinese, and Islamic, for example.
The code below helps you find out when the next Chinese New Year is (which is quite soon!):
js// Chinese New Years are on 1/1 in the Chinese calendar
const chineseNewYear = Temporal.PlainMonthDay.from({
  monthCode: "M01",
  day: 1,
  calendar: "chinese",
});
const currentYear = Temporal.Now.plainDateISO().withCalendar("chinese").year;
let nextCNY = chineseNewYear.toPlainDate({ year: currentYear });
// If nextCNY is before the current date, move forward by 1 year
if (Temporal.PlainDate.compare(nextCNY, Temporal.Now.plainDateISO()) <= 0) {
  nextCNY = nextCNY.add({ years: 1 });
}
console.log(
  `The next Chinese New Year is on ${nextCNY.withCalendar("iso8601").toLocaleString()}`,
);
// The next Chinese New Year is on 1/29/2025 (at the time of writing)

Working with Unix timestamps is a very common use case as many systems (APIs, databases) use the format to represent times.
The following example shows how to take a Unix Epoch timestamp in milliseconds, create an instant from it, get the current time with Temporal.Now, then calculate how many hours from now until the Unix timestamp:
js// 1851222399924 is our timestamp
const launch = Temporal.Instant.fromEpochMilliseconds(1851222399924);
const now = Temporal.Now.instant();
const duration = now.until(launch, { smallestUnit: "hour" });
console.log(`It will be ${duration.toLocaleString("en-US")} until the launch`);
// "It will be 31,600 hr until the launch" <- @js-temporal/polyfill
// "It will be PT31600H until the launch" <- Firefox Nightly

Currently, toLocaleString doesn't output a locale-sensitive string in the Firefox implementation, so durations above (PT31600H) are returned as a non-locale-sensitive duration format.
This may change as it's more of a design decision rather than a technical limitation as formatting the duration is possible, so the polyfill and Firefox implementations may eventually converge.
There's a lot to highlight, but one pattern that I thought was interesting in the API is the compare() methods, which allow you to sort durations in an elegant and efficient way:
jsconst durations = [
  Temporal.Duration.from({ hours: 1 }),
  Temporal.Duration.from({ hours: 2 }),
  Temporal.Duration.from({ hours: 1, minutes: 30 }),
  Temporal.Duration.from({ hours: 1, minutes: 45 }),
];

durations.sort(Temporal.Duration.compare);
console.log(durations.map((d) => d.toString()));
// [ 'PT1H', 'PT1H30M', 'PT1H45M', 'PT2H' ]
Trying Temporal and browser supportSupport is slowly starting to be included in experimental browser releases, and Firefox appears to have the most mature implementation at this point.
In Firefox, Temporal is being built into the Nightly version behind the javascript.options.experimental.temporal preference.
If you want to see the full compatibility story, you can check the (quite epic) Temporal object Browser Compatibility section.
Here are the main browser bugs that track Temporal implementations:

Firefox: Build temporal in Nightly by default
Safari: [JSC] Implement Temporal
Chrome: Implement the Temporal proposal

Additionally, you can visit https://tc39.es/proposal-temporal/docs/ which has @js-temporal/polyfill available.
That means, you can open the developer tools on the TC39 docs page, and try some of the examples in the console in any browser without changing flags or preferences.
With experimental implementations landing, now is a good time to try out Temporal and become familiar with what will be the modern approach to handling dates and times in JavaScript.Acknowledgements
Thanks to Eric Meyer for his work on the topic.
It's been roughly 4 years since Eric's efforts to document browser compatibility data and scaffold the documentation in his fork of mdn/content.
Joshua Chen for picking up the torch from Eric and getting a pull request together for the MDN documentation.
André Bargull for the work on the Firefox Temporal implementation.
See also
Fixing JavaScript Date – Getting Started by Maggie Pint (2017)
Previous Post Fix your website's Largest Contentful Paint by optimizing image loadingNext Post Implications of Global Privacy Control\n\n\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nCSS anchor positioningThe CSS anchor positioning module defines features that allow you to tether elements together. Certain elements are defined as anchor elements; anchor-positioned elements can then have their size and position set based on the size and location of the anchor elements to which they are bound.
In addition, the specification provides CSS-only mechanisms to:

Specify a set of alternative positions for an anchored element; when the default rendering position causes it to overflow its containing block and/or be rendered offscreen, the browser will try rendering the anchored element in the alternative positions instead.
Declare conditions under which anchor-positioned elements should be hidden, in situations where it is not appropriate to tether them to anchor elements.
ReferenceProperties
anchor-name
position-anchor
position-area
position-try-fallbacks
position-try-order
position-try shorthand
position-visibility


Note:
The CSS anchor positioning module introduces the anchor-scope property that has not yet been implemented.
At-rules and descriptors
@position-try
Functions
anchor()
anchor-size()
Data types and values
anchor-center
<anchor-side>
<anchor-size>
<position-area>
<try-size>
<try-tactic>
HTML attributes
anchor 
Non-standard

Interfaces
CSSPositionTryDescriptors
CSSPositionTryRule
HTMLElement.anchorElement 
Non-standard

Guides
Using CSS anchor positioning

An introductory guide to fundamental anchor positioning concepts, including associating, positioning, and sizing elements relative to their anchor.

Handling overflow: try fallbacks and conditional hiding

A guide to the mechanisms CSS anchor positioning provides to prevent anchor-positioned elements from overflowing their containing elements or the viewport, including position try fallback options and conditionally hiding elements.

Related concepts
CSS logical properties and values module:

inset-block-start
inset-block-end
inset-inline-start
inset-inline-end
inset-block
inset-inline
inset shorthand
inline-size
min-block-size
min-inline-size
block-size
max-block-size
max-inline-size
margin-block
margin-block-end
margin-block-start
margin-inline
margin-inline-end
margin-inline-start
Inset properties glossary term


CSS positioned layout module:

top
left
bottom
right


CSS box model module:

width
height
min-width
min-height
max-width
max-height
margin
margin-bottom
margin-left
margin-right
margin-top


CSS box alignment module:

align-items
align-self
justify-items
justify-self
place-items
place-self


SpecificationsSpecificationCSS Anchor Positioning See also
CSS scroll anchoring module
Learn: CSS positioning
CSS logical properties and values module
Learn: Sizing items in CSS
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nUsing the View Transition APIThis article explains the theory behind how the View Transition API works, how to create view transitions and customize the transition animations, and how to manipulate active view transitions. This covers view transitions for both DOM state updates in a single-page app (SPA), and navigating between documents in a multi-page app (MPA).The view transition processLet's walk through the process by which a view transition works:


A view transition is triggered. How this is done depends on the type of view transition:

In the case of same-document transitions (SPAs), a view transition is triggered by passing the function that would trigger the view change DOM update as a callback to the document.startViewTransition() method.
In the case of cross-document transitions (MPAs), a view transition is triggered by initiating navigation to a new document. Both the current and destination documents of the navigation need to be on the same origin, and opt-in to the view transition by including a @view-transition at rule in their CSS with a navigation descriptor of auto.

Note:
An active view transition has an associated ViewTransition instance (for example, returned by startViewTransition() in the case of same-document (SPA) transitions). The ViewTransition object includes several promises, allowing you to run code in response to different parts of the view transition process being reached. See Controlling view transitions with JavaScript for more information.





On the current (old page) view, the API captures snapshots of elements that have a view-transition-name declared on them.


The view change occurs:


In the case of same-document transitions (SPAs), the callback passed to startViewTransition() is invoked, which causes the DOM to change.
When the callback has run successfully, the ViewTransition.updateCallbackDone promise fulfills, allowing you to respond to the DOM updating.


In the case of cross-document transitions (MPAs), the navigation occurs between the current and destination documents.




The API captures snapshots from the new view as a live representation.
At this point, the view transition is about to run, and the ViewTransition.ready promise fulfills, allowing you to respond by running a custom JavaScript animation instead of the default, for example.


The old page snapshots animate "out", while the new view snapshots animate "in". By default, the old view snapshots animate from opacity 1 to 0, and the new view snapshots animate from opacity 0 to 1, which creates a cross-fade.


When the transition animations have reached their end states, the ViewTransition.finished promise fulfills, allowing you to respond.



Note:
If the document's page visibility state is hidden (for example if the document is obscured by a window, the browser is minimized, or another browser tab is active) during a document.startViewTransition() call, the view transition is skipped entirely.
The view transition pseudo-element treeTo handle creating the outbound and inbound transition animations, the API constructs a pseudo-element tree with the following structure:
::view-transition
└─ ::view-transition-group(root)
  └─ ::view-transition-image-pair(root)
      ├─ ::view-transition-old(root)
      └─ ::view-transition-new(root)


Note:
A ::view-transition-group subtree is created for every captured view-transition-name.

In the case of same-document transitions (SPAs), the pseudo-element tree is made available in the document. In the case of cross-document transitions (MPAs), the pseudo-element tree is made available in the destination document only.
The most interesting parts of the tree structure are as follows:


::view-transition is the root of view transitions overlay, which contains all view transition snapshot groups and sits over the top of all other page content.


A ::view-transition-group acts as a container for each view transition snapshot group. The root argument specifies the default snapshot group — the view transition animation will apply to the snapshot whose view-transition-name is root. By default, this is the :root element, because the default browser styles define this:
css:root {
  view-transition-name: root;
}

Be aware however that page authors can change this by unsetting the above, and setting view-transition-name: root on a different element.


::view-transition-old targets the static snapshot of the old page element, and ::view-transition-new targets the live snapshot of the new page element. Both of these render as replaced content, in the same manner as an <img> or <video>, meaning that they can be styled with handy properties like object-fit and object-position.



Note:
It is possible to target different DOM elements with different custom view transition animations by setting a different view-transition-name on each one. In such cases, a ::view-transition-group is created for each one. See Different animations for different elements for an example.


Note:
As you'll see later, to customize the outbound and inbound animations you need to target the ::view-transition-old and ::view-transition-new pseudo-elements with your animations, respectively.
Creating a basic view transitionThis section illustrates how to create a basic view transition, in both the SPA and MPA case.Basic SPA view transitionAs an example, an SPA may include functionality to fetch new content and update the DOM in response to an event of some kind, such as a navigation link being clicked or an update being pushed from the server. In our View Transitions SPA demo we've simplified this to a displayNewImage() function that shows a new full-size image based on the thumbnail that was clicked. We've encapsulated this inside an updateView() function that only calls the View Transition API if the browser supports it:
jsfunction updateView(event) {
  // Handle the difference in whether the event is fired on the <a> or the <img>
  const targetIdentifier = event.target.firstChild || event.target;

  const displayNewImage = () => {
    const mainSrc = `${targetIdentifier.src.split("_th.jpg")[0]}.jpg`;
    galleryImg.src = mainSrc;
    galleryCaption.textContent = targetIdentifier.alt;
  };

  // Fallback for browsers that don't support View Transitions:
  if (!document.startViewTransition) {
    displayNewImage();
    return;
  }

  // With View Transitions:
  const transition = document.startViewTransition(() => displayNewImage());
}

This code is enough to handle the transition between displayed images. Supporting browsers will show the change from old to new images and captions as a smooth cross-fade (the default view transition). It will still work in non-supporting browsers but without the nice animation.Basic MPA view transitionWhen creating a cross-document (MPA) view transition, the process is even simpler than for SPAs. No JavaScript is required, as the view update is triggered by a cross-document, same-origin navigation rather than a JavaScript-initiated DOM change. To enable a basic MPA view transition, you need to specify a @view-transition at-rule in the CSS for both the current and destination documents to opt them in, like so:
css@view-transition {
  navigation: auto;
}

Our View Transitions MPA demo shows this at-rule in action, and additionally demonstrates how to customize the outbound and inbound animations of the view transition.

Note:
Currently MPA view transitions can only be created between same-origin documents, but this restriction may be relaxed in future implementations.
Customizing your animationsThe View Transitions pseudo-elements have default CSS Animations applied (which are detailed in their reference pages).
Most appearance transitions are given a default smooth cross-fade animation, as mentioned above. There are some exceptions:

height and width transitions have a smooth scaling animation applied.
position and transform transitions have a smooth movement animation applied.

You can modify the default animations in any way you want using regular CSS — target the "from" animation with ::view-transition-old, and the "to" animation with ::view-transition-new.
For example, to change the speed of both:
css::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

It is recommended that you target the ::view-transition-group() with such styles in cases where you want to apply them to ::view-transition-old() and ::view-transition-new(). Because of the pseudo-element hierarchy and default user-agent styling, the styles will be inherited by both. For example:
css::view-transition-group(root) {
  animation-duration: 0.5s;
}


Note:
This is also a good option for safeguarding your code — ::view-transition-group() also animates and you could end up with different durations for the group/image-pair pseudo-elements versus the old and new pseudo-elements.

In the case of cross-document (MPA) transitions, the pseudo-elements need to be included in the destination document only for the view transition to work. If you want to use the view transition in both directions, you'll need to include it in both, of course.
Our View Transitions MPA demo includes the above CSS, but takes the customization a step further, defining custom animations and applying them to the ::view-transition-old(root) and ::view-transition-new(root) pseudo-elements. The result is that the default cross-fade transition is swapped out for a "swipe up" transition when navigation occurs:
css/* Create a custom animation */

@keyframes move-out {
  from {
    transform: translateY(0%);
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes move-in {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
  animation: 0.4s ease-in both move-out;
}

::view-transition-new(root) {
  animation: 0.4s ease-in both move-in;
}
Different animations for different elementsBy default, all of the different elements that change during the view update are transitioned using the same animation. If you want some elements to animate differently from the default root animation, you can separate them out using the view-transition-name property. For example, in our View Transitions SPA demo the <figcaption> elements are given a view-transition-name of figure-caption to separate them from the rest of the page in terms of view transitions:
cssfigcaption {
  view-transition-name: figure-caption;
}

With this CSS applied, the generated pseudo-element tree will now look like this:
::view-transition
├─ ::view-transition-group(root)
│ └─ ::view-transition-image-pair(root)
│     ├─ ::view-transition-old(root)
│     └─ ::view-transition-new(root)
└─ ::view-transition-group(figure-caption)
  └─ ::view-transition-image-pair(figure-caption)
      ├─ ::view-transition-old(figure-caption)
      └─ ::view-transition-new(figure-caption)

The existence of the second set of pseudo-elements allows separate view transition styling to be applied just to the <figcaption>. The different old and new view captures are handled separately from one another.

Note:
The value of view-transition-name can be anything you want except for none — the none value specifically means that the element will not participate in a view transition.
view-transition-name values must also be unique. If two rendered elements have the same view-transition-name at the same time, ViewTransition.ready will reject and the transition will be skipped.

The following code applies a custom animation just to the <figcaption>:
css@keyframes grow-x {
  from {
    transform: scaleX(0);
  }
  to {
    transform: scaleX(1);
  }
}

@keyframes shrink-x {
  from {
    transform: scaleX(1);
  }
  to {
    transform: scaleX(0);
  }
}

::view-transition-group(figure-caption) {
  height: auto;
  right: 0;
  left: auto;
  transform-origin: right center;
}

::view-transition-old(figure-caption) {
  animation: 0.25s linear both shrink-x;
}

::view-transition-new(figure-caption) {
  animation: 0.25s 0.25s linear both grow-x;
}

Here we've created a custom CSS animation and applied it to the ::view-transition-old(figure-caption) and ::view-transition-new(figure-caption) pseudo-elements. We've also added a number of other styles to both to keep them in the same place and stop the default styling from interfering with our custom animations.

Note:
You can use * as the identifier in a pseudo-element to target all snapshot pseudo-elements, regardless of what name they have. For example:
css::view-transition-group(*) {
  animation-duration: 2s;
}

Taking advantage of the default animation stylesNote that we also discovered another transition option that is simpler and produced a nicer result than the above. Our final <figcaption> view transition ended up looking like this:
cssfigcaption {
  view-transition-name: figure-caption;
}

::view-transition-group(figure-caption) {
  height: 100%;
}

This works because, by default, ::view-transition-group transitions width and height between the old and new views with a smooth scale. We just needed to set a fixed height on both states to make it work.

Note: Smooth transitions with the View Transition API contains several other customization examples.
Controlling view transitions with JavaScriptA view transition has an associated ViewTransition object instance, which contains several promise members allowing you to run JavaScript in response to different states of the transition being reached. For example, ViewTransition.ready fulfills once the pseudo-element tree is created and the animation is about to start, whereas ViewTransition.finished fulfills once the animation is finished, and the new page view is visible and interactive to the user.
The ViewTransition can be accessed like so:


In the case of same-document (SPA) transitions, the document.startViewTransition() method returns the ViewTransition associated with the transition.


In the case of cross-document (MPA) transitions:

A pageswap event is fired when a document is about to be unloaded due to a navigation. Its event object (PageSwapEvent) provides access to the ViewTransition via the PageSwapEvent.viewTransition property, as well as a NavigationActivation via PageSwapEvent.activation containing the navigation type and current and destination document history entries.

Note:
If the navigation has a cross-origin URL anywhere in the redirect chain, the activation property returns null.


A pagereveal event is fired when a document is first rendered, either when loading a fresh document from the network or activating a document (either from back/forward cache (bfcache) or prerender). Its event object (PageRevealEvent) provides access to the ViewTransition via the PageRevealEvent.viewTransition property.



Let's have a look at some example code to show how these features could be used.A JavaScript-powered custom same-document (SPA) transitionThe following JavaScript could be used to create a circular reveal view transition emanating from the position of the user's cursor on click, with animation provided by the Web Animations API.
js// Store the last click event
let lastClick;
addEventListener("click", (event) => (lastClick = event));

function spaNavigate(data) {
  // Fallback for browsers that don't support this API:
  if (!document.startViewTransition) {
    updateTheDOMSomehow(data);
    return;
  }

  // Get the click position, or fallback to the middle of the screen
  const x = lastClick?.clientX ?? innerWidth / 2;
  const y = lastClick?.clientY ?? innerHeight / 2;
  // Get the distance to the furthest corner
  const endRadius = Math.hypot(
    Math.max(x, innerWidth - x),
    Math.max(y, innerHeight - y),
  );

  // Create a transition:
  const transition = document.startViewTransition(() => {
    updateTheDOMSomehow(data);
  });

  // Wait for the pseudo-elements to be created:
  transition.ready.then(() => {
    // Animate the root's new view
    document.documentElement.animate(
      {
        clipPath: [
          `circle(0 at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // Specify which pseudo-element to animate
        pseudoElement: "::view-transition-new(root)",
      },
    );
  });
}

This animation also requires the following CSS, to turn off the default CSS animation and stop the old and new view states from blending in any way (the new state "wipes" right over the top of the old state, rather than transitioning in):
css::view-transition-image-pair(root) {
  isolation: auto;
}

::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
  mix-blend-mode: normal;
  display: block;
}
A JavaScript-powered custom cross-document (MPA) transitionThe List of Chrome DevRel team members demo provides a basic set of team profile pages, and demonstrates how to use the pageswap and pagereveal events to customize the outgoing and inbound animations of a cross-document view transition based on the "from" and "to" URLs.
The pageswap event listener looks as follows. This sets view transition names on the elements on the outbound page that link to the profile pages. When navigating from the home page to a profile page, custom animations are provided only for the linked element that is clicked in each case.
jswindow.addEventListener("pageswap", async (e) => {
  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const currentUrl = e.activation.from?.url
      ? new URL(e.activation.from.url)
      : null;
    const targetUrl = new URL(e.activation.entry.url);

    // Going from profile page to homepage
    // ~> The big img and title are the ones!
    if (isProfilePage(currentUrl) && isHomePage(targetUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }

    // Going to profile page
    // ~> The clicked items are the ones!
    if (isProfilePage(targetUrl)) {
      const profile = extractProfileNameFromUrl(targetUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove view-transition-names after snapshots have been taken
      // Stops naming conflicts resulting from the page state persisting in BFCache
      await e.viewTransition.finished;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }
  }
});


Note:
We remove the view-transition-name values after snapshots have been taken in each case. If we left them set, they would persist in the page state saved in the bfcache upon navigation. If the back button was then pressed, the pagereveal event handler of the page being navigated back to would then attempt to set the same view-transition-name values on different elements. If multiple elements have the same view-transition-name set, the view transition is skipped.

The pagereveal event listener looks as follows. This works in a similar way to the pageswap event listener, although bear in mind that here we are customizing the "to" animation, for page elements on the new page.
jswindow.addEventListener("pagereveal", async (e) => {
  // If the "from" history entry does not exist, return
  if (!navigation.activation.from) return;

  // Only run this if an active view transition exists
  if (e.viewTransition) {
    const fromUrl = new URL(navigation.activation.from.url);
    const currentUrl = new URL(navigation.activation.entry.url);

    // Went from profile page to homepage
    // ~> Set VT names on the relevant list item
    if (isProfilePage(fromUrl) && isHomePage(currentUrl)) {
      const profile = extractProfileNameFromUrl(fromUrl);

      // Set view-transition-name values on the elements to animate
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "name";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#${profile} span`).style.viewTransitionName =
        "none";
      document.querySelector(`#${profile} img`).style.viewTransitionName =
        "none";
    }

    // Went to profile page
    // ~> Set VT names on the main title and image
    if (isProfilePage(currentUrl)) {
      // Set view-transition-name values on the elements to animate
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "name";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "avatar";

      // Remove names after snapshots have been taken
      // so that we're ready for the next navigation
      await e.viewTransition.ready;
      document.querySelector(`#detail main h1`).style.viewTransitionName =
        "none";
      document.querySelector(`#detail main img`).style.viewTransitionName =
        "none";
    }
  }
});
Stabilizing page state to make cross-document transitions consistentBefore running a cross-document transition, you ideally want to wait until the state of the page stabilizes, relying on render blocking to ensure that:

Critical styles are loaded and applied.
Critical scripts are loaded and run.
The HTML visible for the user's initial view of the page has been parsed, so it renders consistently.

Styles are render blocked by default, and scripts can be render blocked using the blocking="render" attribute.
To ensure that your initial HTML has been parsed and will always render consistently before the transition animation runs, you can use <link rel="expect">. In this element, you include the following attributes:

rel="expect" to indicate that you want to use this <link> element to render block some HTML on the page.
href="#element-id" to indicate the ID of the element you want to render block.
blocking="render" to render block the specified HTML.

Let's explore what this looks like with an example HTML document:
html<!doctype html>
<html lang="en">
  <head>
    <!-- This will be render-blocking by default -->
    <link rel="stylesheet" href="style.css" />

    <!-- Marking critical scripts as render blocking will
         ensure they're run before the view transition is activated -->
    <script async href="layout.js" blocking="render"></script>

    <!-- Use rel="expect" and blocking="render" to ensure the
         #lead-content element is visible and fully parsed before
         activating the transition -->
    <link rel="expect" href="#lead-content" blocking="render" />
  </head>
  <body>
    <h1>Page title</h1>
    <nav>...</nav>
    <div id="lead-content">
      <section id="first-section">The first section</section>
      <section>The second section</section>
    </div>
  </body>
</html>

The result is that document rendering is blocked until the lead content <div> has been parsed, ensuring a consistent view transition.
You can also specify a media attribute on <link rel="expect"> elements. For example, you might want to block rendering on a smaller amount of content when loading the page on a narrow-screen device, than on a wide-screen device. This makes sense — on a mobile, less content will be visible when the page first loads than in the case of a desktop.
This could be achieved with the following HTML:
html<link
  rel="expect"
  href="#lead-content"
  blocking="render"
  media="screen and (min-width: 641px)" />
<link
  rel="expect"
  href="#first-section"
  blocking="render"
  media="screen and (max-width: 640px)" />
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTemporalLimited availabilityThis feature is not Baseline because it does not work in some of the most widely-used browsers.Learn moreSee full compatibilityReport feedbackExperimental: This is an experimental technologyCheck the Browser compatibility table carefully before using this in production.
The Temporal object enables date and time management in various scenarios, including built-in time zone and calendar representation, wall-clock time conversions, arithmetics, formatting, and more. It is designed as a full replacement for the Date object.DescriptionUnlike most global objects, Temporal is not a constructor. You cannot use it with the new operator or invoke the Temporal object as a function. All properties and methods of Temporal are static (just like the Math object).
Temporal has an intricate and powerful API. It exposes over 200 utility methods via several classes, so it could appear very complex. We will provide a high-level overview of how these APIs are related to each other.Background and conceptsJavaScript has had the Date object for handling date and time since its first days. However, the Date API is based on the poorly designed java.util.Date class from Java, which was replaced in the early 2010s; but, because of JavaScript's goal of backward compatibility, Date sticks around in the language.
The important lesson to preface the whole introduction is that date handling is complex. Most of the problems of Date are fixable by adding more methods, but a fundamental design flaw remains: it exposes so many methods on the same object that developers are often confused about what to use, leading to unexpected pitfalls. A well-designed API not only needs to do more, but also should do less with each level of abstraction, because preventing misuse is as important as enabling use cases.
Date objects wear two hats simultaneously:

As a timestamp: the number of milliseconds or nanoseconds elapsed since a fixed point in time (known as the epoch).
As a combination of components: year, month, day, hour, minute, second, millisecond, and nanosecond. The year, month, and day identifiers only make sense with reference to a calendar system. The whole combination maps to a unique instant in history when associated with a time zone. Date objects provide methods for reading and modifying these components.

Time zones underlie a significant number of date-related bugs. When interacting with a Date via the "combination of components" model, the time can only be in two time zones: UTC and local (device), and there's no way to specify an arbitrary time zone. Also lacking is the concept of "no time zone": this is known as a calendar date (for dates) or wall-clock time (for times), which is a time you "read off a calendar or clock". For example, if you are setting a daily wake up alarm, you will want to set it to "8:00AM" regardless of whether it is daylight saving time or not, whether you have traveled to a different time zone, etc.
A second feature lacking from Date is a calendar system. Most people may be familiar with the Gregorian calendar, where there are two eras, BC and AD; there are 12 months; each month has a different number of days; there's a leap year every 4 years; and so on. However, some of these concepts may not apply when you are working with another calendar system, such as the Hebrew calendar, the Chinese calendar, the Japanese calendar, etc. With Date, you can only work with the Gregorian calendar model.
There are many other undesirable legacies about Date, such as all setters being mutating (which often causes unwanted side effects), the date time string format being impossible to parse in a consistent way, etc. In the end, the best solution is to build a new API from scratch, which is what Temporal is.API overviewTemporal is a namespace, like Intl. It contains several classes and namespaces, each of which is designed to handle a specific aspect of date and time management. The classes can be grouped as such:

Representing a time duration (a difference between two time points): Temporal.Duration
Representing a time point:

Representing a unique instant in history:

As a timestamp: Temporal.Instant
As a date-time component combination paired with a time zone: Temporal.ZonedDateTime


Representing a time-zone-unaware date/time (which are all prefixed with "Plain"):

Date (year, month, day) + time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainDateTime (Note: ZonedDateTime is equivalent to PlainDateTime plus a time zone)

Date (year, month, day): Temporal.PlainDate

Year, month: Temporal.PlainYearMonth
Month, day: Temporal.PlainMonthDay


Time (hour, minute, second, millisecond, microsecond, nanosecond): Temporal.PlainTime







Furthermore, there's also another utility namespace, Temporal.Now, which provides methods for getting the current time in various formats.Shared class interfaceThere are many classes in the Temporal namespace, but they share many similar methods. The following table lists all methods of each class (except conversion methods):




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Construction
Instant()Instant.from()Instant.fromEpochMilliseconds()Instant.fromEpochNanoseconds()
ZonedDateTime()ZonedDateTime.from()
PlainDateTime()PlainDateTime.from()
PlainDate()PlainDate.from()
PlainTime()PlainTime.from()
PlainYearMonth()PlainYearMonth.from()
PlainMonthDay()PlainMonthDay.from()


Updater
N/A
with()withCalendar()withTimeZone()withPlainTime()
with()withCalendar()withPlainTime()
with()withCalendar()
with()
with()
with()


Arithmetic
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
add()subtract()since()until()
N/A


Rounding
round()
round()
round()
N/A
round()
N/A
N/A


Comparison
equals()Instant.compare()
equals()ZonedDateTime.compare()
equals()PlainDateTime.compare()
equals()PlainDate.compare()
equals()PlainTime.compare()
equals()PlainYearMonth.compare()
equals()


Serialization
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()
toJSON()toLocaleString()toString()valueOf()



The following table summarizes which properties are available on each class, giving you a sense of what information each class can represent.




Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay




Calendar
N/A
calendarId
calendarId
calendarId
N/A
calendarId
calendarId


Year-related
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A
eraeraYearyearinLeapYearmonthsInYeardaysInYear
N/A


Month-related
N/A
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
monthmonthCodedaysInMonth
N/A
monthmonthCodedaysInMonth
monthCode


Week-related
N/A
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
weekOfYearyearOfWeekdaysInWeek
N/A
N/A
N/A


Day-related
N/A
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
daydayOfWeekdayOfYear
N/A
N/A
day


Time components
N/A
hourminutesecondmillisecondmicrosecondnanosecond
hourminutesecondmillisecondmicrosecondnanosecond
N/A
hourminutesecondmillisecondmicrosecondnanosecond
N/A
N/A


Time zone
N/A
timeZoneIdoffsetoffsetNanosecondshoursInDaygetTimeZoneTransition()startOfDay()
N/A
N/A
N/A
N/A
N/A


Epoch time
epochMillisecondsepochNanoseconds
epochMillisecondsepochNanoseconds
N/A
N/A
N/A
N/A
N/A


Conversion between classesThe table below summarizes all conversion methods that exist on each class.




How to convert from...


Instant
ZonedDateTime
PlainDateTime
PlainDate
PlainTime
PlainYearMonth
PlainMonthDay

to...Instant/toInstant()Convert to ZonedDateTime first
ZonedDateTimetoZonedDateTimeISO()/toZonedDateTime()toZonedDateTime()PlainDate#toZonedDateTime() (pass as argument)Convert to PlainDate first
PlainDateTimeConvert to ZonedDateTime firsttoPlainDateTime()/toPlainDateTime()PlainDate#toPlainDateTime() (pass as argument)
PlainDatetoPlainDate()toPlainDate()/No overlap in informationtoPlainDate()toPlainDate()
PlainTimetoPlainTime()toPlainTime()No overlap in information/No overlap in information
PlainYearMonthConvert to PlainDate firsttoPlainYearMonth()No overlap in information/Convert to PlainDate first
PlainMonthDaytoPlainMonthDay()Convert to PlainDate first/


With these tables, you should have a basic idea of how to navigate the Temporal API.CalendarsA calendar is a way to organize days, typically into periods of weeks, months, years, and eras. Most of the world uses the Gregorian calendar, but there are many other calendars in use, especially in religious and cultural contexts. By default, all calendar-aware Temporal objects use the ISO 8601 calendar system, which is based on the Gregorian calendar and defines additional week-numbering rules. Intl.supportedValuesOf() lists most of the calendars likely to be supported by browsers. Here we provide a brief overview of how calendar systems are formed to help you internalize what factors may vary between calendars.
There are three prominent periodic events on Earth: its rotation around the sun (365.242 days for one revolution), the moon's rotation around the Earth (29.53 days from new moon to new moon), and its rotation around its axis (24 hours from sunrise to sunrise). Every culture has the same measure of a "day", which is 24 hours. Occasional changes such as daylight saving time are not part of the calendar, but are part of the time zone's information.

Some calendars primarily define one year as 365.242 days on average, by defining years to have 365 days, and adding an extra day, the leap day, about every 4 years. Then, the year may be further divided into parts called months. These calendars are called solar calendars. The Gregorian calendar and the Solar Hijri calendar are solar calendars.
Some calendars primarily define one month as 29.5 days on average, by defining months to alternate between 29 and 30 days. Then, 12 months may be grouped into a year of 354 days. These calendars are called lunar calendars. The Islamic calendar is a lunar calendar. Because a lunar year is artificial and does not correlate with the season cycle, lunar calendars are generally rarer.
Some calendars also primarily define months based on lunar cycles, like lunar calendars. Then, to compensate for the 11-day discrepancy with the solar year, an extra month, the leap month, is added about every 3 years. These calendars are called lunisolar calendars. The Hebrew calendar and the Chinese calendar are lunisolar calendars.

In Temporal, every date under one calendar system is uniquely identified by three components: year, month, and day. While year is typically a positive integer, it may also be zero or negative, and increases monotonically with time. The year 1 (or 0, if it exists) is known as the calendar epoch, and is arbitrary for each calendar. month is a positive integer that increments by 1 every time, starting at 1 and ending at date.monthsInYear, then resetting back to 1 as the year advances. day is also a positive integer, but it may not start at 1 or increment by 1 every time, because political changes may cause days to be skipped or repeated. But in general, day monotonically increases and resets as the month advances.
In addition to year, a year can also be uniquely identified by the combination of era and eraYear, for calendars that use eras. For example, the Gregorian calendar uses the era "CE" (Common Era) and "BCE" (Before Common Era), and the year -1 is the same as { era: "bce", eraYear: 1 }. era is a lowercase string, and eraYear is an arbitrary integer that may be zero or negative, or even decrease with time (usually for the oldest era).

Note:
Always use era and eraYear as a pair; don't use one property without also using the other. In addition, to avoid conflicts, don't combine year and era/eraYear when designating a year. Pick one year representation and use it consistently.
Be careful of the following incorrect assumptions about years:

Don't assume that era and eraYear are always present; they may be undefined.
Don't assume that era is a user-friendly string; use toLocaleString() to format your date instead.
Don't assume that two year values from different calendars are comparable; use the compare() static method instead.
Don't assume that years have 365/366 days and 12 months; use daysInYear and monthsInYear instead.
Don't assume that leap years (inLeapYear is true) have one extra day; they may have an extra month.


In addition to month, a month in a year can also be uniquely identified by the monthCode. monthCode usually maps to the month's name, but month does not. For example, in the case of lunisolar calendars, two months with the same monthCode, where one belongs to a leap year and the other one does not, will have different month values if they come after the leap month, due to the insertion of an extra month.

Note:
To avoid conflicts, don't combine month and monthCode when designating a month. Pick one month representation and use it consistently. month is more useful if you need the order of months in a year (e.g., when looping through the months), while monthCode is more useful if you need the name of the month (e.g., when storing birthdays).
Be careful of the following incorrect assumptions about months:

Don't assume that monthCode and month always correspond.
Don't assume the number of days in a month; use daysInMonth instead.
Don't assume that monthCode is a user-friendly string; use toLocaleString() to format your date instead.
Generally, don't cache the name of months in an array or object. Even though monthCode usually maps to the month's name within one calendar, we recommend always computing the month's name using, for example, date.toLocaleString("en-US", { calendar: date.calendarId, month: "long" }).


In addition to day (which is a month-based index), a day in a year can also be uniquely identified by the dayOfYear. dayOfYear is a positive integer that increments by 1 every time, starting at 1 and ending at date.daysInYear.
The concept of a "week" is not connected with any astronomical event, but is a cultural construct. While the most common length is 7 days, weeks can also have 4, 5, 6, 8, or more days — or even lack a fixed number of days altogether. To get the specific number of days of the week of a date, use the date's daysInWeek. Temporal identifies weeks by the combination of weekOfYear and yearOfWeek. weekOfYear is a positive integer that increments by 1 every time, starting at 1, then resetting back to 1 as the year advances. yearOfWeek is generally the same as year, but may be different at the start or end of each year, because one week may cross two years, and yearOfWeek picks one of the two years based on the calendar's rules.

Note:
Always use weekOfYear and yearOfWeek as a pair; don't use weekOfYear and year.
Be careful of the following incorrect assumptions about weeks:

Don't assume that weekOfYear and yearOfWeek are always present; they may be undefined.
Don't assume that weeks are always 7 days long; use daysInWeek instead.
Note that the current Temporal API does not support year-week dates, so you can't construct dates using these properties or serialize dates to year-week representations. They are only informational properties.

RFC 9557 formatAll Temporal classes can be serialized and deserialized using the format specified in RFC 9557, which is based on ISO 8601 / RFC 3339. The format, in its full form, is as follows (spaces are only for readability and should not be present in the actual string):
YYYY-MM-DD T HH:mm:ss.sssssssss Z/±HH:mm [time_zone_id] [u-ca=calendar_id]

Different classes have different requirements for the presence of each component, so you will find a section titled "RFC 9557 format" in each class's documentation, which specifies the format recognized by that class.
This is very similar to the date time string format used by Date, which is also based on ISO 8601. The main addition is the ability to specify micro- and nanosecond components, and the ability to specify the time zone and calendar system.Representable datesAll Temporal objects that represent a specific calendar date impose a similar limit on the range of representable dates, which is ±108 days (inclusive) from the Unix epoch, or the range of instants from -271821-04-20T00:00:00 to +275760-09-13T00:00:00. This is the same range as valid dates. More specifically:

Temporal.Instant and Temporal.ZonedDateTime apply this limit directly on its epochNanoseconds value.
Temporal.PlainDateTime interprets the date-time in the UTC time zone and requires it to be ±(108 + 1) days (exclusive) from the Unix epoch, so its valid range is -271821-04-19T00:00:00 to +275760-09-14T00:00:00, exclusive. This allows any ZonedDateTime to be converted to a PlainDateTime regardless of its offset.
Temporal.PlainDate applies the same check as PlainDateTime to the noon (12:00:00) of that date, so its valid range is -271821-04-19 to +275760-09-13. This allows any PlainDateTime to be converted to a PlainDate regardless of its time, and vice versa.
Temporal.PlainYearMonth has the valid range of -271821-04 to +275760-09. This allows any PlainDate to be converted to a PlainYearMonth regardless of its date (except if a non-ISO month's first day falls in the ISO month -271821-03).

The Temporal objects will refuse to construct an instance representing a date/time beyond this limit. This includes:

Using the constructor or from() static method.
Using the with() method to update calendar fields.
Using add(), subtract(), round(), or any other method to derive new instances.
Static properties
Temporal.Duration 
Experimental


Represents a difference between two time points, which can be used in date/time arithmetic. It is fundamentally represented as a combination of years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, and nanoseconds values.

Temporal.Instant 
Experimental


Represents a unique point in time, with nanosecond precision. It is fundamentally represented as the number of nanoseconds since the Unix epoch (midnight at the beginning of January 1, 1970, UTC), without any time zone or calendar system.

Temporal.Now 
Experimental


Provides methods for getting the current time in various formats.

Temporal.PlainDate 
Experimental


Represents a calendar date (a date without a time or time zone); for example, an event on a calendar which happens during the whole day no matter which time zone it's happening in. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system.

Temporal.PlainDateTime 
Experimental


Represents a date (calendar date) and time (wall-clock time) without a time zone. It is fundamentally represented as a combination of a date (with an associated calendar system) and a time.

Temporal.PlainMonthDay 
Experimental


Represents the month and day of a calendar date, without a year or time zone; for example, an event on a calendar that recurs every year and happens during the whole day. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The year is used to disambiguate the month-day in non-ISO calendar systems.

Temporal.PlainTime 
Experimental


Represents a time without a date or time zone; for example, a recurring event that happens at the same time every day. It is fundamentally represented as a combination of hour, minute, second, millisecond, microsecond, and nanosecond values.

Temporal.PlainYearMonth 
Experimental


Represents the year and month of a calendar date, without a day or time zone; for example, an event on a calendar that happens during the whole month. It is fundamentally represented as an ISO 8601 calendar date, with year, month, and day fields, and an associated calendar system. The day is used to disambiguate the year-month in non-ISO calendar systems.

Temporal.ZonedDateTime 
Experimental


Represents a date and time with a time zone. It is fundamentally represented as a combination of an instant, a time zone, and a calendar system.

Temporal[Symbol.toStringTag]

The initial value of the [Symbol.toStringTag] property is the string "Temporal". This property is used in Object.prototype.toString().

SpecificationsSpecificationTemporal proposal # sec-temporal-introBrowser compatibilitySee also
Intl.DateTimeFormat
Intl.RelativeTimeFormat
Intl.DurationFormat
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 6, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loadingPrevious Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\nIn this article2024 MDN content areasMathMLManifest (web app manifests)Other 2024 content highlights on MDNKicking off 2025MDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\nMDN 2024 content projectsVadim MakeevJanuary 8, 20259 minute readMDN Web Docs provides accurate and accessible resources for people getting started building for the web right through to professional developers.
Our commitment includes maintenance of long-existing content and documenting features that are brand new to the web platform.
In 2024, the MDN content team chose some content areas to audit and update so they stay useful and relevant in an evolving web platform.
We looked at topics that were popular but contained some outdated or incomplete material, and invested time in improvements, additions, and removing obsolete content.
This post recaps what we achieved in our content projects in 2024, highlights some of our top picks and recommended reading, and looks forward to what's next on MDN for 2025.2024 MDN content areasFor 2024, we chose three technology categories that are popular, but had reader feedback that indicated they needed a refresh.
We focused on HTTP, MathML, and web Manifests.
From July to December 2024, the team worked through these areas to bring the quality up in a number of ways.
Let's have a look at what changed in each section below.MathMLMathML is an XML-based language for describing mathematical notation on the web. Similar to SVG, MathML can also be included in the HTML and rendered by the browser, no plugins or libraries are required.

  
    ∑
    
      n
      =
      1
    
    
      +
      ∞
    
  

html<math display="block">
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mrow>
      <mo>+</mo>
      <mn>∞</mn>
    </mrow>
  </munderover>
</math>

Unlike the MathML Core specification, which often groups elements, MDN now features each MathML element on its page, with examples, usage notes, and BCD (browser-compat-data) now also updated. For example, you can read about <semantics>, <annotation> and <annotation-xml> elements and how they help to annotate MathML expressions.
Just like we're writing this blog post using Markdown instead of HTML, MathML is often generated by math processors using lightweight markup languages like LaTeX. To help content authors, all MathML examples now have annotations. For example, x2+yx^{2} + y can be written as x^{2} + y in LaTeX:
html<math>
  <semantics>
    <mrow>
      <msup>
        <mi>x</mi>
        <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>y</mi>
    </mrow>
    <!-- Annotated with LaTeX, a lightweight markup language. -->
    <annotation encoding="application/x-tex">x^{2} + y</annotation>
  </semantics>
</math>

This will also allow us to start using LaTeX for MathML in the future, making it easier for content authors to write and maintain examples. To fully appreciate the difference, you can compare the full MathML source code of some bigger examples, such as Deriving the Quadratic Formula and Proving the Pythagorean theorem, with their LaTeX equivalents.
MathML documentation on MDN now features accessibility information for all elements. For example, using <math> element for representing math content allows screen readers to read the formula, which makes MathML better for such cases than using images or other formats.
Additionally, all MathML features now have live examples, so you can see how they're rendered in your browser. And just like with other live examples on MDN, you can always click "Play" in the top right corner to play around with the code in a new tab.
html,
body {
  height: 100%;
}

body {
  display: grid;
  place-items: center;
  font-size: 1.5rem;
}

<math display="block">
  <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
      <mrow>
        <mrow>
          <mo>−</mo>
          <mi>b</mi>
        </mrow>
        <mo>±</mo>
        <msqrt>
          <mrow>
            <msup>
              <mi>b</mi>
              <mn>2</mn>
            </msup>
            <mo>−</mo>
            <mrow>
              <mn>4</mn>
              <mo>⁢</mo>
              <mi>a</mi>
              <mo>⁢</mo>
              <mi>c</mi>
            </mrow>
          </mrow>
        </msqrt>
      </mrow>
      <mrow>
        <mn>2</mn>
        <mo>⁢</mo>
        <mi>a</mi>
      </mrow>
    </mfrac>
  </mrow>
</math>


Not only is MathML documented on MDN, but it's also used to describe different parts of the web platform. For example, Set.difference() JavaScript method, CSS transformation functions, 3D collision detection in game development, WebXR Device API, and many more.
We made sure MathML is now rendered correctly throughout MDN: inside paragraphs and on the block level, on big and small screens, and in different browsers.Manifest (web app manifests)A web app manifest is a JSON text file that provides information about a web application.
The most common use for a manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
json{
  "name": "HackerWeb",
  "short_name": "HackerWeb",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "description": "A readable Hacker News app",
  "icons": [
    {
      "src": "images/icons/homescreen192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}

For the manifest content updates, Dipika collaborated with Firefox engineer Jonathan Almeida to update browser compatibility data for manifest members in Firefox.
The manifest BCD additions now cover compat data for Firefox and Firefox for Android, ensuring accurate and up-to-date support information.
Readers on MDN, Can I use, and other sites, now have solid guidance on manifest support across browsers.
On the content side, several improvements landed across the section for prose, layout and templating fixes.
The page template is now improved for readability and consistency across the entire section.
For each member value (for example, "display": "standalone",), there is a proper prose description, with example scenarios where the value might be used.
Usage notes are collected into a dedicated "Description" section, and any caveats that the specification mentioned that were not in the MDN pages and now documented.
Some pages were missing "Syntax" sections completely, so now these gaps are filled so readers can better understand how to use the documented features and some possible member values:
json/* Boolean values */
"prefer_related_applications": true
"prefer_related_applications": false

This refresh made sure that the existing content was more comprehensive and readable but also included references to similar features, which allowed for more flexibility for developers. For example, using prefers-color-scheme in HTML to set different theme_color values for light and dark mode:
html<meta
  name="theme-color"
  content="#F4E6D8"
  media="(prefers-color-scheme: light)" />
<meta
  name="theme-color"
  content="#5D4037"
  media="(prefers-color-scheme: dark)" />
HTTP content updatesHTTP is a protocol that's foundational for data exchange on the web.
It allows communication between browsers and servers, but it can also be used for machine-to-machine communication, automating access to APIs, and more.
On MDN, the HTTP section has over 300 pages of reference material, and the majority of pages are about HTTP headers and response status codes.
Response status codes let the client know the outcome of a HTTP request (such as 200, 404), and give some additional context in certain cases.
There are 61 status codes documented on MDN and they include examples for common responses and clarifications for rarer types that web developers may not encounter often.
You can even make sure you're familiar with the 418 (I'm a teapot) status just in case.
There are 148 HTTP headers documented on MDN.
HTTP headers are the parts of the HTTP message that carry metadata, information about the client or server, instructions for the recipient, and so on.
Some headers have several sub-pages that describe mechanisms you can control via headers, such as Content Security Policy (CSP) directives that instruct a browser to restrict what the code comprising a site can run and Permissions Policy directives for requesting permission to use browser features such as location or microphone access.
The HTTP guides have overviews of how the protocol works, describing the evolution of the protocol from HTTP/0.9 right through to current versions.
We document different ways to control HTTP interactions such as caching and conditional requests, and we have guides about how to use and understand the protocol for beginners, right up to more involved topics.
A lot of the refresh of these guides meant making less specific references to HTTP/1.1 when talking about message formats seeing as HTTP/2 and HTTP/3 are increasingly common.
httpHEAD /en-US/docs/Web/HTTP HTTP/2
Host: developer.mozilla.org
User-Agent: curl/8.7.1
Accept: */*

* Request completely sent off
HTTP/2 200

To summarize, the changes we made across the entire HTTP section included adding examples where they were missing or too short to be useful, removing outdated or obsolete information, and making the formatting and presentation consistent over all pages.
HTTP highlights on MDN
Part of the refresh involved updating and adding sequence diagrams that explain client-server exchanges.
We've been finding mermaid syntax useful for a lot of these types of diagrams as it makes it easier to store sources for images that we may need to update later.
These images are stored in the shared-assets repository, which allows us to reuse images instead of duplicate them in the source, and these are easier to write, read, maintain, and they look nice, too:

One interesting pick from the HTTP section is the Server-Timing response header that you can use to surface server metrics to a client:
httpHTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 123
Date: Fri, 03 Jan 2025 10:41:21 GMT
Server-Timing: custom-metric;dur=123.45;desc="My custom metric"

--- response body ---

Depending on the type of request, you can decide if you want to send server timings to the client, and these are visible in the Network request details panel in most browser's developer tools.
For example, the BBC iPlayer is using the Server-Timing header to send performance metrics about the service, visible in the Network > Timings panel below.
If you find this interesting, be sure to check the Performance API and the Web performance documentation.

For the HTTP section, most of the BCD updates involved improving the accuracy of existing entries and adding missing compat data for headers.
Additions included the Service-Worker request header for logging service worker script requests and the Sec-Websocket-* headers used in the WebSocket handshake.
Most of the HTTP updates are for older features, but the accuracy of the support information is crucial for developers making decisions about what to build.
One example is the Trailer compatibility details which now reflects browser implementations.
It's important to avoid misleading information in compatibility tables because they may encourage people to develop functionality in their applications for features that have poor browser support in reality.Other 2024 content highlights on MDNHere's a few interesting picks of documentation that landed in 2024:

New! CSS anchor positioning documentation
New! Using the View Transition API guide

Aside from reference docs, we've written about these topics on the MDN blog:

Locale-sensitive text segmentation in JavaScript with Intl.Segmenter
Exclusive accordions using the HTML <details> element
New JavaScript Set methods
Using the Page Visibility API
Interop 2023: MDN updates
Creating effective technical documentation

We also blogged about these changes and launches:

A new learning experience on MDN merging the MDN Curriculum into Learn Web Development.
Introducing the MDN HTTP Observatory for testing server HTTP header configuration.
And, of course, we have a new Community page which we are delighted to share!
Firefox release notes for developersFirefox release notes describe what's changed for everyday browser users.
The MDN team document each Firefox release with release notes specifically for developers.
That means in 2024, Firefox versions 122 up to 133 have pages describing the changes in each Firefox release that developers can target.
You can find everything in the Firefox release notes for developers pages.
Something you may not be aware of is that we also document Experimental features in Firefox.
This page describes features implemented in Firefox that are only available behind a preference (though configuration).
You can test out upcoming features before they are released, which is ideal if you're planning to use an experimental technology or if you're curious and would like to provide feedback on Bugzilla.Kicking off 2025The content projects that the team worked on were a superb learning experience, and we hope our readers benefit greatly from it.
If you want to make our docs better, let us know if there are other sections that need attention, and even lend your expertise.
If you want to learn about a topic, why not try to improve the documentation!
By contributing to MDN, you can improve your skills in a technology category, and millions of readers will benefit from it.
We're happy to share that we saw the following contributions in mdn/content GitHub repository in 2024:

915 different authors contributed.
~4300 pull requests opened.
~1500 issues opened.

We want to send out a big thanks to everyone who contributed in 2024 and we hope to see you continue in 2025.
One of the first larger changes we're excited to see is that JavaScript Temporal is coming with support scheduled to land in Firefox 135.
There is a huge pull request for Temporal authored by Josh-Cena, which means you can expect to be able to read Temporal documentation on MDN very soon.
We hope you enjoyed this post!
Feel free to get in touch with us and let us know what you think.Previous Post A new learning experience on MDNNext Post Fix your website's Largest Contentful Paint by optimizing image loading\n\n\n\nA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projectsPrevious Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\nIn this articleOverview of learning material on MDNDeveloping the MDN curriculumWhy the update?The new state of learning material on MDNWhat's next for learners on MDNSummaryA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\nA new learning experience on MDNRuth JohnDecember 20, 20244 minute readA major update to the MDN Learn Web Development section started in November 2024 and was finally published in December 2024.
To summarize, the MDN Curriculum has been merged into Learn Web Development.
This post looks at the background leading up to this decision being made, what the changes mean specifically, and what updates you can expect to see in the future.Overview of learning material on MDNWe originally launched the MDN Learn Web Development section in 2016 with the aim of making MDN more accessible to non-experts and helping to take new web developers from "beginner to comfortable".
The content was pretty successful — by 2019 it was being used by over a million people per month to learn web development topics.
However, it was noted that the structure was sub-par:

The content had become bloated with topics that weren't really suitable for beginner web developers — either they were too advanced, or they were out of scope altogether.
Beginners tend to want a robust pathway they can follow to get the knowledge they need, rather than being expected to figure out what to learn and when.
Learners these days tend to want interactive multimedia content, not just text.
Developing the MDN curriculumTo solve the second issue highlighted above, we created a resource to help guide people towards learning a better skillset, making them more employable, and enabling them to build a better, more accessible, more responsible web of tomorrow.
As part of this project, we did substantial research to find out exactly what skills are seen as essential in new hires, and what the most common knowledge gaps are.
The resulting curriculum was intended to be useful as a study guide for self-learners, and a syllabus for educators to base courses on.
We also used it as a place to experiment with including interactive multimedia content via our learning partner, Scrimba.
We launched the MDN Curriculum in early 2024.Why the update?The curriculum was well-received by educators, but we quickly received feedback that users found it confusing having two learning resources on MDN, with the curriculum/learning pathway in one place and the learning content in another place.
In addition, the pathway was just a curriculum; learners still had to figure out what content to look at to achieve the learning objectives. And it did nothing to solve the first issue listed above — the content was still bloated.The new state of learning material on MDN
To provide a less confusing, more streamlined learning experience, we decided to merge the curriculum pathway into the MDN Learn Web Development section, restructuring it in the process. The results can be seen at the following new URL — developer.mozilla.org/docs/Learn_web_development.

The most significant changes are as follows:

The articles now follow the same structure as the curriculum, with useful background and environment setup information in Getting started, the web fundamentals everyone should know in Core, and optional extra topics in Extensions. There is a clear pathway to follow between each article in the first two major sections, so readers know what to learn next at each stage.
In some cases, content was deemed not suitable for a beginner audience and has been repurposed as extensions/additional articles or migrated to other parts of MDN.
The specific learning outcomes detailed in the curriculum have been added to the top of the Getting started, Core, and some of the Extension articles, to match the learning outcomes detailed in the Curriculum.
Other features from the Curriculum have been migrated across to the Learn Web Development section, such as the About page and Resources for educators.

Initially, the Curriculum section will stay, however it will be merged into the Learn area over the next few iterations of this work and will be removed when it is felt the time is right.
We will keep a downloadable version as a resource for educators.What's next for learners on MDNMoving forward, we will continue to update the content and design to make Learn Web Development even more useful to learners and educators.
We are intending to give the article content a significant overhaul as we move into 2025. A lot of the content is timeless and does a good job of teaching the fundamentals, but the pacing is uneven, some of the articles are pretty long (which can be intimidating for beginners), and some of the challenges and examples have been around for a long time. Inspired by resources such as the content produced by our learning partner, Scrimba, we intend to shake our content up a bit to make it more fun, bite-size, and digestible.
We are also looking at improving the design of our learning pages, to echo the bright bold design we used on the curriculum and improve the experience further.
You can expect to see regular iterative improvements going forward, so watch this space.SummaryWe hope you find the new Learn Web Development content structure useful — have a look around and let us know what you think.
If you still have unanswered questions or wish to report issues, please get in touch via the usual communication channels.
If your issue concerns a specific piece of content, you might want to file a GitHub issue.Previous Post Countdown to the holidays with daily coding challengesNext Post MDN 2024 content projects\n\n\n\nIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer jobPrevious Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\nIn this articleWhat's new for the MDN Community?Want to start contributing to MDN?Join the conversationLicensing and reuseIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\nIntroducing the new MDN Community pagePranshu KhannaOctober 15, 20245 minute readMDN has always been a place for people to connect, collaborate, and grow. As we look to the future, we want to celebrate our achievements and bring people together on the exciting path ahead. Today, I'm thrilled to introduce our brand-new community page.
Launching during Hacktoberfest, a month-long celebration of open source, is excellent timing for MDN, the go-to place for open-source web documentation. We're thrilled to welcome even more contributors and acknowledge the achievements of the MDN community.What's new for the MDN Community?We aim to make your community experience welcoming and engaging. You'll quickly find the resources you need, and we'll showcase more of the community's contributions. I'm excited to guide you through the new updates that make this space more interactive and valuable for everyone!A place for collaboration and growthOur new Community page highlights contributions from developers, writers, and learners who work together to improve MDN. Many community members contribute to MDN to grow their technical, writing, and language skills while building connections with collaborators. We invite you to connect with other members, share your knowledge, learn from others, and grow professionally alongside peers as passionate about the web as you are.
Recognizing our contributorsMeet Our Contributors highlights people who have contributed to the platform. We celebrate the diverse skills and backgrounds that help MDN's mission to provide a blueprint for a better internet and empower a new generation of developers and content creators to build it.
The Contributor Spotlight program is a series of personal stories about what motivates people to work on MDN. People like Joshua appreciate MDN's infrastructure, which is unique in how it helps everyone work efficiently, or Hochan, who enjoys the community's diversity and how it broadens his perspective. We're proud to amplify and share the voices of our community and the reasons why they are driven to improve MDN.Get recognition for your contributionsWe want this to be a community where everyone's contributions are visible and valued. If you're passionate about making the web better, there are so many ways to get involved. You can squash bugs, improve content, help with localization, or even answer questions on Discord. Every contribution, no matter the size, helps shape the future of MDN, and we want to ensure those efforts don't go unnoticed.
By contributing, your name could also appear on this page as one of the dedicated individuals shaping the web. Whether through our GitHub repository, working on translation efforts, or simply helping out other developers, there are plenty of opportunities to be a part of this community and leave your mark. The new page makes it easier than ever to get started, with guides and resources available to help you find the best way to contribute.
Contributing to open sourceIf you're new to contributing to MDN, we've made it easier than ever to get started. We've added a video that offers simple, clear instructions on how you can begin making an impact. We collaborate on GitHub, and you'll find step-by-step guidance to help you with writing, fixing bugs, or even improving documentation. Plus, you can check out our helpful video on how to get started with contributing to MDN Web Docs, so you're fully prepared to make your first contribution.
MDN is driven by a global community dedicated to documenting the web for the future. Whatever your skill set, there's a place for you to make a difference. You can now easily get involved, and start playing your part in building a better, more inclusive web.
Want to start contributing to MDN?We understand if you're new to MDN or open-source projects, and would like to start right away. That is exactly why we have our first issues front and center, it is the perfect place to start. We've highlighted beginner-friendly issues to help you improve MDN. This section lists specific tasks that are great for first-time contributors, whether it's fixing a bug, addressing an issue with documentation, or enhancing translated content. You'll find clear guidance on how to contribute, along with links to relevant repositories, so you can jump right in and start making an impact.
Join the conversationMDN is an open-source project that you can help us shape in many ways. We'd love it if you dropped by our Discord so you can get to know other community members, ask questions, and get help from fellow developers. It's a space for lively discussion where you can share ideas and seek advice. Also, we invite you to Join our Community Call, where you'll receive updates from the MDN team, hear about new initiatives, and share your questions and thoughts on how we can continue improving the platform and content. Whether through Discord or our calls, we want you to have the space to connect and make an impact in this community.
Licensing and reuseMDN Resources are openly accessible and free to reuse under a variety of open-source licenses. We encourage developers, educators, and content creators to use and share MDN's materials, as long as proper attribution is given. Our goal is to ensure that the knowledge we build together is freely available to anyone who needs it, while still protecting the contributions of our community members.
We're incredibly excited about the future of our community and what we can build together. We want our platform to be even more collaborative, accessible, and vibrant, where every contribution supports and shapes the web, and there's a place for everyone to make an impact.
We'd love to hear your feedback on the new community page or any ideas you have for improving MDN. Let us know on Discord or start a discussion on GitHub. I look forward to seeing you there!Previous Post Fixing your website's JavaScript performanceNext Post How to land your first developer job\n\n\n\nContributor profile@yashrajbhartiHi! I'm Yash, a UXE and a Senior Mentor of the Liquid Galaxy, where I work on GIS applications, making immersive data viz projects on Google Maps, Street View, and Earth. Liquid Galaxy is a Google-founded open-source project and was my primary reason for falling in love with open-source. I work on the web with HTML, CSS, and JS, and I believe that honing strong basics can make even the most complex tasks easy.
I still remember my first contribution to MDN. I was so proud of myself. Even though the fix was small, the cheer from Will Bamberg at the time meant a lot. It was for PWA docs, where I corrected that the iTunes value associated with the App Store for platform members of related apps has been dropped since it's currently not supported by Safari.
Since then, I have been lurking to find a way to contribute to MDN. I also contributed to web.dev to learn more. I am not new to MDN, W3C, or web.dev (HTML5Rocks), and have been learning like a nerd for the last 9 years, but a couple of years back, I started finally contributing. I felt like helping the community, making explainers, and I worked alongside people like Adam Argyle on a CSS motion blur proposal and Thomas Steiner (Project Fugu). I discovered, that when I put my passion and heart into something, I can achieve it. The grit to solve challenges isn't new to me.
My work at Liquid Galaxy, documentation, and creating an innovative UX to control Google Earth using Google Maps led me to get invited as a Speaker to Google, CA, USA, which was my first time outside India. I got to speak at Talks at Google, and most importantly, to network! I met Kristi Progri who was previously a Mozilla Representative, and I thought "that's so cool, I read MDN every day" and I was confident that I could get involved, too.
After an incredible journey to Google, knowing the roots of the Liquid Galaxy from 2008, I was mesmerized and was full of energy to do something, so I went to MDN and saw some small bugs like buttontext details, where I met Estelle Weyl (and I'm so thankful I did, as I had all the passion and pure knowledge waiting to test the waters). They helped me with the contributions by stating how buttontext for accessibility reasons will be fixed by filing a bug in WebKit. After some PRs like this, I mailed them asking to create an issue about the <model> tag. They told me it's still a WIP but there are some Baseline 'Widely Available' PRs I can contribute to. They trusted me, created a Google Sheet, and gave me edit access. And I delivered. The rest is history, I found my chance and took it, I knew Estelle because I had read her book on CSS, and was amazed to work alongside her on this. This sheet holds value to me and is the most up-to-date record of the work we are doing.
I love it because just think about how many future developers can be helped with it, those who truly learn like me and do not rely on crash courses to just get it "done". I thank Estelle for my journey and I want to stay in this community and help make MDN the library, a well-organized library I know it as, where you just know where each book is.Yash Raj BhartiMDN resonates with my passion to build a consistent and open web, where developers can learn and grow.How did you start using MDN?I started just like others, but using it as a source of learning, from those little tooltips that say "MDN reference" in VS Code, all the way to contributing and making the docs correct, wherever I can find a way to contribute, to hopefully be a part of it.What do you like about MDN?I like that it has all the implementation knowledge needed. When documenting, what I truly got to know from Will was, we are not just paraphrasing W3C specs, we are building it with an abstraction keeping in mind developers (and UXEs like me too) are our end users.Why do you contribute to Open Source or MDN?Anything open source is where we can ask "why should we not contribute"? There's all the reasons in the world to help and let everyone prosper, and that's what I love, whether it's for Google or Mozilla.What do you enjoy about contributing to MDN?I loved making DOMQuad as I was learning first hand and I believe I will become an encyclopedia as a by-product of helping others! That's rad.\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nWebtechnologie für EntwicklerDas offene Web bietet unglaubliche Möglichkeiten für Entwickler. Um diese Technologien voll auszuschöpfen, müssen Sie wissen, wie man sie nutzt. Nachfolgend finden Sie Links zu unserer Webtechnologie-Dokumentation.Dokumentation für Webentwickler
Webentwickler-Leitfäden

Die Webentwickler-Leitfäden bieten praktische Anleitungen, um Ihnen zu helfen, Webtechnologien für Ihre Ziele oder Bedürfnisse zu nutzen.

Tutorials für Webentwickler

Tutorials, die Sie Schritt für Schritt durch das Lernen von HTML, CSS, JavaScript und Web-APIs führen.

Barrierefreiheit

Ermöglichen, dass so viele Menschen wie möglich Websites nutzen können, selbst wenn die Fähigkeiten dieser Menschen in irgendeiner Weise eingeschränkt sind.

Performance

Inhalte so schnell wie möglich verfügbar und interaktiv machen.

Datenschutz

Schutz der persönlichen Daten der Nutzer.

Sicherheit

Schutz der Benutzer vor Datenlecks und Datendiebstahl, Seitenkanalangriffen und Angriffen wie Cross-Site-Scripting, Inhaltseinschleusung und Clickjacking.

Glossar

Definitionen von Web-bezogenen Begriffen.

Webtechnologie-Referenzen
Web-APIs

JavaScript-Programmier-APIs, die Sie verwenden können, um Apps im Web zu entwickeln.

HTML

HTML bietet die grundlegenden Bausteine zur Strukturierung von Webdokumenten und Apps.

CSS

Cascading Style Sheets werden verwendet, um das Erscheinungsbild von Webdokumenten und Apps zu beschreiben.

JavaScript

JavaScript ist die native Programmiersprache des Webs.

WebAssembly

WebAssembly ermöglicht es, Programme, die in C, C++, Rust, Swift, C#, Go und mehr geschrieben sind, im Web auszuführen.

Events

Ereignisse sind das, worauf Sie Web-Apps reagieren lassen; zum Beispiel, wenn eine Webseite fertig geladen wurde, oder ein Benutzer etwas auswählt, eine Taste drückt, ein Fenster vergrößert, ein Formular absendet oder ein Video pausiert.

HTTP

HTTP ist das grundlegende Internetprotokoll zum Abrufen von Dokumenten, Stylesheets, Skripten, Bildern, Videos, Fonts und anderen Ressourcen über das Web – und zum Zurücksenden von Daten an Webserver.

Medien

Formate, Codecs, Protokolle, APIs und Techniken zum Einbetten und Streamen von Video-, Audio- und Bildinhalten in Webdokumenten und Apps.

SVG

Scalable Vector Graphics ermöglicht es Ihnen, Bilder zu erstellen, die sich reibungslos auf jede Größe skalieren lassen.

MathML

MathML ermöglicht die Darstellung komplexer mathematischer Notationen im Web.

URI

Uniform Resource Identifiers werden von verschiedenen Technologien verwendet, einschließlich des Browsers selbst über die Adressleiste, um Ressourcen auf unterschiedliche Weise zu identifizieren.

WebDriver

WebDriver ist ein Browser-Automatisierungsmechanismus zum Fernsteuern eines Browsers, indem Aktionen einer echten Person imitiert werden, die den Browser benutzt. Es wird häufig für Cross-Browser-Tests von Web-Apps verwendet.

Web-Erweiterungen

Web-Erweiterungen sind eine Möglichkeit, Benutzern erweiterte Funktionen in ihren Browsern bereitzustellen, indem z.B. Werbung und andere Inhalte blockiert, das Erscheinungsbild von Seiten angepasst und mehr getan wird.

Web App Manifeste

Web App Manifeste ermöglichen es Benutzern, Web-Apps auf ihren Gerätestartbildschirmen zu installieren, mit Aspekten wie Hoch-/Querformat-Bildschirmorientierung und Anzeigemodus (z.B. Vollbild) vorkonfiguriert.

Progressive Web Apps (PWAs)

Progressive Web Apps bieten ein Benutzererlebnis, das dem nativer mobiler Apps ähnelt.

OpenSearch

OpenSearch ermöglicht es einer Website, eine Suchmaschine für sich selbst zu beschreiben, so dass ein Browser oder eine andere Client-Anwendung diese Suchmaschine nutzen kann.

XML

Die Extensible Markup Language ist eine strikte Serialisierung des Document Object Model.

XSLT

Extensible Stylesheet Language Transformations ist eine auf XML basierende Sprache, die zusammen mit spezialisierten Verarbeitungsprogrammen zur Transformation von XML-Dokumenten verwendet wird.

XPath

XPath verwendet eine nicht-XML-Syntax, um eine flexible Möglichkeit zu bieten, verschiedene Teile eines XML-Dokuments anzusprechen (hinzuweisen). Es kann auch verwendet werden, um adressierte Knoten innerhalb eines Dokuments zu testen, um festzustellen, ob sie einem Muster entsprechen oder nicht.

EXSLT

EXSLT ist eine Menge von Erweiterungen zu XSLT.

Dokumentation der Entwicklerwerkzeuge
Firefox Developer Tools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Firefox eingebaut sind.

Chrome DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Chrome eingebaut sind.

Safari Web Inspector

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Safari eingebaut sind.

Edge DevTools

Dokumentation für die Menge an Webentwickler-Werkzeugen, die in Edge eingebaut sind.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensible\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensibleHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTecnología para desarrolladores webLa Web abierta presenta increíbles oportunidades para los desarrolladores. Para aprovechar al máximo estas tecnologías, debes saber cómo utilizarlas. A continuación, encontrarás enlaces a nuestra documentación de tecnología web.Documentación para desarrolladores web
Referencia para desarrolladores web

Una lista de todas las referencias para tecnologías web, incluidas las de HTML, CSS, etc.

Guía para desarrolladores web

La Guía para desarrolladores web ofrece contenido práctico útil que te ayudará a utilizar las tecnologías web para hacer lo que quieres o necesitas hacer.

Tutoriales para desarrolladores web

Una lista de tutoriales que te guiarán paso a paso a través del aprendizaje de las APIs, tecnologías o amplias áreas temáticas.

Desarrollar aplicaciones web

Documentación para desarrolladores de aplicaciones web; Las aplicaciones web son verdaderas aplicaciones de una sola escritura y se implementan en cualquier lugar para dispositivos móviles, de escritorio y Firefox OS.

Fragmentos de código

Esta es una lista rápida de fragmentos de código útiles (pequeñas muestras de código) disponibles para los desarrolladores de extensiones para las diversas aplicaciones de Mozilla. Muchos de estos ejemplos también se pueden utilizar en aplicaciones XULRunner, así como en el propio código de Mozilla.

Referencias de tecnología web
APIs web

Material de referencia para cada una de las APIs individuales que comprenden la poderosa capacidad de secuencia de comandos de la Web, incluido el DOM y todas las APIs e interfaces relacionadas que puedes utilizar para crear contenido y aplicaciones Web.

HTML

El lenguaje de marcado de hipertexto es el lenguaje utilizado para describir y definir el contenido de una página web.

CSS

Las hojas de estilo en cascada (Cascading Style Sheets) se utilizan para describir la apariencia del contenido web.

SVG

Los gráficos vectoriales escalables (Scalable Vector Graphics) te permiten describir imágenes como conjuntos de vectores y formas para permitirles escalar sin problemas, independientemente del tamaño en el que se dibujen.

MathML

El lenguaje de marcado matemático permite mostrar sintaxis y ecuaciones matemáticas complejas.


Temporal
Lo siguiente aquí es temporal para ayudarte a realizar un seguimiento de las cosas mientras el trabajo de la organización está en curso. No le hagas caso.
AccesibilidadAplicaciones Web ProgresivasCSSHTML: Lenguaje de etiquetas de hipertextoHTTPJavaScriptMathMLReferencia de EventosReferencia de la API WebRendimiento WebSVGSeguridad WebTecnologías multimedia de la webXML: Lenguaje de marcado extensibleHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 mar 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTechnologies web pour développeursLe Web fournit d'incroyables opportunités aux développeuses et développeurs. Pour tirer le meilleur parti de ces technologies, il est nécessaire de savoir comment les utiliser. Voici différents liens qui vous permettront de naviguer dans la documentation de ces technologies web.Documentation pour le développement web
Références

Une liste de l'ensemble des références sur les technologies web dont celles sur HTML, CSS, etc.

Guides

Cette page fournit différents tutoriels pour vous aider à manipuler les technologies web afin de réaliser ce que vous souhaitez.

Tutoriels

Une liste de tutoriels qui progressent étape par étape pour apprendre les API, langages et autres sujets.

Les applications web progressives (Progressive Web Applications ou PWA en anglais)

Les applications web progressives sont des applications web qui utilisent les API et les fonctionnalités du navigateur ainsi que des stratégies d'amélioration progressive afin d'apporter une expérience utilisateur semblable aux applications natives et qui puissent fonctionner sur les différentes plateformes web.

Références des technologies web
API Web

Les références pour l'ensemble des API qui permettent de rendre le Web interactif et scriptable. On y trouve notamment le DOM, les diverses interfaces et API utilisées pour construire du contenu et des applications web.

HTML

HyperText Markup Language est le langage utilisé pour décrire et définir le contenu d'une page web.

CSS

Cascading Style Sheets est le langage utilisé pour décrire l'apparence du contenu web.

JavaScript

JavaScript est le langage de programmation utilisé pour ajouter de l'interactivité à un site web.

HTTP

HyperText Transfer Protocol est le protocole utilisé entre le navigateur et les serveurs web.

SVG

Scalable Vector Graphics est un format qui permet de décrire des images comme ensembles de vecteurs et de formes afin de pouvoir les mettre à l'échelle quelles que soient les dimensions selon lesquelles elles sont dessinées.

MathML

Mathematical Markup Language est un langage qui permet d'afficher des expressions mathématiques complexes.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n開発者向けのウェブ技術オープンなウェブは、開発者に素晴らしい機会をもたらします。これらの技術を最大限に活用するには、それらの使い方を知る必要があります。以下に、ウェブ技術のドキュメントへのリンクがあります。ウェブ開発者のためのドキュメント
ウェブ開発者ガイド

ウェブ開発者ガイドは、ウェブ技術を実際に使用して、やりたいことや必要なことを実現するために役立つハウツーコンテンツを提供しています。

ウェブ開発者向けチュートリアル

HTML、CSS、JavaScript、Web API の学習を段階的に進めるためのチュートリアルです。

アクセシビリティ

ウェブサイトを使用する人に何らかの制約があっても、できるだけ多くの人が使用できるようにすることです。

パフォーマンス

コンテンツをできるだけ早く利用できるように、操作できるようにすることです。

セキュリティ

データ漏洩やデータ盗難、サイドチャンネル攻撃、クロスサイトスクリプティング、コンテンツインジェクション、クリックジャッキングなどの攻撃からユーザーを保護することです。

ウェブ技術のリファレンス
Web API

ウェブでアプリを構築するために利用できる JavaScript のプログラミング API 群です。

HTML

HTML は、ウェブの文書やアプリを構成する基礎的な構成要素を提供します。

CSS

CSS は、ウェブの文書やアプリの外観を記述するために使用されます。

JavaScript

JavaScript は、ウェブのネイティブプログラミング言語です。

WebAssembly

WebAssembly により、 C、C++、Rust、Swift、C#、Go などで書かれたプログラムをウェブで実行できます。

イベント

イベントとは、ウェブアプリで応答するために構築するものです。例えば、ウェブページの読み込みが完了したとき、ユーザーが何かを選択したとき、キーを押したとき、ウィンドウのサイズを変更したとき、フォームを送信したとき、動画を一時停止したとき、などです。

HTTP

HTTP は、文書、スタイルシート、スクリプト、画像、動画、フォント、その他のリソースをウェブ上で取得し、ウェブサーバーにデータを送り返すための基本的なインターネットプロトコルです。

メディア

ウェブ文書やアプリに動画、音声、画像コンテンツを埋め込んだりストリーミングしたりするための形式、コーデック、プロトコル、API、技術です。

SVG

SVG を使用すると、画像を一連のベクトルと形状として記述して、描画されるサイズに関係なくスムーズに拡大縮小できます。

MathML

MathML により、複雑な数式や構文を表示することができます。

ウェブコンポーネント

ウェブコンポーネントは、アプリで定義したり再利用したりすることができるカスタム要素です。

WebDriver

WebDriverは、実際にブラウザーを使用している人の動作をエミュレートして、ブラウザーを遠隔制御するためのブラウザーオートメーションメカニズムです。

ウェブ拡張機能

ウェブ拡張機能は、ユーザーがブラウザーで広告や他のコンテンツをブロックしたり、ページの外観をカスタマイズしたりするなどの機能を強化するための方法です。

ウェブアプリマニフェスト

ウェブアプリマニフェストにより、縦画面/横画面の方向や表示モード（全画面など）をあらかじめ設定し、ユーザーの機器のホーム画面へウェブアプリケーションをインストールすることができます。

プログレッシブウェブアプリ (PWA)

プログレッシブウェブアプリは、ネイティブアプリのような使い勝手をもたらします。

用語集

ウェブ関連用語の定義。

開発者ツールの文書
Firefox Developer Tools

Firefox に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Chrome DevTools

Chrome に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Safari Web Inspector

Safari に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Edge DevTools

Edge に組み込まれた一連のウェブ開発者ツールのためのドキュメントです。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 1월 19일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n개발자를 위한 웹 기술웹의 개방성은 개발자들에게 많은 기회를 제공합니다. 하지만 웹 기술을 잘 활용하려면 우선 그 사용 방법을 잘 알아야 합니다. 아래의 링크들을 확인하여 다양한 웹 기술을 배워보세요.웹 개발자를 위한 문서
웹 개발자 안내서

웹 개발자 안내서는 원하는 것과 필요한 것을 웹으로 만들 때 유용한 도움말을 제공합니다.

웹 개발자를 위한 자습서

HTML, CSS, JavaScript, Web API에 대한 단계별 학습을 제공하는 문서 목록입니다.

접근성

가능한 한 많은 사람들이 웹사이트를 사용할 수 있게 합니다. 비록 이러한 사람들의 능력이 어떤 식으로든 제한되어 있는 경우에도 말이죠.

성능

가능한 한 빠르게 콘텐츠를 사용 가능하게 하고 가능하면 상호작용이 기능하게 만듭니다.

개인정보

사용자의 개인 데이터를 보호합니다.

보안

데이터 유출 및 도난, 부채널 공격(side-channel attacks) 및 크로스 사이트 스크립팅, 콘텐츠 주입 및 클릭 재킹과 같은 공격으로부터 사용자를 보호합니다.

웹 기술 참고서
웹 API

웹에서 앱을 만들기 위해 사용하는 JavaScript 프로그래밍 API입니다.

HTML

HTML은 웹 문서와 앱을 구조화하는데 필요한 기본적인 구성 요소를 제공합니다.

CSS

Cascading Style Sheets는 웹 문서와 앱의 외형을 만드는데 사용됩니다.

JavaScript

JavaScript는 웹의 기본 프로그래밍 언어입니다.

WebAssembly

WebAssembly는 C, C++, Rust, Swift, C#, Go 등으로 작성한 프로그램을 웹에서 구동할 수 있도록 합니다.

Events

이벤트는 웹 페이지 로드가 완료되거나 사용자가 무언가를 선택하거나 키를 누르거나 창 크기를 조정하거나 양식을 제출하거나 비디오를 일시 중지할 때 여러분이 만든 웹 앱이 반응해야하는 것 입니다.

HTTP

HTTP는 웹을 통해 문서, 스타일시트, 스크립트, 이미지, 비디오, 글꼴 및 기타 리소스를 가져오고 웹 서버로 다시 보내기 위한 기본적인 인터넷 프로토콜입니다.

Media

웹 문서 및 앱에 비디오, 오디오 및 이미지 콘텐츠를 내장하고 스트리밍하기 위한 형식, 코덱, 프로토콜, API 및 기술.

SVG

Scalable Vector Graphics(SVG)는 어떠한 크기로 확대해도 부드러운 이미지를 만들수 있습니다.

MathML

MathML은 복잡한 수학 표기법을 웹에 표시할 수 있습니다.

웹 컴포넌트

웹 컴포넌트는 개발자가 직접 정의하고 재사용할 수 있는 사용자 정의 요소입니다.

WebDriver

웹드라이버(WebDriver)는 브라우저를 사용하는 실제 사람의 행위를 모방하여 원격으로 브라우저를 제어하는 브라우저-자동화 메커니즘입니다. 웹 앱의 브라우저간 테스트를 위해 폭넓게 사용합니다.

Web Extensions

웹 확장 기능(Web Extensions)은 브라우저에서 사용자에게 향상된 기능을 제공합니다. 광고 및 기타 컨텐츠 차단, 페이지 모양 사용자 지정 등을 수행할 수 있습니다.

Web App Manifests

웹 앱 매니페스트(Web App Manifest)를 사용하면 사용자가 세로/가로 화면 방향과 디스플레이 모드(예: 전체 화면)를 미리 설정하여 장치의 홈 스크린에 웹 앱을 설치할 수 있습니다.

프로그레시브 웹 앱(PWAs)

프로그레시브 웹 앱(Progressive Web App)은 네이티브 모바일 앱과 유사한 사용자 경험을 제공합니다.

개발자 도구 문서
Firefox Developer Tools

Firefox에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Chrome DevTools

Chrome에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Safari Web Inspector

Safari에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Edge DevTools

Edge에 내장된 웹 개발자 도구 집합에 대한 설명서입니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 1월 19일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nTecnologia Web para desenvolvedoresA Web aberta apresenta oportunidades incríveis para os desenvolvedores. Para tirar o máximo proveito dessas tecnologias, você precisa saber como usá-las. Abaixo, você encontrará links para nossa documentação de tecnologias Web.Documentação para desenvolvedores Web
Guia para Desenvolvedores Web

O Guia para Desenvolvedores Web provê um conteúdo útil de informações, para realmente ajudá-lo a usar as tecnologias Web para fazer o que deseja ou precisa.

Tutoriais para Desenvolvedores Web

Uma lista de tutoriais para orientá-lo passo a passo no aprendizado de APIs, tecnologias ou áreas abrangentes dos tópicos.

Acessibilidade

Permitir que o maior número possível de pessoas use sites, mesmo quando as habilidades dessas pessoas são limitadas de alguma forma.

Performance

Tornar o conteúdo o mais disponível e interativo possível, o mais rápido possível.

Security

Protegendo os usuários contra vazamentos de dados e roubo de dados, ataques de canal lateral e ataques como scripts entre sites, injeção de conteúdo e click-jacking.

Referências para Tecnologias Web
APIs da Web

APIs de programação JavaScript que você pode usar para criar aplicativos na Web.

HTML

HTML fornece os blocos de construção fundamentais para estruturar documentos e aplicativos da Web.

CSS

Folhas de estilo em cascata são usadas para descrever a aparência de documentos e aplicativos da Web.

JavaScript

JavaScript é a linguagem de programação nativa da Web.

WebAssembly

O WebAssembly permite que programas escritos em C, C++, Rust, Swift, C#, Go e muito mais sejam executados na Web.

Eventos

Eventos são o que você cria aplicativos da Web para reagir; por exemplo, quando uma página da Web termina de carregar ou um usuário seleciona algo, pressiona uma tecla, redimensiona uma janela, envia um formulário ou pausa um vídeo.

HTTP

HTTP é o protocolo fundamental da Internet para buscar documentos, folhas de estilo, scripts, imagens, vídeos, fontes e outros recursos pela Web — e para enviar dados de volta aos servidores Web.

Mídia

Formatos, codecs, protocolos, APIs e técnicas para incorporar e transmitir conteúdo de vídeo, áudio e imagem em documentos e aplicativos da Web.

SVG

Gráficos vetoriais escaláveis permitem que você crie imagens que podem ser dimensionadas suavemente para qualquer tamanho.

MathML

MathML permite exibir notações matemáticas complexas na Web.

Componentes da Web

Componentes Web são elementos personalizados que você pode definir e reutilizar em seus aplicativos Web.

WebDriver

WebDriver é um mecanismo de automação de navegador para controlar remotamente um navegador emulando as ações de uma pessoa real usando o navegador. É amplamente usado para testes entre navegadores de aplicativos da Web.

Extensões da Web

Extensões da Web são uma maneira de você fornecer aos usuários recursos aprimorados em seus navegadores — para fazer coisas como bloquear anúncios e outros conteúdos, personalizar a aparência das páginas e muito mais.

Manifestos de aplicativos da Web

Manifestos de aplicativos da Web permitem que os usuários instalem aplicativos da Web nas telas iniciais de seus dispositivos, com aspectos como orientação de tela retrato/paisagem e modo de exibição (por exemplo, tela cheia) predefinidos.

Progressive Web Apps (PWAs)

Progressive Web Apps fornecem uma experiência de usuário semelhante a aplicativos móveis nativos.

Documentação das ferramentas do desenvolvedor
Ferramentas do desenvolvedor do Firefox

Documentação para o conjunto de ferramentas de desenvolvimento web incorporadas ao Firefox.

Chrome DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Chrome.

Safari Web Inspector

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Safari.

Edge DevTools

Documentação para o conjunto de ferramentas de desenvolvedor da Web incorporadas ao Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nВеб-технологии для разработчиковСовременные веб-технологии предоставляют разработчикам неограниченные возможности для реализации своих идей. Для того, чтобы вы могли использовать весь их потенциал, необходимо знать как правильно их использовать. На этой странице мы постарались собрать ссылки на документацию по различным технологиям, которые могут быть вам полезны.Веб-технологииОсновы веб разработки
HTML

Язык гипертекстовой разметки — это язык, используемый для определения структуры и описания содержания веб-страницы в структурированной форме.

CSS

Каскадные таблицы стилей используются для описания внешнего вида веб-контента.

HTTP

HyperText Transfer Protocol (HTTP) — это протокол, по которому доставляются HTML и прочие медиа-документы.

Написание сценариев
JavaScript

JavaScript — язык программирования, широко используемый для реализации взаимодействия пользователя с веб-сайтами и приложениями.

Веб API

Данный раздел включает справочные материалы по каждому из отдельно взятых API, содержащих огромные возможности для создания веб-сценариев, включая DOM и все связанные с ним API, которые вы можете использовать для построения веб-контента и приложений.

Справочник по веб API содержит все интерфейсы в алфавитном порядке.
WebAPI — данная страница содержит перечень API для взаимодействия с устройствами и другие API не менее полезные для приложений.
Справка по событиям содержит список событий, которые возникают на веб-странице или в веб-приложении.


Веб Компоненты

Веб Компоненты - это набор различных технологий, позволяющих создавать собственные переиспользуемые элементы - со своей функциональностью, инкапсулированной от остального кода - и использовать их в ваших веб-приложениях.

Графика
Canvas

<canvas> элемент предоставляет API для рисования 2D-графики, с использованием JavaScript.

SVG

SVG (Scalable Vector Graphics - масштабируемая векторная графика) - позволяет вам описать изображение в виде линий, кривых и других геометрических фигур. Благодаря этому можно масштабировать рисунок без потери качества.

WebGL

WebGL - это JavaScript API, позволяющее рисовать 3D или 2D изображения используя HTML-элемент <canvas>. Эта технология позволяет использовать стандарт OpenGL ES в Web-содержимом.

Аудио, видео и мультимедиа
Web медиа-технологии

Список связанного с медиа API, со ссылками на документацию для каждого из них.

Media capture and streams API

Справочник для API, используемого для потоковой передачи, записи и управления данным как локально, так и по сети. Также включает в себя инструменты для использования локальных камер и микрофонов для захвата видео, аудио и статичных изображений.

Использование HTML аудио и видео

Включение видео и\или аудио в веб-страницу и управление их воспроизведением.

WebRTC

RTC в WebRTC означает Real-Time Communications (связь в реальном времени) - технологию, обеспечивающую поток аудио или видео и обмен данным между одноранговыми клиентами браузера.

Прочее
MathML

Математический язык разметки предоставляет возможность показа комплексных математических уравнений и синтаксиса.

XSLT

Extensible Stylesheet Language Transformations (XSLT) позволяет преобразовать XML-документ в человекочитаемый HTML.

EXSLT

Функциональное расширение, которое предоставляет дополнительные возможности для XSLT.

XPath

XPath позволяет вам выбрать DOM-узел в документе, используя более мощный синтаксис, чем предоставляется обычными CSS selectors.

Документация по типам
Руководство веб-разработчика

Руководство веб-разработчика предоставляет полезные пошаговые материалы, которые помогут вам в полной мере использовать веб-технологии для выполнения ваших задач и реализации ваших идей.

Учебные материалы для веб-разработчиков

Перечень учебных материалов позволит вам пошагово изучить API, технологии и расширить свой кругозор в области веб-технологий.

Справочные материалы

На данной странице будут представлены ссылки на всю справочную информацию, имеющуюся в MDN; а пока можно использовать ссылки на веб-технологии из левой части данной страницы.

Прочие разделы
Центр приложений

Содержит документацию для разработчиков веб-приложений. При помощи данных материалов можно научиться создавать приложения для мобильных устройств, персональных компьютеров и Firefox OS.

Общедоступность

Общедоступность (доступность, accessibility) в веб-разработке означает предоставление возможности использования веб-сайтов максимально возможному числу людей, даже если эти люди имеют некоторые физиологические ограничения. Этот раздел содержит информацию о разработке наиболее доступного веб-контента для таких людей.

Безопасность

Этот раздел уделяет внимание вопросам безопасности веб-сайтов и веб-приложений.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 24 мар. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n面向开发者的 Web 技术开放的 Web 为开发者提供了巨大的机遇，为了充分利用这些技术，你需要知道如何使用它们。在下方你可以找到这些 Web 技术文档的链接。面向 Web 开发者的文档
Web 开发者指南

Web 开发者指南提供了实用的操作方法内容，帮助你使用 Web 技术实现你的目标或需求。

面向 Web 开发者的教程

这些教程会带着你一步一步地学习 HTML、CSS、JavaScript 和 Web API。

无障碍

让更多人能够使用你的网站，即使他们的某些能力受限。

性能

让网站上的内容尽可能快地变得可用和可交互。

隐私

保护用户的个人数据。

安全

保护用户免受数据泄露和数据盗窃、侧信道攻击，以及跨站脚本、内容注入和点击劫持等攻击。

术语表

Web 相关术语的定义。

Web 技术参考
Web API

用 JavaScript 编程 API 构建 Web 应用。

HTML

用 HTML 的基本构建块创建 Web 文档和应用。

CSS

用层叠样式表描述 Web 文档和应用的外观。

JavaScript

JavaScript 是 Web 的原生编程语言。

WebAssembly

用 WebAssembly 在 Web 上运行使用 C、C++、Rust、Swift、C#、Go 等语言编写的程序。

事件

Web 应用中，可响应的内容称作事件；例如，当一个网页完成加载，或者用户选择什么、按下一个键、调整一个窗口的大小、提交一个表单或暂停一个视频。

HTTP

HTTP 是通过 Web 来获取文档、样式表、脚本、图像、视频、字体和其他资源——并将数据发送回 Web 服务器的基础互联网协议。

媒体

用于在 Web 文档和应用中嵌入和流式传输视频、音频和图像内容的格式、编解码器、协议、API 和技术。

SVG

可缩放矢量图形用于创建可平滑地缩放至任意尺寸的图像。

MathML

通过 MathML 能在 Web 上显示复杂的数学符号。

URI

统一资源标识符被各种技术使用，包括浏览器自身通过地址栏，以各种方式标识资源。

WebDriver

WebDriver 是一种浏览器自动化机制，可通过模拟真人使用浏览器的操作远程控制浏览器。被广泛应用于 Web 应用的跨浏览器测试。

Web 扩展

Web 扩展是一种在浏览器中为用户提供增强功能的方式——用于阻止广告和其他内容、定制页面的外观以及更多行为。

Web 应用清单

Web 应用清单能让用户将 Web 应用安装到其设备主屏幕上，并预先设置好屏幕方向（纵向或横向）和显示模式（如全屏）等内容。

渐进式 Web 应用（PWA）

渐进式 Web 应用能提供类似原生移动应用的用户体验。

OpenSearch

OpenSearch 允许网站描述自身的搜索引擎，以便浏览器或客户端应用程序能使用该搜索引擎。

XML

可扩展标记语言是可由文档对象模型严格序列化的一种语言。

XSLT

可扩展样式表语言转换是一种基于 XML 的语言，和专门的处理软件一起使用，用于 XML 文档转换。

XPath

XPath 使用非 XML 语法来提供一种灵活地定位（指向）XML 文档的不同部分的方法。它也可以用于检查文档中某个定位节点是否与某个模式匹配。

EXSLT

EXSLT 是一组 XSLT 的扩展。

开发者工具文档
Firefox 开发者工具

Firefox 内置的 Web 开发者工具的文档。

Chrome 开发者工具

Chrome 内置的 Web 开发者工具的文档。

Safari Web 监视器

Safari 内置的 Web 开发者工具的文档。

Edge 开发者工具

Edge 内置的 Web 开发者工具的文档。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月12日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

提供實用教學，幫助你實際使用 Web 技術來做你想做或需要做的事情。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述　Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

提供實用教學，幫助你實際使用 Web 技術來做你想做或需要做的事情。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述　Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n給開發者的 Web 技術文件全球資訊網的開放性提供了開發人員非常棒的機會。要充分發揮 Web 潛能，你需要知道如何使用它們。你可以從以下連結找到各種 Web 技術說明。Web 開發者說明文件
Web 開發者指南

提供實用教學，幫助你實際使用 Web 技術來做你想做或需要做的事情。

Web 開發者入門

帶你逐步學習 HTML、CSS、JavaScript 和 Web API。

無障礙

盡可能地使所有人皆能使用你的網站，不論他們是否具有能力障礙。

效能

使內容完全發揮可用性和互動性，並且越快越好。

隱私

保護使用者的個人資料。

安全性

保護使用者免受資料外洩和盜取、旁路攻擊，以及跨網站指令碼、內容注入和點擊劫持等攻擊。

術語表

Web 相關術語的定義。

Web 技術參考
Web API

用於開發 Web 應用程式的 JavaScript API。

HTML

HTML 提供用於構建 Web 文件和應用程式的基本結構。

CSS

階層式樣式表用於描述　Web 文件和應用程式的外觀。

JavaScript

JavaScript 是 Web 的原生程式語言。

WebAssembly

WebAssembly 能夠讓以 C、C++、Rust、Swift、C#、Go 等語言開發的程式在 Web 上執行。

事件

你的 Web 應用程式能夠對事件做出反應；例如當 Web 完成載入，或使用者選擇某些內容、按下按鍵、調整視窗大小、提交表單、暫停影片等。

HTTP

超文字傳輸協定（Hypertext Transfer Protocol）是基本的網際網路協定，用於從網路上取得檔案、樣式表、程式碼、圖片、影片、字型，以及其他資源——以及將資料傳回伺服器。

媒體

用於在 Web 檔案和應用程式中嵌入和串流視訊、音訊和圖片內容的格式、轉碼器、協定、API 和技術。

SVG

可縮放向量圖形（Scalable Vector Graphic）使你能夠建立任何大小皆能平滑縮放的圖片。

MathML

數學標記語言（Mathematical Markup Language）使 Web 得以展示複雜的數學運算式及語法。

URI

統一資源識別碼（URI）被各種技術使用，包括瀏覽器本身透過地址欄來以各種方式識別資源。

WebDriver

WebDriver 是一種透過模擬真人使用瀏覽器的操作來遠端控制瀏覽器的自動化機制。被廣泛用於 Web 應用程式的跨瀏覽器測試。

Web 擴充功能

Web 擴充功能是一種讓你在瀏覽器中為使用者提供增強功能的方式，例如阻擋廣告和其他內容、自訂頁面外觀等。

Web 應用程式資訊清單

Web 應用程式資訊清單（Web App Manifest）讓使用者能夠將 Web 應用程式安裝到他們的裝置主畫面上，並預先設定畫面方向（直向或橫向）和顯示模式（如全螢幕）等。

漸進式 Web 應用程式

漸進式 Web 應用程式（Progressive Web App）提供使用者近似原生行動應用程式的體驗。

OpenSearch

OpenSearch 允許網站為自身描述一個搜尋引擎，以便瀏覽器或其他用戶端應用程式可以使用該搜尋引擎。

XML

可擴展標記語言是一種嚴格的文件物件模型序列化格式。

XSLT

可延伸樣式表轉換語言是一種基於 XML 的語言，與專門的處理軟體結合使用，用於轉換 XML 文件。

XPath

XPath 使用非 XML 語法提供一種靈活的方式來定位（指向）XML 文件的不同部分。它還可以用於測試文件中的定位節點是否符合某個模式。

EXSLT

EXSLT 是 XSLT 的一組擴展。

開發者工具說明文件
Firefox 開發者工具

Firefox 內建的 Web 開發者工具的說明文件。

Chrome 開發者工具

Chrome 內建的 Web 開發者工具的說明文件。

Safari Web 檢閱器

Safari 內建的 Web 開發者工具的說明文件。

Edge 開發者工具

Edge 內建的 Web 開發者工具的說明文件。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年3月21日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb technology for developersThe open Web presents incredible opportunities for developers. To take full advantage of these technologies, you need to know how to use them. Below you'll find links to our Web technology documentation.Documentation for Web developers
Web developer guides

The Web Developer Guides provide practical, how-to content to help you use Web technologies for your goals or needs.

Tutorials for Web developers

Tutorials to take you step-by-step through learning HTML, CSS, JavaScript, and Web APIs.

Accessibility

Enabling as many people as possible to use websites, even when those people's abilities are limited in some way.

Performance

Making content as available and interactive as possible, as soon as possible.

Privacy

Protecting users' personal data.

Security

Protecting users from data leaks and data theft, side-channel attacks, and attacks such as cross-site scripting, content injection, and click-jacking.

Glossary

Definitions of Web-related terms.

Web technology references
Web APIs

JavaScript programming APIs you can use to build apps on the Web.

HTML

HTML provides the fundamental building blocks for structuring Web documents and apps.

CSS

Cascading Style Sheets are used to describe the appearance of Web documents and apps.

JavaScript

JavaScript is the Web's native programming language.

WebAssembly

WebAssembly allows programs written in C, C++, Rust, Swift, C#, Go, and more to run on the Web.

Events

Events are what you build Web apps to react to; for example, when a Web page finishes loading, or a user selects something, presses a key, resizes a window, submits a form, or pauses a video.

HTTP

HTTP is the fundamental Internet protocol for fetching documents, stylesheets, scripts, images, videos, fonts, and other resources over the Web — and for sending data back to Web servers.

Media

Formats, codecs, protocols, APIs, and techniques for embedding and streaming video, audio, and image content in Web documents and apps.

SVG

Scalable Vector Graphics lets you create images that scale smoothly to any size.

MathML

MathML lets you display complex mathematical notation on the Web.

URI

Uniform Resource Identifiers are used by various technologies, including the browser itself via the address bar, to identify resources in various ways.

WebDriver

WebDriver is a browser-automation mechanism for remotely controlling a browser by emulating the actions of a real person using the browser. It's widely used for cross-browser testing of Web apps.

Web Extensions

Web Extensions are a way for you to give users enhanced capabilities in their browsers — for doing things such as blocking ads and other content, customizing the appearance of pages, and more.

Web App Manifests

Web App Manifests let you enable users to install Web apps to their device home screens, with aspects such as portrait/landscape screen orientation and display mode (e.g., full screen) pre-set.

Progressive Web Apps (PWAs)

Progressive Web Apps provide a user experience similar to native mobile apps.

OpenSearch

OpenSearch allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine.

XML

The Extensible Markup Language is a strict serialization of the Document Object Model.

XSLT

Extensible Stylesheet Language Transformations is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.

XPath

XPath uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.

EXSLT

EXSLT a set of extensions to XSLT.

Developer tools documentation
Firefox Developer Tools

Documentation for the set of web-developer tools built into Firefox.

Chrome DevTools

Documentation for the set of web-developer tools built into Chrome.

Safari Web Inspector

Documentation for the set of web-developer tools built into Safari.

Edge DevTools

Documentation for the set of web-developer tools built into Edge.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEvent referenceEvents are fired to notify code of "interesting changes" that may affect code execution. These can arise from user interactions such as using a mouse or resizing a window, changes in the state of the underlying environment (e.g., low battery or media events from the operating system), and other causes.
Each event is represented by an object that is based on the Event interface, and may have additional custom fields and/or functions to provide information about what happened. The documentation for every event has a table (near the top) that includes a link to the associated event interface, and other relevant information. A full list of the different event types is given in Event > Interfaces based on Event.
This topic provides an index to the main sorts of events you might be interested in (animation, clipboard, workers etc.) along with the main classes that implement those sorts of events.Event index
  
    
      Event type
      Description
      Documentation
    
    
      Animation
      
        
          Events related to the
          Web Animation API.
        
        
          Used to respond to changes in animation status (e.g., when an animation
          starts or ends).
        
      
      
        Animation events fired on
        Document,
        Window,
        HTMLElement.
      
    
    
      Asynchronous data fetching
      Events related to the fetching data.
      
        Events fired on
        AbortSignal,
        XMLHttpRequest,
        FileReader.
      
    
    
      Clipboard
      
        
          Events related to the
          Clipboard API.
        
        Used to notify when content is cut, copied, or pasted.
      
      
        Events fired on
        Document,
        Element,
        Window.
      
    
    
      Composition
      
        
          Events related to composition; entering text "indirectly" (rather than
          using normal keyboard presses).
        
        
          For example, text entered via a speech to text engine, or using
          special key combinations that modify keyboard presses to represent new
          characters in another language.
        
      
      
        Events fired on
        Element.
      
    
    
      CSS transition
      
        
          Events related to
          CSS Transitions.
        
        
          Provides notification events when CSS transitions start, stop, are
          cancelled, etc.
        
      
      
        Events fired on
        Document,
        HTMLElement,
        Window.
      
    
    
      Database
      
        
          Events related to database operations: opening, closing, transactions,
          errors, etc.
        
      
      
        Events fired on
        IDBDatabase,
        IDBOpenDBRequest,
        IDBRequest,
        IDBTransaction.
      
    
    
      DOM mutation
      
        
          Events related to modifications to the Document Object Model (DOM)
          hierarchy and nodes.
        
      
      
        
          
            Warning:
            Mutation Events are
            deprecated.
            Mutation Observers
            should be used instead.
          
        
      
    
    
      Drag'n'drop, Wheel
      
        
          Events related to using the
          HTML Drag and Drop API
          and wheel events.
        
        
          Drag and Wheel events are derived from mouse events. While they are
          fired when using mouse wheel or drag/drop, they may also be used with
          other appropriate hardware.
        
      
      
        
          Drag events fired on
          Document
        
        
          Wheel events fired on
          Element
        
      
    
    
      Focus
      Events related to elements gaining and losing focus.
      
        Events fired on
        Element,
        Window.
      
    
    
      Form
      
        Events related to forms being constructed, reset and submitted.
      
      
        Events fired on
        HTMLFormElement.
      
    
    
      Fullscreen
      
        
          Events related to the
          Fullscreen API.
        
        
          Used to notify when the transitioning between full screen and windowed
          modes, and also of errors occurring during this transition.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Gamepad
      
        
          Events related to the
          Gamepad API.
        
      
      
        Events fired on
        Window.
      
    
    
      Gestures
      
        
          Touch events are
          recommended for implementing gestures.
        
      
      
        
          Events fired on
          Document,
          Element.
        
        In addition there are a number of non-standard gesture events:
        
          
            Non-standard WebKit specific events on
            Element:
            gesturestart event,
            gesturechange event,
            gestureend event.
          
        
      
    
    
      History
      
        
          Events related to the
          History API.
        
      
      
        Events fired on
        Window.
      
    
    
      HTML element content display management
      
        
          Events related to changing the state of a display or textual element.
        
      
      
        Events fired on
        HTMLDetailsElement,
        HTMLDialogElement,
        HTMLSlotElement.
      
    
    
      Inputs
      
        
          Events related to HTML input elements e.g.
          <input>, <select>, or
          <textarea>.
        
      
      
        Events fired on
        HTMLElement,
        HTMLInputElement.
      
    
    
      Keyboard
      
        
          Events related to using a
          keyboard.
        
        Used to notify when keys are moved up, down, or just pressed.
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Loading/unloading documents
      Events related to loading and unloading documents.
      
        
          Events fired on
          Document
          and
          Window.
        
      
    
    
      Manifests
      
        
          Events related to installation of
          progressive web app manifests.
        
      
      
        Events fired on
        Window.
      
    
    
      Media
      
        
          Events related to media usage (including the
          Media Capture and Streams API,
          Web Audio API,
          Picture-in-Picture API, etc.).
        
      
      
        Events fired on
        ScriptProcessorNode,
        HTMLMediaElement,
        AudioTrackList,
        AudioScheduledSourceNode,
        MediaRecorder,
        MediaStream,
        MediaStreamTrack,
        VideoTrackList,
        HTMLTrackElement,
        OfflineAudioContext,
        TextTrack,
        TextTrackList,
        Element/audio,
        Element/video.
      
    
    
      Messaging
      
        
          Events related to a window receiving a message from another browsing
          context.
        
      
      
        Events fired on
        Window.
      
    
    
      Mouse
      
        
          Events related to using a
          computer mouse.
        
        
          Used to notify when the mouse is clicked, double-clicked, up and down
          events, right-click, movement in and out of an element, text
          selection, etc.
        
        
          Pointer events provide a hardware-agnostic alternative to mouse
          events. Drag and Wheel events are derived from mouse events.
        
      
      
        Mouse events fired on
        Element
      
    
    
      Network/Connection
      Events related to gaining and losing network connection.
      
        
          Events fired on
          Window.
        
        
          Events fired on
          NetworkInformation
          (Network Information API).
        
      
    
    
      Payments
      
        
          Events related to the
          Payment Request API.
        
      
      
        
          Events fired on
          PaymentRequest,
          PaymentResponse.
        
      
    
    
      Performance
      
        
          Events related to any performance-related spec grouped into
          Performance APIs.
        
      
      
        
          Events fired on
          Performance.
        
      
    
    
      Pointer
      
        
          Events related to the
          Pointer Events API.
        
        
          Provides hardware-agnostic notification from pointing devices
          including Mouse, Touch, pen/stylus.
        
      
      
        Events fired on
        Document,
        HTMLElement.
      
    
    
      Print
      Events related to printing.
      
        Events fired on
        Window.
      
    
    
      Promise rejection
      
        
          Events sent to the global script context when any JavaScript promise
          is rejected.
        
      
      
        Events fired on
        Window.
      
    
    
      Sockets
      
        
          Events related to the
          WebSockets API.
        
      
      
        Events fired on
        WebSocket.
      
    
    
      SVG
      Events related to SVG images.
      
        
          Events fired on
          SVGElement,
          SVGAnimationElement,
          SVGGraphicsElement.
        
      
    
    
      Text selection
      
        
          Selection API events
          related to selecting text.
        
      
      
        
          Event (selectionchange) fired on
          HTMLTextAreaElement,
          HTMLInputElement.
        
      
    
    
      Touch
      
        
          Events related to the
          Touch Events API.
        
        
          Provides notification events from interacting with a touch sensitive
          screen (i.e., using a finger or stylus). Not related to the
          Force Touch API.
        
      
      
        Events fired on
        Document,
        Element.
      
    
    
      Virtual reality
      
        
          Events related to the
          WebXR Device API.
        
        
          
            Warning: The
            WebVR API (and
            associated
            Window events) are deprecated.
          
        
      
      
        Events fired on
        XRSystem,
        XRSession,
        XRReferenceSpace.
      
    
    
      RTC (real time communication)
      
        
          Events related to the
          WebRTC API.
        
      
      
        Events fired on
        RTCDataChannel,
        RTCDTMFSender,
        RTCIceTransport,
        RTCPeerConnection.
      
    
    
      Server-sent events
      
        
          Events related to the
          server sent events API.
        
      
      
        Events fired on
        EventSource.
      
    
    
      Speech
      
        
          Events related to the
          Web Speech API.
        
      
      
        Events fired on
        SpeechSynthesisUtterance.
      
    
    
      Workers
      
        
          Events related to the
          Web Workers API,
          Service Worker API,
          Broadcast Channel API, and
          Channel Messaging API.
        
        
          Used to respond to new messages and message sending errors. Service
          workers can also be notified of other events, including push
          notifications, users clicking on displayed notifications, that push
          subscription has been invalidated, deletion of items from the content
          index, etc.
        
      
      
        Events fired on
        ServiceWorkerGlobalScope,
        DedicatedWorkerGlobalScope,
        SharedWorkerGlobalScope,
        WorkerGlobalScope,
        Worker,
        BroadcastChannel,
        MessagePort.
      
    
  
SpecificationsSpecificationHTML # events-2Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
Tutorials
MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

Guides
Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

Reference
MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibility\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
Tutorials
MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

Guides
Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

Reference
MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMathMLBaseline 2023Newly availableSince January 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.Learn moreSee full compatibilityReport feedbackMathematical Markup Language (MathML) is an XML-based language for describing mathematical notation.
MathML was originally designed as a general-purpose specification for browsers, office suites, computer algebra systems, EPUB readers, LaTeX-based generators. However, this approach was not very adapted to the Web: the subset focusing on semantics has never been implemented in browsers while the subset focusing on math layout led to incomplete and inconsistent browser implementations.
MathML Core is a subset with increased implementation details based on rules from LaTeX and the Open Font Format. It is tailored for browsers and designed specifically to work well with other web standards including HTML, CSS, DOM, JavaScript.
Below you will find links to documentation, examples, and tools to work with MathML. MDN uses MathML Core as a reference specification but, due to an erratic standardization history, legacy MathML features may still show up in existing implementations and web content.

Note:
It is highly recommended that developers and authors switch to MathML Core, perhaps relying on other web technologies to cover missing use cases. The Math WG is maintaining a set of MathML polyfills to facilitate that transition.
Tutorials
MathML for beginners

This tutorial will guide you through creating math formulas using structured markup. It starts with an introduction to adding MathML to an HTML document, followed by a deep dive into key components: fractions and roots, scripted elements, and text containers. The tutorial then covers tabular layouts for matrices and advanced math formatting. Finally, a challenge tests your understanding by having you recreate three famous mathematical formulas using the learned concepts.

Guides
Authoring MathML

Suggestions and tips for writing MathML, including suggested MathML editors and how to integrate their output into Web content.

Fonts for MathML

How users can install such math fonts to properly display MathML in browsers.

Reference
MathML element reference

Details about each MathML element and compatibility information for desktop and mobile browsers.

MathML global attribute reference

Information about global MathML attributes applicable to all elements.

MathML attribute reference

Information about MathML attributes that modify the appearance or behavior of elements.

MathML attribute values

Further information about MathML attribute values.

ExamplesBelow you'll find some examples you can look at to help you to understand how to use MathML.MathML formulasThe following demos display increasingly complex mathematical concepts in Web content.

Proving the Pythagorean theorem

Small example showing a proof of the Pythagorean Theorem.

Deriving the quadratic formula

Outlines the derivation of the Quadratic Formula.

Mozilla MathML test

Original test from the Mozilla MathML project. It contains examples from the TeXbook with image references generated by TeX.

MathML browser test

A similar test with concrete formulas taken from Wikipedia.

Other Web technologiesThe following demos mix MathML with other Web technologies to produce advanced content.

<la-tex> custom element

A custom element that accepts LaTeX content.

Magnetic field demo

A 3D representation of a magnetic field, using SVG and WebGL.

Συνάρτηση ζήτα Ρήμαν (el)

A greek article about the Riemann zeta function, with Web fonts from the Greek Font Society.

Pell's equation

A JavaScript program to solve Pell's equation using BigInt.

Lovelace's program for Bernoulli numbers

An emulator for Ada Lovelace's program to calculate Bernoulli numbers, using Private properties.

Getting help from the community
W3C Math Home
Raise issues on GitHub w3c/mathml repository
www-math w3.org mail archive
Tools
W3C Validator
W3C's wiki page
Related topics
CSS
HTML
SVG
SpecificationsSpecificationMathematical Markup Language (MathML) Version 4.0 Browser compatibilityHelp improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 4, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.Guides
Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThese articles describe the HTML elements used for including media:

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.Guides
Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThese articles describe the HTML elements used for including media:

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMedia technologies on the webOver the years, the web's ability to present, create, and manage audio, video, and other media has matured.
There are now a large number of APIs, as well as HTML elements, DOM interfaces, and other features that make it possible to work with media in exciting and immersive ways.
This article lists guides and references for various features you may use when incorporating media into your projects.Guides
Audio and Video Delivery

We can deliver audio and video on the web in a number of ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and Video manipulation

Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video.

Autoplay guide for media and Web Audio APIs

Unexpected automatic playback of media or audio can be an unwelcome surprise to users. While autoplay serves a purpose, it should be used carefully. To give users control over this, many browsers now provide forms of autoplay blocking. This article is a guide to autoplay, with tips on when and how to use it and how to work with browsers to handle autoplay blocking gracefully.

DASH Adaptive Streaming for HTML 5 Video

Dynamic Adaptive Streaming over HTTP (DASH) is an adaptive streaming protocol. This means that it allows for a video stream to switch between bit rates on the basis of network performance, in order to keep a video playing.

Streaming audio and video

A guide which covers how to stream audio and video, as well as techniques and technologies you can take advantage of to ensure the best possible quality and/or performance of your streams.

Media types and formats on the web

A guide to the file types and codecs available for images, audio, and video media on the web. This includes recommendations for what formats to use for what kinds of content, best practices including how to provide fallbacks and how to prioritize media types, and also includes general browser support information for each media container and codec.

Using images in HTML

A guide to adding images to websites that are responsive, accessible, and performant.

ReferencesHTMLThese articles describe the HTML elements used for including media:

<audio>

The <audio> element is used to play audio. These can be used invisibly as a destination for more complex media, or with visible controls for user-controlled playback of audio files. Accessible from JavaScript as HTMLAudioElement objects.

<video>

The <video> element is used to play video content. It can be used to present video files, or as a destination for streamed video content. <video> can also be used as a way to link media APIs with other HTML and DOM technologies, including <canvas> (for frame grabbing and manipulation), for example. It is accessible from JavaScript as HTMLVideoElement objects.

<track>

The HTML <track> element can be placed within an <audio> or <video> element to provide a reference to a WebVTT format subtitle or caption track to be used when playing the media. Accessible from JavaScript as HTMLTrackElement objects.

<source>

The HTML <source> element is used within an <audio> or <video> element to specify source media to present. Multiple sources can be used to provide the media in different formats, sizes, or resolutions. Accessible from JavaScript as HTMLSourceElement objects.

APIs
Media Capabilities API

The Media Capabilities API lets you determine the encoding and decoding capabilities of the device your app or site is running on. This lets you make real-time decisions about what formats to use and when.

Media Capture and Streams API

A reference for the API which makes it possible to stream, record, and manipulate media both locally and across a network. This includes using local cameras and microphones to capture video, audio, and still images.

Media Session API

The Media Session API provides a way to customize media notifications. It does this by providing metadata for display by the user agent for the media your web app is playing. It also provides action handlers that the browser can use to access platform media keys such as hardware keys found on keyboards, headsets, remote controls, and software keys found in notification areas and on lock screens of mobile devices.

MediaStream Recording API

The MediaStream Recording API lets you capture media streams to process or filter the data or record it to disk.

Web Audio API

The Web Audio API lets you generate, filter, and manipulate sound data both in real-time and on pre-recorded material, then send that audio to a destination such as an <audio> element, a media stream, or to disk.

WebRTC

WebRTC (Web Real-Time Communication) makes it possible to stream live audio and video, as well as transfer arbitrary data, between two peers over the Internet, without requiring an intermediary.

Related topicsRelated topics which may be of interest, since they can be used in tandem with media APIs in interesting ways.

Accessible multimedia

In this guide, we cover ways web designers and developers can create content that is accessible to people with different capabilities. This ranges from using the alt attribute on <img> elements to captions to tagging media for screen readers.

Canvas API

The Canvas API lets you draw into an <canvas>, manipulating and changing the contents of an image. This can be used with media in many ways, including by setting a <canvas> element as the destination for video playback or camera capture so that you can capture and manipulate video frames.

WebGL

WebGL provides an OpenGL ES compatible API on top of the existing Canvas API, making it possible to do powerful 3D graphics on the Web. Through a canvas, this can be used to add 3D imagery to media content.

WebXR

WebXR, which has replaced the now-obsolete WebVR API, is a technology that provides support for creating virtual reality (VR) and augmented reality (AR) content. The mixed reality content can then be displayed on the device's screen or using goggles or a headset.

WebVR 
Deprecated


The Web Virtual Reality API supports virtual reality (VR) devices such as the Oculus Rift or the HTC Vive, making it possible for developers to translate position and movement of the user into movement within a 3D scene which is then presented on the device. WebVR has been replaced by WebXR, and is due to be removed from browsers soon.

Web Audio spatialization basics

In 3D environments, which may either be 3D scenes rendered to the screen or a mixed reality experience experienced using a headset, it's important for audio to be performed so that it sounds like it's coming from the direction of its source. This guide covers how to accomplish this.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nPrivacy on the webPeople use websites for several important tasks such as banking, shopping, entertainment, and paying their taxes. In doing so, they are required to share personal information with those sites. Users place a certain level of trust in the sites they share their data with. If that information fell into the wrong hands, it could be used to exploit users, for example by profiling them, targeting them with unwanted ads, or even stealing their identity or money.
Modern browsers already have a wealth of features to protect users' privacy on the web, but that's not enough. To create a trustworthy and privacy-respecting experience, developers need to educate their site users in good practices (and enforce them). Developers should also create sites that collect as little data from users as possible, use the data responsibly, and transport and store it securely.
In this article, we:

Define privacy and important related terms.
Examine browser features that automatically protect user privacy.
Look at what developers can do to create privacy-respecting web content that minimizes the risk of users' personal information/data being obtained unexpectedly by third parties.
Defining privacy terms and conceptsBefore we look at the various privacy and security features available to use on the web, let's define some important terms.Privacy and its relationship with securityIt is hard to talk about privacy without also talking about security — they are closely related, and you can't really create privacy-respecting websites without good security. Therefore, we shall define both.


Privacy refers to the act of giving users the right to control how their data is collected, stored, and used, and not using it irresponsibly. For example, you should clearly communicate to your users what data you are collecting, who it will be shared with, and how it will be used. Users must be given a chance to consent to your terms of data usage, have access to all of their data that you are storing, and delete it if they no longer wish you to have it. You must also comply with your own terms: nothing erodes user trust like having their data used and shared in ways they never consented to. And this isn't just ethically wrong; it could be against the law. Many parts of the world now have legislation that protects consumer privacy rights (for example the EU's GDPR).


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data, and user and partner (external) data. It is no use having a robust privacy policy that makes your users trust you if your security is weak and malicious parties can steal their data anyway.

Personal and private informationPersonal information is any information that describes a user. Examples include:

Postal address, email address, phone number, or other contact information
Passport number, bank account, credit card, social security number, or other official identifiers
Physical attributes such as height, gender expression, weight, hair color, or age
Health information such as medical history, allergies, or ongoing conditions
Usernames, when they can be linked to an individual
Hobbies, interests, or other personal preferences
Biometric data such as fingerprints or facial recognition data

Private information is any information that users do not want shared publicly and must be kept private (i.e., information that is accessible only by a certain group of authorized users). Some private data is private by law (for example medical data), and some is private more by personal preference.Personally identifiable informationFollowing on from the above section, personally identifiable information (PII) is information that can be used, in whole or in part, to track down and/or identify a specific person. For example, if a site leaks a list of users' names and zip codes online, a bad actor could almost certainly use this information to find their full addresses. Even if a full-scale leak does not happen, it is still possible to identify users through less obvious means, such as the browsers they are using, the devices they are using, specific fonts they have installed, and so on.TrackingTracking refers to the process of recording a user's activity across many different websites. This can be done in various ways, for example:

Looking at multiple third-party cookies set across different sites where third-party content is embedded to find out various information points about the user.
Looking at the Referer header to see where a user has navigated from.
Including parameters on the URLs of inbound links (for example in embedded ads linking to product pages, or marketing emails) that can reveal to the linked site where the link originated from, what marketing campaign it is part of, the email address or other identifier of the user that clicked on it, etc. This process is referred to as link decorating, and results in link URLs that look like this: https://example.com/article/?id=62yhgt1a&campaign=902.
Redirect tracking, which involves trackers momentarily (and imperceptibly) redirecting a user to their website to use first-party storage to track that user across websites. This allows trackers to get around third-party cookies being blocked. For example, if you have read a product review and want to click through to buy it, you might unwittingly navigate to the redirect tracker first, then to the retailer. This means the tracker is loaded as a first party, and can associate tracking data with the identifiers they have stored in their first-party cookies before forwarding you to the retailer.

Tracking data can be used to build a profile of a user and their interests and preferences, which is usually bad and can be annoying to various degrees. For example:

Targeted ads: Everyone has had the unnerving experience of researching some items to buy on one device and then suddenly being bombarded by adverts for the same products on all their other devices.
Selling or sharing data: Some third parties have been known to compile tracking data and then sell it to/share it with others to use for various purposes, like targeted ads. This is obviously highly unethical and may also be illegal, depending on where in the world it happens.
Prejudice via data: In the worst cases, sharing data could result in the user being unfairly disadvantaged. For example, imagine an insurance company finding out data points about a potential customer that they didn't consent to share, and using them as a justification for increasing insurance premiums.
FingerprintingA process very closely related to tracking is fingerprinting: this specifically refers to identifying users by building up a store of data points about them that differentiate them from other users. This could be anything from cookie contents to what browser they are using and what fonts they have installed locally.
Modern browsers take steps to help prevent fingerprinting-based attacks by either not allowing information to be accessed or, where the information must be made available, by introducing variations or "noise" that prevent it from being used for identification purposes.
For example, if a website queries a user's browser for the elapsed time, a comparison of that time to the time reported by the server might be useful as a factor in fingerprinting. Because of this, browsers typically introduce a small amount of variability to timers to make them less useful for identifying the user's system.

Note:
See Fingerprinting on web.dev for additional useful information.
Privacy features provided by browsersBrowser vendors are aware of the need to protect user privacy and the negative effects of tracking, fingerprinting, etc., on user experience. To this end, they have implemented various features that enhance privacy protection and/or mitigate threats. In this section, we look at different categories of privacy protection that browsers apply automatically.HTTPS by defaultTransport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously, for example for tracking.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics are as follows:

Certificate Transparency

An open standard for monitoring and auditing certificates, creating a database of public logs that can be used to help identify incorrect or malicious certificates.

HTTP Strict Transport Security (HSTS)

HSTS is used by servers to let them protect themselves from protocol downgrade and cookie hijack attacks by letting sites tell clients that they can only use HTTPS to communicate with the server.

HTTP/2

While HTTP/2 technically does not have to use encryption, most browser developers support it only when used with HTTPS; so in that regard, it can be thought of as a feature to enhance security/privacy.

Opt-in for "powerful features"So-called "powerful" web API features that provide access to potentially sensitive data and operations are available only in secure contexts, which basically means HTTPS-only. Not only that, but these web features are gated behind a system of user permissions. Users have to explicitly opt in to features like allowing notifications, accessing geolocation data, making the browser go into fullscreen mode, accessing media streams from webcams, using web payments, etc.Anti-tracking technologyBrowsers have implemented several anti-tracking features that automatically enhance their users' privacy protection. Many of these block or limit the ability of third-party sites embedded in <iframe>s to access cookies set on the top-level domain, run tracking scripts, etc.

The Set-Cookie header SameSite attribute's default value has been updated to Lax, to provide better protection against tracking and CSRF attacks. See Controlling third-party cookies with SameSite for more information.
Browsers have all started to block third-party cookies by default. See How do browsers handle third-party cookies? for more details.
Browsers are implementing technologies to allow third-party cookies only in certain circumstances that do not damage privacy, or to implement common use cases that currently require third-party cookies in alternative ways. See Transitioning from third-party cookies and Replacing third-party cookies.
Several browsers strip out known tracking parameters from URLs — this includes Firefox, Safari, and Brave. Browser extensions also help to do this, for example ClearURLs.
Browsers have implemented redirect tracking protection.
Privacy considerations for client-side developersThere are several actions web developers can and should take to improve privacy for their users. The below sections discuss the most important ones. Some of the categories are not purely technical tasks as such and will involve collaboration with other team members.Collect data ethicallyCompanies collect lots of different data from their users for a variety of different reasons:

Usernames, passwords, emails, etc. for authentication purposes.
Emails, postal addresses, and phone numbers for communication.
Age, gender, geographical location, favorite pastimes, and a host of other PII for anything from site personalization to customer satisfaction surveys.
Browsing habits on their sites and other sites, to measure page and feature success metrics.
And so much more.

When collecting data from your customers, you have an opportunity to behave with integrity, show them that you are trustworthy, and build a great relationship with them, in turn, improving your brand and your chance of success.
The ethics of data collection can be broken down into three simple principles:

Don't collect more data than you need
Communicate clearly how you are going to use the data you collect
Delete the data once you have finished with it


Note:
The tips provided below make for a better, more privacy-aware user experience, but many of them are required by law to comply with regulations, for example the GDPR in the EU. You should make sure to find out what regulations apply to you in your locale, and what you need to do to comply with them.
Don't collect more data than you needIt is tempting to ask for a lot of data from your users because you think it might be useful in the future. However, every bit of extra data you collect adds risk to your users' privacy and increases the chance that they will abandon the step they are performing (whether it is filling out a survey or signing up for a service).
It is good to anonymize data. You should also consider whether you can get what you need by making your data request less granular. As an example, instead of asking a user their favorite products, you could ask them to select between more general categories.
The best way to protect user privacy though, is to minimize the data you collect. Referring to the previous example, you could infer the same data by looking at user purchase history. As another example, users appreciate being able to buy products anonymously. You shouldn't force them to sign up for an account; if it's not necessary for the service to operate, it should be their choice.Communicate clearly how you are going to use the data you collectOnce you have decided what data you are going to collect, you should publish a privacy policy on your site that clearly states:

Data that you collect
Ways in which you use the data
Parties with whom you tend to share the data, if at all, and a declaration that you will ask for user consent before sharing
The duration for which you keep the data before it is deleted
Ways in which users can view the data you have collected from them and delete it if they want to

When providing you with data, your users should be given an opportunity to read your privacy policy, and consent to it. They should be able to control if they are happy with this and agree to your terms. And as indicated above, they should also get to see what data of theirs you have collected, and delete it if they want to.
When you've published your privacy policy, you need to make sure that you comply with it — doing what you say you are going to do is very important in building user trust. You should only collect the data you say you'll collect, and only use it for the purpose you say you'll use it for. If someone from your company comes up with a clever new way to use existing data, that still isn't OK under the terms of your policy if it doesn't specify that you'll use it for that purpose. If users consented to the use of their data for a specific purpose and that purpose expands, you may have to consider obtaining new consent.Delete the data once you have finished with itEarlier on, we mentioned giving users a way to see what data of theirs you have collected, and delete it if they want to. You could possibly do this as part of the same experience they can use to delete their account (their data goes with it), or make them two separate options. Either way, the options should be easy to find.
Allowing the user to choose when significant portions of data get deleted is very empowering, and builds trust, but there may be some bits of data that you will want to handle deletion of yourself. For example, some data might only be used for a few hours or minutes and then deleted, like data that is used during the administration of a user's session while they are logged in.

Note:
The Clear-Site-Data HTTP response header is very useful for clearing short-lived user data — it instructs the browser to clear out its cache and/or cookies and/or storage (e.g., Web Storage or IndexedDB data). For example, you might get your server to send it along with a "logged out confirmation" page so that once the user is logged out, their data is safely removed.
Cut down on trackingEarlier on we discussed tracking, and some of the unethical purposes it is used for. We shouldn't have to spell out how such uses can erode user trust; wherever possible, you should only use potential tracking mechanisms like third-party cookies for ethical uses, such as transferring sign-in or other personalization status across sites.
Also recall from earlier that browsers are all starting to block third-party cookies by default, while implementing alternative technologies to achieve common use case. It is a good idea to prepare for this, by limiting the amount of tracking activities you rely on, and/or implementing desired information persistence in other ways. See Transitioning from third-party cookies for more information.Carefully manage third-party resourcesOf course, it would be easy to manage privacy if you were only worried about resources you have created (code, cookies, sites, etc.). The real challenge comes from the fact that your site will likely use third-party resources. This can include third-party content embedded in <iframe>s, libraries, frameworks, APIs, externally-hosted resources such as images and videos, etc.
Third-party resources are an essential part of modern web development, they provide a lot of power. However, any third-party resource you allow onto your site potentially has the same permissions as your own resources; it all depends on how it is included on your site:

JavaScript running inside third-party content embedded in your site via an <iframe> is separated by same-origin policy, meaning that it wouldn't have access to other scripts and data included in the top-level browsing context.
However, a third-party script included directly in your page via a <script> element would have access to your other scripts and data, whether it was hosted on your site or another site. It would effectively be first-party code. A malicious script included in this way could secretly steal your users' data, for example sending it off to a third-party server.

It is important to audit all of the third-party resources you use on your site. Make sure you know what data they collect, what requests they make and to whom, and what their privacy policies are. Your carefully designed privacy policy is useless if you use a third-party script that violates it.

Note:
There are various tools out there that can help you build up a picture of what requests a site is making, for example the Request Map Generator.

Once you have audited your third-party resources and understand what they are doing, you should then consider their negatives as a trade-off for the value they bring. If a third-party script is free and really useful but collects quite a lot of user data, you could:

Accept that trade-off, update your privacy policy to include details of it, and hope that it doesn't impact your users' trust too much.
Look for an alternative, less data-hungry third-party tool.
Build your own tool.

The following list provides some tips on how to mitigate privacy risks inherent with using third-party resources:


When embedding third-party resources, consider if there is a way to achieve the same or a similar effect with less privacy impact. For example, it might be fun to have a social media post viewer embedded on your site, but is it really necessary? Wouldn't a link to your social media page be sufficient? Also, some third-party services have privacy-enhancing options. See, for example, YouTube's Embed videos & playlists > Turn on privacy-enhanced mode.


Where possible, you should block third parties from receiving a Referer header when you make requests to them. This can be done in a pretty granular way, for example by including rel="noreferrer" on external links. Or, you could set this more globally for the page or site, for example by using the Referrer-Policy header.

Note:
See also Referer header: privacy and security concerns.



Use the Permissions-Policy HTTP header to control access to API "powerful features" (such as notifications, geolocation data, accessing media streams from webcams, etc.). This can be useful for privacy because it stops third-party sites from doing unexpected things with these features, and users don't want to be unnecessarily bombarded by permission prompts that they may not understand. You can also control usage of "powerful features" inside third-party sites embedded inside <iframe> elements by specifying permissions policies inside an allow attribute on the <iframe> itself.

Note:
See also our Permissions-Policy guide for more information and examples, and permissionspolicy.com for useful tools including a policy generator.



Use the <iframe> sandbox attribute to allow or disallow usage of certain features inside the content embedded in the <iframe> — this includes things like downloads, form submissions, modals, and scripting.



Note:
See Third parties over on web.dev for additional useful information on auditing and more.
Protect user dataYou need to make sure that user data is transmitted and stored securely once you've collected it. This is more of a security topic, but it is worth mentioning here — a good privacy policy is useless if your security is lax and attackers can steal the data from you.
The below tips offer some guidance on protecting your user's data:

Security is hard to get right. When implementing a secure solution that involves data collection — particularly if it is sensitive data such as sign-in credentials — it makes sense to use a reputable solution from a well-respected provider. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose — for example an identity provider solution, or a secure online survey provider.
If you want to roll out your own solution for collecting user data, make sure you understand what you are doing. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multifactor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
When collecting user sign-up information, enforce strong passwords so your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. Encourage your users to use a password manager to generate and store complex passwords; this way they won't worry about remembering them, or create a security risk by writing them down.
Don't include sensitive data in URLs — if a third party intercepts the URL (for example via the Referer header), they could steal that information. Use POST requests rather than GET requests to avoid this.
Consider using tools like Content Security Policy and Permissions Policy to enforce a set of feature usage on your site that makes it harder to introduce vulnerabilities. Be careful when doing this — if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality. This is something you can look into when auditing your third-party resources (see Carefully manage third-party resources).
See also
Web security
Learn Privacy on web.dev
The Privacy Sandbox on privacysandbox.google.com
Lean Data Practices on mozilla.org
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nProgressive web appsA progressive web app (PWA) is an app that's built using web platform technologies, but that provides a user experience like that of a platform-specific app.
Like a website, a PWA can run on multiple platforms and devices from a single codebase. Like a platform-specific app, it can be installed on the device, can operate while offline and in the background, and can integrate with the device and with other installed apps.GuidesThese guides give conceptual explanations of different aspects of PWAs. They're intended to help you understand what kinds of things are possible with PWAs, and to provide enough pointers to help you understand how to achieve them.

What is a progressive web app?

An introduction to PWAs, comparing them with traditional websites and with platform-specific apps, and outlining their main features.

Making PWAs installable

One of the defining aspects of a PWA is that it can be installed on the device, and then appears to users as a platform-specific app, a permanent feature of their device which they can launch directly from the operating system like any other app. In this guide we'll explore what "installable" means, what a PWA needs to provide for it to be installable, and how you can customize the install experience.

Installing and uninstalling web apps

This guide covers how users can install and uninstall PWAs on their devices.

Offline and background operation

In this guide, we'll introduce a set of technologies that enable a PWA to provide a good user experience even when the device has intermittent network connectivity and to perform operations in the background, even when the main app is not running.

Caching

An overview of the APIs that enable a PWA to cache resources locally, and some common strategies used by PWAs to implement offline functionality.

Best practices for PWAs

PWAs should adapt to different browsers and devices, be accessible, have good performance, and integrate well with the operating system. This guide provides a list of best practices to help you make sure your PWA is as good as it can be.

How toThese guides give concrete detailed instructions for how to implement specific PWA features.

Create a standalone app

Describes how to specify that a PWA should be launched in its own dedicated window when it is launched, rather than a browser tab.

Define your app icons

Describes how to define your own set of icons to be used when the PWA is installed on a device.

Customize your app's colors

Describes how to set background and theme colors for a PWA.

Display badges

Describes how to display a badge on the PWA's icon: for example to let the user know that they have received new messages.

Expose common app actions as shortcuts

Describes how to expose common actions for a PWA that can be launched from the operating system's app shortcut menu.

Share data between apps

Describes how PWAs can share data with each other by using the operating system's app sharing mechanism.

Trigger installation from your PWA

Describes how developers can provide their own UI to invite users to install their PWA.

Associate files with your PWA

Describes how you can create an association between file types and your PWA, so that when the user clicks on the file, your PWA is launched to handle it.

TutorialsIn these tutorials, you'll build a PWA from scratch. Tutorials walk through the steps of creating an app, from start to finish, explaining how the different features of the app are implemented.

Creating your first PWA

This novice-level tutorial walks through the creation of a PWA to track menstrual cycles. Lessons include a walk through of the HTML, CSS, and JavaScript required to create a fully functional web app, setting up a testing environment, and complete explanations guiding the learner through upgrading the web app into a PWA; including developing and inspecting a manifest, adding a service worker, and using the service worker to delete stale caches.

Deep dive into PWA

This intermediate-level tutorial walks through the creation of a PWA that lists information about games submitted to the A-Frame category in the js13kGames 2017 competition. This tutorial includes all the basics for creating a PWA, with additional features, including notifications, push, and app performance.

ReferenceReference documentation for the web technologies you will use to build a PWA.Web app manifest
Web app manifest members

Developers can use web app manifest members to describe a PWA, customize its appearance, and more deeply integrate it into the operating system.

Service Worker APIsCommunication with the app
The following APIs can be used by a service worker to communicate with its associated client PWA:

Client.postMessage()

Allows a service worker to send a message to its client PWA.

Broadcast Channel API

Allows a service worker and its client PWA to establish a basic two-way communication channel.


Offline operation
The following APIs can be used by a service worker to make your app work offline:

Cache

A persistent storage mechanism for HTTP responses used to store assets that can be reused when the app is offline.

Clients

An interface used to provide access to the documents that are controlled by the service worker.

FetchEvent

An event, dispatched in the service worker with every HTTP request made by the client PWA. The event can be used to either send the request to the server as normal and save the response for future use, or intercept the request and immediately respond with a response cached previously.


Background operation
The following APIs can be used by a service worker to perform tasks in the background, even when your app is not running:

Background Synchronization API

A way to defer tasks to run in a service worker once there is a stable network connection.

Web Periodic Background Synchronization API

A way to register tasks to be run in a service worker at periodic intervals with network connectivity.

Background Fetch API

A method for a service worker to manage downloads that may take a significant amount of time, such as video or audio files.

Other web APIs
IndexedDB

A client-side storage API for significant amounts of structured data, including files.

Badging API

A method of setting a badge on the application icon, providing a low-distraction notification.

Notifications API

A way to send notifications that are displayed at the operating system level.

Web Share API

A mechanism for sharing text, links, files, and other content to other apps selected by the user on their device.

Window Controls Overlay API

An API for PWAs installed on desktop operating systems that enables hiding the default window title bar, enabling displaying the app over the full surface area of the app window.

See also
Progressive web apps on web.dev
Learn PWA on web.dev
Progressive web apps on learn.microsoft.com (2023)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.Tutorials
Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

Guides
Applying SVG effects to HTML content
Content type
Linking
Namespaces crash course
Scripting
SVG animation with SMIL
SVG as an image
SVG filters
SVG in HTML introduction
Reference
SVG element reference

Details about each SVG element.

SVG attribute reference

Details about each SVG attribute.

SVG DOM interface reference

Details about the SVG DOM API, for interaction with JavaScript.

Applying SVG effects to HTML content

SVG works together with HTML, CSS and JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.Tutorials
Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

Guides
Applying SVG effects to HTML content
Content type
Linking
Namespaces crash course
Scripting
SVG animation with SMIL
SVG as an image
SVG filters
SVG in HTML introduction
Reference
SVG element reference

Details about each SVG element.

SVG attribute reference

Details about each SVG attribute.

SVG DOM interface reference

Details about the SVG DOM API, for interaction with JavaScript.

Applying SVG effects to HTML content

SVG works together with HTML, CSS and JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSVG: Scalable Vector GraphicsScalable Vector Graphics (SVG) is an XML-based markup language for describing two-dimensional based vector graphics.
As such, it's a text-based, open Web standard for describing images that can be rendered cleanly at any size and are designed specifically to work well with other web standards including CSS, DOM, JavaScript, and SMIL. SVG is, essentially, to graphics what HTML is to text.
SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor or with drawing software.
Compared to classic bitmapped image formats such as JPEG or PNG, SVG-format vector images can be rendered at any size without loss of quality and can be easily localized by updating the text within them, without the need of a graphical editor to do so. With proper libraries, SVG files can even be localized on-the-fly.
SVG has been developed by the World Wide Web Consortium (W3C) since 1999.Tutorials
Introducing SVG from scratch

This tutorial aims to explain the internals of SVG and is packed with technical details. If you just want to draw beautiful images, you might find more useful resources at Inkscape's documentation page. Another good introduction to SVG is provided by the W3C's SVG Primer. Also check out this advent calendar-themed SVG Tutorial that walks you through coding 25 festive SVGs.

Guides
Applying SVG effects to HTML content
Content type
Linking
Namespaces crash course
Scripting
SVG animation with SMIL
SVG as an image
SVG filters
SVG in HTML introduction
Reference
SVG element reference

Details about each SVG element.

SVG attribute reference

Details about each SVG attribute.

SVG DOM interface reference

Details about the SVG DOM API, for interaction with JavaScript.

Applying SVG effects to HTML content

SVG works together with HTML, CSS and JavaScript.

Resources
SVG test suite
Markup validator
SVG authoring guidelines
SVG tutorial
D3 data visualization library
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 18, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nSecurity on the webWebsites contain several different types of information. Some of it is non-sensitive, for example the copy shown on the public pages. Some of it is sensitive, for example customer usernames, passwords, and banking information, or internal algorithms and private product information.
Sensitive information needs to be protected, and that is the focus of web security. If that information fell into the wrong hands, it could be used to:

Put companies at a competitive disadvantage by sharing their information with competitors.
Disable or hijack their services, again causing serious problems with their operation.
Put their customer's privacy at risk, making them vulnerable to profiling, targeting, loss of data, identity theft, or even financial loss.

Modern browsers already have several features to protect users' security on the web, but developers also need to use best practices and code carefully to ensure that their websites are secure. Even simple bugs in your code can result in vulnerabilities that bad actors can exploit to steal data and gain unauthorized control over services.
This article provides an introduction to web security, including conceptual information to help you understand website vulnerabilities and practical guides on how to secure them.Relationship between security and privacySecurity and privacy are distinct yet closely related topics. It is worth knowing the differences between the two and how they relate.


Security is the act of keeping private data and systems protected against unauthorized access. This includes both company (internal) data and user and partner (external) data.


Privacy refers to the act of giving users control over how their data is collected, stored, and used, while also ensuring that it is not used irresponsibly. For example, you should let your users know what data you are collecting from them, the parties with whom it will be shared, and how it will be used. Users must be given a chance to consent to your privacy policy, have access to their data you store, and delete it if they choose to.


Good security is essential for good privacy. You could follow all the advice listed in our Privacy on the web guide, but acting with integrity and having a robust privacy policy are futile if your site is not secure and attackers can just steal data anyway.Security features provided by browsersWeb browsers follow a strict security model that enforces strong security for content, connections between the browser and the server, and data transportation. This section looks at the features that underpin this model.Same-origin policy and CORSSame-origin policy is a fundamental security mechanism of the web that restricts how a document or a script loaded from one origin can interact with a resource from another origin. It helps isolate potentially malicious documents, reducing possible attack vectors.
In general, documents from one origin cannot make requests to other origins. This makes sense because you don't want sites to be able to interfere with one another and access unauthorized data.
However, you might want to relax this restriction in some circumstances; for example, if you have multiple websites that interact with each other, you may allow them to request resources from one another using fetch(). This can be permitted using Cross-Origin Resource Sharing (CORS), an HTTP-header-based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.HTTP model for communicationThe HTTP protocol is used by web browsers and servers to communicate with one another, request resources, provide responses (for example, providing a requested resource or detailing why a request failed), and provide security features for that communication.
Transport Layer Security (TLS) provides security and privacy by encrypting data during transport over the network and is the technology behind the HTTPS protocol. TLS is good for privacy because it stops third parties from being able to intercept transmitted data and use it maliciously.
All browsers are moving towards requiring HTTPS by default; this is practically the case already because you can't do much on the web without this protocol.
Related topics:

Transport layer security (TLS)

The TLS protocol is the standard for enabling two networked applications or devices to exchange information privately and robustly. Applications that use TLS can choose their security parameters, which can have a substantial impact on the security and reliability of data.

HTTP Strict-Transport-Security

The Strict-Transport-Security HTTP header lets a website specify that it may only be accessed using HTTPS.

Certificate Transparency

Certificate Transparency (CT) is an open framework designed to protect against and monitor for certificate misissuance. Newly issued certificates are 'logged' to publicly run, often independent CT logs. These provide append-only, cryptographically assured records of issued TLS certificates.

Mixed content

An HTTPS page that includes content fetched using cleartext HTTP is called a mixed content page. Pages like this are only partially encrypted, leaving the unencrypted content accessible to sniffers and man-in-the-middle attackers.

Weak signature algorithms

The strength of the hash algorithm used in signing a digital certificate is a critical element of the security of the certificate. Some signature algorithms are known to be weak, and should be avoided when appropriate.

Secure contexts and feature permissionsBrowsers control the usage of "powerful features" in different ways. These "powerful features" include generating system notifications on a website, using a user's webcam to get access to a media stream, manipulating the system GPU, and using web payments. If a site could just use the APIs that control such features without restriction, malicious developers could attempt to do the following:

Annoy users with unneeded notifications and other UI features.
Turn their webcam on without warning to spy on them.
Clog up their browser/system to create Denial of Service (DoS) attacks.
Steal data or money.

These "powerful features" are controlled in the following ways:


Usage of such features is permitted only in secure contexts. A secure context is a window or a worker for which there is reasonable confidence that the content has been delivered securely (via HTTPS/TLS). In a secure context, the potential for communication with contexts that are not secure is limited. Secure contexts also help to prevent man-in-the-middle attackers from accessing powerful features.
To see a list of web platform features available only in secure contexts, see Features restricted to secure contexts.


The usage of these features is gated behind a system of user permissions: users have to explicitly opt-in to providing access to such features, meaning that they can't be used automatically. User permission requests happen automatically, and you can query the state of an API permission by using the Permissions API.


Several other browser features can be used only in response to a user action such as clicking a button, meaning that they need to be invoked from inside an appropriate event handler. This is called transient activation. See Features gated by user activation for more information.

High-level security considerationsThere are many aspects of web security that need to be thought about on the server- and client-side. This section focuses mainly on client-side security considerations. You can find a useful summary of security from a server-side perspective, which also includes descriptions of common attacks to watch out for, at Website security (part of our Server-side website programming learning module).Store client-side data responsiblyHandling data responsibly is largely concerned with cutting down on third-party cookie usage and being careful about the data you store and share with them. Traditionally, web developers have used cookies to store all kinds of data, and it has been easy for attackers to exploit this tendency. As a result, browsers have started to limit what you can do with cross-site cookies, with the aim of removing access to them altogether in the future.
You should prepare for the removal of cross-site cookies by limiting the amount of tracking activities you rely on and/or by implementing the persistence of the desired information in other ways. See Transitioning from third-party cookies and Replacing third-party cookies for more information.Protect user identity and manage loginsWhen implementing a secure solution that involves data collection, particularly if the data is sensitive such as log-in credentials, it makes sense to use a reputable solution. For example, any respectable server-side framework will have built-in features to protect against common vulnerabilities. You could also consider using a specialized product for your purpose, for example an identity provider solution or a secure online survey provider.
If you want to roll your own solution for collecting user data, make sure you understand all aspects and requirements. Hire an experienced server-side developer and/or security engineer to implement the system, and ensure it is tested thoroughly. Use multi-factor authentication (MFA) to provide better protection. Consider using a dedicated API such as Web Authentication or Federated Credential Management to streamline the client-side of the app.
Here are some other tips for providing secure logins:


When collecting user login information, enforce strong passwords so that your user's account details cannot be easily guessed. Weak passwords are one of the main causes of security breaches. In addition, encourage your users to use a password manager so that they can use more complex passwords, don't need to worry about remembering them, and won't create a security risk by writing them down. See also our article on Insecure passwords.


You should also educate your users about phishing. Phishing is the act of sending a message to a user (for example, an email or an SMS) containing a link to a site that looks like a site they use every day but isn't. The link is accompanied by a message designed to trick users into entering their username and password on the site so it can be stolen and then used by an attacker for malicious purposes.

Note:
Some phishing sites can be very sophisticated and hard to distinguish from a real website. You should therefore educate your users to not trust random links in emails and SMS messages. If they receive a message along the lines of "Urgent, you need to log in now to resolve an issue", they should go to the site directly in a new tab and try logging in directly rather than clicking the link in the message. Or they could phone or email you to discuss the message they received.



Protect against brute force attacks on login pages with rate limiting, account lockouts after a certain number of unsuccessful attempts, and CAPTCHA challenges.


Manage user login sessions with unique session IDs, and automatically log out users after periods of inactivity.

Don't include sensitive data in URL query stringsAs a general rule, you shouldn't include sensitive data in URL query strings because if a third party intercepts the URL (for example, via the Referer HTTP header), they could steal that information. Even more serious is the fact that these URLs can be indexed by public web crawlers, HTTP proxies, and archiving tools such as the internet archive, meaning that your sensitive data could persist on publicly accessible resources.
Use POST requests rather than GET requests to avoid these issues. Our article Referer header policy: Privacy and security concerns describes in more detail the privacy and security risks associated with the Referer header, and offers advice on mitigating those risks.

Note:
Steering away from transmitting sensitive data in URLs via GET requests can also help protect against cross-site request forgery and replay attacks.
Enforce usage policiesConsider using web platform features like Content Security Policy (CSP) and Permissions Policy to enforce a set of feature and resource usage rules on your website that make it harder to introduce vulnerabilities.
CSP allows you to add a layer of security by, for example, allowing images or scripts to be loaded only from specific trusted origins. This helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks involve a range of malicious activities, including data theft, site defacement, and distribution of malware.
Permissions policy works in a similar way, except that it is more concerned with allowing or blocking access to specific "powerful features" (as mentioned earlier).

Note:
Such policies are very useful to help keep sites secure, especially when you are using a lot of third-party code on your site. However, keep in mind that if you block usage of a feature that a third-party script relies on to work, you may end up breaking your site's functionality.
Maintain data integrityFollowing on from the previous section, when you allow feature and resource usage on your site, you should try to ensure that resources have not been tampered with.
Related topics:

Subresource integrity

Subresource Integrity (SRI) is a security feature that enables browsers to verify that resources they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched resource must match.

HTTP Access-Control-Allow-Origin

The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.

HTTP X-Content-Type-Options

The X-Content-Type-Options response header is a marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and must be followed. This header is a way to opt out of MIME type sniffing, or, in other words, to specify that the MIME types are deliberately configured.

Sanitize form inputAs a general rule, don't trust anything that users enter into forms. Filling out forms online is complicated and tedious, and it is easy for users to enter incorrect data or data in the wrong format. In addition, malicious folks are skilled in the art of entering specific strings of executable code into form fields (for example, SQL or JavaScript). If you're not careful about handling such inputs, they could either execute harmful code on your site or delete your databases. See SQL injection for a good example of how this could happen.
To protect against this, you should thoroughly sanitize data entered into your forms:

You should implement client-side validation to inform users when they have entered data in the wrong format. You can do this using built-in HTML form validation features, or you can write your own validation code. See Client-side form validation for more information.
You should use output encoding when displaying user input in an application UI to safely display data exactly as a user typed it in and avoid it being executed as code. See Output encoding for more information.

You can't rely on client-side validation alone for security — it should be combined with server-side validation. Client-side validation enhances the user experience by providing instant validation feedback without having to wait for a round trip to the server. However, client-side validation is easy for a malicious party to bypass (for example, by turning off JavaScript in the browser to bypass JavaScript-based validation).
Any reputable server-side framework will provide functionality for validating form submissions. In addition, a common best practice is to escape any special characters that form part of executable syntax, thereby making any entered code no longer executable and treated as plain text.Protect against clickjackingIn a clickjacking attack, a user is fooled into clicking a UI element that performs an action different from what the user expects, often resulting in the user's confidential information being passed to a malicious third party. This risk is inherent in embedded third-party content, so make sure you trust what is being embedded into your site. Additionally, be aware that clickjacking can be combined with phishing techniques. You can read about phishing in the previous section Protect user identity and manage logins.
The following features can help guard against clickjacking:

HTTP X-Frame-Options

The X-Frame-Options HTTP response header can be used to indicate whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>. Sites can use this to avoid clickjacking attacks, by ensuring that their content is not embedded into other sites.

CSP: frame-ancestors

The HTTP Content-Security-Policy (CSP) frame-ancestors directive specifies valid parents that may embed a page using <frame>, <iframe>, <object>, or <embed>.

Practical security implementation guidesTo get comprehensive instructions for implementing security features effectively on websites and to ensure you're following best practices, see our set of Practical security implementation guides.
Some of these guides are directly related to the HTTP Observatory tool. Observatory performs security audits on a website and provides a grade and score along with recommendations for fixing the security issues it finds. These guides explain how to resolve issues surfaced by the MDN Observatory tests: the tool links to the relevant guide for each issue, helping guide you towards an effective resolution. Interestingly, Mozilla's internal developer teams use this guidance when implementing websites to ensure that security best practices are applied.See also
Privacy on the web
Learn: Website security
Mozilla Security Blog
OWASP Cheat Sheet series
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a physical resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.URLs and URNsURLsAny of the following URLs can be typed into your browser's address bar to tell it to load the associated document (resource):
urlhttps://developer.mozilla.org
https://developer.mozilla.org/en-US/docs/Learn_web_development/
https://developer.mozilla.org/en-US/search?q=URL

A URL is composed of different parts, some mandatory and others optional. A more complex example might look like this:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
URNsA Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.
urlurn:isbn:9780141036144
urn:ietf:rfc:7230

The two URNs correspond to

the book Nineteen Eighty-Four by George Orwell,
the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.
Syntax of Uniform Resource Identifiers (URIs)We will break down the following URL into its components:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
Scheme
http:// is the scheme of the URL, indicating which protocol the browser must use. Usually it is the HTTP protocol or its secured version, HTTPS. The Web requires one of these two, but browsers also know how to handle other protocols such as mailto: (to open a mail client) or ftp: to handle a file transfer, so don't be surprised if you see such protocols. The schemes reference provides a list of the most common schemes, and documentation for some of them.
When using URLs in HTML content, you should generally only use a few of these URL schemes. When referring to subresources — that is, files that are being loaded as part of a larger document — you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.
FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.AuthorityThe URI authority is comprised of user info (optional and usually unspecified), the host name, and the port.

www.example.com is the host name of the URI, indicating which Web server is being requested. Here, we use a domain name. It is also possible to directly use an IP address, but because it is less convenient, it is rare to do so, unless the server doesn't have a registered domain name.

:80 is the port of the URL, indicating the technical "gate" used to access the resources on the web server. It is usually omitted if the web server uses the standard ports of the HTTP protocol (80 for HTTP and 443 for HTTPS) to grant access to its resources. Otherwise, it is mandatory.Path
/path/to/myfile.html is the path of the URL, indicating the location of the resource on the web server. In the early days of the Web, this was an actual directory path to a physical location on the web server. Nowadays, web servers usually abstract this to an arbitrary location.Query
?key1=value1&key2=value2 is the query of the URL, which are extra parameters provided to the web server. The parameters are a list of key/value pairs prefixed by the ? symbol, and separated with the & symbol. These can be used to provide additional context about the resource being requested. Each resource location can have its own rules regarding parameters, and the only reliable way to know how specific parameters are handled is by asking the owner of the server, such as reading its documentation.Fragment
#SomewhereInTheDocument is the fragment of the URL, which is an anchor to another part of the resource itself. An anchor represents a sort of "bookmark" inside the resource, giving the browser the directions to show the content located at that "bookmarked" spot. On an HTML document, for example, the browser will scroll to the point where the anchor is defined; on a video or audio document, the browser will try to go to the time the anchor represents. It is worth noting that the part after the #, also known as the fragment identifier, is never sent to the server with the request.
There's a special text fragment feature that allows you to link to a specific part of a web page identified by its text content.Examplesurlhttps://developer.mozilla.org/en-US/docs/Learn
tel:+1-816-555-1212
git@github.com:mdn/browser-compat-data.git
ftp://example.org/resource.txt
urn:isbn:9780141036144
mailto:help@supercyberhelpdesk.info
SpecificationsSpecificationUnknown specification See also
What is a URL?\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a physical resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.URLs and URNsURLsAny of the following URLs can be typed into your browser's address bar to tell it to load the associated document (resource):
urlhttps://developer.mozilla.org
https://developer.mozilla.org/en-US/docs/Learn_web_development/
https://developer.mozilla.org/en-US/search?q=URL

A URL is composed of different parts, some mandatory and others optional. A more complex example might look like this:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
URNsA Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.
urlurn:isbn:9780141036144
urn:ietf:rfc:7230

The two URNs correspond to

the book Nineteen Eighty-Four by George Orwell,
the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.
Syntax of Uniform Resource Identifiers (URIs)We will break down the following URL into its components:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
Scheme
http:// is the scheme of the URL, indicating which protocol the browser must use. Usually it is the HTTP protocol or its secured version, HTTPS. The Web requires one of these two, but browsers also know how to handle other protocols such as mailto: (to open a mail client) or ftp: to handle a file transfer, so don't be surprised if you see such protocols. The schemes reference provides a list of the most common schemes, and documentation for some of them.
When using URLs in HTML content, you should generally only use a few of these URL schemes. When referring to subresources — that is, files that are being loaded as part of a larger document — you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.
FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.AuthorityThe URI authority is comprised of user info (optional and usually unspecified), the host name, and the port.

www.example.com is the host name of the URI, indicating which Web server is being requested. Here, we use a domain name. It is also possible to directly use an IP address, but because it is less convenient, it is rare to do so, unless the server doesn't have a registered domain name.

:80 is the port of the URL, indicating the technical "gate" used to access the resources on the web server. It is usually omitted if the web server uses the standard ports of the HTTP protocol (80 for HTTP and 443 for HTTPS) to grant access to its resources. Otherwise, it is mandatory.Path
/path/to/myfile.html is the path of the URL, indicating the location of the resource on the web server. In the early days of the Web, this was an actual directory path to a physical location on the web server. Nowadays, web servers usually abstract this to an arbitrary location.Query
?key1=value1&key2=value2 is the query of the URL, which are extra parameters provided to the web server. The parameters are a list of key/value pairs prefixed by the ? symbol, and separated with the & symbol. These can be used to provide additional context about the resource being requested. Each resource location can have its own rules regarding parameters, and the only reliable way to know how specific parameters are handled is by asking the owner of the server, such as reading its documentation.Fragment
#SomewhereInTheDocument is the fragment of the URL, which is an anchor to another part of the resource itself. An anchor represents a sort of "bookmark" inside the resource, giving the browser the directions to show the content located at that "bookmarked" spot. On an HTML document, for example, the browser will scroll to the point where the anchor is defined; on a video or audio document, the browser will try to go to the time the anchor represents. It is worth noting that the part after the #, also known as the fragment identifier, is never sent to the server with the request.
There's a special text fragment feature that allows you to link to a specific part of a web page identified by its text content.Examplesurlhttps://developer.mozilla.org/en-US/docs/Learn
tel:+1-816-555-1212
git@github.com:mdn/browser-compat-data.git
ftp://example.org/resource.txt
urn:isbn:9780141036144
mailto:help@supercyberhelpdesk.info
SpecificationsSpecificationUnknown specification See also
What is a URL?
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nURIsUniform Resource Identifiers (URI) are used to identify "resources" on the web.
URIs are commonly used as targets of HTTP requests, in which case the URI represents a location for a physical resource, such as a document, a photo, binary data.
The most common type of URI is a Uniform Resource Locator (URL), which is known as the web address.
URIs can be used to trigger behaviors other than fetching a resource, including opening an email client, sending text messages, or executing JavaScript, when used in other places such as the href of an HTML <a> link.URLs and URNsURLsAny of the following URLs can be typed into your browser's address bar to tell it to load the associated document (resource):
urlhttps://developer.mozilla.org
https://developer.mozilla.org/en-US/docs/Learn_web_development/
https://developer.mozilla.org/en-US/search?q=URL

A URL is composed of different parts, some mandatory and others optional. A more complex example might look like this:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
URNsA Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.
urlurn:isbn:9780141036144
urn:ietf:rfc:7230

The two URNs correspond to

the book Nineteen Eighty-Four by George Orwell,
the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.
Syntax of Uniform Resource Identifiers (URIs)We will break down the following URL into its components:
urlhttp://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
Scheme
http:// is the scheme of the URL, indicating which protocol the browser must use. Usually it is the HTTP protocol or its secured version, HTTPS. The Web requires one of these two, but browsers also know how to handle other protocols such as mailto: (to open a mail client) or ftp: to handle a file transfer, so don't be surprised if you see such protocols. The schemes reference provides a list of the most common schemes, and documentation for some of them.
When using URLs in HTML content, you should generally only use a few of these URL schemes. When referring to subresources — that is, files that are being loaded as part of a larger document — you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.
FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.AuthorityThe URI authority is comprised of user info (optional and usually unspecified), the host name, and the port.

www.example.com is the host name of the URI, indicating which Web server is being requested. Here, we use a domain name. It is also possible to directly use an IP address, but because it is less convenient, it is rare to do so, unless the server doesn't have a registered domain name.

:80 is the port of the URL, indicating the technical "gate" used to access the resources on the web server. It is usually omitted if the web server uses the standard ports of the HTTP protocol (80 for HTTP and 443 for HTTPS) to grant access to its resources. Otherwise, it is mandatory.Path
/path/to/myfile.html is the path of the URL, indicating the location of the resource on the web server. In the early days of the Web, this was an actual directory path to a physical location on the web server. Nowadays, web servers usually abstract this to an arbitrary location.Query
?key1=value1&key2=value2 is the query of the URL, which are extra parameters provided to the web server. The parameters are a list of key/value pairs prefixed by the ? symbol, and separated with the & symbol. These can be used to provide additional context about the resource being requested. Each resource location can have its own rules regarding parameters, and the only reliable way to know how specific parameters are handled is by asking the owner of the server, such as reading its documentation.Fragment
#SomewhereInTheDocument is the fragment of the URL, which is an anchor to another part of the resource itself. An anchor represents a sort of "bookmark" inside the resource, giving the browser the directions to show the content located at that "bookmarked" spot. On an HTML document, for example, the browser will scroll to the point where the anchor is defined; on a video or audio document, the browser will try to go to the time the anchor represents. It is worth noting that the part after the #, also known as the fragment identifier, is never sent to the server with the request.
There's a special text fragment feature that allows you to link to a specific part of a web page identified by its text content.Examplesurlhttps://developer.mozilla.org/en-US/docs/Learn
tel:+1-816-555-1212
git@github.com:mdn/browser-compat-data.git
ftp://example.org/resource.txt
urn:isbn:9780141036144
mailto:help@supercyberhelpdesk.info
SpecificationsSpecificationUnknown specification See also
What is a URL?
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guides
Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guides
Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb performanceWeb performance is the objective measurements and the perceived user experience of load time and runtime.
Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions.
Performance concerns questions like: Is scrolling smooth? Are buttons responsive? Do pop-ups load quickly and animate fluidly?
The objective measurements include time to load, frames per second, and time to become interactive, and subjective experience means how long it feels like it takes for content to load.
The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.
There are tools, APIs, and best practices that help us measure and improve web performance. We cover them in the following pages.Web performance guides
Performance fundamentals

Performance means efficiency. In the context of Open Web Apps, this document explains in general what performance is, how the browser platform helps improve it, and what tools and processes you can use to test and improve it.

Populating the page: how browsers work

Users want web experiences with content that is fast to load and smooth to interact with. Therefore, a developer should strive to achieve these two goals.
To understand how to improve performance and perceived performance, it helps to understand how the browser works.

Understanding latency

Latency is the time it takes for a packet of data to travel from source to a destination. In terms of performance optimization, it's important to optimize to reduce causes of latency and to test site performance emulating high latency to optimize for users with slow or unreliable connections.

Recommended Web Performance Timings: How long is too long?

There are no clear set rules as to what constitutes a slow pace when loading pages, but there are specific guidelines for indicating content will load (1 second), idling (50ms), animating (16.7ms) and responding to user input (50 to 200ms).

Using dns-prefetch

DNS-prefetch is an attempt to resolve domain names before resources get requested. This could be a file loaded later or link target a user tries to follow.

Navigation and resource timings

Navigation timings are metrics measuring a browser's document navigation events. Resource timings are detailed network timing measurements regarding the loading of an application's resources. Both provide the same read-only properties, but navigation timing measures the main document's timings whereas the resource timing provides the times for all the assets or resources called in by that main document and the resources' requested resources.

Optimizing startup performance

Improving your startup performance is often one of the highest value performance optimizations that can be made.
Good user experience includes ensuring your app loads quickly. This article provides performance tips and suggestions for both writing new applications and porting applications to the web from other platforms.

Critical rendering path

The Critical Rendering Path is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen. Optimizing the critical render path improves render performance.
The critical rendering path includes the Document Object Model (DOM), CSS Object Model (CSSOM), render tree and layout.

Lazy loading

Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times.

Speculative loading

Speculative loading refers to the practice of performing navigation actions (such as DNS fetching, fetching resources, or rendering documents) before the associated pages are actually visited, based on predictions as to what pages the user is most likely to visit next.

Performance budgets

A performance budget is a limit to prevent regressions. It can apply to a file, a file type, all files loaded on a page, a specific metric (e.g., Time to Interactive), a custom metric (e.g., Time to Hero Element), or a threshold over a period of time.

Performance Monitoring: RUM vs. synthetic monitoring

Synthetic monitoring and real user monitoring (RUM) are two approaches for monitoring and providing insight into web performance. RUM and synthetic monitoring provide for different views of performance and have benefits, good use cases and shortfalls. RUM is generally best suited for understanding long-term trends whereas synthetic monitoring is very well suited to regression testing and mitigating shorter-term performance issues during development. In this article we define and compare these two performance monitoring approaches.

CSS and JavaScript animation performance

Animations are critical for a pleasurable user experience on many applications. There are many ways to implement web animations, such as CSS transitions/animations or JavaScript-based animations (using requestAnimationFrame()). In this article, we analyze the performance differences between CSS-based and JavaScript-based animation.

Animation performance and frame rate

Animation on the web can be done via SVG, JavaScript, including <canvas> and WebGL, CSS animation, <video>, animated GIFs and even animated PNGs and other image types.
The performance cost of animating a CSS property can vary from one property to another, and animating expensive CSS properties can result in Jank as the browser struggles to hit a smooth frame rate.

Tutorials for beginnersThe MDN Web Performance Learning Area contains modern, up-to-date tutorials covering Performance essentials. Start here if you are a newcomer to performance:

Web performance: brief overview

Overview of the web performance learning path. Start your journey here.

What is web performance?

This article starts the module off with a good look at what performance actually is — this includes the tools, metrics, APIs, networks, and groups of people we need to consider when thinking about performance, and how we can make performance part of our web development workflow.

How do users perceive performance?

More important than how fast your website is in milliseconds, is how fast your users perceive your site to be. These perceptions are impacted by actual page load time, idling, responsiveness to user interaction, and the smoothness of scrolling and other animations. In this article, we discuss the various loading metrics, animation, and responsiveness metrics, along with best practices to improve user perception, if not the actual timings.

Web performance basics

In addition to the front end components of HTML, CSS, JavaScript, and media files, there are features that can make applications slower and features that can make applications subjectively and objectively faster. There are many APIs, developer tools, best practices, and bad practices relating to web performance. Here we'll introduce many of these features ad the basic level and provide links to deeper dives to improve performance for each topic.

HTML performance features

Some attributes and the source order of your markup can impact the performance of your website. By minimizing the number of DOM nodes, making sure the best order and attributes are used for including content such as styles, scripts, media, and third-party scripts, you can drastically improve the user experience. This article looks in detail at how HTML can be used to ensure maximum performance.

Multimedia: images and video

The lowest hanging fruit of web performance is often media optimization. Serving different media files based on each user agent's capability, size, and pixel density is possible. Additional tips like removing audio tracks from background videos can improve performance even further. In this article we discuss the impact video, audio, and image content has on performance, and the methods to ensure that impact is as minimal as possible.

CSS performance features

CSS may be a less important optimization focus for improved performance, but there are some CSS features that impact performance more than others. In this article we look at some CSS properties that impact performance and suggested ways of handling styles to ensure performance is not negatively impacted.

JavaScript performance best practices

JavaScript, when used properly, can allow for interactive and immersive web experiences — or it can significantly harm download time, render time, in-app performance, battery life, and user experience. This article outlines some JavaScript best practices that should be considered to ensure even complex content is as performant as possible.

Performance APIsThe Performance API is a group of standards used to measure the performance of web applications.
The following pages provide overviews of the Performance APIs including information on how to use them:

High precision timing

The Performance API allows high precision measurements that are based on time in potential sub-millisecond resolution and a stable monotonic clock that is not subject to system clock skew or adjustments.
The high resolution timers are needed for accurate benchmarking instead of the less precise and non-monotonic Date timestamps.

Long animation frame timing

Long animation frames (LoAFs) can impact the user experience of a website.
They can cause slow user interface (UI) updates, resulting in seemingly unresponsive controls and janky (or non-smooth) animated effects and scrolling, leading to user frustration.
The Long Animation Frames API allows developers to get information about the long animation frames and better understand their root causes. This article shows how to use the Long Animation Frames API.

Monitoring bfcache blocking reasons

The PerformanceNavigationTiming.notRestoredReasons property reports information on why the current document was blocked from using the bfcache on navigation.
Developers can use this information to identify pages that need updates to make them bfcache-compatible, thereby improving site performance.

Navigation timing

Navigation Timing provides metrics associated with navigating from one page to another via the PerformanceNavigationTiming API.
For example, you can determine how much time it takes to load or unload a document, or log the time it took until DOM construction has finished and interaction with the DOM is possible.

Performance data

The Performance API doesn't provide performance data analysis, or visualizations.
However, the Performance API is integrated well with developer tools and its data is often sent to analytics end points and libraries to record performance metrics which help you to evaluate the data to find performance bottlenecks affecting your users.
This page provides an overview about what sorts of Performance API data exists, how it is collected, and how it can be accessed.

Resource Timing API

Resource Timing enables retrieving and analyzing detailed network timing data for the loading of an application's resources.
An application can use the timing metrics to determine, for example, the length of time it takes to load a specific resource (such as an image or a script) either implicitly as part of page load or explicitly from JavaScript, for example using the fetch() API.

Server timing

Server-Timing allows servers to communicate metrics about the request-response cycle to the user agent.
You can collect this information and act on server-side metrics in the same way as all the other metrics processed with the Performance API.

User Timing API

Create application specific timestamps using the user timing API's "mark" and "measure" entry types using high-precision timestamps that are part of the browser's performance timeline.

Related APIsThe following APIs are also useful for measuring and influencing page performance:

Page Visibility API

Provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.

Background Tasks API

The Cooperative Scheduling of Background Tasks API (also referred to as the Background Tasks API or the requestIdleCallback() API) provides the ability to queue tasks to be executed automatically by the user agent when it determines that there is free time to do so.

Beacon API

The Beacon interface schedules an asynchronous and non-blocking request to a web server.

Intersection Observer API

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's Viewport.
This enabled use cases such as Timing element visibility to get asynchronously notified when elements of interest become visible.

Media Capabilities API

Exposes decoding and encoding abilities of a client device, such as whether media is supported and whether playback should be smooth and power efficient, with real time feedback about playback to better enable adaptive streaming, and access to display property information.

Network Information API

Information about the system's connection in terms of general connection type (e.g., 'wifi, 'cellular', etc.).
This can be used to select high definition content or low definition content based on the user's connection.

Battery Status API

The Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change.
This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.

Navigator.deviceMemory

The deviceMemory read-only property of the Navigator interface returns the approximate amount of device memory in gigabytes.

FetchEvent.preloadResponse

The preloadResponse read-only property of the FetchEvent interface returns a Promise that resolves to the navigation preload Response if navigation preload was triggered, or undefined otherwise.

Profiling and tooling
Firefox Profiler Performance Features

This website provides information on how to use and understand the performance features in your developer tools, including Call Tree, Flame Graph, Stack Chart, Marker Chart and Network Chart.

Profiling with the built-in profiler

Learn how to profile app performance with Firefox's built-in profiler.

ReferencesHTML
<picture> element
<video> element
<source> element
<img> attributes (like srcset) for responsive images
rel="preload" attribute for preloading content via HTML
CSS
will-change
JavaScript
DOMContentLoaded
Garbage collection
requestAnimationFrame
HTTP
Content-encoding
Resource hints via dns-prefetch, preconnect, prefetch, and prerender
HTTP/2
Client Hints
See also
Responsive images HTML guide
Web Workers API, including Using Service Workers and Using Web Workers
Offline and background operation
Caching
Client hints
Glossary terms:

Beacon
Brotli compression
Content Delivery Networks (CDN)
Cumulative Layout Shifts (CLS)
Code splitting
CSSOM
Domain sharding
Effective connection type
First contentful paint (FCP)
First CPU idle
First paint
gzip_compression
HTTP/2
HTTP
Interaction to next paint (INP)
Jank
Largest Contentful Paint (LCP)
Latency
Lazy load
Long task
Lossless compression
Lossy compression
Main thread
Minification
Network throttling
Packet
Page load time
Page prediction
Parse
Perceived performance
Prefetch
Prerender
QUIC
RAIL
Real User Monitoring (RUM)
Resource Timing
Round Trip Time (RTT)
Server Timing
Speculative parsing
Speed index (and Perceptual Speed Index)
SSL
Synthetic monitoring
TCP handshake
TCP slow start
Transmission Control Protocol (TCP)
Time to first byte (TTFB)
Time to interactive (TTI)
TLS
Tree shaking
Web performance


Performance in Firefox Developer Tools
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWebDriverWebDriver is a remote control interface that enables introspection and control of user agents. It provides a platform- and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
To have the ability to write instruction sets that can be run interchangeably in many browsers on different platforms is critical to deliver a consistent experience to users. With the new wave of developments on the web platform, the increase diversity in devices and demands for real interoperability between the technologies, WebDriver provides tooling for cross-browser testing.
Provided is a set of interfaces to discover and manipulate DOM elements in web documents and to control the behavior of a user agent. It is primarily intended to allow web authors to write tests that automate a user agent from a separate controlling process, but may also be used in such a way as to allow in-browser scripts to control a — possibly separate — browser.UsageSo what does WebDriver let you do and what does it look like? Since WebDriver is programming language neutral, the answer to this question depends on which WebDriver client you're using and the choice of language.
But using a popular client written in Python, your interaction with WebDriver might look like this:
pythonfrom selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support.expected_conditions import presence_of_element_located

with webdriver.Firefox() as driver:

    driver.get("https://google.com/ncr")
    wait = WebDriverWait(driver, 10)
    driver.find_element(By.NAME, "q").send_keys("cheese" + Keys.RETURN)
    wait.until(presence_of_element_located((By.XPATH, '//*[@id="rcnt"]')))
    results = driver.find_elements(By.XPATH, "//a[@href]")

    for i, elem in enumerate(results):
        print(f'#{i} {elem.text} ({elem.get_attribute("href")})')

This might produce output akin to this:
#1 Cheese - Wikipedia (https://en.wikipedia.org/wiki/Cheese)
Reference
Timeouts
CommandsClose WindowGet Element AttributeGet Element PropertyGet Element Tag NameGet TimeoutsGet Window HandlesGet Window RectNew WindowSet TimeoutsSet Window RectCapabilitiesacceptInsecureCertsfirefoxOptionswebSocketUrlErrorsInsecure certificateInvalid argumentInvalid cookie domainInvalid selectorInvalid session IDJavaScript errorScript timeoutStale element referenceUnknown commandUnknown errorUnknown methodSpecifications
WebDriver
See also
Testing
Selenium documentation
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 28, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXML: Extensible Markup LanguageThe Extensible Markup Language is a strict serialization of the Document Object Model.
EXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:XML GuidesThis page lists guides for XML.XPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.XSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb developer guidesThere are many guides on MDN Web Docs that teach you how to use features or APIs through practical examples.
This page is a curated list of some of the most popular goal-oriented learning material.HTML
Structuring the web with HTML

The HTML learning area offers tutorials to help you learn HTML from the ground up.

HTML basics

This article will give you a basic understanding of HTML. After following this guide, you can further explore the material in the HTML Learning Area.

CSS
Learn to style HTML using CSS

Our complete CSS tutorial, taking you from first steps through styling text, creating layouts, and more.

CSS Layout Guides

There are a large number of guides to CSS Layout across MDN, this page collects them all together.

Using CSS animations

CSS animations make it possible to animate transitions from one CSS style configuration to another. This guide will help you get started with the animation properties.

JavaScript
JavaScript learning area

Whether you are a complete beginner, or hoping to refresh your skills, this is the place to start.

Media
Audio and video delivery

We can deliver audio and video on the web in several ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and video manipulation

The beauty of the web is that you can combine technologies to create new forms. Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video. This article provides a reference to explain what you need to do.

APIs
Using FormData objects

The FormData object lets you compile a set of key/value pairs to send using fetch(). It's primarily intended for sending form data, but can be used independently of forms to transmit keyed data. The transmission is in the same format that the form's submit() method would use to send the data if the form's encoding type were set to "multipart/form-data".

Progressive web apps

Progressive web apps (PWAs) use modern web APIs along with traditional progressive enhancement strategy to create cross-platform web applications. These apps work everywhere and provide several features that give them the same user experience advantages as native apps. This set of guides tells you all you need to know about PWAs.

Parsing and serializing XML

The web platform provides different methods of parsing and serializing XML, each with its pros and cons.

Performance
Optimization and performance

When building modern web apps and sites, it's important to make your content work quickly and efficiently. This lets it perform effectively for both powerful desktop systems and weaker handheld devices.

Mobile web development
Learn: Responsive design

This article provides an overview of some main techniques needed to design websites that work well on mobile devices.

Fonts
Variable fonts guide

Find out how to use variable fonts in your designs.

The Web Open Font Format (WOFF)

WOFF (Web Open Font Format) is a font file format that is free for anyone to use on the web.

User interface development
User input methods and controls

User input goes beyond just a mouse and keyboard: think of touchscreens for example. This article provides recommendations for managing user input and implementing controls in open web apps, along with FAQs, real-world examples, and links to further information for anyone needing more detailed information on the underlying technologies.\n\nWeb developer guidesThere are many guides on MDN Web Docs that teach you how to use features or APIs through practical examples.
This page is a curated list of some of the most popular goal-oriented learning material.HTML
Structuring the web with HTML

The HTML learning area offers tutorials to help you learn HTML from the ground up.

HTML basics

This article will give you a basic understanding of HTML. After following this guide, you can further explore the material in the HTML Learning Area.

CSS
Learn to style HTML using CSS

Our complete CSS tutorial, taking you from first steps through styling text, creating layouts, and more.

CSS Layout Guides

There are a large number of guides to CSS Layout across MDN, this page collects them all together.

Using CSS animations

CSS animations make it possible to animate transitions from one CSS style configuration to another. This guide will help you get started with the animation properties.

JavaScript
JavaScript learning area

Whether you are a complete beginner, or hoping to refresh your skills, this is the place to start.

Media
Audio and video delivery

We can deliver audio and video on the web in several ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and video manipulation

The beauty of the web is that you can combine technologies to create new forms. Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video. This article provides a reference to explain what you need to do.

APIs
Using FormData objects

The FormData object lets you compile a set of key/value pairs to send using fetch(). It's primarily intended for sending form data, but can be used independently of forms to transmit keyed data. The transmission is in the same format that the form's submit() method would use to send the data if the form's encoding type were set to "multipart/form-data".

Progressive web apps

Progressive web apps (PWAs) use modern web APIs along with traditional progressive enhancement strategy to create cross-platform web applications. These apps work everywhere and provide several features that give them the same user experience advantages as native apps. This set of guides tells you all you need to know about PWAs.

Parsing and serializing XML

The web platform provides different methods of parsing and serializing XML, each with its pros and cons.

Performance
Optimization and performance

When building modern web apps and sites, it's important to make your content work quickly and efficiently. This lets it perform effectively for both powerful desktop systems and weaker handheld devices.

Mobile web development
Learn: Responsive design

This article provides an overview of some main techniques needed to design websites that work well on mobile devices.

Fonts
Variable fonts guide

Find out how to use variable fonts in your designs.

The Web Open Font Format (WOFF)

WOFF (Web Open Font Format) is a font file format that is free for anyone to use on the web.

User interface development
User input methods and controls

User input goes beyond just a mouse and keyboard: think of touchscreens for example. This article provides recommendations for managing user input and implementing controls in open web apps, along with FAQs, real-world examples, and links to further information for anyone needing more detailed information on the underlying technologies.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 25, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb developer guidesThere are many guides on MDN Web Docs that teach you how to use features or APIs through practical examples.
This page is a curated list of some of the most popular goal-oriented learning material.HTML
Structuring the web with HTML

The HTML learning area offers tutorials to help you learn HTML from the ground up.

HTML basics

This article will give you a basic understanding of HTML. After following this guide, you can further explore the material in the HTML Learning Area.

CSS
Learn to style HTML using CSS

Our complete CSS tutorial, taking you from first steps through styling text, creating layouts, and more.

CSS Layout Guides

There are a large number of guides to CSS Layout across MDN, this page collects them all together.

Using CSS animations

CSS animations make it possible to animate transitions from one CSS style configuration to another. This guide will help you get started with the animation properties.

JavaScript
JavaScript learning area

Whether you are a complete beginner, or hoping to refresh your skills, this is the place to start.

Media
Audio and video delivery

We can deliver audio and video on the web in several ways, ranging from 'static' media files to adaptive live streams. This article is intended as a starting point for exploring the various delivery mechanisms of web-based media and compatibility with popular browsers.

Audio and video manipulation

The beauty of the web is that you can combine technologies to create new forms. Having native audio and video in the browser means we can use these data streams with technologies such as <canvas>, WebGL or Web Audio API to modify audio and video directly, for example adding reverb/compression effects to audio, or grayscale/sepia filters to video. This article provides a reference to explain what you need to do.

APIs
Using FormData objects

The FormData object lets you compile a set of key/value pairs to send using fetch(). It's primarily intended for sending form data, but can be used independently of forms to transmit keyed data. The transmission is in the same format that the form's submit() method would use to send the data if the form's encoding type were set to "multipart/form-data".

Progressive web apps

Progressive web apps (PWAs) use modern web APIs along with traditional progressive enhancement strategy to create cross-platform web applications. These apps work everywhere and provide several features that give them the same user experience advantages as native apps. This set of guides tells you all you need to know about PWAs.

Parsing and serializing XML

The web platform provides different methods of parsing and serializing XML, each with its pros and cons.

Performance
Optimization and performance

When building modern web apps and sites, it's important to make your content work quickly and efficiently. This lets it perform effectively for both powerful desktop systems and weaker handheld devices.

Mobile web development
Learn: Responsive design

This article provides an overview of some main techniques needed to design websites that work well on mobile devices.

Fonts
Variable fonts guide

Find out how to use variable fonts in your designs.

The Web Open Font Format (WOFF)

WOFF (Web Open Font Format) is a font file format that is free for anyone to use on the web.

User interface development
User input methods and controls

User input goes beyond just a mouse and keyboard: think of touchscreens for example. This article provides recommendations for managing user input and implementing controls in open web apps, along with FAQs, real-world examples, and links to further information for anyone needing more detailed information on the underlying technologies.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 25, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb development tutorialsThe links on this page lead to a variety of tutorials and learning materials.
Whether you are a beginner, intermediate, or expert at web development, you will find something helpful here.
These tutorials are created by forward-thinking companies and web developers who have embraced open standards and good practices, and allow or provide translations through an open content license such as Creative Commons.For complete beginners
Getting started with the Web

Getting started with the Web is a concise series introducing you to the practicalities of web development.
You'll set up the tools you need to construct a basic webpage and publish your own code.

HTML tutorialsIntroduction to HTML
Structuring content with HTML

Our introductory HTML learning module teaches HTML from the ground up — no previous knowledge required.
It sets the stage, getting you used to important concepts and syntax, looking at applying HTML to text, how to create hyperlinks, and how to use HTML to structure a webpage.

HTML for Beginners

An HTML guide for beginners that includes explanations of common tags, including HTML tags.
Also includes a step-by-step guide to creating a basic web page with code examples.

HTML Challenges

Use these challenges to hone your HTML skills (for example, "Should I use an <h2> element or a <strong> element?"), focusing on meaningful markup.

Advanced HTML topics
Web forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, such as registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side parts of forms.

Tips for authoring fast-loading HTML pages

Optimize web pages to provide a more responsive site for visitors and reduce the load on your web server and Internet connection.

CSS tutorialsIntroduction to CSS
CSS basics

CSS (Cascading Style Sheets) is the code you use to style your webpage. CSS Basics takes you through what you need to get started. We'll answer questions like: How do I make my text black or red? How do I make my content show up in such-and-such a place on the screen? How do I decorate my webpage with background images and colors?

CSS Styling basics

CSS (Cascading Style Sheets) is used to style and lay out web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides a gentle beginning to your path toward CSS mastery with the basics of how it works, what the syntax looks like, and how you can start using it to add styling to HTML.

Selectors

Target HTML elements, including based on element state, with CSS.

Specificity

Understanding the browser algorithm to determine which CSS declarations get applied to an element when there are competing declarations, with a specificity quiz.

Handling conflicts

The cascade, specificity, and inheritance control how CSS is applied to HTML and how conflicts between style declarations are resolved.

CSS text Styling

Here we look at text styling fundamentals, including setting font, boldness, and italics, line and letter spacing, and drop shadows and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

Solve common CSS problems

Common questions and answers for beginners.

Intermediate CSS topics
CSS layout

At this point we've already looked at CSS fundamentals, how to style text, and how to style and manipulate the boxes that your content sits inside. Now it's time to look at how to place your boxes in the right place in relation to the viewport, and one another. We have covered the necessary prerequisites so can now dive deep into CSS layout, looking at different display settings, traditional layout methods involving float and positioning, and new fangled layout tools like flexbox.

CSS reference

Complete reference to CSS, with details on support by Firefox and other browsers.

Fluid Grids

Design layouts that fluidly resize with the browser window, while still using a typographic grid.

CSS Challenges

Flex your CSS skills, and see where you need more practice.

Advanced CSS topics
Using CSS transforms

Apply rotation, skewing, scaling, and translation using CSS.

CSS transitions

CSS transitions provide a way to animate changes to CSS properties, instead of having the changes take effect instantly.

Canvas tutorial

Learn how to draw graphics using scripting using the canvas element.

JavaScript tutorialsIntroduction to JavaScript
Dynamic scripting with JavaScript

In this module, we continue our coverage of all JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events. You've seen this stuff already in the course, but only in passing — here we'll discuss it all explicitly.

Getting started with JavaScript

What is JavaScript and how can it help you?

Codecademy

Codecademy is an easy way to learn how to code JavaScript. It's interactive and you can do it with your friends.

freeCodeCamp

freeCodeCamp teaches a variety of languages and frameworks for web development. It also has a forum, an internet radio station, and a blog.

Intermediate JavaScript topics
Introducing JavaScript objects

In JavaScript, most things are objects, from core JavaScript features like strings and arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages. The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you. Here we teach object theory and syntax in detail, look at how to create your own objects, and explain what JSON data is and how to work with it.

Client-side web APIs

When writing client-side JavaScript for websites or applications, you won't go very far before you start to use APIs — interfaces for manipulating different aspects of the browser and operating system the site is running on, or even data from other websites or services. In this module, we will explore what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

Eloquent JavaScript

A comprehensive guide to intermediate and advanced JavaScript methodologies.

Speaking JavaScript

For programmers who want to learn JavaScript quickly and properly, and for JavaScript programmers who want to deepen their skills and/or look up specific topics.

Essential JavaScript Design Patterns

An introduction to essential JavaScript design patterns.

JavaScript.info - The Modern JavaScript Tutorial

Part 1: The Language. Part 2: Working with Browsers.

Advanced JavaScript topics
JavaScript Guide

A comprehensive, regularly updated guide to JavaScript for all levels of learning from beginner to advanced.

You Don't Know JS

A series of books diving deep into the core mechanisms of the JavaScript language.

JavaScript Garden

Documentation of the most quirky parts of JavaScript.

Exploring ES6

Reliable and in-depth information on ECMAScript 2015.

JavaScript Patterns

A JavaScript pattern and anti-pattern collection that covers function patterns, jQuery patterns, jQuery plugin patterns, design patterns, general patterns, literals and constructor patterns, object creation patterns, code reuse patterns, DOM.

How browsers work

A detailed research article describing different modern browsers, their engines, page rendering etc.

JavaScript Videos

A collection of JavaScript videos to watch.

Extension Development
WebExtensions

WebExtensions is a cross-browser system for developing browser add-ons. To a large extent, the system is compatible with the extension API supported by Google Chrome and Opera. Extensions written for these browsers will in most cases run in Firefox or Microsoft Edge with just a few changes. The API is also fully compatible with multiprocess Firefox.\n\nWeb development tutorialsThe links on this page lead to a variety of tutorials and learning materials.
Whether you are a beginner, intermediate, or expert at web development, you will find something helpful here.
These tutorials are created by forward-thinking companies and web developers who have embraced open standards and good practices, and allow or provide translations through an open content license such as Creative Commons.For complete beginners
Getting started with the Web

Getting started with the Web is a concise series introducing you to the practicalities of web development.
You'll set up the tools you need to construct a basic webpage and publish your own code.

HTML tutorialsIntroduction to HTML
Structuring content with HTML

Our introductory HTML learning module teaches HTML from the ground up — no previous knowledge required.
It sets the stage, getting you used to important concepts and syntax, looking at applying HTML to text, how to create hyperlinks, and how to use HTML to structure a webpage.

HTML for Beginners

An HTML guide for beginners that includes explanations of common tags, including HTML tags.
Also includes a step-by-step guide to creating a basic web page with code examples.

HTML Challenges

Use these challenges to hone your HTML skills (for example, "Should I use an <h2> element or a <strong> element?"), focusing on meaningful markup.

Advanced HTML topics
Web forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, such as registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side parts of forms.

Tips for authoring fast-loading HTML pages

Optimize web pages to provide a more responsive site for visitors and reduce the load on your web server and Internet connection.

CSS tutorialsIntroduction to CSS
CSS basics

CSS (Cascading Style Sheets) is the code you use to style your webpage. CSS Basics takes you through what you need to get started. We'll answer questions like: How do I make my text black or red? How do I make my content show up in such-and-such a place on the screen? How do I decorate my webpage with background images and colors?

CSS Styling basics

CSS (Cascading Style Sheets) is used to style and lay out web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides a gentle beginning to your path toward CSS mastery with the basics of how it works, what the syntax looks like, and how you can start using it to add styling to HTML.

Selectors

Target HTML elements, including based on element state, with CSS.

Specificity

Understanding the browser algorithm to determine which CSS declarations get applied to an element when there are competing declarations, with a specificity quiz.

Handling conflicts

The cascade, specificity, and inheritance control how CSS is applied to HTML and how conflicts between style declarations are resolved.

CSS text Styling

Here we look at text styling fundamentals, including setting font, boldness, and italics, line and letter spacing, and drop shadows and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

Solve common CSS problems

Common questions and answers for beginners.

Intermediate CSS topics
CSS layout

At this point we've already looked at CSS fundamentals, how to style text, and how to style and manipulate the boxes that your content sits inside. Now it's time to look at how to place your boxes in the right place in relation to the viewport, and one another. We have covered the necessary prerequisites so can now dive deep into CSS layout, looking at different display settings, traditional layout methods involving float and positioning, and new fangled layout tools like flexbox.

CSS reference

Complete reference to CSS, with details on support by Firefox and other browsers.

Fluid Grids

Design layouts that fluidly resize with the browser window, while still using a typographic grid.

CSS Challenges

Flex your CSS skills, and see where you need more practice.

Advanced CSS topics
Using CSS transforms

Apply rotation, skewing, scaling, and translation using CSS.

CSS transitions

CSS transitions provide a way to animate changes to CSS properties, instead of having the changes take effect instantly.

Canvas tutorial

Learn how to draw graphics using scripting using the canvas element.

JavaScript tutorialsIntroduction to JavaScript
Dynamic scripting with JavaScript

In this module, we continue our coverage of all JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events. You've seen this stuff already in the course, but only in passing — here we'll discuss it all explicitly.

Getting started with JavaScript

What is JavaScript and how can it help you?

Codecademy

Codecademy is an easy way to learn how to code JavaScript. It's interactive and you can do it with your friends.

freeCodeCamp

freeCodeCamp teaches a variety of languages and frameworks for web development. It also has a forum, an internet radio station, and a blog.

Intermediate JavaScript topics
Introducing JavaScript objects

In JavaScript, most things are objects, from core JavaScript features like strings and arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages. The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you. Here we teach object theory and syntax in detail, look at how to create your own objects, and explain what JSON data is and how to work with it.

Client-side web APIs

When writing client-side JavaScript for websites or applications, you won't go very far before you start to use APIs — interfaces for manipulating different aspects of the browser and operating system the site is running on, or even data from other websites or services. In this module, we will explore what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

Eloquent JavaScript

A comprehensive guide to intermediate and advanced JavaScript methodologies.

Speaking JavaScript

For programmers who want to learn JavaScript quickly and properly, and for JavaScript programmers who want to deepen their skills and/or look up specific topics.

Essential JavaScript Design Patterns

An introduction to essential JavaScript design patterns.

JavaScript.info - The Modern JavaScript Tutorial

Part 1: The Language. Part 2: Working with Browsers.

Advanced JavaScript topics
JavaScript Guide

A comprehensive, regularly updated guide to JavaScript for all levels of learning from beginner to advanced.

You Don't Know JS

A series of books diving deep into the core mechanisms of the JavaScript language.

JavaScript Garden

Documentation of the most quirky parts of JavaScript.

Exploring ES6

Reliable and in-depth information on ECMAScript 2015.

JavaScript Patterns

A JavaScript pattern and anti-pattern collection that covers function patterns, jQuery patterns, jQuery plugin patterns, design patterns, general patterns, literals and constructor patterns, object creation patterns, code reuse patterns, DOM.

How browsers work

A detailed research article describing different modern browsers, their engines, page rendering etc.

JavaScript Videos

A collection of JavaScript videos to watch.

Extension Development
WebExtensions

WebExtensions is a cross-browser system for developing browser add-ons. To a large extent, the system is compatible with the extension API supported by Google Chrome and Opera. Extensions written for these browsers will in most cases run in Firefox or Microsoft Edge with just a few changes. The API is also fully compatible with multiprocess Firefox.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 23, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb development tutorialsThe links on this page lead to a variety of tutorials and learning materials.
Whether you are a beginner, intermediate, or expert at web development, you will find something helpful here.
These tutorials are created by forward-thinking companies and web developers who have embraced open standards and good practices, and allow or provide translations through an open content license such as Creative Commons.For complete beginners
Getting started with the Web

Getting started with the Web is a concise series introducing you to the practicalities of web development.
You'll set up the tools you need to construct a basic webpage and publish your own code.

HTML tutorialsIntroduction to HTML
Structuring content with HTML

Our introductory HTML learning module teaches HTML from the ground up — no previous knowledge required.
It sets the stage, getting you used to important concepts and syntax, looking at applying HTML to text, how to create hyperlinks, and how to use HTML to structure a webpage.

HTML for Beginners

An HTML guide for beginners that includes explanations of common tags, including HTML tags.
Also includes a step-by-step guide to creating a basic web page with code examples.

HTML Challenges

Use these challenges to hone your HTML skills (for example, "Should I use an <h2> element or a <strong> element?"), focusing on meaningful markup.

Advanced HTML topics
Web forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, such as registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side parts of forms.

Tips for authoring fast-loading HTML pages

Optimize web pages to provide a more responsive site for visitors and reduce the load on your web server and Internet connection.

CSS tutorialsIntroduction to CSS
CSS basics

CSS (Cascading Style Sheets) is the code you use to style your webpage. CSS Basics takes you through what you need to get started. We'll answer questions like: How do I make my text black or red? How do I make my content show up in such-and-such a place on the screen? How do I decorate my webpage with background images and colors?

CSS Styling basics

CSS (Cascading Style Sheets) is used to style and lay out web pages — for example, to alter the font, color, size, and spacing of your content, split it into multiple columns, or add animations and other decorative features. This module provides a gentle beginning to your path toward CSS mastery with the basics of how it works, what the syntax looks like, and how you can start using it to add styling to HTML.

Selectors

Target HTML elements, including based on element state, with CSS.

Specificity

Understanding the browser algorithm to determine which CSS declarations get applied to an element when there are competing declarations, with a specificity quiz.

Handling conflicts

The cascade, specificity, and inheritance control how CSS is applied to HTML and how conflicts between style declarations are resolved.

CSS text Styling

Here we look at text styling fundamentals, including setting font, boldness, and italics, line and letter spacing, and drop shadows and other text features. We round off the module by looking at applying custom fonts to your page, and styling lists and links.

Solve common CSS problems

Common questions and answers for beginners.

Intermediate CSS topics
CSS layout

At this point we've already looked at CSS fundamentals, how to style text, and how to style and manipulate the boxes that your content sits inside. Now it's time to look at how to place your boxes in the right place in relation to the viewport, and one another. We have covered the necessary prerequisites so can now dive deep into CSS layout, looking at different display settings, traditional layout methods involving float and positioning, and new fangled layout tools like flexbox.

CSS reference

Complete reference to CSS, with details on support by Firefox and other browsers.

Fluid Grids

Design layouts that fluidly resize with the browser window, while still using a typographic grid.

CSS Challenges

Flex your CSS skills, and see where you need more practice.

Advanced CSS topics
Using CSS transforms

Apply rotation, skewing, scaling, and translation using CSS.

CSS transitions

CSS transitions provide a way to animate changes to CSS properties, instead of having the changes take effect instantly.

Canvas tutorial

Learn how to draw graphics using scripting using the canvas element.

JavaScript tutorialsIntroduction to JavaScript
Dynamic scripting with JavaScript

In this module, we continue our coverage of all JavaScript's key fundamental features, turning our attention to commonly-encountered types of code blocks such as conditional statements, loops, functions, and events. You've seen this stuff already in the course, but only in passing — here we'll discuss it all explicitly.

Getting started with JavaScript

What is JavaScript and how can it help you?

Codecademy

Codecademy is an easy way to learn how to code JavaScript. It's interactive and you can do it with your friends.

freeCodeCamp

freeCodeCamp teaches a variety of languages and frameworks for web development. It also has a forum, an internet radio station, and a blog.

Intermediate JavaScript topics
Introducing JavaScript objects

In JavaScript, most things are objects, from core JavaScript features like strings and arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages. The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you. Here we teach object theory and syntax in detail, look at how to create your own objects, and explain what JSON data is and how to work with it.

Client-side web APIs

When writing client-side JavaScript for websites or applications, you won't go very far before you start to use APIs — interfaces for manipulating different aspects of the browser and operating system the site is running on, or even data from other websites or services. In this module, we will explore what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

Eloquent JavaScript

A comprehensive guide to intermediate and advanced JavaScript methodologies.

Speaking JavaScript

For programmers who want to learn JavaScript quickly and properly, and for JavaScript programmers who want to deepen their skills and/or look up specific topics.

Essential JavaScript Design Patterns

An introduction to essential JavaScript design patterns.

JavaScript.info - The Modern JavaScript Tutorial

Part 1: The Language. Part 2: Working with Browsers.

Advanced JavaScript topics
JavaScript Guide

A comprehensive, regularly updated guide to JavaScript for all levels of learning from beginner to advanced.

You Don't Know JS

A series of books diving deep into the core mechanisms of the JavaScript language.

JavaScript Garden

Documentation of the most quirky parts of JavaScript.

Exploring ES6

Reliable and in-depth information on ECMAScript 2015.

JavaScript Patterns

A JavaScript pattern and anti-pattern collection that covers function patterns, jQuery patterns, jQuery plugin patterns, design patterns, general patterns, literals and constructor patterns, object creation patterns, code reuse patterns, DOM.

How browsers work

A detailed research article describing different modern browsers, their engines, page rendering etc.

JavaScript Videos

A collection of JavaScript videos to watch.

Extension Development
WebExtensions

WebExtensions is a cross-browser system for developing browser add-ons. To a large extent, the system is compatible with the extension API supported by Google Chrome and Opera. Extensions written for these browsers will in most cases run in Firefox or Microsoft Edge with just a few changes. The API is also fully compatible with multiprocess Firefox.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 23, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nMDN Web Docs Glossary: Definitions of Web-related termsWeb technologies contain long lists of jargon and abbreviations that are used in documentation and coding. This glossary provides definitions of words and abbreviations you need to know to successfully understand and build for the web.
Glossary terms can be selected from the sidebar.

Note:
This glossary is a never-ending work in progress. You can help improve it by writing new entries or by making the existing ones better.\n\nMDN Web Docs Glossary: Definitions of Web-related termsWeb technologies contain long lists of jargon and abbreviations that are used in documentation and coding. This glossary provides definitions of words and abbreviations you need to know to successfully understand and build for the web.
Glossary terms can be selected from the sidebar.

Note:
This glossary is a never-ending work in progress. You can help improve it by writing new entries or by making the existing ones better.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nMDN Web Docs Glossary: Definitions of Web-related termsWeb technologies contain long lists of jargon and abbreviations that are used in documentation and coding. This glossary provides definitions of words and abbreviations you need to know to successfully understand and build for the web.
Glossary terms can be selected from the sidebar.

Note:
This glossary is a never-ending work in progress. You can help improve it by writing new entries or by making the existing ones better.
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jul 25, 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWebAssemblyWebAssembly is a type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.In a NutshellWebAssembly has huge implications for the web platform — it provides a way to run code written in multiple languages on the web at near-native speed, with client apps running on the web that previously couldn't have done so.
WebAssembly is designed to complement and run alongside JavaScript — using the WebAssembly JavaScript APIs, you can load WebAssembly modules into a JavaScript app and share functionality between the two. This allows you to take advantage of WebAssembly's performance and power and JavaScript's expressiveness and flexibility in the same app, even if you don't know how to write WebAssembly code.
And what's even better is that it is being developed as a web standard via the W3C WebAssembly Working Group and Community Group with active participation from all major browser vendors.Guides
WebAssembly concepts

Get started by reading the high-level concepts behind WebAssembly — what it is, why it is so useful, how it fits into the web platform (and beyond), and how to use it.

Compiling a New C/C++ Module to WebAssembly

When you've written code in C/C++, you can then compile it into Wasm using a tool like Emscripten. Let's look at how it works.

Compiling an Existing C Module to WebAssembly

A core use-case for WebAssembly is to take the existing ecosystem of C libraries and allow developers to use them on the web.

Compiling from Rust to WebAssembly

If you've written some Rust code, you can compile it into WebAssembly! This tutorial takes you through all you need to know to compile a Rust project to Wasm and use it in an existing web app.

Loading and running WebAssembly code

After you have a Wasm module, this article covers how to fetch, compile and instantiate it, combining the WebAssembly JavaScript API with the Fetch or XHR APIs.

Using the WebAssembly JavaScript API

Once you've loaded a Wasm module, you'll want to use it. In this article, we show you how to use WebAssembly via the WebAssembly JavaScript API.

Exported WebAssembly functions

Exported WebAssembly functions are the JavaScript reflections of WebAssembly functions, which allow calling WebAssembly code from JavaScript. This article describes what they are.

Understanding WebAssembly text format

This article explains the Wasm text format. This is the low-level textual representation of a Wasm module shown in browser developer tools when debugging.

Converting WebAssembly text format to Wasm

This article provides a guide on how to convert a WebAssembly module written in text format into a Wasm binary.

API reference
WebAssembly instruction reference

Reference documentation with interactive samples for the set of WebAssembly operators.

WebAssembly JavaScript interface

This object acts as the namespace for all WebAssembly-related functionality.

WebAssembly.Global()

A WebAssembly.Global object represents a global variable instance, accessible from both JavaScript and importable/exportable across one or more WebAssembly.Module instances. This allows dynamic linking of multiple modules.

WebAssembly.Module()

A WebAssembly.Module object contains stateless WebAssembly code that has already been compiled by the browser and can be efficiently shared with Workers, and instantiated multiple times.

WebAssembly.Instance()

A WebAssembly.Instance object is a stateful, executable instance of a Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.

WebAssembly.compile()

The WebAssembly.compile() function compiles WebAssembly binary code into a WebAssembly.Module object.

WebAssembly.compileStreaming()

The WebAssembly.compileStreaming() function compiles a WebAssembly.Module directly from a streamed underlying source.

WebAssembly.instantiate()

The WebAssembly.instantiate() function allows you to compile and instantiate WebAssembly code.

WebAssembly.instantiateStreaming()

The WebAssembly.instantiateStreaming() function is the primary API for compiling and instantiating WebAssembly code, returning both a Module and its first Instance.

WebAssembly.validate()

The WebAssembly.validate() function validates a given typed array of WebAssembly binary code.

WebAssembly.Memory()

A WebAssembly.Memory object is a resizable ArrayBuffer that holds the raw bytes of memory accessed by an Instance.

WebAssembly.Table()

A WebAssembly.Table object is a resizable typed array of opaque values, like function references, that are accessed by an Instance.

WebAssembly.Tag()

The WebAssembly.Tag object defines a type of WebAssembly exception that can be thrown to/from WebAssembly code.

WebAssembly.Exception()

The WebAssembly.Exception object represents a runtime exception thrown from WebAssembly to JavaScript, or thrown from JavaScript to a WebAssembly exception handler.

WebAssembly.CompileError()

Creates a new WebAssembly CompileError object.

WebAssembly.LinkError()

Creates a new WebAssembly LinkError object.

WebAssembly.RuntimeError()

Creates a new WebAssembly RuntimeError object.

Examples
WASMSobel
See our webassembly-examples repo for a number of other examples.
SpecificationsSpecificationWebAssembly JavaScript Interface # webassembly-namespaceWebAssembly JavaScript Interface # ref-for-syntax-numtype①⓪Unknown specification Unknown specification Unknown specification Unknown specification WebAssembly Core: Garbage Collection # garbage-collection①Unknown specification Unknown specification WebAssembly JavaScript Interface # dom-globaldescriptor-mutableUnknown specification Unknown specification Unknown specification Unknown specification Unknown specification Browser compatibilitySee also
WebAssembly on Mozilla Research
webassembly.org
WebAssembly articles on Mozilla Hacks blog
W3C WebAssembly Community Group
Emscripting a C Library to Wasm\n\nWebAssemblyWebAssembly is a type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.In a NutshellWebAssembly has huge implications for the web platform — it provides a way to run code written in multiple languages on the web at near-native speed, with client apps running on the web that previously couldn't have done so.
WebAssembly is designed to complement and run alongside JavaScript — using the WebAssembly JavaScript APIs, you can load WebAssembly modules into a JavaScript app and share functionality between the two. This allows you to take advantage of WebAssembly's performance and power and JavaScript's expressiveness and flexibility in the same app, even if you don't know how to write WebAssembly code.
And what's even better is that it is being developed as a web standard via the W3C WebAssembly Working Group and Community Group with active participation from all major browser vendors.Guides
WebAssembly concepts

Get started by reading the high-level concepts behind WebAssembly — what it is, why it is so useful, how it fits into the web platform (and beyond), and how to use it.

Compiling a New C/C++ Module to WebAssembly

When you've written code in C/C++, you can then compile it into Wasm using a tool like Emscripten. Let's look at how it works.

Compiling an Existing C Module to WebAssembly

A core use-case for WebAssembly is to take the existing ecosystem of C libraries and allow developers to use them on the web.

Compiling from Rust to WebAssembly

If you've written some Rust code, you can compile it into WebAssembly! This tutorial takes you through all you need to know to compile a Rust project to Wasm and use it in an existing web app.

Loading and running WebAssembly code

After you have a Wasm module, this article covers how to fetch, compile and instantiate it, combining the WebAssembly JavaScript API with the Fetch or XHR APIs.

Using the WebAssembly JavaScript API

Once you've loaded a Wasm module, you'll want to use it. In this article, we show you how to use WebAssembly via the WebAssembly JavaScript API.

Exported WebAssembly functions

Exported WebAssembly functions are the JavaScript reflections of WebAssembly functions, which allow calling WebAssembly code from JavaScript. This article describes what they are.

Understanding WebAssembly text format

This article explains the Wasm text format. This is the low-level textual representation of a Wasm module shown in browser developer tools when debugging.

Converting WebAssembly text format to Wasm

This article provides a guide on how to convert a WebAssembly module written in text format into a Wasm binary.

API reference
WebAssembly instruction reference

Reference documentation with interactive samples for the set of WebAssembly operators.

WebAssembly JavaScript interface

This object acts as the namespace for all WebAssembly-related functionality.

WebAssembly.Global()

A WebAssembly.Global object represents a global variable instance, accessible from both JavaScript and importable/exportable across one or more WebAssembly.Module instances. This allows dynamic linking of multiple modules.

WebAssembly.Module()

A WebAssembly.Module object contains stateless WebAssembly code that has already been compiled by the browser and can be efficiently shared with Workers, and instantiated multiple times.

WebAssembly.Instance()

A WebAssembly.Instance object is a stateful, executable instance of a Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.

WebAssembly.compile()

The WebAssembly.compile() function compiles WebAssembly binary code into a WebAssembly.Module object.

WebAssembly.compileStreaming()

The WebAssembly.compileStreaming() function compiles a WebAssembly.Module directly from a streamed underlying source.

WebAssembly.instantiate()

The WebAssembly.instantiate() function allows you to compile and instantiate WebAssembly code.

WebAssembly.instantiateStreaming()

The WebAssembly.instantiateStreaming() function is the primary API for compiling and instantiating WebAssembly code, returning both a Module and its first Instance.

WebAssembly.validate()

The WebAssembly.validate() function validates a given typed array of WebAssembly binary code.

WebAssembly.Memory()

A WebAssembly.Memory object is a resizable ArrayBuffer that holds the raw bytes of memory accessed by an Instance.

WebAssembly.Table()

A WebAssembly.Table object is a resizable typed array of opaque values, like function references, that are accessed by an Instance.

WebAssembly.Tag()

The WebAssembly.Tag object defines a type of WebAssembly exception that can be thrown to/from WebAssembly code.

WebAssembly.Exception()

The WebAssembly.Exception object represents a runtime exception thrown from WebAssembly to JavaScript, or thrown from JavaScript to a WebAssembly exception handler.

WebAssembly.CompileError()

Creates a new WebAssembly CompileError object.

WebAssembly.LinkError()

Creates a new WebAssembly LinkError object.

WebAssembly.RuntimeError()

Creates a new WebAssembly RuntimeError object.

Examples
WASMSobel
See our webassembly-examples repo for a number of other examples.
SpecificationsSpecificationWebAssembly JavaScript Interface # webassembly-namespaceWebAssembly JavaScript Interface # ref-for-syntax-numtype①⓪Unknown specification Unknown specification Unknown specification Unknown specification WebAssembly Core: Garbage Collection # garbage-collection①Unknown specification Unknown specification WebAssembly JavaScript Interface # dom-globaldescriptor-mutableUnknown specification Unknown specification Unknown specification Unknown specification Unknown specification Browser compatibilitySee also
WebAssembly on Mozilla Research
webassembly.org
WebAssembly articles on Mozilla Hacks blog
W3C WebAssembly Community Group
Emscripting a C Library to Wasm
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWebAssemblyWebAssembly is a type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside JavaScript, allowing both to work together.In a NutshellWebAssembly has huge implications for the web platform — it provides a way to run code written in multiple languages on the web at near-native speed, with client apps running on the web that previously couldn't have done so.
WebAssembly is designed to complement and run alongside JavaScript — using the WebAssembly JavaScript APIs, you can load WebAssembly modules into a JavaScript app and share functionality between the two. This allows you to take advantage of WebAssembly's performance and power and JavaScript's expressiveness and flexibility in the same app, even if you don't know how to write WebAssembly code.
And what's even better is that it is being developed as a web standard via the W3C WebAssembly Working Group and Community Group with active participation from all major browser vendors.Guides
WebAssembly concepts

Get started by reading the high-level concepts behind WebAssembly — what it is, why it is so useful, how it fits into the web platform (and beyond), and how to use it.

Compiling a New C/C++ Module to WebAssembly

When you've written code in C/C++, you can then compile it into Wasm using a tool like Emscripten. Let's look at how it works.

Compiling an Existing C Module to WebAssembly

A core use-case for WebAssembly is to take the existing ecosystem of C libraries and allow developers to use them on the web.

Compiling from Rust to WebAssembly

If you've written some Rust code, you can compile it into WebAssembly! This tutorial takes you through all you need to know to compile a Rust project to Wasm and use it in an existing web app.

Loading and running WebAssembly code

After you have a Wasm module, this article covers how to fetch, compile and instantiate it, combining the WebAssembly JavaScript API with the Fetch or XHR APIs.

Using the WebAssembly JavaScript API

Once you've loaded a Wasm module, you'll want to use it. In this article, we show you how to use WebAssembly via the WebAssembly JavaScript API.

Exported WebAssembly functions

Exported WebAssembly functions are the JavaScript reflections of WebAssembly functions, which allow calling WebAssembly code from JavaScript. This article describes what they are.

Understanding WebAssembly text format

This article explains the Wasm text format. This is the low-level textual representation of a Wasm module shown in browser developer tools when debugging.

Converting WebAssembly text format to Wasm

This article provides a guide on how to convert a WebAssembly module written in text format into a Wasm binary.

API reference
WebAssembly instruction reference

Reference documentation with interactive samples for the set of WebAssembly operators.

WebAssembly JavaScript interface

This object acts as the namespace for all WebAssembly-related functionality.

WebAssembly.Global()

A WebAssembly.Global object represents a global variable instance, accessible from both JavaScript and importable/exportable across one or more WebAssembly.Module instances. This allows dynamic linking of multiple modules.

WebAssembly.Module()

A WebAssembly.Module object contains stateless WebAssembly code that has already been compiled by the browser and can be efficiently shared with Workers, and instantiated multiple times.

WebAssembly.Instance()

A WebAssembly.Instance object is a stateful, executable instance of a Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.

WebAssembly.compile()

The WebAssembly.compile() function compiles WebAssembly binary code into a WebAssembly.Module object.

WebAssembly.compileStreaming()

The WebAssembly.compileStreaming() function compiles a WebAssembly.Module directly from a streamed underlying source.

WebAssembly.instantiate()

The WebAssembly.instantiate() function allows you to compile and instantiate WebAssembly code.

WebAssembly.instantiateStreaming()

The WebAssembly.instantiateStreaming() function is the primary API for compiling and instantiating WebAssembly code, returning both a Module and its first Instance.

WebAssembly.validate()

The WebAssembly.validate() function validates a given typed array of WebAssembly binary code.

WebAssembly.Memory()

A WebAssembly.Memory object is a resizable ArrayBuffer that holds the raw bytes of memory accessed by an Instance.

WebAssembly.Table()

A WebAssembly.Table object is a resizable typed array of opaque values, like function references, that are accessed by an Instance.

WebAssembly.Tag()

The WebAssembly.Tag object defines a type of WebAssembly exception that can be thrown to/from WebAssembly code.

WebAssembly.Exception()

The WebAssembly.Exception object represents a runtime exception thrown from WebAssembly to JavaScript, or thrown from JavaScript to a WebAssembly exception handler.

WebAssembly.CompileError()

Creates a new WebAssembly CompileError object.

WebAssembly.LinkError()

Creates a new WebAssembly LinkError object.

WebAssembly.RuntimeError()

Creates a new WebAssembly RuntimeError object.

Examples
WASMSobel
See our webassembly-examples repo for a number of other examples.
SpecificationsSpecificationWebAssembly JavaScript Interface # webassembly-namespaceWebAssembly JavaScript Interface # ref-for-syntax-numtype①⓪Unknown specification Unknown specification Unknown specification Unknown specification WebAssembly Core: Garbage Collection # garbage-collection①Unknown specification Unknown specification WebAssembly JavaScript Interface # dom-globaldescriptor-mutableUnknown specification Unknown specification Unknown specification Unknown specification Unknown specification Browser compatibilitySee also
WebAssembly on Mozilla Research
webassembly.org
WebAssembly articles on Mozilla Hacks blog
W3C WebAssembly Community Group
Emscripting a C Library to Wasm
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Jan 31, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nWeb app manifestsA web application manifest, defined in the Web Application Manifest specification, is a JSON text file that provides information about a web application.
The most common use for a web application manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
A web application manifest contains a single JSON object where the top-level keys are called members.MembersThis section lists the members that may appear in the manifest.
All members are optional in the specification, but some applications require some members to be present. For example, PWAs must provide certain manifest members.
background_colorcategoriesdescriptiondisplaydisplay_override
Experimental
file_handlers
Experimental
iconsidlaunch_handler
Experimental
namenote_taking
Experimental
orientationprefer_related_applications
Experimental
protocol_handlers
Experimental
related_applications
Experimental
scopescreenshotsserviceworker
Experimental

Non-standard
share_target
Experimental
short_nameshortcutsstart_urltheme_color

Note:
The dir, lang, and iarc_rating_id members are not implemented.
Example manifestjson{
  "short_name": "MDN",
  "name": "MDN Web Docs",
  "icons": [
    {
      "src": "/favicon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/favicon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Deploying a manifestWeb app manifests are deployed in your HTML pages using a <link> element in the <head> of a document:
html<link rel="manifest" href="manifest.json" />

The .webmanifest extension is specified in the Media type registration section of the specification (the response of the manifest file should return Content-Type: application/manifest+json). Browsers generally support manifests with other appropriate extensions like .json (Content-Type: application/json).
If the manifest requires credentials to fetch, the crossorigin attribute must be set to use-credentials, even if the manifest file is in the same origin as the current page.
html<link rel="manifest" href="/app.webmanifest" crossorigin="use-credentials" />
Splash screensIn some browsers and operating systems, a splash screen is displayed when an installed PWA is launched. This splash screen is automatically generated and its appearance is defined by members in the web app manifest, specifically:

name
background_color
icons
Browser compatibilitySee also
Progressive Web Apps (PWAs)\n\nWeb app manifestsA web application manifest, defined in the Web Application Manifest specification, is a JSON text file that provides information about a web application.
The most common use for a web application manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
A web application manifest contains a single JSON object where the top-level keys are called members.MembersThis section lists the members that may appear in the manifest.
All members are optional in the specification, but some applications require some members to be present. For example, PWAs must provide certain manifest members.
background_colorcategoriesdescriptiondisplaydisplay_override
Experimental
file_handlers
Experimental
iconsidlaunch_handler
Experimental
namenote_taking
Experimental
orientationprefer_related_applications
Experimental
protocol_handlers
Experimental
related_applications
Experimental
scopescreenshotsserviceworker
Experimental

Non-standard
share_target
Experimental
short_nameshortcutsstart_urltheme_color

Note:
The dir, lang, and iarc_rating_id members are not implemented.
Example manifestjson{
  "short_name": "MDN",
  "name": "MDN Web Docs",
  "icons": [
    {
      "src": "/favicon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/favicon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Deploying a manifestWeb app manifests are deployed in your HTML pages using a <link> element in the <head> of a document:
html<link rel="manifest" href="manifest.json" />

The .webmanifest extension is specified in the Media type registration section of the specification (the response of the manifest file should return Content-Type: application/manifest+json). Browsers generally support manifests with other appropriate extensions like .json (Content-Type: application/json).
If the manifest requires credentials to fetch, the crossorigin attribute must be set to use-credentials, even if the manifest file is in the same origin as the current page.
html<link rel="manifest" href="/app.webmanifest" crossorigin="use-credentials" />
Splash screensIn some browsers and operating systems, a splash screen is displayed when an installed PWA is launched. This splash screen is automatically generated and its appearance is defined by members in the web app manifest, specifically:

name
background_color
icons
Browser compatibilitySee also
Progressive Web Apps (PWAs)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nWeb app manifestsA web application manifest, defined in the Web Application Manifest specification, is a JSON text file that provides information about a web application.
The most common use for a web application manifest is to provide information that the browser needs to install a progressive web app (PWA) on a device, such as the app's name and icon.
A web application manifest contains a single JSON object where the top-level keys are called members.MembersThis section lists the members that may appear in the manifest.
All members are optional in the specification, but some applications require some members to be present. For example, PWAs must provide certain manifest members.
background_colorcategoriesdescriptiondisplaydisplay_override
Experimental
file_handlers
Experimental
iconsidlaunch_handler
Experimental
namenote_taking
Experimental
orientationprefer_related_applications
Experimental
protocol_handlers
Experimental
related_applications
Experimental
scopescreenshotsserviceworker
Experimental

Non-standard
share_target
Experimental
short_nameshortcutsstart_urltheme_color

Note:
The dir, lang, and iarc_rating_id members are not implemented.
Example manifestjson{
  "short_name": "MDN",
  "name": "MDN Web Docs",
  "icons": [
    {
      "src": "/favicon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/favicon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Deploying a manifestWeb app manifests are deployed in your HTML pages using a <link> element in the <head> of a document:
html<link rel="manifest" href="manifest.json" />

The .webmanifest extension is specified in the Media type registration section of the specification (the response of the manifest file should return Content-Type: application/manifest+json). Browsers generally support manifests with other appropriate extensions like .json (Content-Type: application/json).
If the manifest requires credentials to fetch, the crossorigin attribute must be set to use-credentials, even if the manifest file is in the same origin as the current page.
html<link rel="manifest" href="/app.webmanifest" crossorigin="use-credentials" />
Splash screensIn some browsers and operating systems, a splash screen is displayed when an installed PWA is launched. This splash screen is automatically generated and its appearance is defined by members in the web app manifest, specifically:

name
background_color
icons
Browser compatibilitySee also
Progressive Web Apps (PWAs)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nOpenSearch description formatThe OpenSearch description format can be used to describe the web interface of a search engine. This allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine. OpenSearch is supported by (at least) Firefox, Edge, Safari, and Chrome. (See Reference Material for links to other browsers' documentation.)
Firefox also supports additional features not in the OpenSearch standard, such as search suggestions. This article focuses on creating OpenSearch-compatible search engines that support these additional Firefox features.OverviewThe address bar in browsers has a dual purpose: you can type a URL to directly go to a site, or you can type a search term to query a search engine. The search engine returns a list of results that you can browse directly, or you can open the search engine's full results page.
By default, browsers can connect to a few popular search engines, such as Google, Bing, or Yandex. The OpenSearch protocol allows websites to define their own search engines, enabling users to search those websites directly from the browser's address bar. For example, the MDN website has a site-wide search engine. If MDN registers itself as a search engine, users can search MDN directly from the address bar.
Browsers query a search engine by requesting a URL. The site defines a template for the URL to be requested, and the browser fills in the user's search terms in the specified placeholders. For example, if the search engine URL is https://example.com/search?q={searchTerms}, then the browser will request https://example.com/search?q=foo when the user types "foo" into the address bar. The search engine then generates a response—either a list of search results or a full search results page.
A site defines its search engine by linking to an XML description file in its HTML. When the user first visits the site, the browser detects this description file and registers the search engine. The browser then uses the registered search engine to handle searches from the address bar.

Note:
Chrome registers site search engines as "inactive" by default. Users must manually activate each site in the search engine settings.
OpenSearch description fileThe XML file that describes a search engine follows the basic template below. Sections in [square brackets] should be customized for your specific engine.
xml<OpenSearchDescription
  xmlns="http://a9.com/-/spec/opensearch/1.1/"
  xmlns:moz="http://www.mozilla.org/2006/browser/search/">
  <ShortName>[SNK]</ShortName>
  <Description>[Search engine full name and summary]</Description>
  <InputEncoding>[UTF-8]</InputEncoding>
  <Image width="16" height="16" type="image/x-icon">[https://example.com/favicon.ico]</Image>
  <Url type="text/html" template="[searchURL]"/>
  <Url type="application/x-suggestions+json" template="[suggestionURL]"/>
</OpenSearchDescription>


ShortName

A short name for the search engine. It must be 16 or fewer characters of plain text, with no HTML or other markup.

Description

A brief description of the search engine. It must be 1024 or fewer characters of plain text, with no HTML or other markup.

InputEncoding

The character encoding to use when submitting input to the search engine.

Image

URL of an icon for the search engine. When possible, include a 16×16 image of type image/x-icon (such as /favicon.ico) and a 64×64 image of type image/jpeg or image/png.
The URL may also use the data: URL scheme. (You can generate a data: URL from an icon file at The data: URL kitchen.)
xml<Image height="16" width="16" type="image/x-icon">https://example.com/favicon.ico</Image>
  <!-- or -->
<Image height="16" width="16">data:image/x-icon;base64,AAABAAEAEBAAA…DAAA=</Image>

Firefox caches the icon as a base64 data: URL (search plug-ins are stored in the profile's searchplugins/ folder). http: and https: URLs are converted to data: URLs when this is done.

Note:
For icons loaded remotely (that is, from https:// URLs as opposed to data: URLs), Firefox will reject icons larger than 10 kilobytes.



Url

Describes the URL or URLs to use for the search. The template attribute indicates the base URL for the search query.
Firefox supports three URL types:

type="text/html" specifies the URL for the actual search query.
type="application/x-suggestions+json" specifies the URL for fetching search suggestions. In Firefox 63 onwards, type="application/json" is accepted as an alias of this.
type="application/x-moz-keywordsearch" specifies the URL used when a keyword search is entered in the location bar. This is supported only in Firefox.

For these URL types, you can use {searchTerms} to substitute the search terms entered by the user in the search bar or location bar. Other supported dynamic search parameters are described in OpenSearch 1.1 parameters.
For search suggestions, the application/x-suggestions+json URL template is used to fetch a suggestion list in JSON format.

Linking to the OpenSearch description fileTo support autodiscovery, add a <link> element for each search engine to the <head> of your web page:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="[searchTitle]"
  href="[descriptionURL]" />

Replace the items in [square brackets] as explained below:

searchTitle

The name of the search to perform, such as "Search MDC" or "Yahoo! Search". This must match your plugin file's <ShortName>.

descriptionURL

The URL to the XML description file, so the browser can download it.


If your site offers multiple search engines, you can support autodiscovery for them all. For example:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Author"
  href="http://example.com/mysiteauthor.xml" />

<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Title"
  href="http://example.com/mysitetitle.xml" />

This way, your site can offer two engines to search: one by author and another by title.

Note:
In Firefox, an icon change in the search box indicates there's a provided search plugin. (See image, the green plus sign.) Thus if a search box is not shown in the user's UI, they will receive no indication. In general, behavior varies among browsers.
Supporting automatic updates for OpenSearch descriptionThe OpenSearch description file can update automatically. To support this, include an extra Url element with type="application/opensearchdescription+xml" and rel="self". The template attribute should be the URL of the OpenSearch document to automatically update to.
For example:
xml<Url
  type="application/opensearchdescription+xml"
  rel="self"
  template="https://example.com/mysearchdescription.xml" />
Troubleshooting tipsIf there is a mistake in your XML description file, you could run into errors when adding the search engine. If the error message isn't helpful, use the following tips to troubleshoot the problem:

Check that your server serves OpenSearch descriptions with Content-Type: application/opensearchdescription+xml.
Make sure that your XML description file is well-formed. You can check by loading the file directly into a browser. Ampersands (&) in the template URL must be escaped as &amp;, and tags must be closed with a trailing slash or a matching end tag.
Make sure to include the xmlns attribute—without it, you could get the error message like "Firefox could not download the search plugin".
You must include a text/html URL — search engines including only Atom or RSS URL types (which is valid, but Firefox doesn't support) will also generate the "could not download the search plugin" error.
Remotely fetched favicons must not be larger than 10KB (see Firefox bug 361923).
As mentioned earlier, browsers may not activate site search shortcuts by default. Check the browser's settings and make sure the search engine is activated.

In addition, the search plugin service provides a logging mechanism that may be useful to plugin developers. Use about:config to set the pref browser.search.log to true. Then, logging information will appear in Firefox's Browser Console (Tools ➤ Browser Tools ➤ Browser Console) when search plugins are added.Reference Material
OpenSearch Documentation
Safari 8.0 Release Notes: Quick Website Search
Microsoft Edge Dev Guide: Search provider discovery
The Chromium Projects: Tab to Search
imdb.com has a working osd.xml
Ready2Search - create OpenSearch plugins. Customized Search through Ready2Search\n\nOpenSearch description formatThe OpenSearch description format can be used to describe the web interface of a search engine. This allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine. OpenSearch is supported by (at least) Firefox, Edge, Safari, and Chrome. (See Reference Material for links to other browsers' documentation.)
Firefox also supports additional features not in the OpenSearch standard, such as search suggestions. This article focuses on creating OpenSearch-compatible search engines that support these additional Firefox features.OverviewThe address bar in browsers has a dual purpose: you can type a URL to directly go to a site, or you can type a search term to query a search engine. The search engine returns a list of results that you can browse directly, or you can open the search engine's full results page.
By default, browsers can connect to a few popular search engines, such as Google, Bing, or Yandex. The OpenSearch protocol allows websites to define their own search engines, enabling users to search those websites directly from the browser's address bar. For example, the MDN website has a site-wide search engine. If MDN registers itself as a search engine, users can search MDN directly from the address bar.
Browsers query a search engine by requesting a URL. The site defines a template for the URL to be requested, and the browser fills in the user's search terms in the specified placeholders. For example, if the search engine URL is https://example.com/search?q={searchTerms}, then the browser will request https://example.com/search?q=foo when the user types "foo" into the address bar. The search engine then generates a response—either a list of search results or a full search results page.
A site defines its search engine by linking to an XML description file in its HTML. When the user first visits the site, the browser detects this description file and registers the search engine. The browser then uses the registered search engine to handle searches from the address bar.

Note:
Chrome registers site search engines as "inactive" by default. Users must manually activate each site in the search engine settings.
OpenSearch description fileThe XML file that describes a search engine follows the basic template below. Sections in [square brackets] should be customized for your specific engine.
xml<OpenSearchDescription
  xmlns="http://a9.com/-/spec/opensearch/1.1/"
  xmlns:moz="http://www.mozilla.org/2006/browser/search/">
  <ShortName>[SNK]</ShortName>
  <Description>[Search engine full name and summary]</Description>
  <InputEncoding>[UTF-8]</InputEncoding>
  <Image width="16" height="16" type="image/x-icon">[https://example.com/favicon.ico]</Image>
  <Url type="text/html" template="[searchURL]"/>
  <Url type="application/x-suggestions+json" template="[suggestionURL]"/>
</OpenSearchDescription>


ShortName

A short name for the search engine. It must be 16 or fewer characters of plain text, with no HTML or other markup.

Description

A brief description of the search engine. It must be 1024 or fewer characters of plain text, with no HTML or other markup.

InputEncoding

The character encoding to use when submitting input to the search engine.

Image

URL of an icon for the search engine. When possible, include a 16×16 image of type image/x-icon (such as /favicon.ico) and a 64×64 image of type image/jpeg or image/png.
The URL may also use the data: URL scheme. (You can generate a data: URL from an icon file at The data: URL kitchen.)
xml<Image height="16" width="16" type="image/x-icon">https://example.com/favicon.ico</Image>
  <!-- or -->
<Image height="16" width="16">data:image/x-icon;base64,AAABAAEAEBAAA…DAAA=</Image>

Firefox caches the icon as a base64 data: URL (search plug-ins are stored in the profile's searchplugins/ folder). http: and https: URLs are converted to data: URLs when this is done.

Note:
For icons loaded remotely (that is, from https:// URLs as opposed to data: URLs), Firefox will reject icons larger than 10 kilobytes.



Url

Describes the URL or URLs to use for the search. The template attribute indicates the base URL for the search query.
Firefox supports three URL types:

type="text/html" specifies the URL for the actual search query.
type="application/x-suggestions+json" specifies the URL for fetching search suggestions. In Firefox 63 onwards, type="application/json" is accepted as an alias of this.
type="application/x-moz-keywordsearch" specifies the URL used when a keyword search is entered in the location bar. This is supported only in Firefox.

For these URL types, you can use {searchTerms} to substitute the search terms entered by the user in the search bar or location bar. Other supported dynamic search parameters are described in OpenSearch 1.1 parameters.
For search suggestions, the application/x-suggestions+json URL template is used to fetch a suggestion list in JSON format.

Linking to the OpenSearch description fileTo support autodiscovery, add a <link> element for each search engine to the <head> of your web page:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="[searchTitle]"
  href="[descriptionURL]" />

Replace the items in [square brackets] as explained below:

searchTitle

The name of the search to perform, such as "Search MDC" or "Yahoo! Search". This must match your plugin file's <ShortName>.

descriptionURL

The URL to the XML description file, so the browser can download it.


If your site offers multiple search engines, you can support autodiscovery for them all. For example:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Author"
  href="http://example.com/mysiteauthor.xml" />

<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Title"
  href="http://example.com/mysitetitle.xml" />

This way, your site can offer two engines to search: one by author and another by title.

Note:
In Firefox, an icon change in the search box indicates there's a provided search plugin. (See image, the green plus sign.) Thus if a search box is not shown in the user's UI, they will receive no indication. In general, behavior varies among browsers.
Supporting automatic updates for OpenSearch descriptionThe OpenSearch description file can update automatically. To support this, include an extra Url element with type="application/opensearchdescription+xml" and rel="self". The template attribute should be the URL of the OpenSearch document to automatically update to.
For example:
xml<Url
  type="application/opensearchdescription+xml"
  rel="self"
  template="https://example.com/mysearchdescription.xml" />
Troubleshooting tipsIf there is a mistake in your XML description file, you could run into errors when adding the search engine. If the error message isn't helpful, use the following tips to troubleshoot the problem:

Check that your server serves OpenSearch descriptions with Content-Type: application/opensearchdescription+xml.
Make sure that your XML description file is well-formed. You can check by loading the file directly into a browser. Ampersands (&) in the template URL must be escaped as &amp;, and tags must be closed with a trailing slash or a matching end tag.
Make sure to include the xmlns attribute—without it, you could get the error message like "Firefox could not download the search plugin".
You must include a text/html URL — search engines including only Atom or RSS URL types (which is valid, but Firefox doesn't support) will also generate the "could not download the search plugin" error.
Remotely fetched favicons must not be larger than 10KB (see Firefox bug 361923).
As mentioned earlier, browsers may not activate site search shortcuts by default. Check the browser's settings and make sure the search engine is activated.

In addition, the search plugin service provides a logging mechanism that may be useful to plugin developers. Use about:config to set the pref browser.search.log to true. Then, logging information will appear in Firefox's Browser Console (Tools ➤ Browser Tools ➤ Browser Console) when search plugins are added.Reference Material
OpenSearch Documentation
Safari 8.0 Release Notes: Quick Website Search
Microsoft Edge Dev Guide: Search provider discovery
The Chromium Projects: Tab to Search
imdb.com has a working osd.xml
Ready2Search - create OpenSearch plugins. Customized Search through Ready2Search
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nOpenSearch description formatThe OpenSearch description format can be used to describe the web interface of a search engine. This allows a website to describe a search engine for itself, so that a browser or other client application can use that search engine. OpenSearch is supported by (at least) Firefox, Edge, Safari, and Chrome. (See Reference Material for links to other browsers' documentation.)
Firefox also supports additional features not in the OpenSearch standard, such as search suggestions. This article focuses on creating OpenSearch-compatible search engines that support these additional Firefox features.OverviewThe address bar in browsers has a dual purpose: you can type a URL to directly go to a site, or you can type a search term to query a search engine. The search engine returns a list of results that you can browse directly, or you can open the search engine's full results page.
By default, browsers can connect to a few popular search engines, such as Google, Bing, or Yandex. The OpenSearch protocol allows websites to define their own search engines, enabling users to search those websites directly from the browser's address bar. For example, the MDN website has a site-wide search engine. If MDN registers itself as a search engine, users can search MDN directly from the address bar.
Browsers query a search engine by requesting a URL. The site defines a template for the URL to be requested, and the browser fills in the user's search terms in the specified placeholders. For example, if the search engine URL is https://example.com/search?q={searchTerms}, then the browser will request https://example.com/search?q=foo when the user types "foo" into the address bar. The search engine then generates a response—either a list of search results or a full search results page.
A site defines its search engine by linking to an XML description file in its HTML. When the user first visits the site, the browser detects this description file and registers the search engine. The browser then uses the registered search engine to handle searches from the address bar.

Note:
Chrome registers site search engines as "inactive" by default. Users must manually activate each site in the search engine settings.
OpenSearch description fileThe XML file that describes a search engine follows the basic template below. Sections in [square brackets] should be customized for your specific engine.
xml<OpenSearchDescription
  xmlns="http://a9.com/-/spec/opensearch/1.1/"
  xmlns:moz="http://www.mozilla.org/2006/browser/search/">
  <ShortName>[SNK]</ShortName>
  <Description>[Search engine full name and summary]</Description>
  <InputEncoding>[UTF-8]</InputEncoding>
  <Image width="16" height="16" type="image/x-icon">[https://example.com/favicon.ico]</Image>
  <Url type="text/html" template="[searchURL]"/>
  <Url type="application/x-suggestions+json" template="[suggestionURL]"/>
</OpenSearchDescription>


ShortName

A short name for the search engine. It must be 16 or fewer characters of plain text, with no HTML or other markup.

Description

A brief description of the search engine. It must be 1024 or fewer characters of plain text, with no HTML or other markup.

InputEncoding

The character encoding to use when submitting input to the search engine.

Image

URL of an icon for the search engine. When possible, include a 16×16 image of type image/x-icon (such as /favicon.ico) and a 64×64 image of type image/jpeg or image/png.
The URL may also use the data: URL scheme. (You can generate a data: URL from an icon file at The data: URL kitchen.)
xml<Image height="16" width="16" type="image/x-icon">https://example.com/favicon.ico</Image>
  <!-- or -->
<Image height="16" width="16">data:image/x-icon;base64,AAABAAEAEBAAA…DAAA=</Image>

Firefox caches the icon as a base64 data: URL (search plug-ins are stored in the profile's searchplugins/ folder). http: and https: URLs are converted to data: URLs when this is done.

Note:
For icons loaded remotely (that is, from https:// URLs as opposed to data: URLs), Firefox will reject icons larger than 10 kilobytes.



Url

Describes the URL or URLs to use for the search. The template attribute indicates the base URL for the search query.
Firefox supports three URL types:

type="text/html" specifies the URL for the actual search query.
type="application/x-suggestions+json" specifies the URL for fetching search suggestions. In Firefox 63 onwards, type="application/json" is accepted as an alias of this.
type="application/x-moz-keywordsearch" specifies the URL used when a keyword search is entered in the location bar. This is supported only in Firefox.

For these URL types, you can use {searchTerms} to substitute the search terms entered by the user in the search bar or location bar. Other supported dynamic search parameters are described in OpenSearch 1.1 parameters.
For search suggestions, the application/x-suggestions+json URL template is used to fetch a suggestion list in JSON format.

Linking to the OpenSearch description fileTo support autodiscovery, add a <link> element for each search engine to the <head> of your web page:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="[searchTitle]"
  href="[descriptionURL]" />

Replace the items in [square brackets] as explained below:

searchTitle

The name of the search to perform, such as "Search MDC" or "Yahoo! Search". This must match your plugin file's <ShortName>.

descriptionURL

The URL to the XML description file, so the browser can download it.


If your site offers multiple search engines, you can support autodiscovery for them all. For example:
html<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Author"
  href="http://example.com/mysiteauthor.xml" />

<link
  rel="search"
  type="application/opensearchdescription+xml"
  title="MySite: By Title"
  href="http://example.com/mysitetitle.xml" />

This way, your site can offer two engines to search: one by author and another by title.

Note:
In Firefox, an icon change in the search box indicates there's a provided search plugin. (See image, the green plus sign.) Thus if a search box is not shown in the user's UI, they will receive no indication. In general, behavior varies among browsers.
Supporting automatic updates for OpenSearch descriptionThe OpenSearch description file can update automatically. To support this, include an extra Url element with type="application/opensearchdescription+xml" and rel="self". The template attribute should be the URL of the OpenSearch document to automatically update to.
For example:
xml<Url
  type="application/opensearchdescription+xml"
  rel="self"
  template="https://example.com/mysearchdescription.xml" />
Troubleshooting tipsIf there is a mistake in your XML description file, you could run into errors when adding the search engine. If the error message isn't helpful, use the following tips to troubleshoot the problem:

Check that your server serves OpenSearch descriptions with Content-Type: application/opensearchdescription+xml.
Make sure that your XML description file is well-formed. You can check by loading the file directly into a browser. Ampersands (&) in the template URL must be escaped as &amp;, and tags must be closed with a trailing slash or a matching end tag.
Make sure to include the xmlns attribute—without it, you could get the error message like "Firefox could not download the search plugin".
You must include a text/html URL — search engines including only Atom or RSS URL types (which is valid, but Firefox doesn't support) will also generate the "could not download the search plugin" error.
Remotely fetched favicons must not be larger than 10KB (see Firefox bug 361923).
As mentioned earlier, browsers may not activate site search shortcuts by default. Check the browser's settings and make sure the search engine is activated.

In addition, the search plugin service provides a logging mechanism that may be useful to plugin developers. Use about:config to set the pref browser.search.log to true. Then, logging information will appear in Firefox's Browser Console (Tools ➤ Browser Tools ➤ Browser Console) when search plugins are added.Reference Material
OpenSearch Documentation
Safari 8.0 Release Notes: Quick Website Search
Microsoft Edge Dev Guide: Search provider discovery
The Chromium Projects: Tab to Search
imdb.com has a working osd.xml
Ready2Search - create OpenSearch plugins. Customized Search through Ready2Search
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 21, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nDocument Object Model (DOM)The Document Object Model (DOM) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory. Usually it refers to JavaScript, even though modeling HTML, SVG, or XML documents as objects are not part of the core JavaScript language.
The DOM represents a document with a logical tree. Each branch of the tree ends in a node, and each node contains objects. DOM methods allow programmatic access to the tree. With them, you can change the document's structure, style, or content.
Nodes can also have event handlers attached to them. Once an event is triggered, the event handlers get executed.
To learn more about what the DOM is and how it represents documents, see our article Introduction to the DOM.DOM interfaces
AbortController
AbortSignal
AbstractRange
Attr
CDATASection
CharacterData
Comment
CustomEvent
Document
DocumentFragment
DocumentType
DOMError 
Deprecated

DOMException
DOMImplementation
DOMParser
DOMPoint
DOMPointReadOnly
DOMRect
DOMTokenList
Element
Event
EventTarget
HTMLCollection
MutationObserver
MutationRecord
NamedNodeMap
Node
NodeIterator
NodeList
ProcessingInstruction
Range
StaticRange
Text
TextDecoder
TextEncoder
TimeRanges
TreeWalker
XMLDocument
Obsolete DOM interfacesThe Document Object Model has been highly simplified. To achieve this, the following interfaces in the different DOM level 3 or earlier specifications have been removed. They are no longer available to web developers.

DOMConfiguration
DOMErrorHandler
DOMImplementationList
DOMImplementationRegistry
DOMImplementationSource
DOMLocator
DOMObject
DOMSettableTokenList
DOMUserData
ElementTraversal
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler
HTML DOMA document containing HTML is described using the Document interface, which is extended by the HTML specification to include various HTML-specific features. In particular, the Element interface is enhanced to become HTMLElement and various subclasses, each representing one of (or a family of closely related) elements.
The HTML DOM API provides access to various browser features such as tabs and windows, CSS styles and stylesheets, browser history, etc. These interfaces are discussed further in the HTML DOM API documentation.SVG DOMSimilarly, a document containing SVG is also described using the Document interface, which is extended by the SVG specification to include various SVG-specific features. In particular, the Element interface is enhanced to become SVGElement and various subclasses, each representing an element or a family of closely related elements. These interfaces are discussed further in the SVG API documentation.SpecificationsSpecificationDOM See also
DOM Examples
CSS Object Model (CSSOM)\n\nDocument Object Model (DOM)The Document Object Model (DOM) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory. Usually it refers to JavaScript, even though modeling HTML, SVG, or XML documents as objects are not part of the core JavaScript language.
The DOM represents a document with a logical tree. Each branch of the tree ends in a node, and each node contains objects. DOM methods allow programmatic access to the tree. With them, you can change the document's structure, style, or content.
Nodes can also have event handlers attached to them. Once an event is triggered, the event handlers get executed.
To learn more about what the DOM is and how it represents documents, see our article Introduction to the DOM.DOM interfaces
AbortController
AbortSignal
AbstractRange
Attr
CDATASection
CharacterData
Comment
CustomEvent
Document
DocumentFragment
DocumentType
DOMError 
Deprecated

DOMException
DOMImplementation
DOMParser
DOMPoint
DOMPointReadOnly
DOMRect
DOMTokenList
Element
Event
EventTarget
HTMLCollection
MutationObserver
MutationRecord
NamedNodeMap
Node
NodeIterator
NodeList
ProcessingInstruction
Range
StaticRange
Text
TextDecoder
TextEncoder
TimeRanges
TreeWalker
XMLDocument
Obsolete DOM interfacesThe Document Object Model has been highly simplified. To achieve this, the following interfaces in the different DOM level 3 or earlier specifications have been removed. They are no longer available to web developers.

DOMConfiguration
DOMErrorHandler
DOMImplementationList
DOMImplementationRegistry
DOMImplementationSource
DOMLocator
DOMObject
DOMSettableTokenList
DOMUserData
ElementTraversal
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler
HTML DOMA document containing HTML is described using the Document interface, which is extended by the HTML specification to include various HTML-specific features. In particular, the Element interface is enhanced to become HTMLElement and various subclasses, each representing one of (or a family of closely related) elements.
The HTML DOM API provides access to various browser features such as tabs and windows, CSS styles and stylesheets, browser history, etc. These interfaces are discussed further in the HTML DOM API documentation.SVG DOMSimilarly, a document containing SVG is also described using the Document interface, which is extended by the SVG specification to include various SVG-specific features. In particular, the Element interface is enhanced to become SVGElement and various subclasses, each representing an element or a family of closely related elements. These interfaces are discussed further in the SVG API documentation.SpecificationsSpecificationDOM See also
DOM Examples
CSS Object Model (CSSOM)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 17, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nDocument Object Model (DOM)The Document Object Model (DOM) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory. Usually it refers to JavaScript, even though modeling HTML, SVG, or XML documents as objects are not part of the core JavaScript language.
The DOM represents a document with a logical tree. Each branch of the tree ends in a node, and each node contains objects. DOM methods allow programmatic access to the tree. With them, you can change the document's structure, style, or content.
Nodes can also have event handlers attached to them. Once an event is triggered, the event handlers get executed.
To learn more about what the DOM is and how it represents documents, see our article Introduction to the DOM.DOM interfaces
AbortController
AbortSignal
AbstractRange
Attr
CDATASection
CharacterData
Comment
CustomEvent
Document
DocumentFragment
DocumentType
DOMError 
Deprecated

DOMException
DOMImplementation
DOMParser
DOMPoint
DOMPointReadOnly
DOMRect
DOMTokenList
Element
Event
EventTarget
HTMLCollection
MutationObserver
MutationRecord
NamedNodeMap
Node
NodeIterator
NodeList
ProcessingInstruction
Range
StaticRange
Text
TextDecoder
TextEncoder
TimeRanges
TreeWalker
XMLDocument
Obsolete DOM interfacesThe Document Object Model has been highly simplified. To achieve this, the following interfaces in the different DOM level 3 or earlier specifications have been removed. They are no longer available to web developers.

DOMConfiguration
DOMErrorHandler
DOMImplementationList
DOMImplementationRegistry
DOMImplementationSource
DOMLocator
DOMObject
DOMSettableTokenList
DOMUserData
ElementTraversal
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler
HTML DOMA document containing HTML is described using the Document interface, which is extended by the HTML specification to include various HTML-specific features. In particular, the Element interface is enhanced to become HTMLElement and various subclasses, each representing one of (or a family of closely related) elements.
The HTML DOM API provides access to various browser features such as tabs and windows, CSS styles and stylesheets, browser history, etc. These interfaces are discussed further in the HTML DOM API documentation.SVG DOMSimilarly, a document containing SVG is also described using the Document interface, which is extended by the SVG specification to include various SVG-specific features. In particular, the Element interface is enhanced to become SVGElement and various subclasses, each representing an element or a family of closely related elements. These interfaces are discussed further in the SVG API documentation.SpecificationsSpecificationDOM See also
DOM Examples
CSS Object Model (CSSOM)
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Dec 17, 2023 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.
Although the process is referred to as "transformation," the original document is not changed; rather, a new XML document is created based on the content of an existing document. Then, the new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text.
XSLT is most often used to convert data between different XML schemas or to convert XML data into web pages or PDF documents.DocumentationReference
XSLT elements reference

This page describes XSLT elements, focusing on top-level elements used in <xsl:stylesheet> or <xsl:transform> and instructions for templates.
It also briefly covers literal result elements (LREs), which copy non-instruction elements like <hr> directly to the output, and attribute value templates that use XPath expressions to set attribute values.

Guides
Transforming XML with XSLT

XSLT allows a stylesheet author to transform a primary XML document in two significant ways: manipulating and sorting the content, including a wholesale reordering of it if so desired, and transforming the content into a different format.

Specifying parameters using processing instructions

Firefox allows stylesheet parameters to be specified when using the <?xml-stylesheet?> processing instruction. This is done using the <?xslt-param?> PI described in this document.

Common XSLT Errors

This article lists some common problems using XSLT in Firefox.

Related topics
XML
XPath
See also
W3Schools XSLT Introduction

This tutorial teaches the reader how to use XSLT to transform XML documents into other formats, like XHTML.

What is XSLT?

This extensive introduction to XSLT and XPath assumes no prior knowledge of the technologies and guides the reader through background, context, structure, concepts and introductory terminology.\n\nXSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.
Although the process is referred to as "transformation," the original document is not changed; rather, a new XML document is created based on the content of an existing document. Then, the new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text.
XSLT is most often used to convert data between different XML schemas or to convert XML data into web pages or PDF documents.DocumentationReference
XSLT elements reference

This page describes XSLT elements, focusing on top-level elements used in <xsl:stylesheet> or <xsl:transform> and instructions for templates.
It also briefly covers literal result elements (LREs), which copy non-instruction elements like <hr> directly to the output, and attribute value templates that use XPath expressions to set attribute values.

Guides
Transforming XML with XSLT

XSLT allows a stylesheet author to transform a primary XML document in two significant ways: manipulating and sorting the content, including a wholesale reordering of it if so desired, and transforming the content into a different format.

Specifying parameters using processing instructions

Firefox allows stylesheet parameters to be specified when using the <?xml-stylesheet?> processing instruction. This is done using the <?xslt-param?> PI described in this document.

Common XSLT Errors

This article lists some common problems using XSLT in Firefox.

Related topics
XML
XPath
See also
W3Schools XSLT Introduction

This tutorial teaches the reader how to use XSLT to transform XML documents into other formats, like XHTML.

What is XSLT?

This extensive introduction to XSLT and XPath assumes no prior knowledge of the technologies and guides the reader through background, context, structure, concepts and introductory terminology.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXSLT: Extensible Stylesheet Language TransformationsExtensible Stylesheet Language Transformations (XSLT) is an XML-based language used, in conjunction with specialized processing software, for the transformation of XML documents.
Although the process is referred to as "transformation," the original document is not changed; rather, a new XML document is created based on the content of an existing document. Then, the new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text.
XSLT is most often used to convert data between different XML schemas or to convert XML data into web pages or PDF documents.DocumentationReference
XSLT elements reference

This page describes XSLT elements, focusing on top-level elements used in <xsl:stylesheet> or <xsl:transform> and instructions for templates.
It also briefly covers literal result elements (LREs), which copy non-instruction elements like <hr> directly to the output, and attribute value templates that use XPath expressions to set attribute values.

Guides
Transforming XML with XSLT

XSLT allows a stylesheet author to transform a primary XML document in two significant ways: manipulating and sorting the content, including a wholesale reordering of it if so desired, and transforming the content into a different format.

Specifying parameters using processing instructions

Firefox allows stylesheet parameters to be specified when using the <?xml-stylesheet?> processing instruction. This is done using the <?xslt-param?> PI described in this document.

Common XSLT Errors

This article lists some common problems using XSLT in Firefox.

Related topics
XML
XPath
See also
W3Schools XSLT Introduction

This tutorial teaches the reader how to use XSLT to transform XML documents into other formats, like XHTML.

What is XSLT?

This extensive introduction to XSLT and XPath assumes no prior knowledge of the technologies and guides the reader through background, context, structure, concepts and introductory terminology.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXML introductionXML (Extensible Markup Language) is a markup language similar to HTML, but without predefined tags to use. Instead, you define your own tags designed specifically for your needs. This is a powerful way to store data in a format that can be stored, searched, and shared. Most importantly, since the fundamental format of XML is standardized, if you share or transmit XML across systems or platforms, either locally or over the internet, the recipient can still parse the data due to the standardized XML syntax.
There are many languages based on XML, including XHTML, MathML, SVG, RSS, and RDF. You can also define your own.Structure of an XML documentThe whole structure of XML and XML-based languages is built on tags.XML declarationXML - declaration is not a tag. It is used for the transmission of the meta-data of a document.
html<?xml version="1.0" encoding="UTF-8"?>

Attributes

version

Used version XML in this document.

encoding

Used encoding in this document.

Commentshtml<!-- Comment -->
"Correct" XML (valid and well-formed)Correct design rulesFor an XML document to be correct, the following conditions must be fulfilled:

Document must be well-formed.
Document must conform to all XML syntax rules.
Document must conform to semantic rules, which are usually set in an XML schema or a DTD (Document Type Definition).
Examplexml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
        Hello World
    <!--missing </warning> -->
</message>

Now let's look at a corrected version of that same document:
xml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
         Hello World
    </warning>
</message>

A document that contains an undefined tag is invalid. For example, if we never defined the <warning> tag, the document above wouldn't be valid.
Most browsers offer a debugger that can identify poorly-formed XML documents.Character referencesLike HTML, XML offers character references for referring to some special reserved characters (such as a greater than sign which is used for tags). There are five of these characters that you should know:



Entity
Character
Description




&lt;
<
Less than sign


&gt;
>
Greater than sign


&amp;
&
Ampersand


&quot;
"
One double-quotation mark


&apos;
'
One apostrophe (or single-quotation mark)



Even though there are only 5 declared character references, or entities, more can be added using the document's Document Type Definition. For example, to create a new &warning; entity, you can do this:
xml<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE body [
  <!ENTITY warning "Warning: Something bad happened... please refresh and try again.">
]>
<body>
  <message> &warning; </message>
</body>

You can also use numeric character references to specify special characters; for example, &#xA9; is the "©" symbol.Displaying XMLXML is usually used for descriptive purposes, but there are ways to display XML data. If you don't define a specific way for the XML to be rendered, the raw XML is displayed in the browser.
One way to style XML output is to specify CSS to apply to the document using the xml-stylesheet processing instruction.
xml<?xml-stylesheet type="text/css" href="stylesheet.css"?>

There is also another more powerful way to display XML: the Extensible Stylesheet Language Transformations (XSLT) which can be used to transform XML into other languages such as HTML. This makes XML incredibly versatile.
xml<?xml-stylesheet type="text/xsl" href="transform.xsl"?>
RecommendationsThis article is obviously only a very brief introduction to what XML is, with a few small examples and references to get you started. For more details about XML, you should look around on the Web for more in-depth articles.
Learning the HyperText Markup Language (HTML) will help you better understand XML.See also
XML.com
Extensible Markup Language (XML) @ W3.org
Using XML: A List Apart\n\nXML introductionXML (Extensible Markup Language) is a markup language similar to HTML, but without predefined tags to use. Instead, you define your own tags designed specifically for your needs. This is a powerful way to store data in a format that can be stored, searched, and shared. Most importantly, since the fundamental format of XML is standardized, if you share or transmit XML across systems or platforms, either locally or over the internet, the recipient can still parse the data due to the standardized XML syntax.
There are many languages based on XML, including XHTML, MathML, SVG, RSS, and RDF. You can also define your own.Structure of an XML documentThe whole structure of XML and XML-based languages is built on tags.XML declarationXML - declaration is not a tag. It is used for the transmission of the meta-data of a document.
html<?xml version="1.0" encoding="UTF-8"?>

Attributes

version

Used version XML in this document.

encoding

Used encoding in this document.

Commentshtml<!-- Comment -->
"Correct" XML (valid and well-formed)Correct design rulesFor an XML document to be correct, the following conditions must be fulfilled:

Document must be well-formed.
Document must conform to all XML syntax rules.
Document must conform to semantic rules, which are usually set in an XML schema or a DTD (Document Type Definition).
Examplexml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
        Hello World
    <!--missing </warning> -->
</message>

Now let's look at a corrected version of that same document:
xml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
         Hello World
    </warning>
</message>

A document that contains an undefined tag is invalid. For example, if we never defined the <warning> tag, the document above wouldn't be valid.
Most browsers offer a debugger that can identify poorly-formed XML documents.Character referencesLike HTML, XML offers character references for referring to some special reserved characters (such as a greater than sign which is used for tags). There are five of these characters that you should know:



Entity
Character
Description




&lt;
<
Less than sign


&gt;
>
Greater than sign


&amp;
&
Ampersand


&quot;
"
One double-quotation mark


&apos;
'
One apostrophe (or single-quotation mark)



Even though there are only 5 declared character references, or entities, more can be added using the document's Document Type Definition. For example, to create a new &warning; entity, you can do this:
xml<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE body [
  <!ENTITY warning "Warning: Something bad happened... please refresh and try again.">
]>
<body>
  <message> &warning; </message>
</body>

You can also use numeric character references to specify special characters; for example, &#xA9; is the "©" symbol.Displaying XMLXML is usually used for descriptive purposes, but there are ways to display XML data. If you don't define a specific way for the XML to be rendered, the raw XML is displayed in the browser.
One way to style XML output is to specify CSS to apply to the document using the xml-stylesheet processing instruction.
xml<?xml-stylesheet type="text/css" href="stylesheet.css"?>

There is also another more powerful way to display XML: the Extensible Stylesheet Language Transformations (XSLT) which can be used to transform XML into other languages such as HTML. This makes XML incredibly versatile.
xml<?xml-stylesheet type="text/xsl" href="transform.xsl"?>
RecommendationsThis article is obviously only a very brief introduction to what XML is, with a few small examples and references to get you started. For more details about XML, you should look around on the Web for more in-depth articles.
Learning the HyperText Markup Language (HTML) will help you better understand XML.See also
XML.com
Extensible Markup Language (XML) @ W3.org
Using XML: A List Apart
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXML introductionXML (Extensible Markup Language) is a markup language similar to HTML, but without predefined tags to use. Instead, you define your own tags designed specifically for your needs. This is a powerful way to store data in a format that can be stored, searched, and shared. Most importantly, since the fundamental format of XML is standardized, if you share or transmit XML across systems or platforms, either locally or over the internet, the recipient can still parse the data due to the standardized XML syntax.
There are many languages based on XML, including XHTML, MathML, SVG, RSS, and RDF. You can also define your own.Structure of an XML documentThe whole structure of XML and XML-based languages is built on tags.XML declarationXML - declaration is not a tag. It is used for the transmission of the meta-data of a document.
html<?xml version="1.0" encoding="UTF-8"?>

Attributes

version

Used version XML in this document.

encoding

Used encoding in this document.

Commentshtml<!-- Comment -->
"Correct" XML (valid and well-formed)Correct design rulesFor an XML document to be correct, the following conditions must be fulfilled:

Document must be well-formed.
Document must conform to all XML syntax rules.
Document must conform to semantic rules, which are usually set in an XML schema or a DTD (Document Type Definition).
Examplexml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
        Hello World
    <!--missing </warning> -->
</message>

Now let's look at a corrected version of that same document:
xml<?xml version="1.0" encoding="UTF-8"?>
<message>
    <warning>
         Hello World
    </warning>
</message>

A document that contains an undefined tag is invalid. For example, if we never defined the <warning> tag, the document above wouldn't be valid.
Most browsers offer a debugger that can identify poorly-formed XML documents.Character referencesLike HTML, XML offers character references for referring to some special reserved characters (such as a greater than sign which is used for tags). There are five of these characters that you should know:



Entity
Character
Description




&lt;
<
Less than sign


&gt;
>
Greater than sign


&amp;
&
Ampersand


&quot;
"
One double-quotation mark


&apos;
'
One apostrophe (or single-quotation mark)



Even though there are only 5 declared character references, or entities, more can be added using the document's Document Type Definition. For example, to create a new &warning; entity, you can do this:
xml<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE body [
  <!ENTITY warning "Warning: Something bad happened... please refresh and try again.">
]>
<body>
  <message> &warning; </message>
</body>

You can also use numeric character references to specify special characters; for example, &#xA9; is the "©" symbol.Displaying XMLXML is usually used for descriptive purposes, but there are ways to display XML data. If you don't define a specific way for the XML to be rendered, the raw XML is displayed in the browser.
One way to style XML output is to specify CSS to apply to the document using the xml-stylesheet processing instruction.
xml<?xml-stylesheet type="text/css" href="stylesheet.css"?>

There is also another more powerful way to display XML: the Extensible Stylesheet Language Transformations (XSLT) which can be used to transform XML into other languages such as HTML. This makes XML incredibly versatile.
xml<?xml-stylesheet type="text/xsl" href="transform.xsl"?>
RecommendationsThis article is obviously only a very brief introduction to what XML is, with a few small examples and references to get you started. For more details about XML, you should look around on the Web for more in-depth articles.
Learning the HyperText Markup Language (HTML) will help you better understand XML.See also
XML.com
Extensible Markup Language (XML) @ W3.org
Using XML: A List Apart
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nXPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.
XPath is mainly used in XSLT, but can also be used as a much more powerful way of navigating through the DOM of any XML-like language document using XPathExpression, such as HTML and SVG, instead of relying on the Document.getElementById() or Document.querySelectorAll() methods, the Node.childNodes properties, and other DOM Core features.
XPath uses a path notation (as in URLs) for navigating through the hierarchical structure of an XML document. It uses a non-XML syntax so that it can be used in URIs and XML attribute values.Guides
Introduction to using XPath in JavaScript

Describes a non-XSLT use of XPath.

XPath snippets

These are JavaScript utility functions, that can be used in your own code, based on DOM Level 3 XPath APIs.

Reference
XPath:Axes

List and definition of the axes defined in the XPath specification. Axes are used to describe the relationships between nodes.

XPath:Functions

List and description of the core XPath functions and XSLT-specific additions to XPath.

See also
XSLT, XML, DOM
Transforming XML with XSLT
Comparison of CSS Selectors and XPath
What is XSLT? introduces XSLT and XPath, including background, context, structure, concepts, and terminology - xml.com (2000)
XPath tester online XPath Builder/Debugger\n\nXPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.
XPath is mainly used in XSLT, but can also be used as a much more powerful way of navigating through the DOM of any XML-like language document using XPathExpression, such as HTML and SVG, instead of relying on the Document.getElementById() or Document.querySelectorAll() methods, the Node.childNodes properties, and other DOM Core features.
XPath uses a path notation (as in URLs) for navigating through the hierarchical structure of an XML document. It uses a non-XML syntax so that it can be used in URIs and XML attribute values.Guides
Introduction to using XPath in JavaScript

Describes a non-XSLT use of XPath.

XPath snippets

These are JavaScript utility functions, that can be used in your own code, based on DOM Level 3 XPath APIs.

Reference
XPath:Axes

List and definition of the axes defined in the XPath specification. Axes are used to describe the relationships between nodes.

XPath:Functions

List and description of the core XPath functions and XSLT-specific additions to XPath.

See also
XSLT, XML, DOM
Transforming XML with XSLT
Comparison of CSS Selectors and XPath
What is XSLT? introduces XSLT and XPath, including background, context, structure, concepts, and terminology - xml.com (2000)
XPath tester online XPath Builder/Debugger
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nXPathXPath stands for XML Path Language. It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. It can also be used to test addressed nodes within a document to determine whether they match a pattern or not.
XPath is mainly used in XSLT, but can also be used as a much more powerful way of navigating through the DOM of any XML-like language document using XPathExpression, such as HTML and SVG, instead of relying on the Document.getElementById() or Document.querySelectorAll() methods, the Node.childNodes properties, and other DOM Core features.
XPath uses a path notation (as in URLs) for navigating through the hierarchical structure of an XML document. It uses a non-XML syntax so that it can be used in URIs and XML attribute values.Guides
Introduction to using XPath in JavaScript

Describes a non-XSLT use of XPath.

XPath snippets

These are JavaScript utility functions, that can be used in your own code, based on DOM Level 3 XPath APIs.

Reference
XPath:Axes

List and definition of the axes defined in the XPath specification. Axes are used to describe the relationships between nodes.

XPath:Functions

List and description of the core XPath functions and XSLT-specific additions to XPath.

See also
XSLT, XML, DOM
Transforming XML with XSLT
Comparison of CSS Selectors and XPath
What is XSLT? introduces XSLT and XPath, including background, context, structure, concepts, and terminology - xml.com (2000)
XPath tester online XPath Builder/Debugger
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Feb 5, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nEXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:EXSLT modulesTo use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function. For example, to use the regular expressions package:
xml<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:regexp="http://exslt.org/regular-expressions">
  <xsl:template match="/">
    …
    <xsl:value-of select="regexp:replace(/root/@value, 'before', 'gi', 'AFTER')"/>
    …
  </xsl:template>

</xsl:stylesheet>
CommonThe EXSLT Common package provides basic functions that expand upon the capabilities of XSLT. The namespace for the Common package is http://exslt.org/common.
Functions

exsl:node-set()
exsl:object-type()
MathThe EXSLT Math package provides functions for working with numeric values and comparing nodes. The namespace for the Math package is http://exslt.org/math.
Functions

math:highest()
math:lowest()
math:max()
math:min()
Regular expressionsThe EXSLT Regular Expressions package provides functions that allow testing, matching, and replacing text using JavaScript style regular expressions.
The EXSLT Regular Expressions namespace is http://exslt.org/regular-expressions.
Functions

regexp:match()
regexp:replace()
regexp:test()
SetsThe EXSLT Sets package offers functions that let you perform set manipulation. The namespace for these functions is http://exslt.org/sets.
Functions

set:difference()
set:distinct()
set:intersection()
set:has-same-node()
set:leading()
set:trailing()
StringsThe EXSLT Strings package provides functions that allow the manipulation of strings. The namespace for the Strings package is http://exslt.org/strings.
Functions

str:concat()
str:split()
str:tokenize()
See also
EXSLT website\n\nEXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:EXSLT modulesTo use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function. For example, to use the regular expressions package:
xml<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:regexp="http://exslt.org/regular-expressions">
  <xsl:template match="/">
    …
    <xsl:value-of select="regexp:replace(/root/@value, 'before', 'gi', 'AFTER')"/>
    …
  </xsl:template>

</xsl:stylesheet>
CommonThe EXSLT Common package provides basic functions that expand upon the capabilities of XSLT. The namespace for the Common package is http://exslt.org/common.
Functions

exsl:node-set()
exsl:object-type()
MathThe EXSLT Math package provides functions for working with numeric values and comparing nodes. The namespace for the Math package is http://exslt.org/math.
Functions

math:highest()
math:lowest()
math:max()
math:min()
Regular expressionsThe EXSLT Regular Expressions package provides functions that allow testing, matching, and replacing text using JavaScript style regular expressions.
The EXSLT Regular Expressions namespace is http://exslt.org/regular-expressions.
Functions

regexp:match()
regexp:replace()
regexp:test()
SetsThe EXSLT Sets package offers functions that let you perform set manipulation. The namespace for these functions is http://exslt.org/sets.
Functions

set:difference()
set:distinct()
set:intersection()
set:has-same-node()
set:leading()
set:trailing()
StringsThe EXSLT Strings package provides functions that allow the manipulation of strings. The namespace for the Strings package is http://exslt.org/strings.
Functions

str:concat()
str:split()
str:tokenize()
See also
EXSLT website
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 8, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nEXSLTEXSLT is a set of extensions to XSLT. There are a number of modules; those that are supported by Firefox are listed below:EXSLT modulesTo use an EXSLT function, you need to declare the namespace the function is in, and then use the appropriate prefix when calling the function. For example, to use the regular expressions package:
xml<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:regexp="http://exslt.org/regular-expressions">
  <xsl:template match="/">
    …
    <xsl:value-of select="regexp:replace(/root/@value, 'before', 'gi', 'AFTER')"/>
    …
  </xsl:template>

</xsl:stylesheet>
CommonThe EXSLT Common package provides basic functions that expand upon the capabilities of XSLT. The namespace for the Common package is http://exslt.org/common.
Functions

exsl:node-set()
exsl:object-type()
MathThe EXSLT Math package provides functions for working with numeric values and comparing nodes. The namespace for the Math package is http://exslt.org/math.
Functions

math:highest()
math:lowest()
math:max()
math:min()
Regular expressionsThe EXSLT Regular Expressions package provides functions that allow testing, matching, and replacing text using JavaScript style regular expressions.
The EXSLT Regular Expressions namespace is http://exslt.org/regular-expressions.
Functions

regexp:match()
regexp:replace()
regexp:test()
SetsThe EXSLT Sets package offers functions that let you perform set manipulation. The namespace for these functions is http://exslt.org/sets.
Functions

set:difference()
set:distinct()
set:intersection()
set:has-same-node()
set:leading()
set:trailing()
StringsThe EXSLT Strings package provides functions that allow the manipulation of strings. The namespace for the Strings package is http://exslt.org/strings.
Functions

str:concat()
str:split()
str:tokenize()
See also
EXSLT website
Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Mar 8, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) ist der grundlegendste Baustein des Webs. Es definiert die Bedeutung und Struktur von Webinhalten. Neben HTML werden in der Regel andere Technologien verwendet, um das Erscheinungsbild/Präsentation einer Webseite zu beschreiben (CSS) oder die Funktionalität/Verhalten (JavaScript).
"Hypertext" bezieht sich auf Links, die Webseiten miteinander verbinden, entweder innerhalb einer einzigen Website oder zwischen Websites. Links sind ein grundlegender Aspekt des Webs. Indem Sie Inhalte ins Internet hochladen und mit von anderen erstellten Seiten verlinken, werden Sie ein aktiver Teilnehmer des World Wide Web.
HTML verwendet "Markup", um Text, Bilder und andere Inhalte für die Anzeige in einem Webbrowser zu annotieren. HTML-Markup umfasst spezielle "Elemente" wie <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> und viele andere.
Ein HTML-Element wird durch "Tags" von anderem Text in einem Dokument abgegrenzt, die aus dem Elementnamen bestehen, umgeben von < und >. Der Name eines Elements innerhalb eines Tags ist nicht case-sensitiv. Das bedeutet, er kann in Großbuchstaben, Kleinbuchstaben oder einer Mischung geschrieben werden. Zum Beispiel kann das <title>-Tag als <Title>, <TITLE> oder in irgendeiner anderen Weise geschrieben werden. Die Konvention und empfohlene Praxis ist jedoch, Tags in Kleinbuchstaben zu schreiben.
Die unten stehenden Artikel können Ihnen helfen, mehr über HTML zu lernen.Tutorials für Anfänger
Ihre erste Website: Erstellen der Inhalte

Dieser Artikel bietet eine kurze Einführung in das, was HTML ist und wie man es verwendet, und richtet sich an Personen, die völlig neu in der Webentwicklung sind.

Inhalte mit HTML strukturieren

Unser Leitfaden zur Webentwicklung im HTML-Modul vermittelt alle HTML-Grundlagen von Grund auf.

Leitfäden
HTML-Formulare

Formulare sind ein sehr wichtiger Bestandteil des Webs - sie bieten viel der Funktionalität, die Sie für die Interaktion mit Websites benötigen, z. B. Registrierung und Anmeldung, Feedback senden, Produkte kaufen und mehr. Dieses Modul gibt Ihnen eine Einführung in die Erstellung der clientseitigen/front-end Teile von Formularen.

CORS-fähiges Bild

Das Attribut crossorigin ermöglicht es zusammen mit einem geeigneten CORS-Header, dass Bilder, die durch das <img>-Element definiert sind, von fremden Ursprüngen geladen und in einem <canvas>-Element verwendet werden können, als ob sie vom aktuellen Ursprung geladen würden.

CORS-Einstellungen für Attribute

Einige HTML-Elemente, die Unterstützung für CORS bieten, wie <img> oder <video>, haben ein crossorigin-Attribut (crossOrigin-Eigenschaft), das Ihnen erlaubt, die CORS-Anfragen für die abgerufenen Daten des Elements zu konfigurieren.

Inhalte mit rel="preload" vorladen

Der preload-Wert des rel-Attributs des <link>-Elements ermöglicht es Ihnen, deklarative Abrufanforderungen in Ihr HTML-<head> zu schreiben. Dabei geben Sie Ressourcen an, die Ihre Seiten sehr bald nach dem Laden benötigen und die Sie daher frühzeitig im Lebenszyklus eines Seitenladevorgangs vorladen möchten, bevor der Hauptbrowser-Rendering-Mechanismus einsetzt. Dies stellt sicher, dass sie früher verfügbar gemacht und die erste Darstellung der Seite weniger wahrscheinlich blockiert wird, was zu Leistungsverbesserungen führt. Dieser Artikel bietet einen grundlegenden Leitfaden dazu, wie preload funktioniert.

Responsive Bilder

In diesem Artikel werden wir das Konzept der responsiven Bilder erlernen - Bilder, die gut auf Geräten mit stark unterschiedlichen Bildschirmgrößen, Auflösungen und anderen ähnlichen Merkmalen funktionieren - und sehen, welche Werkzeuge HTML bietet, um sie zu implementieren. Dies hilft, die Leistung auf verschiedenen Geräten zu verbessern.

Referenz
HTML-Referenz

HTML besteht aus Elementen, von denen jedes durch eine Anzahl von Attributen modifiziert werden kann. HTML-Dokumente sind durch Links miteinander verbunden.

HTML-Element-Referenz

Durchsuchen Sie eine Liste aller HTML-Elemente.

HTML-Attribut-Referenz

Elemente in HTML haben Attribute. Diese sind zusätzliche Werte, die die Elemente konfigurieren oder deren Verhalten auf verschiedene Arten anpassen.

Globale Attribute

Globale Attribute können auf alle HTML-Elemente angewendet werden, selbst auf die, die nicht im Standard spezifiziert sind. Dies bedeutet, dass alle nicht standardisierten Elemente trotzdem diese Attribute erlauben müssen, auch wenn diese Elemente das Dokument HTML5-nichtkonform machen.

Inline-Level-Elemente und Block-Level-Elemente

HTML-Elemente sind in der Regel "Inline-Level"- oder "Block-Level"-Elemente. Ein Inline-Level-Element nimmt nur den Platz ein, der durch die Tags definiert wird, die es umgeben. Ein Block-Level-Element nimmt den gesamten Platz seines übergeordneten Elements (Containers) ein und bildet so eine "Blockbox".

HTML-Kommentare

HTML-Kommentare werden verwendet, um erklärende Anmerkungen zum Markup hinzuzufügen oder zu verhindern, dass der Browser bestimmte Teile des Dokuments interpretiert.

Leitfaden zu Medientypen und -formaten im Web

Die <audio>- und <video>-Elemente ermöglichen es Ihnen, Audio- und Videomedien nativ innerhalb Ihrer Inhalte abzuspielen, ohne dass eine externe Softwareunterstützung erforderlich ist.

HTML-Inhaltskategorien

HTML besteht aus verschiedenen Arten von Inhalten, die jeweils in bestimmten Kontexten verwendet werden dürfen und in anderen nicht. Ebenso hat jeder Kontext eine Reihe von anderen Inhaltskategorien, die er enthalten kann, und Elemente, die darin verwendet werden dürfen oder nicht. Dies ist ein Leitfaden zu diesen Kategorien.

Quirks-Modus und Standardsmodus

Historische Informationen über den Quirks-Modus und den Standardsmodus.

Verwandte Themen
Farbe auf HTML-Elemente mit CSS anwenden

Dieser Artikel behandelt die meisten Methoden, mit denen Sie CSS verwenden, um Farbe zu HTML-Inhalten hinzuzufügen, und listet auf, welche Teile von HTML-Dokumenten farbig gestaltet werden können und welche CSS-Eigenschaften dabei verwendet werden.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) ist der grundlegendste Baustein des Webs. Es definiert die Bedeutung und Struktur von Webinhalten. Neben HTML werden in der Regel andere Technologien verwendet, um das Erscheinungsbild/Präsentation einer Webseite zu beschreiben (CSS) oder die Funktionalität/Verhalten (JavaScript).
"Hypertext" bezieht sich auf Links, die Webseiten miteinander verbinden, entweder innerhalb einer einzigen Website oder zwischen Websites. Links sind ein grundlegender Aspekt des Webs. Indem Sie Inhalte ins Internet hochladen und mit von anderen erstellten Seiten verlinken, werden Sie ein aktiver Teilnehmer des World Wide Web.
HTML verwendet "Markup", um Text, Bilder und andere Inhalte für die Anzeige in einem Webbrowser zu annotieren. HTML-Markup umfasst spezielle "Elemente" wie <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> und viele andere.
Ein HTML-Element wird durch "Tags" von anderem Text in einem Dokument abgegrenzt, die aus dem Elementnamen bestehen, umgeben von < und >. Der Name eines Elements innerhalb eines Tags ist nicht case-sensitiv. Das bedeutet, er kann in Großbuchstaben, Kleinbuchstaben oder einer Mischung geschrieben werden. Zum Beispiel kann das <title>-Tag als <Title>, <TITLE> oder in irgendeiner anderen Weise geschrieben werden. Die Konvention und empfohlene Praxis ist jedoch, Tags in Kleinbuchstaben zu schreiben.
Die unten stehenden Artikel können Ihnen helfen, mehr über HTML zu lernen.Tutorials für Anfänger
Ihre erste Website: Erstellen der Inhalte

Dieser Artikel bietet eine kurze Einführung in das, was HTML ist und wie man es verwendet, und richtet sich an Personen, die völlig neu in der Webentwicklung sind.

Inhalte mit HTML strukturieren

Unser Leitfaden zur Webentwicklung im HTML-Modul vermittelt alle HTML-Grundlagen von Grund auf.

Leitfäden
HTML-Formulare

Formulare sind ein sehr wichtiger Bestandteil des Webs - sie bieten viel der Funktionalität, die Sie für die Interaktion mit Websites benötigen, z. B. Registrierung und Anmeldung, Feedback senden, Produkte kaufen und mehr. Dieses Modul gibt Ihnen eine Einführung in die Erstellung der clientseitigen/front-end Teile von Formularen.

CORS-fähiges Bild

Das Attribut crossorigin ermöglicht es zusammen mit einem geeigneten CORS-Header, dass Bilder, die durch das <img>-Element definiert sind, von fremden Ursprüngen geladen und in einem <canvas>-Element verwendet werden können, als ob sie vom aktuellen Ursprung geladen würden.

CORS-Einstellungen für Attribute

Einige HTML-Elemente, die Unterstützung für CORS bieten, wie <img> oder <video>, haben ein crossorigin-Attribut (crossOrigin-Eigenschaft), das Ihnen erlaubt, die CORS-Anfragen für die abgerufenen Daten des Elements zu konfigurieren.

Inhalte mit rel="preload" vorladen

Der preload-Wert des rel-Attributs des <link>-Elements ermöglicht es Ihnen, deklarative Abrufanforderungen in Ihr HTML-<head> zu schreiben. Dabei geben Sie Ressourcen an, die Ihre Seiten sehr bald nach dem Laden benötigen und die Sie daher frühzeitig im Lebenszyklus eines Seitenladevorgangs vorladen möchten, bevor der Hauptbrowser-Rendering-Mechanismus einsetzt. Dies stellt sicher, dass sie früher verfügbar gemacht und die erste Darstellung der Seite weniger wahrscheinlich blockiert wird, was zu Leistungsverbesserungen führt. Dieser Artikel bietet einen grundlegenden Leitfaden dazu, wie preload funktioniert.

Responsive Bilder

In diesem Artikel werden wir das Konzept der responsiven Bilder erlernen - Bilder, die gut auf Geräten mit stark unterschiedlichen Bildschirmgrößen, Auflösungen und anderen ähnlichen Merkmalen funktionieren - und sehen, welche Werkzeuge HTML bietet, um sie zu implementieren. Dies hilft, die Leistung auf verschiedenen Geräten zu verbessern.

Referenz
HTML-Referenz

HTML besteht aus Elementen, von denen jedes durch eine Anzahl von Attributen modifiziert werden kann. HTML-Dokumente sind durch Links miteinander verbunden.

HTML-Element-Referenz

Durchsuchen Sie eine Liste aller HTML-Elemente.

HTML-Attribut-Referenz

Elemente in HTML haben Attribute. Diese sind zusätzliche Werte, die die Elemente konfigurieren oder deren Verhalten auf verschiedene Arten anpassen.

Globale Attribute

Globale Attribute können auf alle HTML-Elemente angewendet werden, selbst auf die, die nicht im Standard spezifiziert sind. Dies bedeutet, dass alle nicht standardisierten Elemente trotzdem diese Attribute erlauben müssen, auch wenn diese Elemente das Dokument HTML5-nichtkonform machen.

Inline-Level-Elemente und Block-Level-Elemente

HTML-Elemente sind in der Regel "Inline-Level"- oder "Block-Level"-Elemente. Ein Inline-Level-Element nimmt nur den Platz ein, der durch die Tags definiert wird, die es umgeben. Ein Block-Level-Element nimmt den gesamten Platz seines übergeordneten Elements (Containers) ein und bildet so eine "Blockbox".

HTML-Kommentare

HTML-Kommentare werden verwendet, um erklärende Anmerkungen zum Markup hinzuzufügen oder zu verhindern, dass der Browser bestimmte Teile des Dokuments interpretiert.

Leitfaden zu Medientypen und -formaten im Web

Die <audio>- und <video>-Elemente ermöglichen es Ihnen, Audio- und Videomedien nativ innerhalb Ihrer Inhalte abzuspielen, ohne dass eine externe Softwareunterstützung erforderlich ist.

HTML-Inhaltskategorien

HTML besteht aus verschiedenen Arten von Inhalten, die jeweils in bestimmten Kontexten verwendet werden dürfen und in anderen nicht. Ebenso hat jeder Kontext eine Reihe von anderen Inhaltskategorien, die er enthalten kann, und Elemente, die darin verwendet werden dürfen oder nicht. Dies ist ein Leitfaden zu diesen Kategorien.

Quirks-Modus und Standardsmodus

Historische Informationen über den Quirks-Modus und den Standardsmodus.

Verwandte Themen
Farbe auf HTML-Elemente mit CSS anwenden

Dieser Artikel behandelt die meisten Methoden, mit denen Sie CSS verwenden, um Farbe zu HTML-Inhalten hinzuzufügen, und listet auf, welche Teile von HTML-Dokumenten farbig gestaltet werden können und welche CSS-Eigenschaften dabei verwendet werden.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) ist der grundlegendste Baustein des Webs. Es definiert die Bedeutung und Struktur von Webinhalten. Neben HTML werden in der Regel andere Technologien verwendet, um das Erscheinungsbild/Präsentation einer Webseite zu beschreiben (CSS) oder die Funktionalität/Verhalten (JavaScript).
"Hypertext" bezieht sich auf Links, die Webseiten miteinander verbinden, entweder innerhalb einer einzigen Website oder zwischen Websites. Links sind ein grundlegender Aspekt des Webs. Indem Sie Inhalte ins Internet hochladen und mit von anderen erstellten Seiten verlinken, werden Sie ein aktiver Teilnehmer des World Wide Web.
HTML verwendet "Markup", um Text, Bilder und andere Inhalte für die Anzeige in einem Webbrowser zu annotieren. HTML-Markup umfasst spezielle "Elemente" wie <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> und viele andere.
Ein HTML-Element wird durch "Tags" von anderem Text in einem Dokument abgegrenzt, die aus dem Elementnamen bestehen, umgeben von < und >. Der Name eines Elements innerhalb eines Tags ist nicht case-sensitiv. Das bedeutet, er kann in Großbuchstaben, Kleinbuchstaben oder einer Mischung geschrieben werden. Zum Beispiel kann das <title>-Tag als <Title>, <TITLE> oder in irgendeiner anderen Weise geschrieben werden. Die Konvention und empfohlene Praxis ist jedoch, Tags in Kleinbuchstaben zu schreiben.
Die unten stehenden Artikel können Ihnen helfen, mehr über HTML zu lernen.Tutorials für Anfänger
Ihre erste Website: Erstellen der Inhalte

Dieser Artikel bietet eine kurze Einführung in das, was HTML ist und wie man es verwendet, und richtet sich an Personen, die völlig neu in der Webentwicklung sind.

Inhalte mit HTML strukturieren

Unser Leitfaden zur Webentwicklung im HTML-Modul vermittelt alle HTML-Grundlagen von Grund auf.

Leitfäden
HTML-Formulare

Formulare sind ein sehr wichtiger Bestandteil des Webs - sie bieten viel der Funktionalität, die Sie für die Interaktion mit Websites benötigen, z. B. Registrierung und Anmeldung, Feedback senden, Produkte kaufen und mehr. Dieses Modul gibt Ihnen eine Einführung in die Erstellung der clientseitigen/front-end Teile von Formularen.

CORS-fähiges Bild

Das Attribut crossorigin ermöglicht es zusammen mit einem geeigneten CORS-Header, dass Bilder, die durch das <img>-Element definiert sind, von fremden Ursprüngen geladen und in einem <canvas>-Element verwendet werden können, als ob sie vom aktuellen Ursprung geladen würden.

CORS-Einstellungen für Attribute

Einige HTML-Elemente, die Unterstützung für CORS bieten, wie <img> oder <video>, haben ein crossorigin-Attribut (crossOrigin-Eigenschaft), das Ihnen erlaubt, die CORS-Anfragen für die abgerufenen Daten des Elements zu konfigurieren.

Inhalte mit rel="preload" vorladen

Der preload-Wert des rel-Attributs des <link>-Elements ermöglicht es Ihnen, deklarative Abrufanforderungen in Ihr HTML-<head> zu schreiben. Dabei geben Sie Ressourcen an, die Ihre Seiten sehr bald nach dem Laden benötigen und die Sie daher frühzeitig im Lebenszyklus eines Seitenladevorgangs vorladen möchten, bevor der Hauptbrowser-Rendering-Mechanismus einsetzt. Dies stellt sicher, dass sie früher verfügbar gemacht und die erste Darstellung der Seite weniger wahrscheinlich blockiert wird, was zu Leistungsverbesserungen führt. Dieser Artikel bietet einen grundlegenden Leitfaden dazu, wie preload funktioniert.

Responsive Bilder

In diesem Artikel werden wir das Konzept der responsiven Bilder erlernen - Bilder, die gut auf Geräten mit stark unterschiedlichen Bildschirmgrößen, Auflösungen und anderen ähnlichen Merkmalen funktionieren - und sehen, welche Werkzeuge HTML bietet, um sie zu implementieren. Dies hilft, die Leistung auf verschiedenen Geräten zu verbessern.

Referenz
HTML-Referenz

HTML besteht aus Elementen, von denen jedes durch eine Anzahl von Attributen modifiziert werden kann. HTML-Dokumente sind durch Links miteinander verbunden.

HTML-Element-Referenz

Durchsuchen Sie eine Liste aller HTML-Elemente.

HTML-Attribut-Referenz

Elemente in HTML haben Attribute. Diese sind zusätzliche Werte, die die Elemente konfigurieren oder deren Verhalten auf verschiedene Arten anpassen.

Globale Attribute

Globale Attribute können auf alle HTML-Elemente angewendet werden, selbst auf die, die nicht im Standard spezifiziert sind. Dies bedeutet, dass alle nicht standardisierten Elemente trotzdem diese Attribute erlauben müssen, auch wenn diese Elemente das Dokument HTML5-nichtkonform machen.

Inline-Level-Elemente und Block-Level-Elemente

HTML-Elemente sind in der Regel "Inline-Level"- oder "Block-Level"-Elemente. Ein Inline-Level-Element nimmt nur den Platz ein, der durch die Tags definiert wird, die es umgeben. Ein Block-Level-Element nimmt den gesamten Platz seines übergeordneten Elements (Containers) ein und bildet so eine "Blockbox".

HTML-Kommentare

HTML-Kommentare werden verwendet, um erklärende Anmerkungen zum Markup hinzuzufügen oder zu verhindern, dass der Browser bestimmte Teile des Dokuments interpretiert.

Leitfaden zu Medientypen und -formaten im Web

Die <audio>- und <video>-Elemente ermöglichen es Ihnen, Audio- und Videomedien nativ innerhalb Ihrer Inhalte abzuspielen, ohne dass eine externe Softwareunterstützung erforderlich ist.

HTML-Inhaltskategorien

HTML besteht aus verschiedenen Arten von Inhalten, die jeweils in bestimmten Kontexten verwendet werden dürfen und in anderen nicht. Ebenso hat jeder Kontext eine Reihe von anderen Inhaltskategorien, die er enthalten kann, und Elemente, die darin verwendet werden dürfen oder nicht. Dies ist ein Leitfaden zu diesen Kategorien.

Quirks-Modus und Standardsmodus

Historische Informationen über den Quirks-Modus und den Standardsmodus.

Verwandte Themen
Farbe auf HTML-Elemente mit CSS anwenden

Dieser Artikel behandelt die meisten Methoden, mit denen Sie CSS verwenden, um Farbe zu HTML-Inhalten hinzuzufügen, und listet auf, welche Teile von HTML-Dokumenten farbig gestaltet werden können und welche CSS-Eigenschaften dabei verwendet werden.

MDN-Feedback-BoxWar diese Übersetzung hilfreich?JaNeinDiese Seite wurde automatisch aus dem Englischen übersetzt.Übersetzung auf GitHub anzeigen • Fehler mit dieser Übersetzung melden\n\n\n\nHTML: Lenguaje de etiquetas de hipertextoHTML (Lenguaje de Marcas de Hipertexto, del inglés HyperText Markup Language) es el componente más básico de la Web. Define el significado y la estructura del contenido web. Además de HTML, generalmente se utilizan otras tecnologías para describir la apariencia/presentación de una página web (CSS) o la funcionalidad/comportamiento (JavaScript).
"Hipertexto" hace referencia a los enlaces que conectan páginas web entre sí, ya sea dentro de un único sitio web o entre sitios web. Los enlaces son un aspecto fundamental de la Web. Al subir contenido a Internet y vincularlo a las páginas creadas por otras personas, te conviertes en un participante activo en la «World Wide Web» (Red Informática Mundial).
HTML utiliza "marcas" para etiquetar texto, imágenes y otro contenido para mostrarlo en un navegador Web. Las marcas HTML incluyen "elementos" especiales como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> y muchos otros.
Un elemento HTML se distingue de otro texto en un documento mediante "etiquetas", que consisten en el nombre del elemento rodeado por "<" y ">". El nombre de un elemento dentro de una etiqueta no distingue entre mayúsculas y minúsculas. Es decir, se puede escribir en mayúsculas, minúsculas o una mezcla. Por ejemplo, la etiqueta <title> se puede escribir como <Title>, <TITLE> o de cualquier otra forma.
Los siguientes artículos pueden ayudarte a obtener más información sobre HTML.Recursos clave
Introducción a HTML

Si eres nuevo en el desarrollo Web, asegúrate de leer el artículo Conceptos básicos de HTML para aprender qué es HTML y cómo usarlo.

Tutoriales HTML

Para ver artículos sobre cómo usar HTML, así como tutoriales y ejemplos completos, consulte el Área de aprendizaje de HTML.

Referencia HTML

En nuestra extensa sección referencia HTML encontrarás los detalles sobre cada elemento y atributo en HTML.




¿Quieres transformarte en un desarrollador de la interfaz de usuario web?
Hemos elaborado un curso que incluye toda la información esencial que necesitas para trabajar hacia tu objetivo.
Empieza aquí
Tutoriales para principiantesEl Área de aprendizaje de HTML incluye varios módulos que enseñan HTML desde cero, sin necesidad de conocimientos previos.

Introducción a HTML

Este módulo prepara el escenario para que te acostumbres a conceptos y sintaxis importantes, tal como la aplicación de HTML al texto, cómo crear hipervínculos y cómo utilizar HTML para estructurar una página web.

Multimedia e inserción

Este módulo explora cómo usar HTML para incluir multimedia en tus páginas web, incluidas las diferentes formas en que se pueden incluir imágenes y cómo insertar video, audio e incluso otras páginas web completas.

tablas HTML

Representar datos tabulares en una página web de una manera comprensible y accesible puede ser un desafío. Este módulo cubre el marcado básico de tablas, junto con características más complejas como la implementación de subtítulos y resúmenes.

Formularios HTML

Los formularios son una parte muy importante de la Web — proporcionan gran parte de la funcionalidad que necesitas para interactuar con sitios web, p. ej. registrarte e iniciar sesión, enviar comentarios, comprar productos y más. Este módulo te ayuda a comenzar a crear las partes de formularios del lado del cliente/Interfaz de usuario.

Utilizar HTML para resolver problemas comunes

Proporciona enlaces a secciones de contenido que explican cómo usar HTML para resolver muchos problemas comunes al crear una página web: tratar con títulos, agregar imágenes o videos, enfatizar el contenido, crear un formulario básico, etc.

Temas avanzados
Imagen compatible con CORS

El atributo crossorigin, en combinación con un encabezado CORS apropiado, permite imágenes definidas por el elemento <img> que se cargarán desde orígenes externos y se utilizarán en un elemento <canvas> como si se estuvieran cargando desde el origen actual.

Atributos de configuración de CORS

Algunos elementos HTML que brindan soporte para CORS, como <img> o <video>, tienen un atributo crossorigin (propiedad crossOrigin), que te permite configurar las solicitudes CORS para los datos extraídos del elemento.

Precarga de contenido con rel='preload'

El valor de preload del atributo <link> del elemento rel te permite escribir solicitudes de recuperación declarativas en tu HTML <head>, que especifican los recursos que tus páginas necesitarán muy pronto después de la carga, que por lo tanto deseas comenzar a precargar al principio del ciclo de vida de la carga de una página, antes de la representación principal del navegador la maquinaria entra en acción. Esto asegura que estén disponibles antes y es menos probable que bloqueen el primer procesamiento de la página, lo que lleva a mejoras de rendimiento. Este artículo proporciona una guía básica sobre cómo funciona preload.

Referencias
Referencia HTML

HTML consta de elementos, cada uno de los cuales se puede modificar por medio de algunos atributos. Los documentos HTML están conectados entre sí mediante enlaces.

Referencia del elemento HTML

Examina una lista de todos los elementos HTML.

Referencia de atributos HTML

Los elementos en HTML tienen atributos. Se trata de valores adicionales que configuran los elementos o ajustan su comportamiento de diversas formas.

Atributos globales

Los atributos globales se pueden especificar en todos los elementos HTML, incluso aquellos no especificados en el estándar. Esto significa que cualquier elemento no estándar debe permitir esos atributos, aunque esos elementos hagan que el documento no sea compatible con HTML5.

Elementos en línea y Elementos a nivel de bloque

Los elementos HTML suelen ser elementos "en línea" o "a nivel de bloque". Un elemento en línea ocupa solo el espacio delimitado por las etiquetas que lo definen. Un elemento a nivel de bloque ocupa todo el espacio de su elemento padre (contenedor), creando así un "bloque".

Tipos de enlaces

En HTML, se pueden usar varios tipos de enlaces para establecer y definir la relación entre dos documentos. Los elementos de enlace en los que se pueden configurar tipos incluyen <a>, <area> y <link>.

Guía de tipos y formatos de medios en la web

Los elementos <audio> y <video> te permiten reproducir audio y video de forma nativa dentro de tu contenido sin la necesidad de soporte de software externo.

Categorías de contenido HTML

HTML se compone de varios tipos de contenido, cada uno de los cuales se puede usar en ciertos contextos y no está permitido en otros. De manera similar, cada uno tiene un conjunto de otras categorías de contenido que pueden recibir y elementos que pueden o no se pueden usar en ellos. Esta es una guía para estas categorías.

Modo Quirks y modo estándar

Información histórica sobre el modo peculiar («Quirks» en inglés) y el modo estándar.

Temas relacionados
Aplicando color a elementos HTML mediante CSS

Este artículo cubre la mayoría de las formas en que usas CSS para agregar color al contenido HTML, enumerando qué partes de los documentos HTML se pueden colorear y qué propiedades CSS usar al hacerlo. Incluye ejemplos, enlaces a herramientas de creación de paletas de colores y más.\n\nHTML: Lenguaje de etiquetas de hipertextoHTML (Lenguaje de Marcas de Hipertexto, del inglés HyperText Markup Language) es el componente más básico de la Web. Define el significado y la estructura del contenido web. Además de HTML, generalmente se utilizan otras tecnologías para describir la apariencia/presentación de una página web (CSS) o la funcionalidad/comportamiento (JavaScript).
"Hipertexto" hace referencia a los enlaces que conectan páginas web entre sí, ya sea dentro de un único sitio web o entre sitios web. Los enlaces son un aspecto fundamental de la Web. Al subir contenido a Internet y vincularlo a las páginas creadas por otras personas, te conviertes en un participante activo en la «World Wide Web» (Red Informática Mundial).
HTML utiliza "marcas" para etiquetar texto, imágenes y otro contenido para mostrarlo en un navegador Web. Las marcas HTML incluyen "elementos" especiales como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> y muchos otros.
Un elemento HTML se distingue de otro texto en un documento mediante "etiquetas", que consisten en el nombre del elemento rodeado por "<" y ">". El nombre de un elemento dentro de una etiqueta no distingue entre mayúsculas y minúsculas. Es decir, se puede escribir en mayúsculas, minúsculas o una mezcla. Por ejemplo, la etiqueta <title> se puede escribir como <Title>, <TITLE> o de cualquier otra forma.
Los siguientes artículos pueden ayudarte a obtener más información sobre HTML.Recursos clave
Introducción a HTML

Si eres nuevo en el desarrollo Web, asegúrate de leer el artículo Conceptos básicos de HTML para aprender qué es HTML y cómo usarlo.

Tutoriales HTML

Para ver artículos sobre cómo usar HTML, así como tutoriales y ejemplos completos, consulte el Área de aprendizaje de HTML.

Referencia HTML

En nuestra extensa sección referencia HTML encontrarás los detalles sobre cada elemento y atributo en HTML.




¿Quieres transformarte en un desarrollador de la interfaz de usuario web?
Hemos elaborado un curso que incluye toda la información esencial que necesitas para trabajar hacia tu objetivo.
Empieza aquí
Tutoriales para principiantesEl Área de aprendizaje de HTML incluye varios módulos que enseñan HTML desde cero, sin necesidad de conocimientos previos.

Introducción a HTML

Este módulo prepara el escenario para que te acostumbres a conceptos y sintaxis importantes, tal como la aplicación de HTML al texto, cómo crear hipervínculos y cómo utilizar HTML para estructurar una página web.

Multimedia e inserción

Este módulo explora cómo usar HTML para incluir multimedia en tus páginas web, incluidas las diferentes formas en que se pueden incluir imágenes y cómo insertar video, audio e incluso otras páginas web completas.

tablas HTML

Representar datos tabulares en una página web de una manera comprensible y accesible puede ser un desafío. Este módulo cubre el marcado básico de tablas, junto con características más complejas como la implementación de subtítulos y resúmenes.

Formularios HTML

Los formularios son una parte muy importante de la Web — proporcionan gran parte de la funcionalidad que necesitas para interactuar con sitios web, p. ej. registrarte e iniciar sesión, enviar comentarios, comprar productos y más. Este módulo te ayuda a comenzar a crear las partes de formularios del lado del cliente/Interfaz de usuario.

Utilizar HTML para resolver problemas comunes

Proporciona enlaces a secciones de contenido que explican cómo usar HTML para resolver muchos problemas comunes al crear una página web: tratar con títulos, agregar imágenes o videos, enfatizar el contenido, crear un formulario básico, etc.

Temas avanzados
Imagen compatible con CORS

El atributo crossorigin, en combinación con un encabezado CORS apropiado, permite imágenes definidas por el elemento <img> que se cargarán desde orígenes externos y se utilizarán en un elemento <canvas> como si se estuvieran cargando desde el origen actual.

Atributos de configuración de CORS

Algunos elementos HTML que brindan soporte para CORS, como <img> o <video>, tienen un atributo crossorigin (propiedad crossOrigin), que te permite configurar las solicitudes CORS para los datos extraídos del elemento.

Precarga de contenido con rel='preload'

El valor de preload del atributo <link> del elemento rel te permite escribir solicitudes de recuperación declarativas en tu HTML <head>, que especifican los recursos que tus páginas necesitarán muy pronto después de la carga, que por lo tanto deseas comenzar a precargar al principio del ciclo de vida de la carga de una página, antes de la representación principal del navegador la maquinaria entra en acción. Esto asegura que estén disponibles antes y es menos probable que bloqueen el primer procesamiento de la página, lo que lleva a mejoras de rendimiento. Este artículo proporciona una guía básica sobre cómo funciona preload.

Referencias
Referencia HTML

HTML consta de elementos, cada uno de los cuales se puede modificar por medio de algunos atributos. Los documentos HTML están conectados entre sí mediante enlaces.

Referencia del elemento HTML

Examina una lista de todos los elementos HTML.

Referencia de atributos HTML

Los elementos en HTML tienen atributos. Se trata de valores adicionales que configuran los elementos o ajustan su comportamiento de diversas formas.

Atributos globales

Los atributos globales se pueden especificar en todos los elementos HTML, incluso aquellos no especificados en el estándar. Esto significa que cualquier elemento no estándar debe permitir esos atributos, aunque esos elementos hagan que el documento no sea compatible con HTML5.

Elementos en línea y Elementos a nivel de bloque

Los elementos HTML suelen ser elementos "en línea" o "a nivel de bloque". Un elemento en línea ocupa solo el espacio delimitado por las etiquetas que lo definen. Un elemento a nivel de bloque ocupa todo el espacio de su elemento padre (contenedor), creando así un "bloque".

Tipos de enlaces

En HTML, se pueden usar varios tipos de enlaces para establecer y definir la relación entre dos documentos. Los elementos de enlace en los que se pueden configurar tipos incluyen <a>, <area> y <link>.

Guía de tipos y formatos de medios en la web

Los elementos <audio> y <video> te permiten reproducir audio y video de forma nativa dentro de tu contenido sin la necesidad de soporte de software externo.

Categorías de contenido HTML

HTML se compone de varios tipos de contenido, cada uno de los cuales se puede usar en ciertos contextos y no está permitido en otros. De manera similar, cada uno tiene un conjunto de otras categorías de contenido que pueden recibir y elementos que pueden o no se pueden usar en ellos. Esta es una guía para estas categorías.

Modo Quirks y modo estándar

Información histórica sobre el modo peculiar («Quirks» en inglés) y el modo estándar.

Temas relacionados
Aplicando color a elementos HTML mediante CSS

Este artículo cubre la mayoría de las formas en que usas CSS para agregar color al contenido HTML, enumerando qué partes de los documentos HTML se pueden colorear y qué propiedades CSS usar al hacerlo. Incluye ejemplos, enlaces a herramientas de creación de paletas de colores y más.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 11 abr 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: Lenguaje de etiquetas de hipertextoHTML (Lenguaje de Marcas de Hipertexto, del inglés HyperText Markup Language) es el componente más básico de la Web. Define el significado y la estructura del contenido web. Además de HTML, generalmente se utilizan otras tecnologías para describir la apariencia/presentación de una página web (CSS) o la funcionalidad/comportamiento (JavaScript).
"Hipertexto" hace referencia a los enlaces que conectan páginas web entre sí, ya sea dentro de un único sitio web o entre sitios web. Los enlaces son un aspecto fundamental de la Web. Al subir contenido a Internet y vincularlo a las páginas creadas por otras personas, te conviertes en un participante activo en la «World Wide Web» (Red Informática Mundial).
HTML utiliza "marcas" para etiquetar texto, imágenes y otro contenido para mostrarlo en un navegador Web. Las marcas HTML incluyen "elementos" especiales como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> y muchos otros.
Un elemento HTML se distingue de otro texto en un documento mediante "etiquetas", que consisten en el nombre del elemento rodeado por "<" y ">". El nombre de un elemento dentro de una etiqueta no distingue entre mayúsculas y minúsculas. Es decir, se puede escribir en mayúsculas, minúsculas o una mezcla. Por ejemplo, la etiqueta <title> se puede escribir como <Title>, <TITLE> o de cualquier otra forma.
Los siguientes artículos pueden ayudarte a obtener más información sobre HTML.Recursos clave
Introducción a HTML

Si eres nuevo en el desarrollo Web, asegúrate de leer el artículo Conceptos básicos de HTML para aprender qué es HTML y cómo usarlo.

Tutoriales HTML

Para ver artículos sobre cómo usar HTML, así como tutoriales y ejemplos completos, consulte el Área de aprendizaje de HTML.

Referencia HTML

En nuestra extensa sección referencia HTML encontrarás los detalles sobre cada elemento y atributo en HTML.




¿Quieres transformarte en un desarrollador de la interfaz de usuario web?
Hemos elaborado un curso que incluye toda la información esencial que necesitas para trabajar hacia tu objetivo.
Empieza aquí
Tutoriales para principiantesEl Área de aprendizaje de HTML incluye varios módulos que enseñan HTML desde cero, sin necesidad de conocimientos previos.

Introducción a HTML

Este módulo prepara el escenario para que te acostumbres a conceptos y sintaxis importantes, tal como la aplicación de HTML al texto, cómo crear hipervínculos y cómo utilizar HTML para estructurar una página web.

Multimedia e inserción

Este módulo explora cómo usar HTML para incluir multimedia en tus páginas web, incluidas las diferentes formas en que se pueden incluir imágenes y cómo insertar video, audio e incluso otras páginas web completas.

tablas HTML

Representar datos tabulares en una página web de una manera comprensible y accesible puede ser un desafío. Este módulo cubre el marcado básico de tablas, junto con características más complejas como la implementación de subtítulos y resúmenes.

Formularios HTML

Los formularios son una parte muy importante de la Web — proporcionan gran parte de la funcionalidad que necesitas para interactuar con sitios web, p. ej. registrarte e iniciar sesión, enviar comentarios, comprar productos y más. Este módulo te ayuda a comenzar a crear las partes de formularios del lado del cliente/Interfaz de usuario.

Utilizar HTML para resolver problemas comunes

Proporciona enlaces a secciones de contenido que explican cómo usar HTML para resolver muchos problemas comunes al crear una página web: tratar con títulos, agregar imágenes o videos, enfatizar el contenido, crear un formulario básico, etc.

Temas avanzados
Imagen compatible con CORS

El atributo crossorigin, en combinación con un encabezado CORS apropiado, permite imágenes definidas por el elemento <img> que se cargarán desde orígenes externos y se utilizarán en un elemento <canvas> como si se estuvieran cargando desde el origen actual.

Atributos de configuración de CORS

Algunos elementos HTML que brindan soporte para CORS, como <img> o <video>, tienen un atributo crossorigin (propiedad crossOrigin), que te permite configurar las solicitudes CORS para los datos extraídos del elemento.

Precarga de contenido con rel='preload'

El valor de preload del atributo <link> del elemento rel te permite escribir solicitudes de recuperación declarativas en tu HTML <head>, que especifican los recursos que tus páginas necesitarán muy pronto después de la carga, que por lo tanto deseas comenzar a precargar al principio del ciclo de vida de la carga de una página, antes de la representación principal del navegador la maquinaria entra en acción. Esto asegura que estén disponibles antes y es menos probable que bloqueen el primer procesamiento de la página, lo que lleva a mejoras de rendimiento. Este artículo proporciona una guía básica sobre cómo funciona preload.

Referencias
Referencia HTML

HTML consta de elementos, cada uno de los cuales se puede modificar por medio de algunos atributos. Los documentos HTML están conectados entre sí mediante enlaces.

Referencia del elemento HTML

Examina una lista de todos los elementos HTML.

Referencia de atributos HTML

Los elementos en HTML tienen atributos. Se trata de valores adicionales que configuran los elementos o ajustan su comportamiento de diversas formas.

Atributos globales

Los atributos globales se pueden especificar en todos los elementos HTML, incluso aquellos no especificados en el estándar. Esto significa que cualquier elemento no estándar debe permitir esos atributos, aunque esos elementos hagan que el documento no sea compatible con HTML5.

Elementos en línea y Elementos a nivel de bloque

Los elementos HTML suelen ser elementos "en línea" o "a nivel de bloque". Un elemento en línea ocupa solo el espacio delimitado por las etiquetas que lo definen. Un elemento a nivel de bloque ocupa todo el espacio de su elemento padre (contenedor), creando así un "bloque".

Tipos de enlaces

En HTML, se pueden usar varios tipos de enlaces para establecer y definir la relación entre dos documentos. Los elementos de enlace en los que se pueden configurar tipos incluyen <a>, <area> y <link>.

Guía de tipos y formatos de medios en la web

Los elementos <audio> y <video> te permiten reproducir audio y video de forma nativa dentro de tu contenido sin la necesidad de soporte de software externo.

Categorías de contenido HTML

HTML se compone de varios tipos de contenido, cada uno de los cuales se puede usar en ciertos contextos y no está permitido en otros. De manera similar, cada uno tiene un conjunto de otras categorías de contenido que pueden recibir y elementos que pueden o no se pueden usar en ellos. Esta es una guía para estas categorías.

Modo Quirks y modo estándar

Información histórica sobre el modo peculiar («Quirks» en inglés) y el modo estándar.

Temas relacionados
Aplicando color a elementos HTML mediante CSS

Este artículo cubre la mayoría de las formas en que usas CSS para agregar color al contenido HTML, enumerando qué partes de los documentos HTML se pueden colorear y qué propiedades CSS usar al hacerlo. Incluye ejemplos, enlaces a herramientas de creación de paletas de colores y más.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 11 abr 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML (HyperText Markup Language)HTML signifie « HyperText Markup Language » qu'on peut traduire par « langage de balises pour l'hypertexte ». Il est utilisé afin de créer et de représenter le contenu d'une page web et sa structure. D'autres technologies sont utilisées avec HTML pour décrire la présentation d'une page (CSS) et/ou ses fonctionnalités interactives (JavaScript).
L'« hypertexte » désigne les liens qui relient les pages web entre elles, que ce soit au sein d'un même site web ou entre différents sites web. Les liens sont un aspect fondamental du Web. Ce sont eux qui forment cette « toile » (ce mot est traduit par web en anglais). En téléchargeant du contenu sur l'Internet et en le reliant à des pages créées par d'autres personnes, vous devenez un participant actif du World Wide Web.
Le langage HTML utilise des « balises » pour annoter du texte, des images et d'autres contenus afin de les afficher dans un navigateur web. Le balisage HTML comprend des « éléments » spéciaux tels que <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> et bien d'autres.
En HTML, les balises sont insensibles à la casse et peuvent aussi bien être écrites en minuscules, en majuscules voire avec un mélange des deux. Autrement dit, la balise <title> pourrait très bien être écrite comme <Title>, <TiTle> ou d'une autre façon.
Les articles suivants fournissent des éléments de référence utiles au développement web.Ressources clés
Introduction au HTML

Vous faites vos premiers pas dans le développement web ? Nos articles sur les bases de HTML expliquent ce qu'est HTML et comment l'utiliser.

Tutoriels HTML

Pour plus d'informations sur l'utilisation du HTML, des tutoriels et des exemples complets, vous pouvez consulter notre section Apprendre HTML.

Référence HTML

Dans notre référence exhaustive, vous trouverez le détail de chaque élément et attribut constituant HTML.




Vous cherchez à devenir un développeur web front-end ?
Nous avons élaboré un cours qui comprend toutes les informations essentielles dont vous avez besoin pour atteindre votre objectif.
Commencer
Tutoriels pour les débutantsLa section Apprendre HTML contient plusieurs modules pour vous apprendre à utiliser HTML — sans autre connaissance particulière.

Une introduction à HTML

Dans ce module, on brosse un premier portrait de HTML pour présenter les concepts importants, la syntaxe. On voit comment appliquer HTML sur du texte, comment créer des hyperliens et comment structurer une page web grâce à HTML.

Le multimédia et l'intégration

Dans ce module, on explore comment utiliser HTML pour intégrer des fichiers multimédias dans une page web. Cela couvre les différentes façons d'inclure une image, comment ajouter une vidéo ou un fichier audio voire aussi comment intégrer d'autres pages web.

Les tableaux HTML

Il est parfois compliqué de représenter des données tabulaires de façon compréhensible et lisible sur une page web. Dans ce module, on voit les différentes balises utilisées pour construire des tableaux et certaines fonctionnalités plus complexes comme les légendes et résumés.

Les formulaires HTML

Les formulaires sont cruciaux sur le Web, ils permettent de créer un compte sur un site, de se connecter, d'acheter des produits, d'écrire des commentaires, etc. Dans ce module, on voit comment créer des formulaires pour le navigateur (« côté client »).

Utiliser HTML pour résoudre des problèmes courants

Ce module fournit un ensemble d'articles au sujet des problèmes qu'on rencontre fréquemment lorsqu'on crée une page web : gérer les titres, ajouter des images ou des vidéos, mettre en avant une partie du texte, créer un formulaire, etc.

Sujets avancés
Images avec le contrôle d'accès HTTP

L'attribut crossorigin, associé à un en-tête CORS approprié, permet de charger des images définies par l'élément <img> depuis des origines étrangères et de les utiliser dans un élément <canvas> comme si elles étaient chargées depuis l'origine actuelle.

Attributs de réglage du CORS

Certains éléments HTML qui fournissent un support pour CORS, tels que <img> ou <video>, ont un attribut crossorigin (propriété crossOrigin), qui vous permet de configurer les requêtes CORS pour les données extraites de l'élément.

Précharger du contenu avec rel="preload"

La valeur preload de l'attribut <link> de l'élément rel vous permet d'écrire des requêtes déclaratives de récupération dans votre <head> HTML, en spécifiant les ressources dont vos pages auront besoin très rapidement après le chargement, et que vous souhaitez donc commencer à précharger au début du cycle de vie d'une page, avant que le cycle de rendu du navigateur ne se mette en marche. Cela permet de s'assurer que ces éléments sont disponibles plus tôt et qu'ils risquent moins de bloquer le premier rendu de la page, améliorant ainsi les performances. Cet article fournit un guide de base sur le fonctionnement du preload.

Références
Référence HTML

HTML est un langage décrivant la structure et le contenu sémantique d'un document web. Il est constitué d'éléments, chacun pouvant être paramétré grâce à différents attributs. Les documents HTML sont connectés à d'autres via des liens

Référence des éléments HTML

Cette page liste les différents éléments HTML.

Liste des attributs HTML

Les éléments du langage HTML possèdent des attributs. Il s'agit de valeurs supplémentaires qui configurent les éléments ou ajustent leur comportement de diverses manières.

Attributs universels

Les attributs universels peuvent être spécifiés sur tous les éléments HTML, même ceux qui ne sont pas spécifiés dans la norme. Par exemple, les navigateurs qui prennent en charge HTML5 masquent les contenus marqués comme <toto hidden>…<toto> , bien que <toto> ne soit pas un élément valide HTML.

Éléments en ligne et éléments de bloc

Les éléments HTML sont habituellement des éléments « en ligne » ou des éléments de bloc. Un élément en ligne occupe seulement l'espace associé aux balises. Les éléments de bloc sont une catégorie d'éléments HTML opposés aux éléments en ligne. Leur caractéristique principale réside dans le fait qu'ils sont séparés par un saut de ligne avant et après l'élément. Ce faisant, ils prennent la largeur de leurs conteneurs (créant ainsi un bloc de contenu).

Types de lien

Les différents liens permettent de décrire les relations entre deux documents qui sont reliés entre eux par un élément <a>, <area> ou <link>.

Formats de média audio et vidéo pris en charge par HTML

Les éléments <audio> et <video> permettent d'ajouter des médias audio et vidéo directement dans le navigateur (sans avoir à utiliser des plugins ou programmes tiers).

Types de contenu HTML

HTML s'organise selon différents types de contenu dont chacun peut être autorisé ou non en fonction du contexte. Ces catégories indiquent quels éléments peuvent être contenus ou non dans d'autres éléments. Cet article explique le fonctionnement de ces catégories.

Sujets connexes
Appliquer des couleurs sur des éléments HTML grâce à CSS

Cet article couvre la plupart des façons d'utiliser CSS pour ajouter de la couleur au contenu HTML, en indiquant les parties des documents HTML qui peuvent être colorées et les propriétés CSS à utiliser pour ce faire. Il comprend des exemples, des liens vers des outils de création de palettes, etc.\n\nHTML (HyperText Markup Language)HTML signifie « HyperText Markup Language » qu'on peut traduire par « langage de balises pour l'hypertexte ». Il est utilisé afin de créer et de représenter le contenu d'une page web et sa structure. D'autres technologies sont utilisées avec HTML pour décrire la présentation d'une page (CSS) et/ou ses fonctionnalités interactives (JavaScript).
L'« hypertexte » désigne les liens qui relient les pages web entre elles, que ce soit au sein d'un même site web ou entre différents sites web. Les liens sont un aspect fondamental du Web. Ce sont eux qui forment cette « toile » (ce mot est traduit par web en anglais). En téléchargeant du contenu sur l'Internet et en le reliant à des pages créées par d'autres personnes, vous devenez un participant actif du World Wide Web.
Le langage HTML utilise des « balises » pour annoter du texte, des images et d'autres contenus afin de les afficher dans un navigateur web. Le balisage HTML comprend des « éléments » spéciaux tels que <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> et bien d'autres.
En HTML, les balises sont insensibles à la casse et peuvent aussi bien être écrites en minuscules, en majuscules voire avec un mélange des deux. Autrement dit, la balise <title> pourrait très bien être écrite comme <Title>, <TiTle> ou d'une autre façon.
Les articles suivants fournissent des éléments de référence utiles au développement web.Ressources clés
Introduction au HTML

Vous faites vos premiers pas dans le développement web ? Nos articles sur les bases de HTML expliquent ce qu'est HTML et comment l'utiliser.

Tutoriels HTML

Pour plus d'informations sur l'utilisation du HTML, des tutoriels et des exemples complets, vous pouvez consulter notre section Apprendre HTML.

Référence HTML

Dans notre référence exhaustive, vous trouverez le détail de chaque élément et attribut constituant HTML.




Vous cherchez à devenir un développeur web front-end ?
Nous avons élaboré un cours qui comprend toutes les informations essentielles dont vous avez besoin pour atteindre votre objectif.
Commencer
Tutoriels pour les débutantsLa section Apprendre HTML contient plusieurs modules pour vous apprendre à utiliser HTML — sans autre connaissance particulière.

Une introduction à HTML

Dans ce module, on brosse un premier portrait de HTML pour présenter les concepts importants, la syntaxe. On voit comment appliquer HTML sur du texte, comment créer des hyperliens et comment structurer une page web grâce à HTML.

Le multimédia et l'intégration

Dans ce module, on explore comment utiliser HTML pour intégrer des fichiers multimédias dans une page web. Cela couvre les différentes façons d'inclure une image, comment ajouter une vidéo ou un fichier audio voire aussi comment intégrer d'autres pages web.

Les tableaux HTML

Il est parfois compliqué de représenter des données tabulaires de façon compréhensible et lisible sur une page web. Dans ce module, on voit les différentes balises utilisées pour construire des tableaux et certaines fonctionnalités plus complexes comme les légendes et résumés.

Les formulaires HTML

Les formulaires sont cruciaux sur le Web, ils permettent de créer un compte sur un site, de se connecter, d'acheter des produits, d'écrire des commentaires, etc. Dans ce module, on voit comment créer des formulaires pour le navigateur (« côté client »).

Utiliser HTML pour résoudre des problèmes courants

Ce module fournit un ensemble d'articles au sujet des problèmes qu'on rencontre fréquemment lorsqu'on crée une page web : gérer les titres, ajouter des images ou des vidéos, mettre en avant une partie du texte, créer un formulaire, etc.

Sujets avancés
Images avec le contrôle d'accès HTTP

L'attribut crossorigin, associé à un en-tête CORS approprié, permet de charger des images définies par l'élément <img> depuis des origines étrangères et de les utiliser dans un élément <canvas> comme si elles étaient chargées depuis l'origine actuelle.

Attributs de réglage du CORS

Certains éléments HTML qui fournissent un support pour CORS, tels que <img> ou <video>, ont un attribut crossorigin (propriété crossOrigin), qui vous permet de configurer les requêtes CORS pour les données extraites de l'élément.

Précharger du contenu avec rel="preload"

La valeur preload de l'attribut <link> de l'élément rel vous permet d'écrire des requêtes déclaratives de récupération dans votre <head> HTML, en spécifiant les ressources dont vos pages auront besoin très rapidement après le chargement, et que vous souhaitez donc commencer à précharger au début du cycle de vie d'une page, avant que le cycle de rendu du navigateur ne se mette en marche. Cela permet de s'assurer que ces éléments sont disponibles plus tôt et qu'ils risquent moins de bloquer le premier rendu de la page, améliorant ainsi les performances. Cet article fournit un guide de base sur le fonctionnement du preload.

Références
Référence HTML

HTML est un langage décrivant la structure et le contenu sémantique d'un document web. Il est constitué d'éléments, chacun pouvant être paramétré grâce à différents attributs. Les documents HTML sont connectés à d'autres via des liens

Référence des éléments HTML

Cette page liste les différents éléments HTML.

Liste des attributs HTML

Les éléments du langage HTML possèdent des attributs. Il s'agit de valeurs supplémentaires qui configurent les éléments ou ajustent leur comportement de diverses manières.

Attributs universels

Les attributs universels peuvent être spécifiés sur tous les éléments HTML, même ceux qui ne sont pas spécifiés dans la norme. Par exemple, les navigateurs qui prennent en charge HTML5 masquent les contenus marqués comme <toto hidden>…<toto> , bien que <toto> ne soit pas un élément valide HTML.

Éléments en ligne et éléments de bloc

Les éléments HTML sont habituellement des éléments « en ligne » ou des éléments de bloc. Un élément en ligne occupe seulement l'espace associé aux balises. Les éléments de bloc sont une catégorie d'éléments HTML opposés aux éléments en ligne. Leur caractéristique principale réside dans le fait qu'ils sont séparés par un saut de ligne avant et après l'élément. Ce faisant, ils prennent la largeur de leurs conteneurs (créant ainsi un bloc de contenu).

Types de lien

Les différents liens permettent de décrire les relations entre deux documents qui sont reliés entre eux par un élément <a>, <area> ou <link>.

Formats de média audio et vidéo pris en charge par HTML

Les éléments <audio> et <video> permettent d'ajouter des médias audio et vidéo directement dans le navigateur (sans avoir à utiliser des plugins ou programmes tiers).

Types de contenu HTML

HTML s'organise selon différents types de contenu dont chacun peut être autorisé ou non en fonction du contexte. Ces catégories indiquent quels éléments peuvent être contenus ou non dans d'autres éléments. Cet article explique le fonctionnement de ces catégories.

Sujets connexes
Appliquer des couleurs sur des éléments HTML grâce à CSS

Cet article couvre la plupart des façons d'utiliser CSS pour ajouter de la couleur au contenu HTML, en indiquant les parties des documents HTML qui peuvent être colorées et les propriétés CSS à utiliser pour ce faire. Il comprend des exemples, des liens vers des outils de création de palettes, etc.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML (HyperText Markup Language)HTML signifie « HyperText Markup Language » qu'on peut traduire par « langage de balises pour l'hypertexte ». Il est utilisé afin de créer et de représenter le contenu d'une page web et sa structure. D'autres technologies sont utilisées avec HTML pour décrire la présentation d'une page (CSS) et/ou ses fonctionnalités interactives (JavaScript).
L'« hypertexte » désigne les liens qui relient les pages web entre elles, que ce soit au sein d'un même site web ou entre différents sites web. Les liens sont un aspect fondamental du Web. Ce sont eux qui forment cette « toile » (ce mot est traduit par web en anglais). En téléchargeant du contenu sur l'Internet et en le reliant à des pages créées par d'autres personnes, vous devenez un participant actif du World Wide Web.
Le langage HTML utilise des « balises » pour annoter du texte, des images et d'autres contenus afin de les afficher dans un navigateur web. Le balisage HTML comprend des « éléments » spéciaux tels que <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> et bien d'autres.
En HTML, les balises sont insensibles à la casse et peuvent aussi bien être écrites en minuscules, en majuscules voire avec un mélange des deux. Autrement dit, la balise <title> pourrait très bien être écrite comme <Title>, <TiTle> ou d'une autre façon.
Les articles suivants fournissent des éléments de référence utiles au développement web.Ressources clés
Introduction au HTML

Vous faites vos premiers pas dans le développement web ? Nos articles sur les bases de HTML expliquent ce qu'est HTML et comment l'utiliser.

Tutoriels HTML

Pour plus d'informations sur l'utilisation du HTML, des tutoriels et des exemples complets, vous pouvez consulter notre section Apprendre HTML.

Référence HTML

Dans notre référence exhaustive, vous trouverez le détail de chaque élément et attribut constituant HTML.




Vous cherchez à devenir un développeur web front-end ?
Nous avons élaboré un cours qui comprend toutes les informations essentielles dont vous avez besoin pour atteindre votre objectif.
Commencer
Tutoriels pour les débutantsLa section Apprendre HTML contient plusieurs modules pour vous apprendre à utiliser HTML — sans autre connaissance particulière.

Une introduction à HTML

Dans ce module, on brosse un premier portrait de HTML pour présenter les concepts importants, la syntaxe. On voit comment appliquer HTML sur du texte, comment créer des hyperliens et comment structurer une page web grâce à HTML.

Le multimédia et l'intégration

Dans ce module, on explore comment utiliser HTML pour intégrer des fichiers multimédias dans une page web. Cela couvre les différentes façons d'inclure une image, comment ajouter une vidéo ou un fichier audio voire aussi comment intégrer d'autres pages web.

Les tableaux HTML

Il est parfois compliqué de représenter des données tabulaires de façon compréhensible et lisible sur une page web. Dans ce module, on voit les différentes balises utilisées pour construire des tableaux et certaines fonctionnalités plus complexes comme les légendes et résumés.

Les formulaires HTML

Les formulaires sont cruciaux sur le Web, ils permettent de créer un compte sur un site, de se connecter, d'acheter des produits, d'écrire des commentaires, etc. Dans ce module, on voit comment créer des formulaires pour le navigateur (« côté client »).

Utiliser HTML pour résoudre des problèmes courants

Ce module fournit un ensemble d'articles au sujet des problèmes qu'on rencontre fréquemment lorsqu'on crée une page web : gérer les titres, ajouter des images ou des vidéos, mettre en avant une partie du texte, créer un formulaire, etc.

Sujets avancés
Images avec le contrôle d'accès HTTP

L'attribut crossorigin, associé à un en-tête CORS approprié, permet de charger des images définies par l'élément <img> depuis des origines étrangères et de les utiliser dans un élément <canvas> comme si elles étaient chargées depuis l'origine actuelle.

Attributs de réglage du CORS

Certains éléments HTML qui fournissent un support pour CORS, tels que <img> ou <video>, ont un attribut crossorigin (propriété crossOrigin), qui vous permet de configurer les requêtes CORS pour les données extraites de l'élément.

Précharger du contenu avec rel="preload"

La valeur preload de l'attribut <link> de l'élément rel vous permet d'écrire des requêtes déclaratives de récupération dans votre <head> HTML, en spécifiant les ressources dont vos pages auront besoin très rapidement après le chargement, et que vous souhaitez donc commencer à précharger au début du cycle de vie d'une page, avant que le cycle de rendu du navigateur ne se mette en marche. Cela permet de s'assurer que ces éléments sont disponibles plus tôt et qu'ils risquent moins de bloquer le premier rendu de la page, améliorant ainsi les performances. Cet article fournit un guide de base sur le fonctionnement du preload.

Références
Référence HTML

HTML est un langage décrivant la structure et le contenu sémantique d'un document web. Il est constitué d'éléments, chacun pouvant être paramétré grâce à différents attributs. Les documents HTML sont connectés à d'autres via des liens

Référence des éléments HTML

Cette page liste les différents éléments HTML.

Liste des attributs HTML

Les éléments du langage HTML possèdent des attributs. Il s'agit de valeurs supplémentaires qui configurent les éléments ou ajustent leur comportement de diverses manières.

Attributs universels

Les attributs universels peuvent être spécifiés sur tous les éléments HTML, même ceux qui ne sont pas spécifiés dans la norme. Par exemple, les navigateurs qui prennent en charge HTML5 masquent les contenus marqués comme <toto hidden>…<toto> , bien que <toto> ne soit pas un élément valide HTML.

Éléments en ligne et éléments de bloc

Les éléments HTML sont habituellement des éléments « en ligne » ou des éléments de bloc. Un élément en ligne occupe seulement l'espace associé aux balises. Les éléments de bloc sont une catégorie d'éléments HTML opposés aux éléments en ligne. Leur caractéristique principale réside dans le fait qu'ils sont séparés par un saut de ligne avant et après l'élément. Ce faisant, ils prennent la largeur de leurs conteneurs (créant ainsi un bloc de contenu).

Types de lien

Les différents liens permettent de décrire les relations entre deux documents qui sont reliés entre eux par un élément <a>, <area> ou <link>.

Formats de média audio et vidéo pris en charge par HTML

Les éléments <audio> et <video> permettent d'ajouter des médias audio et vidéo directement dans le navigateur (sans avoir à utiliser des plugins ou programmes tiers).

Types de contenu HTML

HTML s'organise selon différents types de contenu dont chacun peut être autorisé ou non en fonction du contexte. Ces catégories indiquent quels éléments peuvent être contenus ou non dans d'autres éléments. Cet article explique le fonctionnement de ces catégories.

Sujets connexes
Appliquer des couleurs sur des éléments HTML grâce à CSS

Cet article couvre la plupart des façons d'utiliser CSS pour ajouter de la couleur au contenu HTML, en indiquant les parties des documents HTML qui peuvent être colorées et les propriétés CSS à utiliser pour ce faire. Il comprend des exemples, des liens vers des outils de création de palettes, etc.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 17 déc. 2024 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: ハイパーテキストマークアップ言語HTML (HyperText Markup Language) はウェブのもっとも基本的な構成要素です。 HTML はウェブページの基本レイアウトに従ってウェブページのコンテンツを記述し定義するものです。 HTML に隣接する他の技術としては、ウェブページの表示や表現を記述するもの (CSS) または機能や振る舞いを記述するもの (JavaScript) があります。
「ハイパーテキスト」はウェブページから別なページに、ウェブサイト内でもウェブサイト間でも、接続するリンクを示します。リンクはウェブの基礎的な特徴です。コンテンツをインターネットにアップロードして他の人々が作成したページにリンクすれば、 World Wide Web の活発な参加者になれます。
HTML ではウェブブラウザーのテキスト、画像、その他のコンテンツを記述するために「マークアップ」を使用します。 HTML のマークアップには、 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> その他のたくさんの特殊な「要素」を用います。
HTML 要素は文書中で、< および > で囲まれた要素名で構成される「タグ」によって区別されます。タグ内の要素名は、大文字と小文字の区別がありません。つまり、大文字でも、小文字でも、混在して書いても構いません。例えば、 <title> タグは <Title> や <TITLE> やその他の方法で書くことができます。ただし、タグを小文字で書くのが慣習となっており、推奨されています。
以下の記事が HTML についてもっと学ぶのに役立ちます。初心者向けチュートリアル
初めてのウェブサイト: コンテンツの作成

この記事では、 HTML とは何か、また、どのように使用するのかについて、ウェブ開発に完全に新しい人々を対象に、簡単なツアーを提供します。

HTML によるコンテンツの構造化

ウェブ開発の学習の HTML モジュールの節では、 HTML の基礎をすべて一から学べます。

ガイド
HTML フォーム

フォームはウェブで非常に重要な部分です。――これはウェブサイトとのやり取り（登録やログイン、フィードバックの送信、商品の購入など）に必要な多くの機能を提供します。このモジュールでは、フォームのクライアント側／フロントエンド部分の作成から始めます。

CORS を利用した画像

crossorigin 属性と CORS ヘッダーを組み合わせることで、 <img> 要素で定義された画像を異なるドメインから読み出し、 それを <canvas> 要素の中で同じドメインから読み出したかのように扱うことができます。

CORS 設定属性

CORS をサポートするいくつかの HTML 要素（<img> や <video> など）は crossorigin 属性（crossOrigin プロパティ）を持っており、要素が取得したデータに関する CORS リクエストを設定することができます。

rel="preload" によるコンテンツの先読み

HTML の <head> 要素内において、 <link> 要素で rel 属性に preload を指定することで、読み込み後すぐにページに必要なリソース、つまりページ読み込みの過程の初期の、ブラウザーの主なレンダリング機構が起動する前に、先読みを始めたいものを指定する宣言的なフェッチリクエストを記述することができます。これにより、ページの最初のレンダリングがブロックされにくくなり、パフォーマンスが向上します。この記事では preload がどのように動作するのかについての基本的なガイドを提供します。

レスポンシブ画像

この記事では、レスポンシブ画像という概念について学びます。レスポンシブ画像とは、画面サイズや解像度、他にも様々な機能が異なる端末でも適切に表示される画像のことです。また、 HTML でレスポンシブ画像を実装するために役立つツールについても見ていきます。これにより、さまざまな端末でパフォーマンスを向上させることができます。

リファレンス
HTML リファレンス

HTML は要素の集まりで、それぞれの要素がいくつかの属性で修飾される場合があります。 HTML 文書は互いにリンクで接続されます。

HTML 要素リファレンス

すべての HTML 要素の一覧を閲覧します。

HTML 属性リファレンス

HTML の要素には属性があります。これは要素を調整したり、さまざまな方法で振る舞いを調整したりするための付加的な値です。

グローバル属性

グローバル属性は、標準仕様で規定されていないものを含むすべての HTML 要素に指定できるものです。つまり、あらゆる標準外の要素も、それを使用することで文書が HTML5 に準拠しなくなるとしても、グローバル属性を受け入れなければならないということです。

インラインレベル要素とブロックレベル要素

通常、 HTML の要素は「インラインレベル」要素または「ブロックレベル」要素のどちらかです。インラインレベル要素は、要素を定義するタグによって指定された範囲のみを占有します。ブロックレベル要素は親要素（コンテナー）の範囲全体を占有し、それによって「ブロックボックス」を作成します。

HTML コメント

HTML コメントは、マークアップに説明メモを追加したり、文書内の特定の部分をブラウザーが解釈しないようにしたりするために使用します。

ウェブにおけるメディア種別と形式のガイド

<audio> および <video> 要素では、外部のソフトウェアの支援を必要とせずにコンテンツの中でネイティブに音声や動画を再生できます。

HTML コンテンツカテゴリー

HTML は数種類のコンテンツで構成されています。それぞれのコンテンツは特定のコンテキストで使用することができ、それ以外のコンテキストでは使用できません。同様に、それぞれのコンテキストには、格納することができる他のコンテンツカテゴリーと、その中で使用できる要素、または使用できない要素の集合があります。これは、これらのカテゴリーへのガイドです

後方互換モードと標準準拠モード

後方互換モードと標準準拠モードの歴史的な情報です。

関連トピック
CSS を使って HTML の要素に色をつける

この記事では、 CSS を使用して HTML コンテンツに色をつける方法、 HTML 文書のどの部分に色付けできるかの一覧、使用する CSS プロパティについて説明します。\n\nHTML: ハイパーテキストマークアップ言語HTML (HyperText Markup Language) はウェブのもっとも基本的な構成要素です。 HTML はウェブページの基本レイアウトに従ってウェブページのコンテンツを記述し定義するものです。 HTML に隣接する他の技術としては、ウェブページの表示や表現を記述するもの (CSS) または機能や振る舞いを記述するもの (JavaScript) があります。
「ハイパーテキスト」はウェブページから別なページに、ウェブサイト内でもウェブサイト間でも、接続するリンクを示します。リンクはウェブの基礎的な特徴です。コンテンツをインターネットにアップロードして他の人々が作成したページにリンクすれば、 World Wide Web の活発な参加者になれます。
HTML ではウェブブラウザーのテキスト、画像、その他のコンテンツを記述するために「マークアップ」を使用します。 HTML のマークアップには、 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> その他のたくさんの特殊な「要素」を用います。
HTML 要素は文書中で、< および > で囲まれた要素名で構成される「タグ」によって区別されます。タグ内の要素名は、大文字と小文字の区別がありません。つまり、大文字でも、小文字でも、混在して書いても構いません。例えば、 <title> タグは <Title> や <TITLE> やその他の方法で書くことができます。ただし、タグを小文字で書くのが慣習となっており、推奨されています。
以下の記事が HTML についてもっと学ぶのに役立ちます。初心者向けチュートリアル
初めてのウェブサイト: コンテンツの作成

この記事では、 HTML とは何か、また、どのように使用するのかについて、ウェブ開発に完全に新しい人々を対象に、簡単なツアーを提供します。

HTML によるコンテンツの構造化

ウェブ開発の学習の HTML モジュールの節では、 HTML の基礎をすべて一から学べます。

ガイド
HTML フォーム

フォームはウェブで非常に重要な部分です。――これはウェブサイトとのやり取り（登録やログイン、フィードバックの送信、商品の購入など）に必要な多くの機能を提供します。このモジュールでは、フォームのクライアント側／フロントエンド部分の作成から始めます。

CORS を利用した画像

crossorigin 属性と CORS ヘッダーを組み合わせることで、 <img> 要素で定義された画像を異なるドメインから読み出し、 それを <canvas> 要素の中で同じドメインから読み出したかのように扱うことができます。

CORS 設定属性

CORS をサポートするいくつかの HTML 要素（<img> や <video> など）は crossorigin 属性（crossOrigin プロパティ）を持っており、要素が取得したデータに関する CORS リクエストを設定することができます。

rel="preload" によるコンテンツの先読み

HTML の <head> 要素内において、 <link> 要素で rel 属性に preload を指定することで、読み込み後すぐにページに必要なリソース、つまりページ読み込みの過程の初期の、ブラウザーの主なレンダリング機構が起動する前に、先読みを始めたいものを指定する宣言的なフェッチリクエストを記述することができます。これにより、ページの最初のレンダリングがブロックされにくくなり、パフォーマンスが向上します。この記事では preload がどのように動作するのかについての基本的なガイドを提供します。

レスポンシブ画像

この記事では、レスポンシブ画像という概念について学びます。レスポンシブ画像とは、画面サイズや解像度、他にも様々な機能が異なる端末でも適切に表示される画像のことです。また、 HTML でレスポンシブ画像を実装するために役立つツールについても見ていきます。これにより、さまざまな端末でパフォーマンスを向上させることができます。

リファレンス
HTML リファレンス

HTML は要素の集まりで、それぞれの要素がいくつかの属性で修飾される場合があります。 HTML 文書は互いにリンクで接続されます。

HTML 要素リファレンス

すべての HTML 要素の一覧を閲覧します。

HTML 属性リファレンス

HTML の要素には属性があります。これは要素を調整したり、さまざまな方法で振る舞いを調整したりするための付加的な値です。

グローバル属性

グローバル属性は、標準仕様で規定されていないものを含むすべての HTML 要素に指定できるものです。つまり、あらゆる標準外の要素も、それを使用することで文書が HTML5 に準拠しなくなるとしても、グローバル属性を受け入れなければならないということです。

インラインレベル要素とブロックレベル要素

通常、 HTML の要素は「インラインレベル」要素または「ブロックレベル」要素のどちらかです。インラインレベル要素は、要素を定義するタグによって指定された範囲のみを占有します。ブロックレベル要素は親要素（コンテナー）の範囲全体を占有し、それによって「ブロックボックス」を作成します。

HTML コメント

HTML コメントは、マークアップに説明メモを追加したり、文書内の特定の部分をブラウザーが解釈しないようにしたりするために使用します。

ウェブにおけるメディア種別と形式のガイド

<audio> および <video> 要素では、外部のソフトウェアの支援を必要とせずにコンテンツの中でネイティブに音声や動画を再生できます。

HTML コンテンツカテゴリー

HTML は数種類のコンテンツで構成されています。それぞれのコンテンツは特定のコンテキストで使用することができ、それ以外のコンテキストでは使用できません。同様に、それぞれのコンテキストには、格納することができる他のコンテンツカテゴリーと、その中で使用できる要素、または使用できない要素の集合があります。これは、これらのカテゴリーへのガイドです

後方互換モードと標準準拠モード

後方互換モードと標準準拠モードの歴史的な情報です。

関連トピック
CSS を使って HTML の要素に色をつける

この記事では、 CSS を使用して HTML コンテンツに色をつける方法、 HTML 文書のどの部分に色付けできるかの一覧、使用する CSS プロパティについて説明します。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月15日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: ハイパーテキストマークアップ言語HTML (HyperText Markup Language) はウェブのもっとも基本的な構成要素です。 HTML はウェブページの基本レイアウトに従ってウェブページのコンテンツを記述し定義するものです。 HTML に隣接する他の技術としては、ウェブページの表示や表現を記述するもの (CSS) または機能や振る舞いを記述するもの (JavaScript) があります。
「ハイパーテキスト」はウェブページから別なページに、ウェブサイト内でもウェブサイト間でも、接続するリンクを示します。リンクはウェブの基礎的な特徴です。コンテンツをインターネットにアップロードして他の人々が作成したページにリンクすれば、 World Wide Web の活発な参加者になれます。
HTML ではウェブブラウザーのテキスト、画像、その他のコンテンツを記述するために「マークアップ」を使用します。 HTML のマークアップには、 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> その他のたくさんの特殊な「要素」を用います。
HTML 要素は文書中で、< および > で囲まれた要素名で構成される「タグ」によって区別されます。タグ内の要素名は、大文字と小文字の区別がありません。つまり、大文字でも、小文字でも、混在して書いても構いません。例えば、 <title> タグは <Title> や <TITLE> やその他の方法で書くことができます。ただし、タグを小文字で書くのが慣習となっており、推奨されています。
以下の記事が HTML についてもっと学ぶのに役立ちます。初心者向けチュートリアル
初めてのウェブサイト: コンテンツの作成

この記事では、 HTML とは何か、また、どのように使用するのかについて、ウェブ開発に完全に新しい人々を対象に、簡単なツアーを提供します。

HTML によるコンテンツの構造化

ウェブ開発の学習の HTML モジュールの節では、 HTML の基礎をすべて一から学べます。

ガイド
HTML フォーム

フォームはウェブで非常に重要な部分です。――これはウェブサイトとのやり取り（登録やログイン、フィードバックの送信、商品の購入など）に必要な多くの機能を提供します。このモジュールでは、フォームのクライアント側／フロントエンド部分の作成から始めます。

CORS を利用した画像

crossorigin 属性と CORS ヘッダーを組み合わせることで、 <img> 要素で定義された画像を異なるドメインから読み出し、 それを <canvas> 要素の中で同じドメインから読み出したかのように扱うことができます。

CORS 設定属性

CORS をサポートするいくつかの HTML 要素（<img> や <video> など）は crossorigin 属性（crossOrigin プロパティ）を持っており、要素が取得したデータに関する CORS リクエストを設定することができます。

rel="preload" によるコンテンツの先読み

HTML の <head> 要素内において、 <link> 要素で rel 属性に preload を指定することで、読み込み後すぐにページに必要なリソース、つまりページ読み込みの過程の初期の、ブラウザーの主なレンダリング機構が起動する前に、先読みを始めたいものを指定する宣言的なフェッチリクエストを記述することができます。これにより、ページの最初のレンダリングがブロックされにくくなり、パフォーマンスが向上します。この記事では preload がどのように動作するのかについての基本的なガイドを提供します。

レスポンシブ画像

この記事では、レスポンシブ画像という概念について学びます。レスポンシブ画像とは、画面サイズや解像度、他にも様々な機能が異なる端末でも適切に表示される画像のことです。また、 HTML でレスポンシブ画像を実装するために役立つツールについても見ていきます。これにより、さまざまな端末でパフォーマンスを向上させることができます。

リファレンス
HTML リファレンス

HTML は要素の集まりで、それぞれの要素がいくつかの属性で修飾される場合があります。 HTML 文書は互いにリンクで接続されます。

HTML 要素リファレンス

すべての HTML 要素の一覧を閲覧します。

HTML 属性リファレンス

HTML の要素には属性があります。これは要素を調整したり、さまざまな方法で振る舞いを調整したりするための付加的な値です。

グローバル属性

グローバル属性は、標準仕様で規定されていないものを含むすべての HTML 要素に指定できるものです。つまり、あらゆる標準外の要素も、それを使用することで文書が HTML5 に準拠しなくなるとしても、グローバル属性を受け入れなければならないということです。

インラインレベル要素とブロックレベル要素

通常、 HTML の要素は「インラインレベル」要素または「ブロックレベル」要素のどちらかです。インラインレベル要素は、要素を定義するタグによって指定された範囲のみを占有します。ブロックレベル要素は親要素（コンテナー）の範囲全体を占有し、それによって「ブロックボックス」を作成します。

HTML コメント

HTML コメントは、マークアップに説明メモを追加したり、文書内の特定の部分をブラウザーが解釈しないようにしたりするために使用します。

ウェブにおけるメディア種別と形式のガイド

<audio> および <video> 要素では、外部のソフトウェアの支援を必要とせずにコンテンツの中でネイティブに音声や動画を再生できます。

HTML コンテンツカテゴリー

HTML は数種類のコンテンツで構成されています。それぞれのコンテンツは特定のコンテキストで使用することができ、それ以外のコンテキストでは使用できません。同様に、それぞれのコンテキストには、格納することができる他のコンテンツカテゴリーと、その中で使用できる要素、または使用できない要素の集合があります。これは、これらのカテゴリーへのガイドです

後方互換モードと標準準拠モード

後方互換モードと標準準拠モードの歴史的な情報です。

関連トピック
CSS を使って HTML の要素に色をつける

この記事では、 CSS を使用して HTML コンテンツに色をつける方法、 HTML 文書のどの部分に色付けできるかの一覧、使用する CSS プロパティについて説明します。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月15日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: Hypertext Markup LanguageHTML(HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를
정의할 때 사용합니다. HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 (CSS), 또는 기능/동작 (JavaScript)을 설명하는 데 사용됩니다.
"Hypertext(하이퍼텍스트)"란 웹 페이지를 다른 페이지로 연결하는 링크를 말합니다. 링크는 웹의 근본적인 속성으로, 인터넷에 자료를 올리고 다른 사람이 만든 페이지로 연결함으로써 여러분도 월드 와이드 웹 세계의 능동적인 일원이 될 수 있습니다.
HTML은 웹 브라우저에 표시되는 글과 이미지 등의 다양한 콘텐츠를 표시하기 위해 "마크업"을 사용합니다. HTML 마크업은 다양한 "요소"를 사용하는데, 요소에는 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> 등 많은 종류가 존재합니다.
HTML 요소는 "태그"를 사용해서 문서의 다른 텍스트와 구분합니다. 태그는 "<", 태그 이름, ">"로 이루어집니다. 태그 안의 요소 이름은 대소문자를 구분하지 않습니다. 즉, 대문자, 소문자, 아니면 섞어서도 작성할 수 있습니다. 예를 들어 <title>요소는 <Title>, <TITLE>, 그 외 기타 가능한 모든 방법으로 작성할 수 있습니다.
아래 문서에서 HTML을 더 깊게 배워보세요.중요한 자료
HTML 소개

웹 개발이 처음이시라면 HTML 기본 문서에서 HTML이란 무엇인지, 그리고 HTML의 사용법을 배워보세요.

HTML 자습서

HTML 학습지를 방문하시면 HTML 사용법과 자습서, 완전한 예제를 찾아보실 수 있습니다.

HTML 참고서

방대한 HTML 참고서에서는 HTML을 구성하는 모든 요소와 특성의 자세한 설명을 볼 수 있습니다.




프런트엔드 웹 개발자가 되고자 하시나요?
목표를 달성하기 위한 모든 필수 정보가 들어있는 교육 과정을 준비했습니다.
시작하기
초보자 자습서MDN HTML 학습지는 HTML을 처음부터 알려주는 모듈로 구성되어 있습니다. 사전 지식도 필요하지 않습니다.

HTML 소개

이 모듈에서는 텍스트에 HTML을 추가하고, 하이퍼링크를 작성하고, HTML을 이용해 웹 페이지의 구조를 작성하는 등 중요한 개념과 구문에 익숙해지도록 기초를 다집니다.

멀티미디어와 임베딩

이 모듈에서는 HTML을 사용해 웹 페이지에 이미지를 추가하는 여러가지 방법과 오디오, 비디오, 혹은 다른 웹 페이지를 통째로 삽입하는 등 멀티미디어를 삽입하는 방법을 살펴봅니다.

HTML 표

표 형태의 데이터를 웹페이지에 이해하기도 쉽고 접근하기도 쉬운 방식으로 표현하는 것은 어려울 수 있습니다. 이 모듈은 기본적인 표 마크업 작성법과, 캡션과 요약 등 고급 기능 구현도 다룹니다.

HTML 양식

양식은 웹의 매우 중요한 부분으로, 회원가입과 로그인, 피드백 전송, 상품 구매 등 웹 사이트의 상호작용에 필요한 많은 기능을 제공합니다. 이 모듈은 양식의 클라이언트 사이트 개발 방법을 안내합니다.

일반적인 HTML 문제 해결하기

이 모듈은 HTML을 사용해서 웹 페이지 제목, 이미지와 비디오 추가, 콘텐츠 강조, 기본적인 양식 생성처럼 일반적인 문제를 해결하는 법을 설명합니다.

고급 주제
CORS 활성화 이미지

crossorigin 속성을 적절한 CORS 헤더와 조합하면 <img> 요소의 이미지를 외부 출처에서 가져올 수 있으며, 마치 현재 출처의 이미지인 것처럼 <canvas>에서도 사용할 수 있습니다.

CORS 설정 특성

<img>, <video> 등 CORS를 지원하는 일부 HTML 요소는 crossorigin 특성(crossOrigin 속성)을 보유하며, 해당 요소가 데이터를 가져올 때의 CORS 요청을 통제할 수 있습니다.

rel="preload"로 콘텐츠 미리 불러오기

<link> 요소, rel 특성의 preload 값을 사용하면 페이지를 불러온 직후 빠르게 사용해야 하는 리소스에 대해 선언적인 가져오기 요청을 <head> 안에 추가할 수 있습니다. 이렇게 지정한 리소스는 페이지 불러오기 라이프사이클의 초기, 브라우저의 주 렌더링이 시작하기도 전에 시작하고, 페이지의 첫 렌더링이 덜 막혀 성능이 개선됩니다. 이 글에서는 preload 작동 방식에 대한 기본적인 지침을 제공합니다.

참고서
HTML 참고서

HTML은 요소로 이루어져있으며, 각각의 요소는 몇 가지 특성을 사용해 수정할 수 있습니다. HTML 문서는 서로 링크로 연결되어 있습니다.

HTML 요소 참고서

모든 HTML 요소의 목록을 살펴보세요.

HTML 특성 참고서

HTML 요소는 특성을 가집니다. 특성은 요소나 그 동작 방식을 다양하게 설정하고 수정하는 일련의 추가 값입니다.

전역 특성

전역 특성은 모든 HTML 요소에 지정할 수 있으며, 심지어 표준에 명시되지 않은 요소에도 지정할 수 있습니다. 비록 비표준 요소를 사용하는 순간 문서는 HTML 표준을 준수하지 않는 것이지만, 그렇다고 해도 모든 비표준 요소는 전역 특성을 허용해야 합니다.

인라인 요소와 블록 레벨 요소

HTML의 요소는 역사적으로 "블록 레벨" 요소와 "인라인" 요소로 분류됐습니다. 인라인 요소는 콘텐츠의 흐름을 끊지 않고, 요소를 구성하는 태그에 할당된 공간만 차지합니다. 블록 레벨 요소는 부모 요소의 전체 공간을 차지하여 "블록"을 만듭니다.

HTML 미디어 유형과 형식 안내서

<audio>와 <video> 요소를 통해 외부 프로그램 없이 오디오와 비디오 미디어를 재생할 수 있습니다.

HTML 콘텐츠 카테고리

HTML 요소는 어떤 상황에서는 사용할 수 있고, 어떤 상황에서는 사용할 수 없는지 결정하는 여러가지 분류, 콘텐츠 카테고리에 속합니다. 마찬가지로, 요소는 자신의 콘텐츠로 허용할 콘텐츠 카테고리도 정의합니다.

호환성 모드와 표준 모드

호환성 모드와 표준 모드에 대한 역사적인 정보입니다.

관련 주제
CSS를 사용해 HTML 요소에 색 입히기

이 문서는 HTML 문서의 어떤 부분에 색을 적용할 수 있는지와, 이 때 사용할 수 있는 CSS 속성을 나열합니다. 예제와 함께 각종 도구로의 링크도 제공합니다.\n\nHTML: Hypertext Markup LanguageHTML(HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를
정의할 때 사용합니다. HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 (CSS), 또는 기능/동작 (JavaScript)을 설명하는 데 사용됩니다.
"Hypertext(하이퍼텍스트)"란 웹 페이지를 다른 페이지로 연결하는 링크를 말합니다. 링크는 웹의 근본적인 속성으로, 인터넷에 자료를 올리고 다른 사람이 만든 페이지로 연결함으로써 여러분도 월드 와이드 웹 세계의 능동적인 일원이 될 수 있습니다.
HTML은 웹 브라우저에 표시되는 글과 이미지 등의 다양한 콘텐츠를 표시하기 위해 "마크업"을 사용합니다. HTML 마크업은 다양한 "요소"를 사용하는데, 요소에는 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> 등 많은 종류가 존재합니다.
HTML 요소는 "태그"를 사용해서 문서의 다른 텍스트와 구분합니다. 태그는 "<", 태그 이름, ">"로 이루어집니다. 태그 안의 요소 이름은 대소문자를 구분하지 않습니다. 즉, 대문자, 소문자, 아니면 섞어서도 작성할 수 있습니다. 예를 들어 <title>요소는 <Title>, <TITLE>, 그 외 기타 가능한 모든 방법으로 작성할 수 있습니다.
아래 문서에서 HTML을 더 깊게 배워보세요.중요한 자료
HTML 소개

웹 개발이 처음이시라면 HTML 기본 문서에서 HTML이란 무엇인지, 그리고 HTML의 사용법을 배워보세요.

HTML 자습서

HTML 학습지를 방문하시면 HTML 사용법과 자습서, 완전한 예제를 찾아보실 수 있습니다.

HTML 참고서

방대한 HTML 참고서에서는 HTML을 구성하는 모든 요소와 특성의 자세한 설명을 볼 수 있습니다.




프런트엔드 웹 개발자가 되고자 하시나요?
목표를 달성하기 위한 모든 필수 정보가 들어있는 교육 과정을 준비했습니다.
시작하기
초보자 자습서MDN HTML 학습지는 HTML을 처음부터 알려주는 모듈로 구성되어 있습니다. 사전 지식도 필요하지 않습니다.

HTML 소개

이 모듈에서는 텍스트에 HTML을 추가하고, 하이퍼링크를 작성하고, HTML을 이용해 웹 페이지의 구조를 작성하는 등 중요한 개념과 구문에 익숙해지도록 기초를 다집니다.

멀티미디어와 임베딩

이 모듈에서는 HTML을 사용해 웹 페이지에 이미지를 추가하는 여러가지 방법과 오디오, 비디오, 혹은 다른 웹 페이지를 통째로 삽입하는 등 멀티미디어를 삽입하는 방법을 살펴봅니다.

HTML 표

표 형태의 데이터를 웹페이지에 이해하기도 쉽고 접근하기도 쉬운 방식으로 표현하는 것은 어려울 수 있습니다. 이 모듈은 기본적인 표 마크업 작성법과, 캡션과 요약 등 고급 기능 구현도 다룹니다.

HTML 양식

양식은 웹의 매우 중요한 부분으로, 회원가입과 로그인, 피드백 전송, 상품 구매 등 웹 사이트의 상호작용에 필요한 많은 기능을 제공합니다. 이 모듈은 양식의 클라이언트 사이트 개발 방법을 안내합니다.

일반적인 HTML 문제 해결하기

이 모듈은 HTML을 사용해서 웹 페이지 제목, 이미지와 비디오 추가, 콘텐츠 강조, 기본적인 양식 생성처럼 일반적인 문제를 해결하는 법을 설명합니다.

고급 주제
CORS 활성화 이미지

crossorigin 속성을 적절한 CORS 헤더와 조합하면 <img> 요소의 이미지를 외부 출처에서 가져올 수 있으며, 마치 현재 출처의 이미지인 것처럼 <canvas>에서도 사용할 수 있습니다.

CORS 설정 특성

<img>, <video> 등 CORS를 지원하는 일부 HTML 요소는 crossorigin 특성(crossOrigin 속성)을 보유하며, 해당 요소가 데이터를 가져올 때의 CORS 요청을 통제할 수 있습니다.

rel="preload"로 콘텐츠 미리 불러오기

<link> 요소, rel 특성의 preload 값을 사용하면 페이지를 불러온 직후 빠르게 사용해야 하는 리소스에 대해 선언적인 가져오기 요청을 <head> 안에 추가할 수 있습니다. 이렇게 지정한 리소스는 페이지 불러오기 라이프사이클의 초기, 브라우저의 주 렌더링이 시작하기도 전에 시작하고, 페이지의 첫 렌더링이 덜 막혀 성능이 개선됩니다. 이 글에서는 preload 작동 방식에 대한 기본적인 지침을 제공합니다.

참고서
HTML 참고서

HTML은 요소로 이루어져있으며, 각각의 요소는 몇 가지 특성을 사용해 수정할 수 있습니다. HTML 문서는 서로 링크로 연결되어 있습니다.

HTML 요소 참고서

모든 HTML 요소의 목록을 살펴보세요.

HTML 특성 참고서

HTML 요소는 특성을 가집니다. 특성은 요소나 그 동작 방식을 다양하게 설정하고 수정하는 일련의 추가 값입니다.

전역 특성

전역 특성은 모든 HTML 요소에 지정할 수 있으며, 심지어 표준에 명시되지 않은 요소에도 지정할 수 있습니다. 비록 비표준 요소를 사용하는 순간 문서는 HTML 표준을 준수하지 않는 것이지만, 그렇다고 해도 모든 비표준 요소는 전역 특성을 허용해야 합니다.

인라인 요소와 블록 레벨 요소

HTML의 요소는 역사적으로 "블록 레벨" 요소와 "인라인" 요소로 분류됐습니다. 인라인 요소는 콘텐츠의 흐름을 끊지 않고, 요소를 구성하는 태그에 할당된 공간만 차지합니다. 블록 레벨 요소는 부모 요소의 전체 공간을 차지하여 "블록"을 만듭니다.

HTML 미디어 유형과 형식 안내서

<audio>와 <video> 요소를 통해 외부 프로그램 없이 오디오와 비디오 미디어를 재생할 수 있습니다.

HTML 콘텐츠 카테고리

HTML 요소는 어떤 상황에서는 사용할 수 있고, 어떤 상황에서는 사용할 수 없는지 결정하는 여러가지 분류, 콘텐츠 카테고리에 속합니다. 마찬가지로, 요소는 자신의 콘텐츠로 허용할 콘텐츠 카테고리도 정의합니다.

호환성 모드와 표준 모드

호환성 모드와 표준 모드에 대한 역사적인 정보입니다.

관련 주제
CSS를 사용해 HTML 요소에 색 입히기

이 문서는 HTML 문서의 어떤 부분에 색을 적용할 수 있는지와, 이 때 사용할 수 있는 CSS 속성을 나열합니다. 예제와 함께 각종 도구로의 링크도 제공합니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 3월 22일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: Hypertext Markup LanguageHTML(HyperText Markup Language)은 웹을 이루는 가장 기초적인 구성 요소로, 웹 콘텐츠의 의미와 구조를
정의할 때 사용합니다. HTML 이외의 다른 기술은 일반적으로 웹 페이지의 모양/표현 (CSS), 또는 기능/동작 (JavaScript)을 설명하는 데 사용됩니다.
"Hypertext(하이퍼텍스트)"란 웹 페이지를 다른 페이지로 연결하는 링크를 말합니다. 링크는 웹의 근본적인 속성으로, 인터넷에 자료를 올리고 다른 사람이 만든 페이지로 연결함으로써 여러분도 월드 와이드 웹 세계의 능동적인 일원이 될 수 있습니다.
HTML은 웹 브라우저에 표시되는 글과 이미지 등의 다양한 콘텐츠를 표시하기 위해 "마크업"을 사용합니다. HTML 마크업은 다양한 "요소"를 사용하는데, 요소에는 <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> 등 많은 종류가 존재합니다.
HTML 요소는 "태그"를 사용해서 문서의 다른 텍스트와 구분합니다. 태그는 "<", 태그 이름, ">"로 이루어집니다. 태그 안의 요소 이름은 대소문자를 구분하지 않습니다. 즉, 대문자, 소문자, 아니면 섞어서도 작성할 수 있습니다. 예를 들어 <title>요소는 <Title>, <TITLE>, 그 외 기타 가능한 모든 방법으로 작성할 수 있습니다.
아래 문서에서 HTML을 더 깊게 배워보세요.중요한 자료
HTML 소개

웹 개발이 처음이시라면 HTML 기본 문서에서 HTML이란 무엇인지, 그리고 HTML의 사용법을 배워보세요.

HTML 자습서

HTML 학습지를 방문하시면 HTML 사용법과 자습서, 완전한 예제를 찾아보실 수 있습니다.

HTML 참고서

방대한 HTML 참고서에서는 HTML을 구성하는 모든 요소와 특성의 자세한 설명을 볼 수 있습니다.




프런트엔드 웹 개발자가 되고자 하시나요?
목표를 달성하기 위한 모든 필수 정보가 들어있는 교육 과정을 준비했습니다.
시작하기
초보자 자습서MDN HTML 학습지는 HTML을 처음부터 알려주는 모듈로 구성되어 있습니다. 사전 지식도 필요하지 않습니다.

HTML 소개

이 모듈에서는 텍스트에 HTML을 추가하고, 하이퍼링크를 작성하고, HTML을 이용해 웹 페이지의 구조를 작성하는 등 중요한 개념과 구문에 익숙해지도록 기초를 다집니다.

멀티미디어와 임베딩

이 모듈에서는 HTML을 사용해 웹 페이지에 이미지를 추가하는 여러가지 방법과 오디오, 비디오, 혹은 다른 웹 페이지를 통째로 삽입하는 등 멀티미디어를 삽입하는 방법을 살펴봅니다.

HTML 표

표 형태의 데이터를 웹페이지에 이해하기도 쉽고 접근하기도 쉬운 방식으로 표현하는 것은 어려울 수 있습니다. 이 모듈은 기본적인 표 마크업 작성법과, 캡션과 요약 등 고급 기능 구현도 다룹니다.

HTML 양식

양식은 웹의 매우 중요한 부분으로, 회원가입과 로그인, 피드백 전송, 상품 구매 등 웹 사이트의 상호작용에 필요한 많은 기능을 제공합니다. 이 모듈은 양식의 클라이언트 사이트 개발 방법을 안내합니다.

일반적인 HTML 문제 해결하기

이 모듈은 HTML을 사용해서 웹 페이지 제목, 이미지와 비디오 추가, 콘텐츠 강조, 기본적인 양식 생성처럼 일반적인 문제를 해결하는 법을 설명합니다.

고급 주제
CORS 활성화 이미지

crossorigin 속성을 적절한 CORS 헤더와 조합하면 <img> 요소의 이미지를 외부 출처에서 가져올 수 있으며, 마치 현재 출처의 이미지인 것처럼 <canvas>에서도 사용할 수 있습니다.

CORS 설정 특성

<img>, <video> 등 CORS를 지원하는 일부 HTML 요소는 crossorigin 특성(crossOrigin 속성)을 보유하며, 해당 요소가 데이터를 가져올 때의 CORS 요청을 통제할 수 있습니다.

rel="preload"로 콘텐츠 미리 불러오기

<link> 요소, rel 특성의 preload 값을 사용하면 페이지를 불러온 직후 빠르게 사용해야 하는 리소스에 대해 선언적인 가져오기 요청을 <head> 안에 추가할 수 있습니다. 이렇게 지정한 리소스는 페이지 불러오기 라이프사이클의 초기, 브라우저의 주 렌더링이 시작하기도 전에 시작하고, 페이지의 첫 렌더링이 덜 막혀 성능이 개선됩니다. 이 글에서는 preload 작동 방식에 대한 기본적인 지침을 제공합니다.

참고서
HTML 참고서

HTML은 요소로 이루어져있으며, 각각의 요소는 몇 가지 특성을 사용해 수정할 수 있습니다. HTML 문서는 서로 링크로 연결되어 있습니다.

HTML 요소 참고서

모든 HTML 요소의 목록을 살펴보세요.

HTML 특성 참고서

HTML 요소는 특성을 가집니다. 특성은 요소나 그 동작 방식을 다양하게 설정하고 수정하는 일련의 추가 값입니다.

전역 특성

전역 특성은 모든 HTML 요소에 지정할 수 있으며, 심지어 표준에 명시되지 않은 요소에도 지정할 수 있습니다. 비록 비표준 요소를 사용하는 순간 문서는 HTML 표준을 준수하지 않는 것이지만, 그렇다고 해도 모든 비표준 요소는 전역 특성을 허용해야 합니다.

인라인 요소와 블록 레벨 요소

HTML의 요소는 역사적으로 "블록 레벨" 요소와 "인라인" 요소로 분류됐습니다. 인라인 요소는 콘텐츠의 흐름을 끊지 않고, 요소를 구성하는 태그에 할당된 공간만 차지합니다. 블록 레벨 요소는 부모 요소의 전체 공간을 차지하여 "블록"을 만듭니다.

HTML 미디어 유형과 형식 안내서

<audio>와 <video> 요소를 통해 외부 프로그램 없이 오디오와 비디오 미디어를 재생할 수 있습니다.

HTML 콘텐츠 카테고리

HTML 요소는 어떤 상황에서는 사용할 수 있고, 어떤 상황에서는 사용할 수 없는지 결정하는 여러가지 분류, 콘텐츠 카테고리에 속합니다. 마찬가지로, 요소는 자신의 콘텐츠로 허용할 콘텐츠 카테고리도 정의합니다.

호환성 모드와 표준 모드

호환성 모드와 표준 모드에 대한 역사적인 정보입니다.

관련 주제
CSS를 사용해 HTML 요소에 색 입히기

이 문서는 HTML 문서의 어떤 부분에 색을 적용할 수 있는지와, 이 때 사용할 수 있는 CSS 속성을 나열합니다. 예제와 함께 각종 도구로의 링크도 제공합니다.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025년 3월 22일 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: Linguagem de Marcação de HipertextoHTML (Linguagem de Marcação de HiperTexto) é o bloco de construção mais básico da web. Define o significado e a estrutura do conteúdo da web. Outras tecnologias além do HTML geralmente são usadas para descrever a aparência/apresentação (CSS) ou a funcionalidade/comportamento (JavaScript) de uma página da web.
"Hipertexto" refere-se aos links que conectam páginas da Web entre si, seja dentro de um único site ou entre sites. Links são um aspecto fundamental da web. Ao carregar conteúdo na Internet e vinculá-lo a páginas criadas por outras pessoas, você se torna um participante ativo na world wide web.
O HTML usa "Marcação" para anotar texto, imagem e outros conteúdos para exibição em um navegador da Web. A marcação HTML inclui "elementos" especiais, como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> e muitos outros.
Um elemento HTML é separado de outro texto em um documento por "tags", que consistem no nome do elemento entre "<" e ">". O nome de um elemento dentro de uma tag é insensível a maiúsculas e minúsculas. Isto é, pode ser escrito em maiúsculas, minúsculas ou um mistura. Por exemplo, a tag <title> pode ser escrita como <Title>, <TITLE> ou de qualquer outra forma.
Os artigos abaixo podem ajudá-lo a aprender mais sobre HTML.


Introdução ao HTML
Se você é novo no desenvolvimento web, não deixe de ler nosso artigo O Básico do HTML para aprender o que é HTML e como usá-lo.


Tutoriais HTML
Para artigos sobre como usar o HTML, assim como tutoriais e exemplos completos, confira nossa Área de Aprendizado de HTML.


Referência do HTML
Em nossa extensa seção de Referência do HTML, você encontrará os detalhes sobre cada elemento e atributo do HTML.

Tutoriais para iniciantesNossa Área de Aprendizado de HTML apresenta vários módulos que ensinam HTML desde o início — sem necessidade de conhecimento prévio.

Introdução ao HTML

Este módulo fornece uma base de conhecimento, permitindo que você acostume-se com os conceitos e sintaxes importantes, tais como aplicar HTML para texto, como criar hyperlinks e como usar HTML para estruturar uma página web.

Multimídia e como incorporá-la

Este módulo explora como usar HTML para incluir multimídia em sua página web, incluindo as diferentes maneiras para incluir imagens, e como incorporar vídeos, áudios e até como colocar uma página inteira em outras páginas web.

Tabelas HTML

Representar dados tabulares em uma página web de maneira entendível e acessível pode ser um desafio. Este módulo cobre marcação tabular básica, junto com outras funcionalidades mais complexas como legendas e sumários.

Formulários HTML

Formulários são partes muito importantes na Web — proporcionam muitas das funcionalidades que você precisa para interagir em páginas web. Exemplos disso são registrar-se e conectar-se, enviar comentários, comprar produtos e muito mais. Este módulo lhe permite começar a criar as partes visíveis dos formulários, ou seja, as partes que os usuários interagem.

Usando HTML para resolver problemas comuns

Apresenta links para seções com conteúdo explicando como usar HTML para resolver problemas muito comuns, quando se cria uma página web: como trabalhar com títulos, agregar imagens ou vídeos, colocar ênfase em conteúdo, criar um formulário básico, etc.

Tópicos avançados
Habilitando Imagem CORS

O atributo crossorigin, em combinação com um cabeçalho CORS adequado, permite definir imagens pelo elemento <img> para ser carregado de outras fontes em um elemento <canvas> como se estivessem sendo carregados da fonte atual.

Configuração de atributos CORS

Alguns elementos em HTML que suportam CORS, como por exemplo o <img> ou <video>, têm o atributo crossorigin (a propriedade crossOrigin), que permite configurar as requisições CORS para os dados recebidos pelo elemento.

Gerenciamento de foco em HTML

O atributo DOM activeElement e o método DOM hasFocus() lhe ajudam a melhorar a interação entre o usuário e os elementos da página.

Tipos de conexões

Em HTML, vários tipos de links podem ser utilizados para realizar conexões entre documentos, como por exemplo <a>, <area> e <link>.

Formatos de arquivos suportados pelos elementos de áudio e vídeo em HTML

Os elementos <audio> e <video> permitem que você reproduza áudios e vídeos no seu HTML. Estes elementos fornecem uma alternativa nativa de recursos do navegador, parecidos com a do Adobe Flash Player e outros plug-ins.

Usando o cachê de aplicação

O cachê de aplicação tem como o objetivo executar a aplicação offline. Você pode usar a interface Application Cache (AppCache) para escolher elementos que o browser possa guardar, deixando-os disponíveis para usuários desconectados. As aplicações que forem armazenadas em cache podem ser utilizadas sem nenhum problema, mesmo que o usuário clique no botão de atualizar a página enquanto estiver offline.

Pré-carregando conteúdo com rel="preload"

O valor preload do atributo rel do elemento <link> permite que você escreva solicitações de busca declarativas em seu elemento <head> do HTML, especificando recursos que suas páginas vão utilizar logo após o carregamento. Você também pode necessitar que estes recursos sejam pré-carregados ao início do ciclo de execução da página e depois que o mecanismo de renderização do navegador comece a agir. Isso garante que estarão disponíveis mais cedo e que seja menos provável que sua página seja bloqueada do processo de renderizar. Isso aumenta a performance da página. Este artigo oferece um guia básico de como preload funciona.

Referências
Referência do HTML

HTML é formado de elementos, onde cada um deles pode ser modificado por alguns atributos. Documentos HTML são interconectados através de links.

Referência dos Elementos HTML

Navegue em uma lista com todos os elementos HTML.

Referência de atributos em HTML

Elementos em HTML possuem atributos. Estes configuram ou ajustam o funcionamento e o comportamento dos seus elementos de muitas maneiras.

Atributos Globais

Os atributos globais podem ser utilizados em todos os elementos HTML, mesmo aqueles que não são especificados como padrão. Isso significa que qualquer elemento não padrão vai permitir estes atributos, mesmo que este retorne um documento HTML5 incompatível.

Elementos em linha e Elementos em nível de bloco

Elementos HTML são normalmente elementos inline (em linha) ou block-level (em nível de bloco). Um elemento em linha ocupa somente o espaço limitado pelas tags que o definem. Um elemento em nível de bloco ocupa o espaço inteiro do elemento pai (container), portanto criando um bloco.

Tipos de Links

No HTML, vários tipos de links podem ser utilizados para estabelecer e definir o relacionamento entre dois documentos. Os tipos de elementos de link que podem ser incluídos são <a>, <area> e <link>.

Formatos de mídia suportados pelos elementos vídeo e áudio do HTML

Os elementos <audio> e <video> permitem que você reproduza mídias de áudio e vídeo. Estes elementos fornecem uma alternativa nativa para o navegador reproduzir recursos similares aos encontrados no Adobe Flash e outros plug-ins.

Tipos de conteúdo HTML

O HTML é composto de uma grande diversidade de conteúdos, e cada um pode ser usado em certos contextos e não ser permitido em outros. Da mesma forma, cada um tem um conjunto de outras categorias de conteúdos que podem ou não serem usadas dentro deles. Este é um guia destas categorias.

Os Modos Quirks e o Modo Padrão

Informações sobre a história dos Modos Quirks e o Modo padrão.

Tópicos relacionados
Aplicando cores em elementos HTML usando CSS

Este artigo mostra as principais formas de se usar CSS para adicionar cores ao seu conteúdo HTML, mostrando que partes dos documentos HTML podem ser coloridas e quais propriedades utilizar. Inclui exemplos e links para ferramentas de palette-building, entre outros.\n\nHTML: Linguagem de Marcação de HipertextoHTML (Linguagem de Marcação de HiperTexto) é o bloco de construção mais básico da web. Define o significado e a estrutura do conteúdo da web. Outras tecnologias além do HTML geralmente são usadas para descrever a aparência/apresentação (CSS) ou a funcionalidade/comportamento (JavaScript) de uma página da web.
"Hipertexto" refere-se aos links que conectam páginas da Web entre si, seja dentro de um único site ou entre sites. Links são um aspecto fundamental da web. Ao carregar conteúdo na Internet e vinculá-lo a páginas criadas por outras pessoas, você se torna um participante ativo na world wide web.
O HTML usa "Marcação" para anotar texto, imagem e outros conteúdos para exibição em um navegador da Web. A marcação HTML inclui "elementos" especiais, como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> e muitos outros.
Um elemento HTML é separado de outro texto em um documento por "tags", que consistem no nome do elemento entre "<" e ">". O nome de um elemento dentro de uma tag é insensível a maiúsculas e minúsculas. Isto é, pode ser escrito em maiúsculas, minúsculas ou um mistura. Por exemplo, a tag <title> pode ser escrita como <Title>, <TITLE> ou de qualquer outra forma.
Os artigos abaixo podem ajudá-lo a aprender mais sobre HTML.


Introdução ao HTML
Se você é novo no desenvolvimento web, não deixe de ler nosso artigo O Básico do HTML para aprender o que é HTML e como usá-lo.


Tutoriais HTML
Para artigos sobre como usar o HTML, assim como tutoriais e exemplos completos, confira nossa Área de Aprendizado de HTML.


Referência do HTML
Em nossa extensa seção de Referência do HTML, você encontrará os detalhes sobre cada elemento e atributo do HTML.

Tutoriais para iniciantesNossa Área de Aprendizado de HTML apresenta vários módulos que ensinam HTML desde o início — sem necessidade de conhecimento prévio.

Introdução ao HTML

Este módulo fornece uma base de conhecimento, permitindo que você acostume-se com os conceitos e sintaxes importantes, tais como aplicar HTML para texto, como criar hyperlinks e como usar HTML para estruturar uma página web.

Multimídia e como incorporá-la

Este módulo explora como usar HTML para incluir multimídia em sua página web, incluindo as diferentes maneiras para incluir imagens, e como incorporar vídeos, áudios e até como colocar uma página inteira em outras páginas web.

Tabelas HTML

Representar dados tabulares em uma página web de maneira entendível e acessível pode ser um desafio. Este módulo cobre marcação tabular básica, junto com outras funcionalidades mais complexas como legendas e sumários.

Formulários HTML

Formulários são partes muito importantes na Web — proporcionam muitas das funcionalidades que você precisa para interagir em páginas web. Exemplos disso são registrar-se e conectar-se, enviar comentários, comprar produtos e muito mais. Este módulo lhe permite começar a criar as partes visíveis dos formulários, ou seja, as partes que os usuários interagem.

Usando HTML para resolver problemas comuns

Apresenta links para seções com conteúdo explicando como usar HTML para resolver problemas muito comuns, quando se cria uma página web: como trabalhar com títulos, agregar imagens ou vídeos, colocar ênfase em conteúdo, criar um formulário básico, etc.

Tópicos avançados
Habilitando Imagem CORS

O atributo crossorigin, em combinação com um cabeçalho CORS adequado, permite definir imagens pelo elemento <img> para ser carregado de outras fontes em um elemento <canvas> como se estivessem sendo carregados da fonte atual.

Configuração de atributos CORS

Alguns elementos em HTML que suportam CORS, como por exemplo o <img> ou <video>, têm o atributo crossorigin (a propriedade crossOrigin), que permite configurar as requisições CORS para os dados recebidos pelo elemento.

Gerenciamento de foco em HTML

O atributo DOM activeElement e o método DOM hasFocus() lhe ajudam a melhorar a interação entre o usuário e os elementos da página.

Tipos de conexões

Em HTML, vários tipos de links podem ser utilizados para realizar conexões entre documentos, como por exemplo <a>, <area> e <link>.

Formatos de arquivos suportados pelos elementos de áudio e vídeo em HTML

Os elementos <audio> e <video> permitem que você reproduza áudios e vídeos no seu HTML. Estes elementos fornecem uma alternativa nativa de recursos do navegador, parecidos com a do Adobe Flash Player e outros plug-ins.

Usando o cachê de aplicação

O cachê de aplicação tem como o objetivo executar a aplicação offline. Você pode usar a interface Application Cache (AppCache) para escolher elementos que o browser possa guardar, deixando-os disponíveis para usuários desconectados. As aplicações que forem armazenadas em cache podem ser utilizadas sem nenhum problema, mesmo que o usuário clique no botão de atualizar a página enquanto estiver offline.

Pré-carregando conteúdo com rel="preload"

O valor preload do atributo rel do elemento <link> permite que você escreva solicitações de busca declarativas em seu elemento <head> do HTML, especificando recursos que suas páginas vão utilizar logo após o carregamento. Você também pode necessitar que estes recursos sejam pré-carregados ao início do ciclo de execução da página e depois que o mecanismo de renderização do navegador comece a agir. Isso garante que estarão disponíveis mais cedo e que seja menos provável que sua página seja bloqueada do processo de renderizar. Isso aumenta a performance da página. Este artigo oferece um guia básico de como preload funciona.

Referências
Referência do HTML

HTML é formado de elementos, onde cada um deles pode ser modificado por alguns atributos. Documentos HTML são interconectados através de links.

Referência dos Elementos HTML

Navegue em uma lista com todos os elementos HTML.

Referência de atributos em HTML

Elementos em HTML possuem atributos. Estes configuram ou ajustam o funcionamento e o comportamento dos seus elementos de muitas maneiras.

Atributos Globais

Os atributos globais podem ser utilizados em todos os elementos HTML, mesmo aqueles que não são especificados como padrão. Isso significa que qualquer elemento não padrão vai permitir estes atributos, mesmo que este retorne um documento HTML5 incompatível.

Elementos em linha e Elementos em nível de bloco

Elementos HTML são normalmente elementos inline (em linha) ou block-level (em nível de bloco). Um elemento em linha ocupa somente o espaço limitado pelas tags que o definem. Um elemento em nível de bloco ocupa o espaço inteiro do elemento pai (container), portanto criando um bloco.

Tipos de Links

No HTML, vários tipos de links podem ser utilizados para estabelecer e definir o relacionamento entre dois documentos. Os tipos de elementos de link que podem ser incluídos são <a>, <area> e <link>.

Formatos de mídia suportados pelos elementos vídeo e áudio do HTML

Os elementos <audio> e <video> permitem que você reproduza mídias de áudio e vídeo. Estes elementos fornecem uma alternativa nativa para o navegador reproduzir recursos similares aos encontrados no Adobe Flash e outros plug-ins.

Tipos de conteúdo HTML

O HTML é composto de uma grande diversidade de conteúdos, e cada um pode ser usado em certos contextos e não ser permitido em outros. Da mesma forma, cada um tem um conjunto de outras categorias de conteúdos que podem ou não serem usadas dentro deles. Este é um guia destas categorias.

Os Modos Quirks e o Modo Padrão

Informações sobre a história dos Modos Quirks e o Modo padrão.

Tópicos relacionados
Aplicando cores em elementos HTML usando CSS

Este artigo mostra as principais formas de se usar CSS para adicionar cores ao seu conteúdo HTML, mostrando que partes dos documentos HTML podem ser coloridas e quais propriedades utilizar. Inclui exemplos e links para ferramentas de palette-building, entre outros.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: Linguagem de Marcação de HipertextoHTML (Linguagem de Marcação de HiperTexto) é o bloco de construção mais básico da web. Define o significado e a estrutura do conteúdo da web. Outras tecnologias além do HTML geralmente são usadas para descrever a aparência/apresentação (CSS) ou a funcionalidade/comportamento (JavaScript) de uma página da web.
"Hipertexto" refere-se aos links que conectam páginas da Web entre si, seja dentro de um único site ou entre sites. Links são um aspecto fundamental da web. Ao carregar conteúdo na Internet e vinculá-lo a páginas criadas por outras pessoas, você se torna um participante ativo na world wide web.
O HTML usa "Marcação" para anotar texto, imagem e outros conteúdos para exibição em um navegador da Web. A marcação HTML inclui "elementos" especiais, como <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video>, <ul>, <ol>, <li> e muitos outros.
Um elemento HTML é separado de outro texto em um documento por "tags", que consistem no nome do elemento entre "<" e ">". O nome de um elemento dentro de uma tag é insensível a maiúsculas e minúsculas. Isto é, pode ser escrito em maiúsculas, minúsculas ou um mistura. Por exemplo, a tag <title> pode ser escrita como <Title>, <TITLE> ou de qualquer outra forma.
Os artigos abaixo podem ajudá-lo a aprender mais sobre HTML.


Introdução ao HTML
Se você é novo no desenvolvimento web, não deixe de ler nosso artigo O Básico do HTML para aprender o que é HTML e como usá-lo.


Tutoriais HTML
Para artigos sobre como usar o HTML, assim como tutoriais e exemplos completos, confira nossa Área de Aprendizado de HTML.


Referência do HTML
Em nossa extensa seção de Referência do HTML, você encontrará os detalhes sobre cada elemento e atributo do HTML.

Tutoriais para iniciantesNossa Área de Aprendizado de HTML apresenta vários módulos que ensinam HTML desde o início — sem necessidade de conhecimento prévio.

Introdução ao HTML

Este módulo fornece uma base de conhecimento, permitindo que você acostume-se com os conceitos e sintaxes importantes, tais como aplicar HTML para texto, como criar hyperlinks e como usar HTML para estruturar uma página web.

Multimídia e como incorporá-la

Este módulo explora como usar HTML para incluir multimídia em sua página web, incluindo as diferentes maneiras para incluir imagens, e como incorporar vídeos, áudios e até como colocar uma página inteira em outras páginas web.

Tabelas HTML

Representar dados tabulares em uma página web de maneira entendível e acessível pode ser um desafio. Este módulo cobre marcação tabular básica, junto com outras funcionalidades mais complexas como legendas e sumários.

Formulários HTML

Formulários são partes muito importantes na Web — proporcionam muitas das funcionalidades que você precisa para interagir em páginas web. Exemplos disso são registrar-se e conectar-se, enviar comentários, comprar produtos e muito mais. Este módulo lhe permite começar a criar as partes visíveis dos formulários, ou seja, as partes que os usuários interagem.

Usando HTML para resolver problemas comuns

Apresenta links para seções com conteúdo explicando como usar HTML para resolver problemas muito comuns, quando se cria uma página web: como trabalhar com títulos, agregar imagens ou vídeos, colocar ênfase em conteúdo, criar um formulário básico, etc.

Tópicos avançados
Habilitando Imagem CORS

O atributo crossorigin, em combinação com um cabeçalho CORS adequado, permite definir imagens pelo elemento <img> para ser carregado de outras fontes em um elemento <canvas> como se estivessem sendo carregados da fonte atual.

Configuração de atributos CORS

Alguns elementos em HTML que suportam CORS, como por exemplo o <img> ou <video>, têm o atributo crossorigin (a propriedade crossOrigin), que permite configurar as requisições CORS para os dados recebidos pelo elemento.

Gerenciamento de foco em HTML

O atributo DOM activeElement e o método DOM hasFocus() lhe ajudam a melhorar a interação entre o usuário e os elementos da página.

Tipos de conexões

Em HTML, vários tipos de links podem ser utilizados para realizar conexões entre documentos, como por exemplo <a>, <area> e <link>.

Formatos de arquivos suportados pelos elementos de áudio e vídeo em HTML

Os elementos <audio> e <video> permitem que você reproduza áudios e vídeos no seu HTML. Estes elementos fornecem uma alternativa nativa de recursos do navegador, parecidos com a do Adobe Flash Player e outros plug-ins.

Usando o cachê de aplicação

O cachê de aplicação tem como o objetivo executar a aplicação offline. Você pode usar a interface Application Cache (AppCache) para escolher elementos que o browser possa guardar, deixando-os disponíveis para usuários desconectados. As aplicações que forem armazenadas em cache podem ser utilizadas sem nenhum problema, mesmo que o usuário clique no botão de atualizar a página enquanto estiver offline.

Pré-carregando conteúdo com rel="preload"

O valor preload do atributo rel do elemento <link> permite que você escreva solicitações de busca declarativas em seu elemento <head> do HTML, especificando recursos que suas páginas vão utilizar logo após o carregamento. Você também pode necessitar que estes recursos sejam pré-carregados ao início do ciclo de execução da página e depois que o mecanismo de renderização do navegador comece a agir. Isso garante que estarão disponíveis mais cedo e que seja menos provável que sua página seja bloqueada do processo de renderizar. Isso aumenta a performance da página. Este artigo oferece um guia básico de como preload funciona.

Referências
Referência do HTML

HTML é formado de elementos, onde cada um deles pode ser modificado por alguns atributos. Documentos HTML são interconectados através de links.

Referência dos Elementos HTML

Navegue em uma lista com todos os elementos HTML.

Referência de atributos em HTML

Elementos em HTML possuem atributos. Estes configuram ou ajustam o funcionamento e o comportamento dos seus elementos de muitas maneiras.

Atributos Globais

Os atributos globais podem ser utilizados em todos os elementos HTML, mesmo aqueles que não são especificados como padrão. Isso significa que qualquer elemento não padrão vai permitir estes atributos, mesmo que este retorne um documento HTML5 incompatível.

Elementos em linha e Elementos em nível de bloco

Elementos HTML são normalmente elementos inline (em linha) ou block-level (em nível de bloco). Um elemento em linha ocupa somente o espaço limitado pelas tags que o definem. Um elemento em nível de bloco ocupa o espaço inteiro do elemento pai (container), portanto criando um bloco.

Tipos de Links

No HTML, vários tipos de links podem ser utilizados para estabelecer e definir o relacionamento entre dois documentos. Os tipos de elementos de link que podem ser incluídos são <a>, <area> e <link>.

Formatos de mídia suportados pelos elementos vídeo e áudio do HTML

Os elementos <audio> e <video> permitem que você reproduza mídias de áudio e vídeo. Estes elementos fornecem uma alternativa nativa para o navegador reproduzir recursos similares aos encontrados no Adobe Flash e outros plug-ins.

Tipos de conteúdo HTML

O HTML é composto de uma grande diversidade de conteúdos, e cada um pode ser usado em certos contextos e não ser permitido em outros. Da mesma forma, cada um tem um conjunto de outras categorias de conteúdos que podem ou não serem usadas dentro deles. Este é um guia destas categorias.

Os Modos Quirks e o Modo Padrão

Informações sobre a história dos Modos Quirks e o Modo padrão.

Tópicos relacionados
Aplicando cores em elementos HTML usando CSS

Este artigo mostra as principais formas de se usar CSS para adicionar cores ao seu conteúdo HTML, mostrando que partes dos documentos HTML podem ser coloridas e quais propriedades utilizar. Inclui exemplos e links para ferramentas de palette-building, entre outros.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 27 de abr. de 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTMLHTML (HyperText Markup Language — «язык гипертекстовой разметки») — самый базовый строительный блок Веба. Он определяет содержание и структуру веб-контента. Другие технологии, помимо HTML, обычно используются для описания внешнего вида/представления (CSS) или функциональности/поведения (JavaScript) веб-страницы.
Под гипертекстом ("hypertext") понимаются ссылки, которые соединяют веб-страницы друг с другом либо в пределах одного веб-сайта, либо между веб-сайтами. Ссылки являются фундаментальным аспектом Веба. Загружая контент в Интернет и связывая его со страницами, созданными другими людьми, вы становитесь активным участником Всемирной паутины.
HTML использует разметку ("markup") для отображения текста, изображений и другого контента в веб-браузере. HTML-разметка включает в себя специальные "элементы", такие как <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video> и многие другие.
HTML-элемент выделяется из прочего текста в документе с помощью "тегов", которые состоят из имени элемента окружённого "<" и ">". Имя элемента внутри тега не чувствительно к регистру. То есть, оно может быть написано в верхнем или нижнем регистре, или смешано. Например, тег <title> может быть записан как <Title>, <TITLE>, или любым другим способом.
Статьи, представленные ниже, могут помочь вам больше узнать о HTML.


Введение в HTML
Если вы новичок в веб-разработке, обязательно прочитайте нашу статью "Основы HTML", чтобы узнать, что такое HTML и как его использовать.


Руководства по HTML
Статьи о том, как использовать HTML, а также обучающие материалы и исчерпывающие примеры можно найти в разделе "Пространство изучения HTML".


Справка по HTML
В нашем обширном разделе "Справка по HTML" вы найдёте подробности о каждом элементе и атрибуте в HTML.

Руководства для начинающихНаше Пространство изучения HTML содержит множество модулей, которые обучают HTML с нуля — начальные знания не требуются.

Введение в HTML

Этот модуль закладывает основу, знакомя вас с важными понятиями и синтаксисом, такими как применение HTML к тексту, создание гиперссылок и использование HTML для построения веб-страницы.

Мультимедиа и встраивание

В этом модуле рассматривается, как использовать HTML для добавления мультимедиа на ваши веб-страницы, включая различные способы вставки изображений, а также для встраивания видео, аудио, и даже других веб-страниц целиком.

HTML-таблицы

Представление табличных данных на веб-странице в понятной, доступной форме может быть проблемой. Этот модуль охватывает базовую разметку таблиц, а также более сложные особенности, такие как добавление заголовков и описаний.

HTML-формы

Формы являются очень важной частью Веба — они предоставляют большую часть функциональности, необходимого для взаимодействия с веб-сайтами, например регистрация и вход в систему, отправка отзывов, покупка товаров, и многое другое. Этот модуль познакомит вас с созданием клиентских (client-side/front-end) частей форм.

Используйте HTML для решения распространённых задач.

Содержит ссылки на разделы, объясняющие как использовать HTML для решения самых распространённых задач при создании веб-страницы: работа с заголовками, добавление изображений или видео, выделение контента, создание простой формы и т.д.

Продвинутые темы
CORS: включённые изображения

Атрибут crossorigin в сочетании с соответствующим заголовком CORS, позволяет загружать изображения, определённые элементом <img>, из внешних источников и использовать в элементе <canvas>, как если бы они были загружены из текущего источника.

CORS: Настройки атрибутов

Некоторые HTML-элементы, предоставляющие поддержку CORS, такие как <img> или <video>, имеют атрибут crossorigin (свойство crossOrigin), который позволяет вам настраивать CORS-запросы для получаемых элементом данных.

Управление фокусом в HTML

DOM-Атрибут activeElement и DOM-метод hasFocus() помогают отслеживать и контролировать взаимодействие пользователя с элементами на веб-странице.

Предварительная загрузка контента с помощью rel="preload"

Значение preload атрибута rel элемента <link> позволяет писать декларативные fetch-запросы в HTML <head>, указывая ресурсы, которые потребуются вашим страницам сразу после загрузки и, следовательно, которые вы хотите начать предварительно загружать на раннем этапе жизненного цикла страницы, прежде чем браузером запустится основной механизм рендеринга (отрисовки). Это гарантирует, что они станут доступными раньше и с меньшей вероятностью заблокируют первый рендеринг страницы, что приведёт к улучшению производительности. В этой статье приведено начальное руководство по работе с preload (предзагрузкой).

Справочники
Справка по HTML

HTML состоит из элементов, каждый из которых может быть изменён некоторым количеством атрибутов. HTML-документы связаны между собой ссылками.

Справка по HTML-элементам

Просмотр списка всех элементов HTML.

Справка по HTML-атрибутам

У элементов в HTML есть атрибуты. Это дополнительные величины, которые настраивают элементы или управляют их поведением различными способами.

Глобальные атрибуты

Глобальные атрибуты могут быть указаны для всех элементов HTML, даже тех, которые не указаны в стандарте. Это означает, что любые нестандартные элементы обязаны по-прежнему разрешать эти атрибуты, даже если эти элементы делают документ несовместимым с HTML5.

Строчные и блочные элементы

Элементы HTML являются обычно "строчными" или "блочными". Строчный элемент занимает только пространство, ограниченное тегами, которые его определяют. Блочный элемент занимает все пространство своего родительского элемента (контейнера), тем самым создавая "блок".

Типы ссылок

В HTML различные типы ссылок могут использоваться для установления и определения связи между двумя документами. Элементы-ссылки, типы которых могут быть заданы, включают в себя <a>, <area> и <link>.

Поддержка медиа-форматов с помощью HTML-элементов audio и video

Элементы <audio> и <video> позволяют вам воспроизводить аудио и видео. Эти элементы предоставляют браузерную альтернативу аналогичным возможностям, которые есть в Adobe Flash и других плагинах.

Виды HTML-контента

HTML состоит из нескольких видов контента, каждый из которых разрешено использовать в определённых контекстах и запрещено в других. Так же, у каждого есть набор других категорий контента, которые они могут содержать, и элементы, которые могут или не могут использоваться в них. Это руководство по таким категориям.

Режим совместимости и стандартный режим

Историческая справка по режиму совместимости и стандартному режиму.

Похожие темы
Применение цвета к HTML-элементам с помощью CSS

В этой статье описывается большинство способов использования CSS для добавления цвета к HTML-контенту, а также перечисляется, какие части документов HTML могут быть окрашены, и какие свойства CSS при этом используются. Включает примеры, ссылки на инструменты для создания палитры и многое другое.\n\nHTMLHTML (HyperText Markup Language — «язык гипертекстовой разметки») — самый базовый строительный блок Веба. Он определяет содержание и структуру веб-контента. Другие технологии, помимо HTML, обычно используются для описания внешнего вида/представления (CSS) или функциональности/поведения (JavaScript) веб-страницы.
Под гипертекстом ("hypertext") понимаются ссылки, которые соединяют веб-страницы друг с другом либо в пределах одного веб-сайта, либо между веб-сайтами. Ссылки являются фундаментальным аспектом Веба. Загружая контент в Интернет и связывая его со страницами, созданными другими людьми, вы становитесь активным участником Всемирной паутины.
HTML использует разметку ("markup") для отображения текста, изображений и другого контента в веб-браузере. HTML-разметка включает в себя специальные "элементы", такие как <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video> и многие другие.
HTML-элемент выделяется из прочего текста в документе с помощью "тегов", которые состоят из имени элемента окружённого "<" и ">". Имя элемента внутри тега не чувствительно к регистру. То есть, оно может быть написано в верхнем или нижнем регистре, или смешано. Например, тег <title> может быть записан как <Title>, <TITLE>, или любым другим способом.
Статьи, представленные ниже, могут помочь вам больше узнать о HTML.


Введение в HTML
Если вы новичок в веб-разработке, обязательно прочитайте нашу статью "Основы HTML", чтобы узнать, что такое HTML и как его использовать.


Руководства по HTML
Статьи о том, как использовать HTML, а также обучающие материалы и исчерпывающие примеры можно найти в разделе "Пространство изучения HTML".


Справка по HTML
В нашем обширном разделе "Справка по HTML" вы найдёте подробности о каждом элементе и атрибуте в HTML.

Руководства для начинающихНаше Пространство изучения HTML содержит множество модулей, которые обучают HTML с нуля — начальные знания не требуются.

Введение в HTML

Этот модуль закладывает основу, знакомя вас с важными понятиями и синтаксисом, такими как применение HTML к тексту, создание гиперссылок и использование HTML для построения веб-страницы.

Мультимедиа и встраивание

В этом модуле рассматривается, как использовать HTML для добавления мультимедиа на ваши веб-страницы, включая различные способы вставки изображений, а также для встраивания видео, аудио, и даже других веб-страниц целиком.

HTML-таблицы

Представление табличных данных на веб-странице в понятной, доступной форме может быть проблемой. Этот модуль охватывает базовую разметку таблиц, а также более сложные особенности, такие как добавление заголовков и описаний.

HTML-формы

Формы являются очень важной частью Веба — они предоставляют большую часть функциональности, необходимого для взаимодействия с веб-сайтами, например регистрация и вход в систему, отправка отзывов, покупка товаров, и многое другое. Этот модуль познакомит вас с созданием клиентских (client-side/front-end) частей форм.

Используйте HTML для решения распространённых задач.

Содержит ссылки на разделы, объясняющие как использовать HTML для решения самых распространённых задач при создании веб-страницы: работа с заголовками, добавление изображений или видео, выделение контента, создание простой формы и т.д.

Продвинутые темы
CORS: включённые изображения

Атрибут crossorigin в сочетании с соответствующим заголовком CORS, позволяет загружать изображения, определённые элементом <img>, из внешних источников и использовать в элементе <canvas>, как если бы они были загружены из текущего источника.

CORS: Настройки атрибутов

Некоторые HTML-элементы, предоставляющие поддержку CORS, такие как <img> или <video>, имеют атрибут crossorigin (свойство crossOrigin), который позволяет вам настраивать CORS-запросы для получаемых элементом данных.

Управление фокусом в HTML

DOM-Атрибут activeElement и DOM-метод hasFocus() помогают отслеживать и контролировать взаимодействие пользователя с элементами на веб-странице.

Предварительная загрузка контента с помощью rel="preload"

Значение preload атрибута rel элемента <link> позволяет писать декларативные fetch-запросы в HTML <head>, указывая ресурсы, которые потребуются вашим страницам сразу после загрузки и, следовательно, которые вы хотите начать предварительно загружать на раннем этапе жизненного цикла страницы, прежде чем браузером запустится основной механизм рендеринга (отрисовки). Это гарантирует, что они станут доступными раньше и с меньшей вероятностью заблокируют первый рендеринг страницы, что приведёт к улучшению производительности. В этой статье приведено начальное руководство по работе с preload (предзагрузкой).

Справочники
Справка по HTML

HTML состоит из элементов, каждый из которых может быть изменён некоторым количеством атрибутов. HTML-документы связаны между собой ссылками.

Справка по HTML-элементам

Просмотр списка всех элементов HTML.

Справка по HTML-атрибутам

У элементов в HTML есть атрибуты. Это дополнительные величины, которые настраивают элементы или управляют их поведением различными способами.

Глобальные атрибуты

Глобальные атрибуты могут быть указаны для всех элементов HTML, даже тех, которые не указаны в стандарте. Это означает, что любые нестандартные элементы обязаны по-прежнему разрешать эти атрибуты, даже если эти элементы делают документ несовместимым с HTML5.

Строчные и блочные элементы

Элементы HTML являются обычно "строчными" или "блочными". Строчный элемент занимает только пространство, ограниченное тегами, которые его определяют. Блочный элемент занимает все пространство своего родительского элемента (контейнера), тем самым создавая "блок".

Типы ссылок

В HTML различные типы ссылок могут использоваться для установления и определения связи между двумя документами. Элементы-ссылки, типы которых могут быть заданы, включают в себя <a>, <area> и <link>.

Поддержка медиа-форматов с помощью HTML-элементов audio и video

Элементы <audio> и <video> позволяют вам воспроизводить аудио и видео. Эти элементы предоставляют браузерную альтернативу аналогичным возможностям, которые есть в Adobe Flash и других плагинах.

Виды HTML-контента

HTML состоит из нескольких видов контента, каждый из которых разрешено использовать в определённых контекстах и запрещено в других. Так же, у каждого есть набор других категорий контента, которые они могут содержать, и элементы, которые могут или не могут использоваться в них. Это руководство по таким категориям.

Режим совместимости и стандартный режим

Историческая справка по режиму совместимости и стандартному режиму.

Похожие темы
Применение цвета к HTML-элементам с помощью CSS

В этой статье описывается большинство способов использования CSS для добавления цвета к HTML-контенту, а также перечисляется, какие части документов HTML могут быть окрашены, и какие свойства CSS при этом используются. Включает примеры, ссылки на инструменты для создания палитры и многое другое.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 15 апр. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTMLHTML (HyperText Markup Language — «язык гипертекстовой разметки») — самый базовый строительный блок Веба. Он определяет содержание и структуру веб-контента. Другие технологии, помимо HTML, обычно используются для описания внешнего вида/представления (CSS) или функциональности/поведения (JavaScript) веб-страницы.
Под гипертекстом ("hypertext") понимаются ссылки, которые соединяют веб-страницы друг с другом либо в пределах одного веб-сайта, либо между веб-сайтами. Ссылки являются фундаментальным аспектом Веба. Загружая контент в Интернет и связывая его со страницами, созданными другими людьми, вы становитесь активным участником Всемирной паутины.
HTML использует разметку ("markup") для отображения текста, изображений и другого контента в веб-браузере. HTML-разметка включает в себя специальные "элементы", такие как <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <output>, <progress>, <video> и многие другие.
HTML-элемент выделяется из прочего текста в документе с помощью "тегов", которые состоят из имени элемента окружённого "<" и ">". Имя элемента внутри тега не чувствительно к регистру. То есть, оно может быть написано в верхнем или нижнем регистре, или смешано. Например, тег <title> может быть записан как <Title>, <TITLE>, или любым другим способом.
Статьи, представленные ниже, могут помочь вам больше узнать о HTML.


Введение в HTML
Если вы новичок в веб-разработке, обязательно прочитайте нашу статью "Основы HTML", чтобы узнать, что такое HTML и как его использовать.


Руководства по HTML
Статьи о том, как использовать HTML, а также обучающие материалы и исчерпывающие примеры можно найти в разделе "Пространство изучения HTML".


Справка по HTML
В нашем обширном разделе "Справка по HTML" вы найдёте подробности о каждом элементе и атрибуте в HTML.

Руководства для начинающихНаше Пространство изучения HTML содержит множество модулей, которые обучают HTML с нуля — начальные знания не требуются.

Введение в HTML

Этот модуль закладывает основу, знакомя вас с важными понятиями и синтаксисом, такими как применение HTML к тексту, создание гиперссылок и использование HTML для построения веб-страницы.

Мультимедиа и встраивание

В этом модуле рассматривается, как использовать HTML для добавления мультимедиа на ваши веб-страницы, включая различные способы вставки изображений, а также для встраивания видео, аудио, и даже других веб-страниц целиком.

HTML-таблицы

Представление табличных данных на веб-странице в понятной, доступной форме может быть проблемой. Этот модуль охватывает базовую разметку таблиц, а также более сложные особенности, такие как добавление заголовков и описаний.

HTML-формы

Формы являются очень важной частью Веба — они предоставляют большую часть функциональности, необходимого для взаимодействия с веб-сайтами, например регистрация и вход в систему, отправка отзывов, покупка товаров, и многое другое. Этот модуль познакомит вас с созданием клиентских (client-side/front-end) частей форм.

Используйте HTML для решения распространённых задач.

Содержит ссылки на разделы, объясняющие как использовать HTML для решения самых распространённых задач при создании веб-страницы: работа с заголовками, добавление изображений или видео, выделение контента, создание простой формы и т.д.

Продвинутые темы
CORS: включённые изображения

Атрибут crossorigin в сочетании с соответствующим заголовком CORS, позволяет загружать изображения, определённые элементом <img>, из внешних источников и использовать в элементе <canvas>, как если бы они были загружены из текущего источника.

CORS: Настройки атрибутов

Некоторые HTML-элементы, предоставляющие поддержку CORS, такие как <img> или <video>, имеют атрибут crossorigin (свойство crossOrigin), который позволяет вам настраивать CORS-запросы для получаемых элементом данных.

Управление фокусом в HTML

DOM-Атрибут activeElement и DOM-метод hasFocus() помогают отслеживать и контролировать взаимодействие пользователя с элементами на веб-странице.

Предварительная загрузка контента с помощью rel="preload"

Значение preload атрибута rel элемента <link> позволяет писать декларативные fetch-запросы в HTML <head>, указывая ресурсы, которые потребуются вашим страницам сразу после загрузки и, следовательно, которые вы хотите начать предварительно загружать на раннем этапе жизненного цикла страницы, прежде чем браузером запустится основной механизм рендеринга (отрисовки). Это гарантирует, что они станут доступными раньше и с меньшей вероятностью заблокируют первый рендеринг страницы, что приведёт к улучшению производительности. В этой статье приведено начальное руководство по работе с preload (предзагрузкой).

Справочники
Справка по HTML

HTML состоит из элементов, каждый из которых может быть изменён некоторым количеством атрибутов. HTML-документы связаны между собой ссылками.

Справка по HTML-элементам

Просмотр списка всех элементов HTML.

Справка по HTML-атрибутам

У элементов в HTML есть атрибуты. Это дополнительные величины, которые настраивают элементы или управляют их поведением различными способами.

Глобальные атрибуты

Глобальные атрибуты могут быть указаны для всех элементов HTML, даже тех, которые не указаны в стандарте. Это означает, что любые нестандартные элементы обязаны по-прежнему разрешать эти атрибуты, даже если эти элементы делают документ несовместимым с HTML5.

Строчные и блочные элементы

Элементы HTML являются обычно "строчными" или "блочными". Строчный элемент занимает только пространство, ограниченное тегами, которые его определяют. Блочный элемент занимает все пространство своего родительского элемента (контейнера), тем самым создавая "блок".

Типы ссылок

В HTML различные типы ссылок могут использоваться для установления и определения связи между двумя документами. Элементы-ссылки, типы которых могут быть заданы, включают в себя <a>, <area> и <link>.

Поддержка медиа-форматов с помощью HTML-элементов audio и video

Элементы <audio> и <video> позволяют вам воспроизводить аудио и видео. Эти элементы предоставляют браузерную альтернативу аналогичным возможностям, которые есть в Adobe Flash и других плагинах.

Виды HTML-контента

HTML состоит из нескольких видов контента, каждый из которых разрешено использовать в определённых контекстах и запрещено в других. Так же, у каждого есть набор других категорий контента, которые они могут содержать, и элементы, которые могут или не могут использоваться в них. Это руководство по таким категориям.

Режим совместимости и стандартный режим

Историческая справка по режиму совместимости и стандартному режиму.

Похожие темы
Применение цвета к HTML-элементам с помощью CSS

В этой статье описывается большинство способов использования CSS для добавления цвета к HTML-контенту, а также перечисляется, какие части документов HTML могут быть окрашены, и какие свойства CSS при этом используются. Включает примеры, ссылки на инструменты для создания палитры и многое другое.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 15 апр. 2025 г. by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML（超文本标记语言）HTML（超文本标记语言——HyperText Markup Language）是构成 Web 世界的一砖一瓦。它定义了网页内容的含义和结构。除 HTML 以外的其他技术则通常用来描述一个网页的表现与展示效果（如 CSS），或功能与行为（如 JavaScript）。
“超文本”（hypertext）是指连接单个网站内或多个网站间的网页的链接。链接是网络的一个基本方面。只要将内容上传到互联网，并将其与他人创建的页面相链接，你就成为了万维网的积极参与者。
HTML 使用“标记”（markup）来注明文本、图片和其他内容，以便于在 Web 浏览器中显示。HTML 标记包含一些特殊“元素”如 <head>、<title>、<body>、<header>、<footer>、<article>、<section>、<p>、<div>、<span>、<img>、<aside>、<audio>、<canvas>、<datalist>、<details>、<embed>、<nav>、<output>、<progress>、<video>、<ul>、<ol>、<li> 等等。
HTML 元素通过“标签”（tag）将文本从文档中引出，标签由在“<”和“>”中包裹的元素名组成，HTML 标签里的元素名不区分大小写。也就是说，它们可以用大写，小写或混合形式书写。例如，<title> 标签可以写成 <Title>，<TITLE> 或以任何其他方式。然而，习惯上与实践上都推荐将标签名全部小写。
下面的文章会帮助你更好地了解 HTML。主要资源
HTML 介绍

如果你是 Web 开发新手，请务必阅读我们的 HTML 基础文章来了解什么是 HTML 以及如何使用它。

HTML 教程

关于如何使用 HTML 的文章，教程和完整的示例，查看我们的 HTML 学习区。

HTML 参考

在我们丰富的 HTML 参考部分中，你可以找到在 HTML 中每一个元素和属性的详细信息。

初学者教程我们的 HTML 学习区 含有许多富有特色的模块，学习者可以在没有任何先前经验的情况下从零开始，掌握 HTML。

HTML 介绍

这一模块将为你打下基础，并为进一步的学习铺平道路。在这里，你将掌握一些重要的概念和语法，学习如何将 HTML 用于文本、如何创建超链接以及运用 HTML 去构建一个网页。

多媒体与嵌入内容

这个模块将带领你探索如何使用 HTML 在你的网页中包含多媒体内容，包括通过许多不同的方式嵌入图片，以及如何嵌入视频、音频甚至整个其他网页。

HTML 表格

如何用可理解并易于访问的形式在网页中展示表格化数据一向都是个不小的挑战。这个模块涵盖了基本的表格标记，以及一些更复杂的特性，比如实现标题和总结等。

HTML 表单

表单是构成 Web 世界的重要组成部分——它们提供了大量你所需要用来与网站进行交互所需的功能。比如注册、登录、发送评论反馈、购买商品等等。这个模块将引导你建立一个客户端／前端部分的表单。

用 HTML 解决常见问题

该部分提供了一些链接，它们指向那些你在构建 Web 页面的过程中最常见的问题的解决方法：如何处理网页标题、添加图片或视频、强调某些内容、建立基本的表单等。

高级主题
CORS 处理跨域图片

通过搭配 crossorigin 属性和适当的 CORS 标头，在 <img> 元素中定义的图片可以从外部来源加载并在 <canvas> 元素中使用，就像是从本地源加载一样。

CORS 设置属性

一些提供了对 CORS 的支持的 HTML 元素，比如 <img> 或 <video>，具有 crossorigin 元素属性／attribute（crossOrigin 对象属性／property），该属性能使你配置其跨域获取资源的请求。

使用 rel="preload" 预加载页面内容

<link> 元素的 rel 属性的值 preload 允许你在 HTML 的 <head> 部分声明一些（资源）获取请求，以指定那些在页面加载后即刻需要的资源。因此在浏览器的主渲染机制介入前，这些资源会在页面加载生命周期的早期阶段进行预加载。这样可以保证这些资源可被更早使用并减少阻塞页面初次渲染的可能性，从而提升性能。这篇文章提供了关于 preload 作用机制的基本指导。

参考
HTML 参考

HTML 由元素组成，每个元素都可以被多个属性修饰。HTML 文档通过链接相互连接。

HTML 元素参考

浏览完整的 HTML 元素列表。

HTML 属性参考

HTML 元素都含有属性。这些额外的属性值可以通过各种途径对元素进行配置或调整其行为。

全局属性

全局属性可以在所有 HTML 元素上进行设置，包括那些没有在相关标准中出现的元素。这意味着即使这些非标准元素使得文档并不符合 HTML5 标准，它们也必须允许这些属性存在。

行级元素和块级元素

HTML 元素通常是“行级”或“块级”元素。一个行级元素仅会占用由定义它的标签所包裹起来的空间。而一个块级元素将会占用其父元素（容器）的全部空间，也就是创建一个“块”。

链接类型

在 HTML 中，各种各样的链接类型被用来确立和定义两个文档之间的关系。可以设置链接类型的链接元素包括 <a>、<area> 和 <link>。

Web 媒体类型和格式指南

<audio> 和 <video> 元素允许你原生地播放音频和视频媒体，无需任何外部软件的支持。

HTML 内容种类

HTML 包含了几种内容，每种内容在特定的情景上下文中有效，而在其他上下文中无效。每种内容也指定了可以被它们包含的类别，以及可以或不可以在其中使用的元素。这里提供了一个关于这些类别的说明。

怪异模式和标准模式

关于怪异模式和标准模式的历史信息。

相关主题
使用 CSS 为 HTML 元素应用颜色

这篇文章涵盖了大多数使用 CSS 为 HTML 内容增加颜色的方式，并列举了 HTML 文档里哪些部分可以进行上色以及这一操作需要使用哪些 CSS 属性。它包含了一些示例，配色建构工具的链接，以及其他内容。\n\nHTML（超文本标记语言）HTML（超文本标记语言——HyperText Markup Language）是构成 Web 世界的一砖一瓦。它定义了网页内容的含义和结构。除 HTML 以外的其他技术则通常用来描述一个网页的表现与展示效果（如 CSS），或功能与行为（如 JavaScript）。
“超文本”（hypertext）是指连接单个网站内或多个网站间的网页的链接。链接是网络的一个基本方面。只要将内容上传到互联网，并将其与他人创建的页面相链接，你就成为了万维网的积极参与者。
HTML 使用“标记”（markup）来注明文本、图片和其他内容，以便于在 Web 浏览器中显示。HTML 标记包含一些特殊“元素”如 <head>、<title>、<body>、<header>、<footer>、<article>、<section>、<p>、<div>、<span>、<img>、<aside>、<audio>、<canvas>、<datalist>、<details>、<embed>、<nav>、<output>、<progress>、<video>、<ul>、<ol>、<li> 等等。
HTML 元素通过“标签”（tag）将文本从文档中引出，标签由在“<”和“>”中包裹的元素名组成，HTML 标签里的元素名不区分大小写。也就是说，它们可以用大写，小写或混合形式书写。例如，<title> 标签可以写成 <Title>，<TITLE> 或以任何其他方式。然而，习惯上与实践上都推荐将标签名全部小写。
下面的文章会帮助你更好地了解 HTML。主要资源
HTML 介绍

如果你是 Web 开发新手，请务必阅读我们的 HTML 基础文章来了解什么是 HTML 以及如何使用它。

HTML 教程

关于如何使用 HTML 的文章，教程和完整的示例，查看我们的 HTML 学习区。

HTML 参考

在我们丰富的 HTML 参考部分中，你可以找到在 HTML 中每一个元素和属性的详细信息。

初学者教程我们的 HTML 学习区 含有许多富有特色的模块，学习者可以在没有任何先前经验的情况下从零开始，掌握 HTML。

HTML 介绍

这一模块将为你打下基础，并为进一步的学习铺平道路。在这里，你将掌握一些重要的概念和语法，学习如何将 HTML 用于文本、如何创建超链接以及运用 HTML 去构建一个网页。

多媒体与嵌入内容

这个模块将带领你探索如何使用 HTML 在你的网页中包含多媒体内容，包括通过许多不同的方式嵌入图片，以及如何嵌入视频、音频甚至整个其他网页。

HTML 表格

如何用可理解并易于访问的形式在网页中展示表格化数据一向都是个不小的挑战。这个模块涵盖了基本的表格标记，以及一些更复杂的特性，比如实现标题和总结等。

HTML 表单

表单是构成 Web 世界的重要组成部分——它们提供了大量你所需要用来与网站进行交互所需的功能。比如注册、登录、发送评论反馈、购买商品等等。这个模块将引导你建立一个客户端／前端部分的表单。

用 HTML 解决常见问题

该部分提供了一些链接，它们指向那些你在构建 Web 页面的过程中最常见的问题的解决方法：如何处理网页标题、添加图片或视频、强调某些内容、建立基本的表单等。

高级主题
CORS 处理跨域图片

通过搭配 crossorigin 属性和适当的 CORS 标头，在 <img> 元素中定义的图片可以从外部来源加载并在 <canvas> 元素中使用，就像是从本地源加载一样。

CORS 设置属性

一些提供了对 CORS 的支持的 HTML 元素，比如 <img> 或 <video>，具有 crossorigin 元素属性／attribute（crossOrigin 对象属性／property），该属性能使你配置其跨域获取资源的请求。

使用 rel="preload" 预加载页面内容

<link> 元素的 rel 属性的值 preload 允许你在 HTML 的 <head> 部分声明一些（资源）获取请求，以指定那些在页面加载后即刻需要的资源。因此在浏览器的主渲染机制介入前，这些资源会在页面加载生命周期的早期阶段进行预加载。这样可以保证这些资源可被更早使用并减少阻塞页面初次渲染的可能性，从而提升性能。这篇文章提供了关于 preload 作用机制的基本指导。

参考
HTML 参考

HTML 由元素组成，每个元素都可以被多个属性修饰。HTML 文档通过链接相互连接。

HTML 元素参考

浏览完整的 HTML 元素列表。

HTML 属性参考

HTML 元素都含有属性。这些额外的属性值可以通过各种途径对元素进行配置或调整其行为。

全局属性

全局属性可以在所有 HTML 元素上进行设置，包括那些没有在相关标准中出现的元素。这意味着即使这些非标准元素使得文档并不符合 HTML5 标准，它们也必须允许这些属性存在。

行级元素和块级元素

HTML 元素通常是“行级”或“块级”元素。一个行级元素仅会占用由定义它的标签所包裹起来的空间。而一个块级元素将会占用其父元素（容器）的全部空间，也就是创建一个“块”。

链接类型

在 HTML 中，各种各样的链接类型被用来确立和定义两个文档之间的关系。可以设置链接类型的链接元素包括 <a>、<area> 和 <link>。

Web 媒体类型和格式指南

<audio> 和 <video> 元素允许你原生地播放音频和视频媒体，无需任何外部软件的支持。

HTML 内容种类

HTML 包含了几种内容，每种内容在特定的情景上下文中有效，而在其他上下文中无效。每种内容也指定了可以被它们包含的类别，以及可以或不可以在其中使用的元素。这里提供了一个关于这些类别的说明。

怪异模式和标准模式

关于怪异模式和标准模式的历史信息。

相关主题
使用 CSS 为 HTML 元素应用颜色

这篇文章涵盖了大多数使用 CSS 为 HTML 内容增加颜色的方式，并列举了 HTML 文档里哪些部分可以进行上色以及这一操作需要使用哪些 CSS 属性。它包含了一些示例，配色建构工具的链接，以及其他内容。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月13日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML（超文本标记语言）HTML（超文本标记语言——HyperText Markup Language）是构成 Web 世界的一砖一瓦。它定义了网页内容的含义和结构。除 HTML 以外的其他技术则通常用来描述一个网页的表现与展示效果（如 CSS），或功能与行为（如 JavaScript）。
“超文本”（hypertext）是指连接单个网站内或多个网站间的网页的链接。链接是网络的一个基本方面。只要将内容上传到互联网，并将其与他人创建的页面相链接，你就成为了万维网的积极参与者。
HTML 使用“标记”（markup）来注明文本、图片和其他内容，以便于在 Web 浏览器中显示。HTML 标记包含一些特殊“元素”如 <head>、<title>、<body>、<header>、<footer>、<article>、<section>、<p>、<div>、<span>、<img>、<aside>、<audio>、<canvas>、<datalist>、<details>、<embed>、<nav>、<output>、<progress>、<video>、<ul>、<ol>、<li> 等等。
HTML 元素通过“标签”（tag）将文本从文档中引出，标签由在“<”和“>”中包裹的元素名组成，HTML 标签里的元素名不区分大小写。也就是说，它们可以用大写，小写或混合形式书写。例如，<title> 标签可以写成 <Title>，<TITLE> 或以任何其他方式。然而，习惯上与实践上都推荐将标签名全部小写。
下面的文章会帮助你更好地了解 HTML。主要资源
HTML 介绍

如果你是 Web 开发新手，请务必阅读我们的 HTML 基础文章来了解什么是 HTML 以及如何使用它。

HTML 教程

关于如何使用 HTML 的文章，教程和完整的示例，查看我们的 HTML 学习区。

HTML 参考

在我们丰富的 HTML 参考部分中，你可以找到在 HTML 中每一个元素和属性的详细信息。

初学者教程我们的 HTML 学习区 含有许多富有特色的模块，学习者可以在没有任何先前经验的情况下从零开始，掌握 HTML。

HTML 介绍

这一模块将为你打下基础，并为进一步的学习铺平道路。在这里，你将掌握一些重要的概念和语法，学习如何将 HTML 用于文本、如何创建超链接以及运用 HTML 去构建一个网页。

多媒体与嵌入内容

这个模块将带领你探索如何使用 HTML 在你的网页中包含多媒体内容，包括通过许多不同的方式嵌入图片，以及如何嵌入视频、音频甚至整个其他网页。

HTML 表格

如何用可理解并易于访问的形式在网页中展示表格化数据一向都是个不小的挑战。这个模块涵盖了基本的表格标记，以及一些更复杂的特性，比如实现标题和总结等。

HTML 表单

表单是构成 Web 世界的重要组成部分——它们提供了大量你所需要用来与网站进行交互所需的功能。比如注册、登录、发送评论反馈、购买商品等等。这个模块将引导你建立一个客户端／前端部分的表单。

用 HTML 解决常见问题

该部分提供了一些链接，它们指向那些你在构建 Web 页面的过程中最常见的问题的解决方法：如何处理网页标题、添加图片或视频、强调某些内容、建立基本的表单等。

高级主题
CORS 处理跨域图片

通过搭配 crossorigin 属性和适当的 CORS 标头，在 <img> 元素中定义的图片可以从外部来源加载并在 <canvas> 元素中使用，就像是从本地源加载一样。

CORS 设置属性

一些提供了对 CORS 的支持的 HTML 元素，比如 <img> 或 <video>，具有 crossorigin 元素属性／attribute（crossOrigin 对象属性／property），该属性能使你配置其跨域获取资源的请求。

使用 rel="preload" 预加载页面内容

<link> 元素的 rel 属性的值 preload 允许你在 HTML 的 <head> 部分声明一些（资源）获取请求，以指定那些在页面加载后即刻需要的资源。因此在浏览器的主渲染机制介入前，这些资源会在页面加载生命周期的早期阶段进行预加载。这样可以保证这些资源可被更早使用并减少阻塞页面初次渲染的可能性，从而提升性能。这篇文章提供了关于 preload 作用机制的基本指导。

参考
HTML 参考

HTML 由元素组成，每个元素都可以被多个属性修饰。HTML 文档通过链接相互连接。

HTML 元素参考

浏览完整的 HTML 元素列表。

HTML 属性参考

HTML 元素都含有属性。这些额外的属性值可以通过各种途径对元素进行配置或调整其行为。

全局属性

全局属性可以在所有 HTML 元素上进行设置，包括那些没有在相关标准中出现的元素。这意味着即使这些非标准元素使得文档并不符合 HTML5 标准，它们也必须允许这些属性存在。

行级元素和块级元素

HTML 元素通常是“行级”或“块级”元素。一个行级元素仅会占用由定义它的标签所包裹起来的空间。而一个块级元素将会占用其父元素（容器）的全部空间，也就是创建一个“块”。

链接类型

在 HTML 中，各种各样的链接类型被用来确立和定义两个文档之间的关系。可以设置链接类型的链接元素包括 <a>、<area> 和 <link>。

Web 媒体类型和格式指南

<audio> 和 <video> 元素允许你原生地播放音频和视频媒体，无需任何外部软件的支持。

HTML 内容种类

HTML 包含了几种内容，每种内容在特定的情景上下文中有效，而在其他上下文中无效。每种内容也指定了可以被它们包含的类别，以及可以或不可以在其中使用的元素。这里提供了一个关于这些类别的说明。

怪异模式和标准模式

关于怪异模式和标准模式的历史信息。

相关主题
使用 CSS 为 HTML 元素应用颜色

这篇文章涵盖了大多数使用 CSS 为 HTML 内容增加颜色的方式，并列举了 HTML 文档里哪些部分可以进行上色以及这一操作需要使用哪些 CSS 属性。它包含了一些示例，配色建构工具的链接，以及其他内容。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月13日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML：超文本標記語言HTML（HyperText Markup Language，超文本標記語言）是 Web 最基本的構建塊。它定義了 Web 內容的意義和結構。除了 HTML 之外，通常還會使用其他技術來描述 Web 的外觀／呈現（CSS）或功能／行為（JavaScript）。
「超文本」（HyperText）指的是將 Web 相互連接的連結，可以在單個網站內部或網站之間進行連接。連結是 Web 的基本方面。通過將內容上傳到互聯網並將其連接到其他人創建的頁面，你成為了全球資訊網的積極參與者。
HTML 使用「標記」（Markup）來詮釋文本、圖像和其他內容，以便在 Web 瀏覽器中顯示。HTML 標記包括特殊的「元素」，例如 <head>、<title>、<body>、<header>、<footer>、<article>、<section>、<p>、<div>、<span>、<img>、<aside>、<audio>、<canvas>、<datalist>、<details>、<embed>、<nav>、<search>、<output>、<progress>、<video>、<ul>、<ol>、<li> 等等。
HTML 元素通過「標籤」與文件中的其他文本區分開來，標籤由元素名稱和 < 及 > 組成。標籤內的元素名稱不區分大小寫。也就是說，它可以用大寫、小寫或混合寫法。例如，<title> 標籤可以寫成 <Title>、<TITLE> 或其他任何方式。然而，慣例和推薦的做法是將標籤寫成小寫。
以下文章可以幫助你進一步了解 HTML。初學者教程
你的第一個網站：創建內容

這篇文章提供了一個簡短的 HTML 簡介和使用方法，適合完全新手的 Web 開發者。

使用 HTML 建構內容

我們的學習 Web 開發章節的 HTML 模塊從頭開始教授所有 HTML 基礎知識。

指南
HTML 表單

表單是 Web 非常重要的一章節——它們提供了與網站互動所需的大章節功能，例如註冊和登錄、發送反饋、購買產品等。此模塊將幫助你開始創建表單的用戶端/前端部分。

啟用 CORS 的圖像

crossorigin 屬性與適當的 CORS 標頭結合使用，允許由 <img> 元素定義的圖像從外部來源加載，並在 <canvas> 元素中使用，就像它們是從當前來源加載的一樣。

CORS 設定屬性

一些支援 CORS 的 HTML 元素，例如 <img> 或 <video>，具有 crossorigin 屬性（crossOrigin 屬性），允許你配置元素提取數據的 CORS 請求。

使用 rel="preload" 預加載內容

<link> 元素的 rel 屬性的 preload 值允許你在 HTML <head> 中編寫聲明式提取請求，指定頁面加載後不久將需要的資源，因此你希望在頁面加載生命週期的早期開始預加載它們，這樣可以確保它們更早可用，並且不太可能阻塞頁面的首次渲染，從而提高性能。這篇文章提供了 preload 的基本指南。

響應式圖像

在這篇文章中，我們將學習響應式圖像的概念——在具有不同螢幕尺寸、分辨率和其他特徵的設備上良好顯示的圖像——並查看 HTML 提供的幫助實現它們的工具。這有助於提高不同設備上的性能。

參考
HTML 參考

HTML 由元素組成，每個元素都可以由若干屬性修飾。HTML 文件通過連結相互連接。

HTML 元素參考

瀏覽所有 HTML 元素的列表。

HTML 屬性參考

HTML 中的元素具有屬性。這些屬性是配置元素或以各種方式調整其行為的附加值。

全域屬性

全域屬性可以在所有 HTML 元素上指定，即使那些未在標準中指定的元素。這意味著任何非標準元素仍然必須允許這些屬性，即使這些元素使文件不符合 HTML5 標準。

內聯級元素和區塊級元素

HTML 元素通常是「內聯級」或「區塊級」元素。內聯級元素僅佔據由定義它的標籤界定的空間。區塊級元素佔據其父元素（容器）的整個空間，從而創建一個「區塊框」。

HTML 註釋

HTML 註釋用於向標記添加說明性註釋或防止瀏覽器解釋文件的特定部分。

Web 上的媒體類型和格式指南

<audio> 和 <video> 元素允許你在內容中本地播放音訊和視訊媒體，而無需外部軟體支援。

HTML 內容類型

HTML 由幾種內容組成，每種內容允許在某些上下文中使用，而在其他上下文中不允許使用。同樣，每個上下文都有一組它可以包含的其他內容類型以及可以或不能在其中使用的元素。這是這些類型的指南。

怪異模式和標準模式

關於怪異模式和標準模式的歷史訊息。

相關主題
使用 CSS 為 HTML 元素應用顏色

這篇文章涵蓋了使用 CSS 為 HTML 內容添加顏色的的大部分方法，列出了 HTML 文件的哪些部分可以著色以及在進行著色時應使用哪些 CSS 屬性。\n\nHTML：超文本標記語言HTML（HyperText Markup Language，超文本標記語言）是 Web 最基本的構建塊。它定義了 Web 內容的意義和結構。除了 HTML 之外，通常還會使用其他技術來描述 Web 的外觀／呈現（CSS）或功能／行為（JavaScript）。
「超文本」（HyperText）指的是將 Web 相互連接的連結，可以在單個網站內部或網站之間進行連接。連結是 Web 的基本方面。通過將內容上傳到互聯網並將其連接到其他人創建的頁面，你成為了全球資訊網的積極參與者。
HTML 使用「標記」（Markup）來詮釋文本、圖像和其他內容，以便在 Web 瀏覽器中顯示。HTML 標記包括特殊的「元素」，例如 <head>、<title>、<body>、<header>、<footer>、<article>、<section>、<p>、<div>、<span>、<img>、<aside>、<audio>、<canvas>、<datalist>、<details>、<embed>、<nav>、<search>、<output>、<progress>、<video>、<ul>、<ol>、<li> 等等。
HTML 元素通過「標籤」與文件中的其他文本區分開來，標籤由元素名稱和 < 及 > 組成。標籤內的元素名稱不區分大小寫。也就是說，它可以用大寫、小寫或混合寫法。例如，<title> 標籤可以寫成 <Title>、<TITLE> 或其他任何方式。然而，慣例和推薦的做法是將標籤寫成小寫。
以下文章可以幫助你進一步了解 HTML。初學者教程
你的第一個網站：創建內容

這篇文章提供了一個簡短的 HTML 簡介和使用方法，適合完全新手的 Web 開發者。

使用 HTML 建構內容

我們的學習 Web 開發章節的 HTML 模塊從頭開始教授所有 HTML 基礎知識。

指南
HTML 表單

表單是 Web 非常重要的一章節——它們提供了與網站互動所需的大章節功能，例如註冊和登錄、發送反饋、購買產品等。此模塊將幫助你開始創建表單的用戶端/前端部分。

啟用 CORS 的圖像

crossorigin 屬性與適當的 CORS 標頭結合使用，允許由 <img> 元素定義的圖像從外部來源加載，並在 <canvas> 元素中使用，就像它們是從當前來源加載的一樣。

CORS 設定屬性

一些支援 CORS 的 HTML 元素，例如 <img> 或 <video>，具有 crossorigin 屬性（crossOrigin 屬性），允許你配置元素提取數據的 CORS 請求。

使用 rel="preload" 預加載內容

<link> 元素的 rel 屬性的 preload 值允許你在 HTML <head> 中編寫聲明式提取請求，指定頁面加載後不久將需要的資源，因此你希望在頁面加載生命週期的早期開始預加載它們，這樣可以確保它們更早可用，並且不太可能阻塞頁面的首次渲染，從而提高性能。這篇文章提供了 preload 的基本指南。

響應式圖像

在這篇文章中，我們將學習響應式圖像的概念——在具有不同螢幕尺寸、分辨率和其他特徵的設備上良好顯示的圖像——並查看 HTML 提供的幫助實現它們的工具。這有助於提高不同設備上的性能。

參考
HTML 參考

HTML 由元素組成，每個元素都可以由若干屬性修飾。HTML 文件通過連結相互連接。

HTML 元素參考

瀏覽所有 HTML 元素的列表。

HTML 屬性參考

HTML 中的元素具有屬性。這些屬性是配置元素或以各種方式調整其行為的附加值。

全域屬性

全域屬性可以在所有 HTML 元素上指定，即使那些未在標準中指定的元素。這意味著任何非標準元素仍然必須允許這些屬性，即使這些元素使文件不符合 HTML5 標準。

內聯級元素和區塊級元素

HTML 元素通常是「內聯級」或「區塊級」元素。內聯級元素僅佔據由定義它的標籤界定的空間。區塊級元素佔據其父元素（容器）的整個空間，從而創建一個「區塊框」。

HTML 註釋

HTML 註釋用於向標記添加說明性註釋或防止瀏覽器解釋文件的特定部分。

Web 上的媒體類型和格式指南

<audio> 和 <video> 元素允許你在內容中本地播放音訊和視訊媒體，而無需外部軟體支援。

HTML 內容類型

HTML 由幾種內容組成，每種內容允許在某些上下文中使用，而在其他上下文中不允許使用。同樣，每個上下文都有一組它可以包含的其他內容類型以及可以或不能在其中使用的元素。這是這些類型的指南。

怪異模式和標準模式

關於怪異模式和標準模式的歷史訊息。

相關主題
使用 CSS 為 HTML 元素應用顏色

這篇文章涵蓋了使用 CSS 為 HTML 內容添加顏色的的大部分方法，列出了 HTML 文件的哪些部分可以著色以及在進行著色時應使用哪些 CSS 屬性。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月27日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML：超文本標記語言HTML（HyperText Markup Language，超文本標記語言）是 Web 最基本的構建塊。它定義了 Web 內容的意義和結構。除了 HTML 之外，通常還會使用其他技術來描述 Web 的外觀／呈現（CSS）或功能／行為（JavaScript）。
「超文本」（HyperText）指的是將 Web 相互連接的連結，可以在單個網站內部或網站之間進行連接。連結是 Web 的基本方面。通過將內容上傳到互聯網並將其連接到其他人創建的頁面，你成為了全球資訊網的積極參與者。
HTML 使用「標記」（Markup）來詮釋文本、圖像和其他內容，以便在 Web 瀏覽器中顯示。HTML 標記包括特殊的「元素」，例如 <head>、<title>、<body>、<header>、<footer>、<article>、<section>、<p>、<div>、<span>、<img>、<aside>、<audio>、<canvas>、<datalist>、<details>、<embed>、<nav>、<search>、<output>、<progress>、<video>、<ul>、<ol>、<li> 等等。
HTML 元素通過「標籤」與文件中的其他文本區分開來，標籤由元素名稱和 < 及 > 組成。標籤內的元素名稱不區分大小寫。也就是說，它可以用大寫、小寫或混合寫法。例如，<title> 標籤可以寫成 <Title>、<TITLE> 或其他任何方式。然而，慣例和推薦的做法是將標籤寫成小寫。
以下文章可以幫助你進一步了解 HTML。初學者教程
你的第一個網站：創建內容

這篇文章提供了一個簡短的 HTML 簡介和使用方法，適合完全新手的 Web 開發者。

使用 HTML 建構內容

我們的學習 Web 開發章節的 HTML 模塊從頭開始教授所有 HTML 基礎知識。

指南
HTML 表單

表單是 Web 非常重要的一章節——它們提供了與網站互動所需的大章節功能，例如註冊和登錄、發送反饋、購買產品等。此模塊將幫助你開始創建表單的用戶端/前端部分。

啟用 CORS 的圖像

crossorigin 屬性與適當的 CORS 標頭結合使用，允許由 <img> 元素定義的圖像從外部來源加載，並在 <canvas> 元素中使用，就像它們是從當前來源加載的一樣。

CORS 設定屬性

一些支援 CORS 的 HTML 元素，例如 <img> 或 <video>，具有 crossorigin 屬性（crossOrigin 屬性），允許你配置元素提取數據的 CORS 請求。

使用 rel="preload" 預加載內容

<link> 元素的 rel 屬性的 preload 值允許你在 HTML <head> 中編寫聲明式提取請求，指定頁面加載後不久將需要的資源，因此你希望在頁面加載生命週期的早期開始預加載它們，這樣可以確保它們更早可用，並且不太可能阻塞頁面的首次渲染，從而提高性能。這篇文章提供了 preload 的基本指南。

響應式圖像

在這篇文章中，我們將學習響應式圖像的概念——在具有不同螢幕尺寸、分辨率和其他特徵的設備上良好顯示的圖像——並查看 HTML 提供的幫助實現它們的工具。這有助於提高不同設備上的性能。

參考
HTML 參考

HTML 由元素組成，每個元素都可以由若干屬性修飾。HTML 文件通過連結相互連接。

HTML 元素參考

瀏覽所有 HTML 元素的列表。

HTML 屬性參考

HTML 中的元素具有屬性。這些屬性是配置元素或以各種方式調整其行為的附加值。

全域屬性

全域屬性可以在所有 HTML 元素上指定，即使那些未在標準中指定的元素。這意味著任何非標準元素仍然必須允許這些屬性，即使這些元素使文件不符合 HTML5 標準。

內聯級元素和區塊級元素

HTML 元素通常是「內聯級」或「區塊級」元素。內聯級元素僅佔據由定義它的標籤界定的空間。區塊級元素佔據其父元素（容器）的整個空間，從而創建一個「區塊框」。

HTML 註釋

HTML 註釋用於向標記添加說明性註釋或防止瀏覽器解釋文件的特定部分。

Web 上的媒體類型和格式指南

<audio> 和 <video> 元素允許你在內容中本地播放音訊和視訊媒體，而無需外部軟體支援。

HTML 內容類型

HTML 由幾種內容組成，每種內容允許在某些上下文中使用，而在其他上下文中不允許使用。同樣，每個上下文都有一組它可以包含的其他內容類型以及可以或不能在其中使用的元素。這是這些類型的指南。

怪異模式和標準模式

關於怪異模式和標準模式的歷史訊息。

相關主題
使用 CSS 為 HTML 元素應用顏色

這篇文章涵蓋了使用 CSS 為 HTML 內容添加顏色的的大部分方法，列出了 HTML 文件的哪些部分可以著色以及在進行著色時應使用哪些 CSS 屬性。

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on 2025年4月27日 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML: HyperText Markup LanguageHTML (HyperText Markup Language) is the most basic building block of the Web. It defines the meaning and structure of web content. Other technologies besides HTML are generally used to describe a web page's appearance/presentation (CSS) or functionality/behavior (JavaScript).
"Hypertext" refers to links that connect web pages to one another, either within a single website or between websites. Links are a fundamental aspect of the Web. By uploading content to the Internet and linking it to pages created by other people, you become an active participant in the World Wide Web.
HTML uses "markup" to annotate text, images, and other content for display in a Web browser. HTML markup includes special "elements" such as <head>, <title>, <body>, <header>, <footer>, <article>, <section>, <p>, <div>, <span>, <img>, <aside>, <audio>, <canvas>, <datalist>, <details>, <embed>, <nav>, <search>, <output>, <progress>, <video>, <ul>, <ol>, <li> and many others.
An HTML element is set off from other text in a document by "tags", which consist of the element name surrounded by < and >. The name of an element inside a tag is case-insensitive. That is, it can be written in uppercase, lowercase, or a mixture. For example, the <title> tag can be written as <Title>, <TITLE>, or in any other way. However, the convention and recommended practice is to write tags in lowercase.
The articles below can help you learn more about HTML.Beginner's tutorials
Your first website: Creating the content

This article provides a brief tour of what HTML is and how to use it, aimed at people who are completely new to web development.

Structuring content with HTML

Our Learn web development section's HTML module teaches all the HTML fundamentals from the ground up.

Guides
HTML forms

Forms are a very important part of the Web — these provide much of the functionality you need for interacting with websites, e.g., registering and logging in, sending feedback, buying products, and more. This module gets you started with creating the client-side/front-end parts of forms.

CORS enabled image

The crossorigin attribute, in combination with an appropriate CORS header, allows images defined by the <img> element to be loaded from foreign origins and used in a <canvas> element as if they were being loaded from the current origin.

CORS settings attributes

Some HTML elements that provide support for CORS, such as <img> or <video>, have a crossorigin attribute (crossOrigin property), which lets you configure the CORS requests for the element's fetched data.

Preloading content with rel="preload"

The preload value of the <link> element's rel attribute allows you to write declarative fetch requests in your HTML <head>, specifying resources that your pages will need very soon after loading, which you therefore want to start preloading early in the lifecycle of a page load, before the browser's main rendering machinery kicks in. This ensures that they are made available earlier and are less likely to block the page's first render, leading to performance improvements. This article provides a basic guide to how preload works.

Responsive images

In this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.

Reference
HTML reference

HTML consists of elements, each of which may be modified by some number of attributes. HTML documents are connected to each other with links.

HTML element reference

Browse a list of all HTML elements.

HTML attribute reference

Elements in HTML have attributes. These are additional values that configure the elements or adjust their behavior in various ways.

Global attributes

Global attributes may be specified on all HTML elements, even those not specified in the standard. This means that any non-standard elements must still permit these attributes, even though those elements make the document HTML5-noncompliant.

Inline-level elements and block-level elements

HTML elements are usually "inline-level" or "block-level" elements. An inline-level element occupies only the space bounded by the tags that define it. A block-level element occupies the entire space of its parent element (container), thereby creating a "block box".

HTML comments

HTML comments are used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.

Guide to media types and formats on the web

The <audio> and <video> elements allow you to play audio and video media natively within your content without the need for external software support.

HTML content categories

HTML is comprised of several kinds of content, each of which is allowed to be used in certain contexts and is disallowed in others. Similarly, each context has a set of other content categories it can contain and elements that can or can't be used in them. This is a guide to these categories.

Quirks mode and standards mode

Historical information on quirks mode and standards mode.

Related topics
Applying color to HTML elements using CSS

This article covers most of the ways you use CSS to add color to HTML content, listing what parts of HTML documents can be colored and what CSS properties to use when doing so.

Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\nHTML guidesThis page lists the guides for using HTML.
Content categoriesMost HTML elements are a member of one or more content categories — these categories group elements that share common characteristics. This is a loose grouping (it doesn't actually create a relationship among elements of these categories), but they help define and describe the categories' shared behavior and their associated rules. It's possible for elements (such as track) to not be a member of any of these categories.HTML cheatsheet for syntax and common tasksWhile using HTML it can be very handy to have an easy way to remember how to use HTML tags properly and how to apply them. MDN provides you with extended HTML reference documentation as well as a deep instructional set of HTML guides. However, in many cases we just need some quick hints as we go. That's the whole purpose of the cheat sheet, to give you some quick accurate ready to use code snippets for common usages.Understanding quirks and standards modesIn the old days of the web, pages were typically written in two versions: One for Netscape Navigator, and one for Microsoft Internet Explorer. When the web standards were made at W3C, browsers could not just start using them, as doing so would break most existing sites on the web. Browsers therefore introduced two modes to treat new standards compliant sites differently from old legacy sites.Using date and time formats in HTMLCertain HTML elements use date and/or time values. The formats of the strings that specify these values are described in this article.Using HTML comments An HTML comment is used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.Using HTML form validation and the Constraint Validation APIThe creation of web forms has always been a complex task. While marking up the form itself is easy, checking whether each field has a valid and coherent value is more difficult, and informing the user about the problem may become a headache. HTML5 introduced new mechanisms for forms: it added new semantic types for the input element and constraint validation to ease the work of checking the form content on the client side. Basic, usual constraints can be checked, without the need for JavaScript, by setting new attributes; more complex constraints can be tested using the Constraint Validation API.Using microdata in HTMLMicrodata is part of the WHATWG HTML Standard and is used to nest metadata within existing content on web pages. Search engines and web crawlers can extract and process microdata from a web page and use it to provide a richer browsing experience for users. Search engines benefit greatly from direct access to this structured data because it allows search engines to understand the information on web pages and provide more relevant results to users. Microdata uses a supporting vocabulary to describe an item and name-value pairs to assign values to its properties. Microdata is an attempt to provide a declarative way of annotating HTML elements with machine-readable tags than the similar approaches of using RDFa and classic microformats.Using microformats in HTMLMicroformats are standards used to embed semantics and structured data in HTML, and provide an API to be used by social web applications, search engines, aggregators, and other tools. These minimal patterns of HTML are used for marking up entities that range from fundamental to domain-specific information, such as people, organizations, events, and locations.Using responsive images in HTMLIn this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.Using the viewport meta elementThis article describes how to use the "viewport" <meta> tag to control the viewport's size and shape.\n\nHTML guidesThis page lists the guides for using HTML.
Content categoriesMost HTML elements are a member of one or more content categories — these categories group elements that share common characteristics. This is a loose grouping (it doesn't actually create a relationship among elements of these categories), but they help define and describe the categories' shared behavior and their associated rules. It's possible for elements (such as track) to not be a member of any of these categories.HTML cheatsheet for syntax and common tasksWhile using HTML it can be very handy to have an easy way to remember how to use HTML tags properly and how to apply them. MDN provides you with extended HTML reference documentation as well as a deep instructional set of HTML guides. However, in many cases we just need some quick hints as we go. That's the whole purpose of the cheat sheet, to give you some quick accurate ready to use code snippets for common usages.Understanding quirks and standards modesIn the old days of the web, pages were typically written in two versions: One for Netscape Navigator, and one for Microsoft Internet Explorer. When the web standards were made at W3C, browsers could not just start using them, as doing so would break most existing sites on the web. Browsers therefore introduced two modes to treat new standards compliant sites differently from old legacy sites.Using date and time formats in HTMLCertain HTML elements use date and/or time values. The formats of the strings that specify these values are described in this article.Using HTML comments An HTML comment is used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.Using HTML form validation and the Constraint Validation APIThe creation of web forms has always been a complex task. While marking up the form itself is easy, checking whether each field has a valid and coherent value is more difficult, and informing the user about the problem may become a headache. HTML5 introduced new mechanisms for forms: it added new semantic types for the input element and constraint validation to ease the work of checking the form content on the client side. Basic, usual constraints can be checked, without the need for JavaScript, by setting new attributes; more complex constraints can be tested using the Constraint Validation API.Using microdata in HTMLMicrodata is part of the WHATWG HTML Standard and is used to nest metadata within existing content on web pages. Search engines and web crawlers can extract and process microdata from a web page and use it to provide a richer browsing experience for users. Search engines benefit greatly from direct access to this structured data because it allows search engines to understand the information on web pages and provide more relevant results to users. Microdata uses a supporting vocabulary to describe an item and name-value pairs to assign values to its properties. Microdata is an attempt to provide a declarative way of annotating HTML elements with machine-readable tags than the similar approaches of using RDFa and classic microformats.Using microformats in HTMLMicroformats are standards used to embed semantics and structured data in HTML, and provide an API to be used by social web applications, search engines, aggregators, and other tools. These minimal patterns of HTML are used for marking up entities that range from fundamental to domain-specific information, such as people, organizations, events, and locations.Using responsive images in HTMLIn this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.Using the viewport meta elementThis article describes how to use the "viewport" <meta> tag to control the viewport's size and shape.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\nHTML guidesThis page lists the guides for using HTML.
Content categoriesMost HTML elements are a member of one or more content categories — these categories group elements that share common characteristics. This is a loose grouping (it doesn't actually create a relationship among elements of these categories), but they help define and describe the categories' shared behavior and their associated rules. It's possible for elements (such as track) to not be a member of any of these categories.HTML cheatsheet for syntax and common tasksWhile using HTML it can be very handy to have an easy way to remember how to use HTML tags properly and how to apply them. MDN provides you with extended HTML reference documentation as well as a deep instructional set of HTML guides. However, in many cases we just need some quick hints as we go. That's the whole purpose of the cheat sheet, to give you some quick accurate ready to use code snippets for common usages.Understanding quirks and standards modesIn the old days of the web, pages were typically written in two versions: One for Netscape Navigator, and one for Microsoft Internet Explorer. When the web standards were made at W3C, browsers could not just start using them, as doing so would break most existing sites on the web. Browsers therefore introduced two modes to treat new standards compliant sites differently from old legacy sites.Using date and time formats in HTMLCertain HTML elements use date and/or time values. The formats of the strings that specify these values are described in this article.Using HTML comments An HTML comment is used to add explanatory notes to the markup or to prevent the browser from interpreting specific parts of the document.Using HTML form validation and the Constraint Validation APIThe creation of web forms has always been a complex task. While marking up the form itself is easy, checking whether each field has a valid and coherent value is more difficult, and informing the user about the problem may become a headache. HTML5 introduced new mechanisms for forms: it added new semantic types for the input element and constraint validation to ease the work of checking the form content on the client side. Basic, usual constraints can be checked, without the need for JavaScript, by setting new attributes; more complex constraints can be tested using the Constraint Validation API.Using microdata in HTMLMicrodata is part of the WHATWG HTML Standard and is used to nest metadata within existing content on web pages. Search engines and web crawlers can extract and process microdata from a web page and use it to provide a richer browsing experience for users. Search engines benefit greatly from direct access to this structured data because it allows search engines to understand the information on web pages and provide more relevant results to users. Microdata uses a supporting vocabulary to describe an item and name-value pairs to assign values to its properties. Microdata is an attempt to provide a declarative way of annotating HTML elements with machine-readable tags than the similar approaches of using RDFa and classic microformats.Using microformats in HTMLMicroformats are standards used to embed semantics and structured data in HTML, and provide an API to be used by social web applications, search engines, aggregators, and other tools. These minimal patterns of HTML are used for marking up entities that range from fundamental to domain-specific information, such as people, organizations, events, and locations.Using responsive images in HTMLIn this article, we'll learn about the concept of responsive images — images that work well on devices with widely differing screen sizes, resolutions, and other such features — and look at what tools HTML provides to help implement them. This helps to improve performance across different devices.Using the viewport meta elementThis article describes how to use the "viewport" <meta> tag to control the viewport's size and shape.Help improve MDNWas this page helpful to you?YesNoLearn how to contribute.This page was last modified on Apr 10, 2025 by MDN contributors.View this page on GitHub • Report a problem with this content\n\n\n\n