# MEMORY

## Overview
Memory is a foundational capability for an agentic system, allowing the agent to retain information from past actions and use it in future decisions. By integrating a memory store, the agent can carry over context between commands within a session (and potentially across sessions), rather than operating in isolation for each input. This enables more complex interactions – later commands can reference or build upon earlier results, and the agent can avoid repeating work or mistakes by recalling what has already been done. In summary, adding persistent memory to the agent will enhance continuity and lay the groundwork for long-term learning and context accumulation.

## Implementation Details
1. **Introduce a Global Memory Store:** In `src/lib/main.js`, define a global memory structure to record processed commands and outcomes. For example, initialize `globalThis.memoryLog = globalThis.memoryLog || []` at the top of the file (similar to how `callCount` is handled) to ensure it persists across invocations in the same runtime. Each entry in `memoryLog` can be an object containing at least the command string and timestamp, and possibly the result of processing.
2. **Record Commands and Results:** Update the `agenticHandler` function to append to `memoryLog` whenever a command is processed.
    - For **single command** inputs (the `'command' in payload` branch), after constructing the `response` object (with `status`, `processedCommand`, etc.), push a copy of this `response` (or a simplified summary) into `memoryLog`.
    - For **batch processing** (`'commands' in payload` branch), append each individual command’s result to `memoryLog` as it’s processed inside the loop. This way, the memory accumulates all commands executed during the agent’s run.
3. **Enable Memory Retrieval:** Add logic to retrieve the stored memory on demand. For instance, if `payload.command` is a specific keyword like `"get_memory"` (case-insensitive), the handler should return the contents of `globalThis.memoryLog` instead of performing a normal command. The return format could be `{ status: "success", memory: [...] }` where the memory array contains the logged entries. Document this special command for users.
4. **Update Unit Tests:** In `tests/unit/main.test.js`, add tests to verify the memory functionality:
    - After processing a single command, calling `agenticHandler({ command: "get_memory" })` should return a result containing that command in the memory list.
    - After a batch of commands, ensure that `memoryLog` length increased accordingly and that a subsequent `"get_memory"` call returns all those commands.
    - Test that memory persists within a single process: e.g. call `agenticHandler` twice with different commands and then check that memory contains both (the test environment resets globals between test cases via `beforeEach`, so multi-call persistence can be checked in one test function).
5. **Documentation:** Update the README to mention the new memory capability. In the **Agentic Library Functions** or **Evolving main.js** section, add a bullet point **Memory Persistence:** describing that the agent now retains a log of all processed commands in-memory during its runtime. Include usage notes, for example: the special `"get_memory"` command can be used to retrieve the log, and note that the memory resets when the process restarts (unless a future persistent storage is introduced).

## Long-Term Direction
This memory feature can evolve significantly over time. In the short term, the memory could be made persistent across runs – for example by saving to a file or database (allowing the agent to remember past sessions or maintain long-term knowledge). The structure of stored memories might become more sophisticated, storing not just raw commands but summarized outcomes or embeddings for efficient lookup. As the agent grows more capable, it could use this memory to inform decisions (avoiding redundant actions, learning from previous errors, etc.). Eventually, the memory module could support **vectorized memory** or semantic search, enabling the agent to retrieve relevant past experiences even as the volume of stored knowledge grows. This trajectory ensures that the agent’s behavior becomes more consistent and “learning-driven” over time, akin to an AGI that accumulates and applies knowledge day by day.
