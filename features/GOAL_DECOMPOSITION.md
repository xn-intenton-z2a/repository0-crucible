# GOAL_DECOMPOSITION

## Overview
Goal Decomposition is the agent’s ability to break down a complex objective into simpler, actionable parts. This trait is closely related to planning, but specifically focuses on parsing an initial high-level goal into discrete tasks. In practice, it means the agent can take something broad – for example, “implement a new feature and write documentation” – and split it into individual steps like “implement feature (code)”, “write tests for feature”, “update README with usage”. By doing so, each sub-task can be tackled with the existing capabilities of the agent. For our CLI/Lambda, goal decomposition ensures that even if a user or system gives a compound instruction, the agent won’t be overwhelmed; it will handle each piece in a logical order. This increases the likelihood of success and makes debugging easier since each step can be verified.

## Implementation Details
- **Input Parsing for Sub-Tasks:** Update `agenticHandler` to recognize when a single-command input actually contains multiple instructions. A straightforward approach is to look for delimiters in the command string. For example, if `payload.command` is a string and contains a semicolon (`;`) or the word “then”, we can treat it as multiple commands. Implement a parser that splits the string on these delimiters into an array of strings (trimming whitespace). Each segment becomes its own command.
- **Batch Execution Reuse:** Once the command is split into sub-commands, reuse the existing batch processing logic. For instance, if the input was `{ command: "do A; then do B" }`, after splitting, programmatically call `agenticHandler({ commands: ["do A", "do B"] })` internally. This way, we leverage the already-tested batch execution flow (sequentially processing each command and aggregating results) without reinventing how to run multiple steps. The agent thus effectively decomposes the goal and immediately carries out the parts one by one.
- **Compound Goal Format:** Alternatively (or additionally), allow a more structured input for goals. For example, if a JSON payload comes in as `{ "goal": "Set up database and API", "steps": [] }`, the agent could detect the `goal` field and apply a decomposition strategy (possibly using a preset template or a simple AI prompt) to fill in the `"steps"` array, then execute them. For now, this can be a stub: if `goal` is provided, log that the feature is recognized but advise using a semicolon-separated commands string until the feature matures.
- **Tests for Decomposition:** Implement unit tests for goal decomposition. One test case: input a single string with two tasks separated by “and then” and verify that `agenticHandler` returns a composite result that includes results for each part in order (and that `globalThis.callCount` increments appropriately for each sub-task). Another test: provide a payload with a `goal` property (instead of `command` or `commands`) and check that the agent doesn’t crash and gives a useful message (since full support might not be complete yet). The tests ensure that multi-part inputs are handled gracefully.
- **README Examples:** Update the README.md to guide users on using this feature. For instance: “The agent can handle compound commands. You can separate tasks with semicolons or the phrase 'then'. Example: `--agentic "{\"command\": \"build the project; then deploy it\"}"` will cause the agent to treat “build the project” and “deploy it” as two separate commands and execute them sequentially.” Also mention any caveats (e.g., it’s best to use clear separators as natural language might not always split correctly). This educates users on how to leverage goal decomposition with the current implementation.

## Long-Term Direction
As the agent evolves, goal decomposition can become more intelligent and less reliant on manual separators. In the future, the agent could use NLP techniques or even an LLM call to truly understand a goal expressed in natural language and break it into structured tasks. This might involve identifying prerequisites, parallelizable tasks, and conditional steps. We could integrate a planning AI module that reads a goal and returns a checklist of sub-goals (very much like how a human project planner would). On a larger scale, goal decomposition could allow the agent to translate a high-level feature request (perhaps coming from an issue ticket or user story) into multiple GitHub issues or PRs across different services – effectively spreading the work across different parts of a system. This trait, combined with replication and planning, paves the way for **auto-orchestration** of complex projects: the agent not only figures out what needs to be done, but can also distribute those tasks to where they need to be done, within or even across repositories.
