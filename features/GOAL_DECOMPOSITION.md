# GOAL_DECOMPOSITION

## Overview
Goal Decomposition is the agent’s ability to take a broad or complex objective and break it down into a set of smaller, more manageable tasks *without immediately executing them*. This trait is closely related to Planning, but serves a slightly different purpose: instead of carrying out the plan right away, the agent can output or enumerate the sub-goals for review or scheduling. In an agentic workflow, this is useful for transparency and coordination — the agent can present a breakdown of a large task (for example, in a GitHub issue or comment) before actually working on each part. It allows humans or other processes to understand the agent’s intended approach, adjust the plan if needed, or distribute tasks. By explicitly representing a goal as sub-tasks, the system can tackle complex projects in stages and ensure no aspect of the goal is overlooked.

## Implementation Details
1. **Payload Trigger for Decomposition:** Extend `agenticHandler` to handle a request for decomposition distinct from immediate execution. One approach is to use a boolean flag in the payload, e.g., `"decomposeOnly": true` alongside a `goal` string. When `payload.decomposeOnly` is true, the agent should parse the goal into sub-tasks but not execute them.
2. **Decomposition Logic:** Similar to the Planning feature, parse the provided `payload.goal` (or alternatively, use `payload.command` if the user passes the objective in the command field with a flag) into a list of smaller tasks. Use simple heuristic parsing for now (split by sentence or delimiters like “;” or the word “then”). Ensure each sub-task is a concise, actionable statement. For example, `"Set up project and then push to repo"` might split into `["Set up project", "push to repo"]`.
3. **Return Task List Instead of Executing:** Instead of processing each sub-command, immediately return a structured response containing the breakdown. The response could look like `{ status: "success", goal: <original goal>, tasks: ["sub-task 1", "sub-task 2", ...] }`. By providing the tasks in an array, the agent communicates what it would do, without side effects. Do not call the sub-tasks through `agenticHandler` here – simply prepare the list.
4. **Maintain Counters and Logs:** Even though we are not executing the commands, it’s reasonable to treat the decomposition as handling one high-level request. You can increment `globalThis.callCount` by 1 for the decomposition action itself (so that it’s counted as an invocation). Optionally, log an info message indicating that goal decomposition was performed. If the memory feature is enabled, consider storing the goal and its decomposed list in `memoryLog` as a reference for future steps.
5. **Add Tests for Decomposition:** In `main.test.js`, write tests to validate this new mode:
  - When given a payload with `{ goal: "Do A and B", decomposeOnly: true }`, the `agenticHandler` should return a success status with a `tasks` array containing the split tasks (e.g. `["Do A", "Do B"]`). Ensure that none of the tasks were executed (for example, if those tasks would increment `callCount` or produce log entries, they should not appear – only the single decomposition action increments the counter). Check that `globalThis.callCount` increased by exactly 1 in this scenario.
  - Test that an invalid usage (like `decomposeOnly: true` with no `goal` provided) results in an error or rejection, to enforce proper input.
6. **Documentation:** Update README to mention **Goal Decomposition** as a capability. Explain that the agent can output a breakdown of a high-level goal into sub-tasks without executing them. Document how to trigger it, for example: using the `--agentic` flag with a payload like `{"goal": "High-level objective...", "decomposeOnly": true}` will cause the agent to return a list of steps. Emphasize how this differs from normal planning: it’s a way to preview or obtain a task list for a goal, which can then be approved or fed back into the agent for execution.

## Long-Term Direction
Goal decomposition can become far more advanced with iterative improvements. In the future, the agent could employ NLP techniques or learned models to decompose goals more intelligently, even if the instructions are vague or high-level. The sub-tasks could include additional structure, such as estimates of difficulty or prerequisite relationships, effectively creating a plan graph rather than a linear list. This feature also paves the way for multi-agent or multi-worker scenarios: eventually, each sub-goal could be handed off to a separate agent or workflow (perhaps even spun off as separate GitHub issues in an automated way). Additionally, a feedback loop could be introduced — after executing sub-tasks, the agent can verify if the overall goal is met or if further decomposition is needed. In summary, robust goal decomposition will help scale the agent’s abilities to tackle complex projects methodically, and allow oversight or collaboration by presenting its plan before execution.
