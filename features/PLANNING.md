# PLANNING

## Overview
Planning equips the agent with the ability to break down and execute multi-step tasks from a single high-level instruction. Without planning, the agent can only handle one command at a time or a predefined batch of commands supplied by the user. By introducing an automated planning capability, the agent can interpret a complex request (for example, a goal that involves multiple actions or stages) and internally generate a sequence of steps to achieve that goal. This trait increases the agent’s autonomy and usefulness: users can give broad objectives, and the agent will orchestrate the necessary sequence of operations. In essence, the planning feature turns the agentic library from a reactive executor into a proactive problem-solver that can handle compound instructions.

## Implementation Details
1. **Extend Payload Schema for Goals:** Modify `agenticHandler` in `src/lib/main.js` to recognize a high-level goal input. For instance, if the payload contains a property `goal` (a string describing an objective) instead of or in addition to a simple `command`, handle it as a special case before the existing command(s) logic.
2. **Parse Goal into Sub-commands:** Implement a simple planner that splits the goal description into discrete actionable steps. A straightforward approach is to split the `payload.goal` string by a delimiter (such as sentence boundaries or the word "then"). For example, split on `. ` or ` and then ` to produce an array of step strings. Trim and filter out any empty entries. Each resulting step represents a sub-command the agent should perform in sequence.
3. **Execute Planned Steps Sequentially:** Reuse the batch-processing capability to execute these derived sub-commands. There are two possible implementations:
  - **Recursive Call:** Construct a new payload `{ commands: [step1, step2, ...] }` and call `agenticHandler` recursively to leverage the existing batch handling. This way, each step will be validated, logged, and executed as if it were provided directly by the user. Ensure to `await` the recursive call so that planning is completed synchronously, and wrap it in try/catch to handle any errors during sub-step execution.
  - **Inline Loop:** Alternatively, iterate over the `steps` array within the planning branch, processing each step similarly to the batch loop. This is akin to manually performing what the batch handler does: for each step, generate a response (with `status`, `processedCommand`, `timestamp`, etc.), increment `callCount`, and collect the results.
    In either case, the overall result returned by the `agenticHandler` for a goal input should include all sub-step outcomes. For example, return an object `{ status: "success", plan: payload.goal, results: [ ...sub-command results... ] }`.
4. **Add Planning Tests:** In `main.test.js`, introduce tests for the new goal planning behavior:
  - Given a payload with a `goal` string that contains multiple actions (e.g. `"Step1. Then do step2."`), verify that `agenticHandler` returns a success status and a `results` array with an entry for each step. Each sub-result should have its own `processedCommand` matching the parsed steps. Also ensure that `globalThis.callCount` increased by the number of sub-commands, demonstrating that each planned step counted as an invocation.
  - Test edge cases: a goal that is just a single action (should simply execute it like a normal command), or a goal string that might be improperly formatted (the planner should handle gracefully, perhaps treating the whole string as one command if no clear delimiter is found).
5. **Usage Documentation:** Update the README to explain the planning capability. Under **Agentic Library Functions**, add a bullet like **Automated Planning:** describing how the agent can take a `goal` (high-level instruction) and decompose it into multiple steps internally. Provide an example usage, for instance: using the CLI `--agentic` flag with a JSON payload `{"goal": "Do X then do Y"}` will result in the agent performing X and then Y automatically, returning a combined result. Clarify that this happens without the user having to explicitly list `commands` in advance.

## Long-Term Direction
The Planning feature can be improved to be far more sophisticated over time. In the near future, the simplistic splitting logic can be replaced or augmented by an AI model or heuristic that truly understands how to break down goals (for example, using a large language model to interpret a complex instruction and propose a series of sub-tasks). The agent could also incorporate conditional planning – adjusting the plan on the fly if one step’s outcome influences the next (dynamic planning and replanning). In the long term, planning could involve scheduling and optimization, deciding the best order to execute tasks or even doing some in parallel when possible. This trait also opens the door to multi-session planning: the agent might remember a goal that could not be completed in one run and resume later. Overall, robust planning moves the project closer to an AGI-like system that can handle open-ended projects (for example, “set up a new repository and implement feature X, then open a PR”) by autonomously figuring out the intermediate steps.
