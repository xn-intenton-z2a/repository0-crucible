tests/unit/pi.test.js
# tests/unit/pi.test.js
import { describe, test, expect } from 'vitest';
import {
  calculatePiMachin,
  calculatePiNilakantha,
  calculatePiChudnovsky,
  calculatePiGaussLegendre,
  calculatePi,
  benchmarkPi
} from '@src/lib/pi.js';

describe('calculatePiMachin', () => {
  test('calculates pi to 5 digits', () => {
    expect(calculatePiMachin(5)).toBe('3.14159');
  });

  test('calculates pi to 10 digits', () => {
    expect(calculatePiMachin(10)).toBe('3.1415926535');
  });
});

describe('calculatePiNilakantha', () => {
  test('calculates pi to 5 digits', () => {
    expect(calculatePiNilakantha(5)).toBe('3.14159');
  });

  test('calculates pi to 10 digits matching Machin', () => {
    const piMach = calculatePiMachin(10);
    const piNila = calculatePiNilakantha(10);
    expect(piNila).toBe(piMach);
  });
});

describe('calculatePiChudnovsky', () => {
  test('calculates pi to 5 digits', () => {
    expect(calculatePiChudnovsky(5)).toBe('3.14159');
  });

  test('calculates pi to 10 digits matching Machin', () => {
    const piMach = calculatePiMachin(10);
    const piChud = calculatePiChudnovsky(10);
    expect(piChud).toBe(piMach);
  });
});

describe('calculatePiGaussLegendre', () => {
  test('calculates pi to 5 digits', () => {
    expect(calculatePiGaussLegendre(5)).toBe('3.14159');
  });

  test('calculates pi to 10 digits matching Machin', () => {
    const piMach = calculatePiMachin(10);
    const piGL = calculatePiGaussLegendre(10);
    expect(piGL).toBe(piMach);
  });
});

describe('calculatePi dispatcher', () => {
  test('dispatches to machin', () => {
    expect(calculatePi(5, 'machin')).toBe(calculatePiMachin(5));
  });

  test('dispatches to nilakantha', () => {
    expect(calculatePi(5, 'nilakantha')).toBe(calculatePiNilakantha(5));
  });

  test('dispatches to chudnovsky', () => {
    expect(calculatePi(5, 'chudnovsky')).toBe(calculatePiChudnovsky(5));
  });

  test('dispatches to gauss-legendre', () => {
    expect(calculatePi(5, 'gauss-legendre')).toBe(calculatePiGaussLegendre(5));
  });

  test('throws on invalid digits', () => {
    expect(() => calculatePi(0, 'machin')).toThrow();
    expect(() => calculatePi(10001, 'machin')).toThrow();
  });

  test('throws on invalid method', () => {
    expect(() => calculatePi(5, 'wrong')).toThrow();
  });
});

describe('benchmarkPi', () => {
  test('invalid digits throws error', async () => {
    await expect(benchmarkPi(0)).rejects.toThrow('digits must be an integer');
  });

  test('invalid runs throws error', async () => {
    await expect(benchmarkPi(5, 0)).rejects.toThrow('runs must be an integer >= 1');
  });

  test('returns result structure for single method', async () => {
    const results = await benchmarkPi(1, 1, ['machin']);
    expect(Array.isArray(results)).toBe(true);
    expect(results).toHaveLength(1);
    const res = results[0];
    expect(res).toHaveProperty('method', 'machin');
    expect(res).toHaveProperty('runs', 1);
    expect(typeof res.averageTimeMs).toBe('number');
    expect(typeof res.minTimeMs).toBe('number');
    expect(typeof res.maxTimeMs).toBe('number');
  });

  test('returns default methods when methods not provided', async () => {
    const results = await benchmarkPi(1, 1);
    expect(results).toHaveLength(4);
    const methods = results.map((r) => r.method).sort();
    expect(methods).toEqual(['chudnovsky', 'gauss-legendre', 'machin', 'nilakantha'].sort());
  });
});
tests/unit/main.test.js
# tests/unit/main.test.js
import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';
import fs from 'fs';
import { main } from '@src/lib/main.js';

describe('CLI Input Validation', () => {
  test('invalid digits throws error', async () => {
    await expect(main(['--digits', '0'])).rejects.toThrow('Invalid --digits');
  });

  test('invalid method throws error', async () => {
    await expect(main(['--method', 'invalid'])).rejects.toThrow('Invalid --method');
  });

  test('invalid format throws error', async () => {
    await expect(main(['--format', 'bmp'])).rejects.toThrow('Invalid --format');
  });

  test('png format without output throws error', async () => {
    await expect(main(['--format', 'png'])).rejects.toThrow('--output is required');
  });
});

describe('CLI Text Output', () => {
  let log;
  beforeEach(() => {
    log = vi.spyOn(console, 'log').mockImplementation(() => {});
  });
  afterEach(() => {
    log.mockRestore();
  });

  test('defaults to 100 digits', async () => {
    await main([]);
    expect(log).toHaveBeenCalled();
  });

  test('chudnovsky method outputs correct pi', async () => {
    log.mockClear();
    await main(['--digits', '5', '--method', 'chudnovsky']);
    expect(log).toHaveBeenCalledWith('3.14159');
  });

  test('gauss-legendre method outputs correct pi', async () => {
    log.mockClear();
    await main(['--digits', '5', '--method', 'gauss-legendre']);
    expect(log).toHaveBeenCalledWith('3.14159');
  });
});

describe('CLI PNG Output', () => {
  const outPath = 'test_output.png';

  afterEach(() => {
    if (fs.existsSync(outPath)) {
      fs.unlinkSync(outPath);
    }
  });

  test('creates a png file', async () => {
    await main(['--digits', '5', '--format', 'png', '--output', outPath]);
    expect(fs.existsSync(outPath)).toBe(true);
  });
});

describe('CLI Benchmark Mode', () => {
  let log;
  beforeEach(() => {
    log = vi.spyOn(console, 'log').mockImplementation(() => {});
  });
  afterEach(() => {
    log.mockRestore();
  });

  test('invalid benchmark-runs throws error', async () => {
    await expect(main(['--benchmark', '--benchmark-runs', '0'])).rejects.toThrow('Invalid --benchmark-runs');
  });

  test('outputs JSON when --benchmark-json used', async () => {
    log.mockClear();
    await main(['--digits', '5', '--benchmark', '--benchmark-runs', '1', '--benchmark-json']);
    expect(log).toHaveBeenCalled();
    const arg = log.mock.calls[0][0];
    const results = JSON.parse(arg);
    expect(Array.isArray(results)).toBe(true);
    expect(results.length).toBeGreaterThan(0);
    expect(results[0]).toHaveProperty('method');
    expect(results[0]).toHaveProperty('averageTimeMs');
  });
});
