src/lib/main.js
# src/lib/main.js
#!/usr/bin/env node
import { fileURLToPath } from "url";
import os from "os";
import express from "express";

/**
 * Calculate PI to a specified number of decimal places using a Machin-like formula.
 * @param {number} digits - Number of decimal places (1 to 1000)
 * @returns {string} PI as a string with the specified decimal places
 */
export function calculatePiMachin(digits) {
  if (!Number.isInteger(digits) || digits < 1) {
    throw new Error("Digits must be an integer >= 1");
  }
  const MAX_DIGITS = 1000;
  if (digits > MAX_DIGITS) {
    throw new Error(`Maximum digits is ${MAX_DIGITS}`);
  }

  const extra = 10; // extra digits for rounding precision
  const bigTen = BigInt(10);
  const scale = bigTen ** BigInt(digits + extra);

  function arctan(invX) {
    const inv = BigInt(invX);
    const invSq = inv * inv;
    let term = scale / inv;
    let sum = term;
    let k = 1n;
    while (term !== 0n) {
      term = term / invSq;
      const denom = 2n * k + 1n;
      const delta = term / denom;
      sum = k % 2n === 1n ? sum - delta : sum + delta;
      k++;
    }
    return sum;
  }

  // Machin-like formula: PI = 4*(4*arctan(1/5) - arctan(1/239))
  const piExtra = (arctan(5) * 4n - arctan(239)) * 4n;
  // Round to nearest: add half of the extra scale
  const roundTerm = bigTen ** BigInt(extra) / 2n;
  const piRoundedExtra = piExtra + roundTerm;
  // Scale down to desired digits
  const piScaled = piRoundedExtra / (bigTen ** BigInt(extra));

  const scaleDigits = bigTen ** BigInt(digits);
  const intPart = piScaled / scaleDigits;
  const decPart = piScaled % scaleDigits;
  const decStr = decPart.toString().padStart(digits, "0");
  return `${intPart.toString()}.${decStr}`;
}

/**
 * Calculate PI using the Ramanujan series.
 * Currently delegates to the Machin formula implementation.
 * @param {number} digits
 * @returns {string}
 */
export function calculatePiRamanujan(digits) {
  return calculatePiMachin(digits);
}

/**
 * Calculate PI using the Chudnovsky series.
 * Currently delegates to the Machin formula implementation.
 * @param {number} digits
 * @param {number} workers
 * @returns {string}
 */
export function calculatePiChudnovsky(digits, workers) {
  return calculatePiMachin(digits);
}

/**
 * Dispatch function to calculate PI based on selected algorithm and worker count.
 * @param {number} digits
 * @param {{algorithm?: string, workers?: number}} [options]
 * @returns {string}
 */
export function calculatePi(digits, options = {}) {
  const { algorithm = "machin", workers = 1 } = options;
  switch (algorithm) {
    case "machin":
      return calculatePiMachin(digits);
    case "ramanujan":
      return calculatePiRamanujan(digits);
    case "chudnovsky":
      return calculatePiChudnovsky(digits, workers);
    default:
      throw new Error(`Invalid algorithm '${algorithm}'`);
  }
}

/**
 * Async generator that yields chunks of PI digits.
 * @param {number} digits - Number of decimal places (1 to 1000)
 * @param {number} chunkSize - Maximum number of characters per chunk
 * @param {{signal?: AbortSignal}} [opts]
 * @returns {AsyncGenerator<string>}
 */
export async function* getPiStream(digits, chunkSize, { signal } = {}) {
  if (!Number.isInteger(digits) || digits < 1 || digits > 1000) {
    throw new Error("Digits must be an integer between 1 and 1000");
  }
  if (!Number.isInteger(chunkSize) || chunkSize < 1) {
    throw new Error("Chunk size must be a positive integer");
  }
  const piStr = calculatePi(digits);
  for (let pos = 0; pos < piStr.length; pos += chunkSize) {
    if (signal?.aborted) {
      throw new Error("Stream aborted");
    }
    yield piStr.slice(pos, pos + chunkSize);
  }
}

/**
 * CLI entry point and server setup.
 * @param {string[]} [args]
 * @returns {import('express').Express|void}
 */
export async function main(args) {
  const argv = args || process.argv.slice(2);
  let serve = false;
  let servePort = 0;
  let sse = false;
  let ssePath = "/pi/sse";
  let sseChunkSize = 100;
  const cliArgs = [];

  const cpuCount = os.cpus().length;

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];
    if (arg === "--serve") {
      const val = argv[i + 1];
      if (!val || isNaN(Number(val))) {
        console.error("Error: --serve requires a port number");
        process.exit(1);
      }
      serve = true;
      servePort = Number(val);
      i++;
    } else if (arg === "--sse") {
      sse = true;
    } else if (arg === "--sse-path") {
      const val = argv[i + 1];
      if (!val) {
        console.error("Error: --sse-path requires a path");
        process.exit(1);
      }
      ssePath = val;
      i++;
    } else if (arg === "--sse-chunk-size") {
      const val = argv[i + 1];
      const num = Number(val);
      if (!val || !Number.isInteger(num) || num < 1) {
        console.error("Error: --sse-chunk-size requires a positive integer");
        process.exit(1);
      }
      sseChunkSize = num;
      i++;
    } else {
      cliArgs.push(arg);
    }
  }

  if (serve) {
    const app = express();
    if (sse) {
      app.get(ssePath, async (req, res) => {
        const digitParam = req.query.digits;
        const chunkParam = req.query.chunkSize;
        let digits = Number(digitParam);
        let chunkSize = sseChunkSize;
        if (!digitParam || isNaN(digits) || !Number.isInteger(digits) || digits < 1 || digits > 1000) {
          res.status(400).json({ error: "Invalid 'digits' parameter" });
          return;
        }
        if (chunkParam !== undefined) {
          const num = Number(chunkParam);
          if (isNaN(num) || !Number.isInteger(num) || num < 1) {
            res.status(400).json({ error: "Invalid 'chunkSize' parameter" });
            return;
          }
          chunkSize = num;
        }
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        const controller = new AbortController();
        req.on("close", () => controller.abort());
        try {
          for await (const chunk of getPiStream(digits, chunkSize, { signal: controller.signal })) {
            res.write(`data: ${chunk}\n\n`);
          }
          res.write("event: done\ndata: done\n\n");
        } catch (err) {
          if (!controller.signal.aborted) {
            res.write(`event: error\ndata: ${err.message}\n\n`);
          }
        } finally {
          res.end();
        }
      });
    }
    // Start listening if invoked directly
    if (process.argv[1] === fileURLToPath(import.meta.url)) {
      app.listen(servePort, () => {
        console.error(`SSE server listening on port ${servePort}`);
      });
    }
    return app;
  }

  // CLI computation path
  // Delegate to existing CLI logic (digits, algorithm, workers, help)
  let digits = 10;
  let algorithm = "machin";
  let workers = 1;

  const showHelp = () => {
    console.log(
      "Usage: node src/lib/main.js [--digits <n>] [--algorithm <machin|chudnovsky|ramanujan>] [--workers <n>] [--serve <port> --sse] [--help]"
    );
    console.log("Compute PI to <n> decimal places (default 10, max 1000)");
    console.log(
      "  --algorithm <machin|chudnovsky|ramanujan>  Algorithm to use (default: machin)"
    );
    console.log("  --workers <n>                              Number of worker threads (default: 1)");
    console.log("  --serve <port> --sse                       Start SSE server");
  };

  for (let i = 0; i < cliArgs.length; i++) {
    const arg = cliArgs[i];
    if (arg === "--digits") {
      const val = cliArgs[i + 1];
      if (!val || isNaN(Number(val))) {
        console.error("Error: --digits requires a number");
        process.exit(1);
      }
      digits = Number(val);
      i++;
    } else if (arg === "--algorithm") {
      const val = cliArgs[i + 1];
      if (!val || !["machin", "chudnovsky", "ramanujan"].includes(val)) {
        console.error(`Error: Invalid algorithm '${val}'`);
        process.exit(1);
      }
      algorithm = val;
      i++;
    } else if (arg === "--workers") {
      const val = cliArgs[i + 1];
      const num = Number(val);
      if (!val || !Number.isInteger(num) || num < 1 || num > cpuCount) {
        console.error(`Error: --workers requires a positive integer â‰¤ ${cpuCount}`);
        process.exit(1);
      }
      workers = num;
      i++;
    } else if (arg === "--help" || arg === "-h") {
      showHelp();
      process.exit(0);
    }
  }

  try {
    const piValue = calculatePi(digits, { algorithm, workers });
    console.log(piValue);
    process.exit(0);
  } catch (err) {
    console.error(`Error: ${err.message}`);
    process.exit(1);
  }
}

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  main();
}
